{"version":3,"file":"ngApolloTesting.umd.js","sources":["../../testing/src/controller.ts","../../testing/src/operation.ts","../../testing/src/backend.ts","../../testing/src/module.ts","../../testing/src/ngApolloTesting.ts"],"names":["ApolloError","LinkObservable","print","Injectable","InjectionToken","ApolloLink","InMemoryCache","NgModule","Apollo","Optional","Inject","ApolloCache"],"mappings":"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","sourcesContent":["import {DocumentNode} from 'graphql';\n\nimport {TestOperation, Operation} from './operation';\n\nexport type MatchOperationFn = (op: Operation) => boolean;\nexport type MatchOperation =\n  | string\n  | DocumentNode\n  | Operation\n  | MatchOperationFn;\n\n/**\n * Controller to be injected into tests, that allows for mocking and flushing\n * of operations.\n *\n *\n */\nexport abstract class ApolloTestingController {\n  /**\n   * Search for operations that match the given parameter, without any expectations.\n   */\n  public abstract match(match: MatchOperation): TestOperation[];\n\n  /**\n   * Expect that a single  has been made which matches the given URL, and return its\n   * mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    operationName: string,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given parameters, and return\n   * its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(op: Operation, description?: string): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given predicate function, and\n   * return its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    matchFn: MatchOperationFn,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that a single  has been made which matches the given condition, and return\n   * its mock.\n   *\n   * If no such  has been made, or more than one such  has been made, fail with an\n   * error message including the given  description, if any.\n   */\n  public abstract expectOne(\n    match: MatchOperation,\n    description?: string,\n  ): TestOperation;\n\n  /**\n   * Expect that no operations have been made which match the given URL.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(operationName: string, description?: string): void;\n\n  /**\n   * Expect that no operations have been made which match the given parameters.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(op: Operation, description?: string): void;\n\n  /**\n   * Expect that no operations have been made which match the given predicate function.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(\n    matchFn: MatchOperationFn,\n    description?: string,\n  ): void;\n\n  /**\n   * Expect that no operations have been made which match the given condition.\n   *\n   * If a matching  has been made, fail with an error message including the given\n   * description, if any.\n   */\n  public abstract expectNone(match: MatchOperation, description?: string): void;\n\n  /**\n   * Verify that no unmatched operations are outstanding.\n   *\n   * If any operations are outstanding, fail with an error message indicating which operations were not\n   * handled.\n   */\n  public abstract verify(): void;\n}\n","import {\n  ApolloError,\n  Operation as LinkOperation,\n  FetchResult,\n} from '@apollo/client/core';\nimport {GraphQLError, ExecutionResult} from 'graphql';\nimport {Observer} from 'rxjs';\n\nconst isApolloError = (err: any): err is ApolloError =>\n  err && err.hasOwnProperty('graphQLErrors');\n\nexport type Operation = LinkOperation & {\n  clientName: string;\n};\n\nexport class TestOperation<T = {[key: string]: any}> {\n  constructor(\n    public operation: Operation,\n    private observer: Observer<FetchResult<T>>,\n  ) {}\n\n  public flush(result: ExecutionResult | ApolloError): void {\n    if (isApolloError(result)) {\n      this.observer.error(result);\n    } else {\n      const fetchResult = result ? {...result} : result;\n      this.observer.next(fetchResult as FetchResult<T>);\n      this.observer.complete();\n    }\n  }\n\n  public flushData(data: {[key: string]: any} | null): void {\n    this.flush({\n      data,\n    });\n  }\n\n  public networkError(error: Error): void {\n    const apolloError = new ApolloError({\n      networkError: error,\n    });\n\n    this.flush(apolloError);\n  }\n\n  public graphqlErrors(errors: GraphQLError[]): void {\n    this.flush({\n      errors,\n    });\n  }\n}\n","import {Injectable} from '@angular/core';\nimport {Observer} from 'rxjs';\nimport {FetchResult, Observable as LinkObservable} from '@apollo/client/core';\nimport {print, DocumentNode} from 'graphql';\n\nimport {ApolloTestingController, MatchOperation} from './controller';\nimport {TestOperation, Operation} from './operation';\n\n/**\n * A testing backend for `Apollo`.\n *\n * `ApolloTestingBackend` works by keeping a list of all open operations.\n * As operations come in, they're added to the list. Users can assert that specific\n * operations were made and then flush them. In the end, a verify() method asserts\n * that no unexpected operations were made.\n */\n@Injectable()\nexport class ApolloTestingBackend implements ApolloTestingController {\n  /**\n   * List of pending operations which have not yet been expected.\n   */\n  private open: TestOperation[] = [];\n\n  /**\n   * Handle an incoming operation by queueing it in the list of open operations.\n   */\n  public handle(op: Operation): LinkObservable<FetchResult> {\n    return new LinkObservable((observer: Observer<any>) => {\n      const testOp = new TestOperation(op, observer);\n      this.open.push(testOp);\n    });\n  }\n\n  /**\n   * Helper function to search for operations in the list of open operations.\n   */\n  private _match(match: MatchOperation): TestOperation[] {\n    if (typeof match === 'string') {\n      return this.open.filter(\n        (testOp) => testOp.operation.operationName === match,\n      );\n    } else if (typeof match === 'function') {\n      return this.open.filter((testOp) => match(testOp.operation));\n    } else {\n      if (this.isDocumentNode(match)) {\n        return this.open.filter(\n          (testOp) => print(testOp.operation.query) === print(match),\n        );\n      }\n\n      return this.open.filter((testOp) => this.matchOp(match, testOp));\n    }\n  }\n\n  private matchOp(match: Operation, testOp: TestOperation): boolean {\n    const variables = JSON.stringify(match.variables);\n    const extensions = JSON.stringify(match.extensions);\n\n    const sameName = this.compare(\n      match.operationName,\n      testOp.operation.operationName,\n    );\n    const sameVariables = this.compare(variables, testOp.operation.variables);\n\n    const sameQuery = print(testOp.operation.query) === print(match.query);\n\n    const sameExtensions = this.compare(\n      extensions,\n      testOp.operation.extensions,\n    );\n\n    return sameName && sameVariables && sameQuery && sameExtensions;\n  }\n\n  private compare(expected?: string, value?: Object | string): boolean {\n    const prepare = (val: any) =>\n      typeof val === 'string' ? val : JSON.stringify(val);\n    const received = prepare(value);\n\n    return !expected || received === expected;\n  }\n\n  /**\n   * Search for operations in the list of open operations, and return all that match\n   * without asserting anything about the number of matches.\n   */\n  public match(match: MatchOperation): TestOperation[] {\n    const results = this._match(match);\n\n    results.forEach((result) => {\n      const index = this.open.indexOf(result);\n      if (index !== -1) {\n        this.open.splice(index, 1);\n      }\n    });\n    return results;\n  }\n\n  /**\n   * Expect that a single outstanding request matches the given matcher, and return\n   * it.\n   *\n   * operations returned through this API will no longer be in the list of open operations,\n   * and thus will not match twice.\n   */\n  public expectOne(match: MatchOperation, description?: string): TestOperation {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 1) {\n      throw new Error(\n        `Expected one matching operation for criteria \"${description}\", found ${matches.length} operations.`,\n      );\n    }\n    if (matches.length === 0) {\n      throw new Error(\n        `Expected one matching operation for criteria \"${description}\", found none.`,\n      );\n    }\n    return matches[0];\n  }\n\n  /**\n   * Expect that no outstanding operations match the given matcher, and throw an error\n   * if any do.\n   */\n  public expectNone(match: MatchOperation, description?: string): void {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 0) {\n      throw new Error(\n        `Expected zero matching operations for criteria \"${description}\", found ${matches.length}.`,\n      );\n    }\n  }\n\n  /**\n   * Validate that there are no outstanding operations.\n   */\n  public verify(): void {\n    const open = this.open;\n\n    if (open.length > 0) {\n      // Show the methods and URLs of open operations in the error, for convenience.\n      const operations = open\n        .map((testOp) => testOp.operation.operationName)\n        .join(', ');\n      throw new Error(\n        `Expected no open operations, found ${open.length}: ${operations}`,\n      );\n    }\n  }\n\n  private isDocumentNode(\n    docOrOp: DocumentNode | Operation,\n  ): docOrOp is DocumentNode {\n    return !(docOrOp as Operation).operationName;\n  }\n\n  private descriptionFromMatcher(matcher: MatchOperation): string {\n    if (typeof matcher === 'string') {\n      return `Match operationName: ${matcher}`;\n    } else if (typeof matcher === 'object') {\n      if (this.isDocumentNode(matcher)) {\n        return `Match DocumentNode`;\n      }\n\n      const name = matcher.operationName || '(any)';\n      const variables = JSON.stringify(matcher.variables) || '(any)';\n\n      return `Match operation: ${name}, variables: ${variables}`;\n    } else {\n      return `Match by function: ${matcher.name}`;\n    }\n  }\n}\n","import {Apollo} from 'apollo-angular';\nimport {\n  ApolloLink,\n  Operation as LinkOperation,\n  InMemoryCache,\n  ApolloCache,\n} from '@apollo/client/core';\nimport {NgModule, InjectionToken, Inject, Optional} from '@angular/core';\n\nimport {ApolloTestingController} from './controller';\nimport {ApolloTestingBackend} from './backend';\nimport {Operation} from './operation';\n\nexport type NamedCaches = Record<string, ApolloCache<any> | undefined | null>;\n\nexport const APOLLO_TESTING_CACHE = new InjectionToken<ApolloCache<any>>(\n  'apollo-angular/testing cache',\n);\n\nexport const APOLLO_TESTING_NAMED_CACHE = new InjectionToken<NamedCaches>(\n  'apollo-angular/testing named cache',\n);\n\nexport const APOLLO_TESTING_CLIENTS = new InjectionToken<string[]>(\n  'apollo-angular/testing named clients',\n);\n\nfunction addClient(name: string, op: LinkOperation): Operation {\n  (op as Operation).clientName = name;\n\n  return op as Operation;\n}\n\n@NgModule({\n  providers: [\n    ApolloTestingBackend,\n    {provide: ApolloTestingController, useExisting: ApolloTestingBackend},\n  ],\n})\nexport class ApolloTestingModuleCore {\n  constructor(\n    apollo: Apollo,\n    backend: ApolloTestingBackend,\n    @Optional()\n    @Inject(APOLLO_TESTING_CLIENTS)\n    namedClients?: string[],\n    @Optional()\n    @Inject(APOLLO_TESTING_CACHE)\n    cache?: ApolloCache<any>,\n    @Optional()\n    @Inject(APOLLO_TESTING_NAMED_CACHE)\n    namedCaches?: any, // FIX: using NamedCaches here makes ngc fail\n  ) {\n    function createOptions(name: string, c?: ApolloCache<any> | null) {\n      return {\n        link: new ApolloLink((operation) =>\n          backend.handle(addClient(name, operation)),\n        ),\n        cache:\n          c ||\n          new InMemoryCache({\n            addTypename: false,\n          }),\n      };\n    }\n\n    apollo.create(createOptions('default', cache));\n\n    if (namedClients && namedClients.length) {\n      namedClients.forEach((name) => {\n        const caches =\n          namedCaches && typeof namedCaches === 'object' ? namedCaches : {};\n\n        apollo.createNamed(name, createOptions(name, caches[name]));\n      });\n    }\n  }\n}\n\n@NgModule({\n  imports: [ApolloTestingModuleCore],\n})\nexport class ApolloTestingModule {\n  static withClients(names: string[]) {\n    return {\n      ngModule: ApolloTestingModuleCore,\n      providers: [\n        {\n          provide: APOLLO_TESTING_CLIENTS,\n          useValue: names,\n        },\n      ],\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {ApolloTestingBackend as ɵc} from './backend';\nexport {APOLLO_TESTING_CLIENTS as ɵa,ApolloTestingModuleCore as ɵb} from './module';"]}