{"ast":null,"code":"import { InjectionToken, Directive, Host, NgModule, SimpleChange, ChangeDetectorRef, Injectable, KeyValueDiffers, ComponentFactoryResolver, Inject, Optional, Input, EventEmitter, Injector, Component, ViewContainerRef, Output, Renderer2, ɵɵdefineInjectable, ɵɵinject, INJECTOR, ElementRef, IterableDiffers } from '@angular/core';\nimport { NgComponentOutlet, CommonModule } from '@angular/common';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/io/types.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction InputsType() {}\n/**\n * @record\n */\n\n\nfunction OutputsType() {}\n/**\n * @record\n */\n\n\nfunction OutputWithArgs() {}\n\nif (false) {\n  /** @type {?} */\n  OutputWithArgs.prototype.handler;\n  /** @type {?|undefined} */\n\n  OutputWithArgs.prototype.args;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/io/event-argument.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction defaultEventArgumentFactory() {\n  return '$event';\n}\n/** @type {?} */\n\n\nconst EventArgumentToken = new InjectionToken('EventArgument', {\n  providedIn: 'root',\n  factory: defaultEventArgumentFactory\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component-injector/token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nfunction DynamicComponentInjector() {}\n\nif (false) {\n  /** @type {?} */\n  DynamicComponentInjector.prototype.componentRef;\n}\n/** @type {?} */\n\n\nconst DynamicComponentInjectorToken = new InjectionToken('DynamicComponentInjector');\n/**\n * @deprecated Since v6.0.0 - Use {\\@link DynamicComponentInjectorToken} instead\n * and provide component class via `useExisting` instead of `useValue`\n * @type {?}\n */\n\nconst COMPONENT_INJECTOR = DynamicComponentInjectorToken;\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component-injector/component-outlet-injector.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nlet ComponentOutletInjectorDirective = /*#__PURE__*/(() => {\n  class ComponentOutletInjectorDirective {\n    /**\n     * @param {?} componentOutlet\n     */\n    constructor(componentOutlet) {\n      this.componentOutlet = componentOutlet;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get componentRef() {\n      // NOTE: Accessing private APIs of Angular\n      return this.componentOutlet._componentRef;\n    }\n\n  }\n\n  ComponentOutletInjectorDirective.ɵfac = function ComponentOutletInjectorDirective_Factory(t) {\n    return new (t || ComponentOutletInjectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgComponentOutlet, 1));\n  };\n\n  ComponentOutletInjectorDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ComponentOutletInjectorDirective,\n    selectors: [[\"\", \"ngComponentOutlet\", \"\"]],\n    exportAs: [\"ndcComponentOutletInjector\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: DynamicComponentInjectorToken,\n      useExisting: ComponentOutletInjectorDirective\n    }])]\n  });\n  /** @nocollapse */\n\n  return ComponentOutletInjectorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ComponentOutletInjectorDirective.prototype.componentOutlet;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component-injector/component-outlet-injector.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ComponentOutletInjectorModule = /*#__PURE__*/(() => {\n  class ComponentOutletInjectorModule {}\n\n  ComponentOutletInjectorModule.ɵfac = function ComponentOutletInjectorModule_Factory(t) {\n    return new (t || ComponentOutletInjectorModule)();\n  };\n\n  ComponentOutletInjectorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ComponentOutletInjectorModule\n  });\n  ComponentOutletInjectorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return ComponentOutletInjectorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ComponentOutletInjectorModule, {\n    declarations: function () {\n      return [ComponentOutletInjectorDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [ComponentOutletInjectorDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/util.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} val\n * @return {?}\n */\n\n\nfunction createNewChange(val) {\n  return new SimpleChange(undefined, val, true);\n}\n/**\n * @param {?} val\n * @param {?} prevVal\n * @return {?}\n */\n\n\nfunction createChange(val, prevVal) {\n  return new SimpleChange(prevVal, val, false);\n}\n/**\n * @return {?}\n */\n\n\nfunction noop() {}\n/**\n * @param {?} ctor\n * @param {?} reflect\n * @return {?}\n */\n\n\nfunction getCtorParamTypes(ctor, reflect) {\n  return reflect.getMetadata('design:paramtypes', ctor);\n}\n/**\n * Extract type arguments from Angular Directive/Component\n * @param {?} type\n * @return {?}\n */\n\n\nfunction extractNgParamTypes(type) {\n  var _a, _b, _c; // NOTE: Accessing private APIs of Angular\n\n\n  return (_c = (_b = (_a = type) === null || _a === void 0 ? void 0 : _a.ctorParameters) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.map(\n  /**\n  * @param {?} param\n  * @return {?}\n  */\n  param => param.type);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/io/io.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction IOMapInfo() {}\n\nif (false) {\n  /** @type {?} */\n  IOMapInfo.prototype.propName;\n  /** @type {?} */\n\n  IOMapInfo.prototype.templateName;\n}\n/**\n * @record\n */\n\n\nfunction IoInitOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  IoInitOptions.prototype.trackOutputChanges;\n}\n/**\n * @record\n */\n\n\nfunction OutputsTypeProcessed() {}\n\nlet IoService = /*#__PURE__*/(() => {\n  class IoService {\n    /**\n     * @param {?} differs\n     * @param {?} cfr\n     * @param {?} eventArgument\n     */\n    constructor(differs, cfr, eventArgument) {\n      this.differs = differs;\n      this.cfr = cfr;\n      this.eventArgument = eventArgument;\n      this.checkInit = this.failInit;\n      this.lastComponentInst = null;\n      this.inputsDiffer = this.differs.find({}).create();\n      this.compFactory = null;\n      this.outputsShouldDisconnect$ = new Subject();\n\n      this.outputsChanged =\n      /**\n      * @return {?}\n      */\n      () => false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get compRef() {\n      return this.compInjector.componentRef;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get componentInst() {\n      return this.compRef ? this.compRef.instance : null;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get componentInstChanged() {\n      if (this.lastComponentInst !== this.componentInst) {\n        this.lastComponentInst = this.componentInst;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get compCdr() {\n      // tslint:disable-next-line: deprecation\n      return this.compRef ? this.compRef.injector.get(ChangeDetectorRef) : null;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._disconnectOutputs();\n    }\n    /**\n     * @param {?} componentInjector\n     * @param {?=} options\n     * @return {?}\n     */\n\n\n    init(componentInjector, options = {}) {\n      this.checkInit = componentInjector ? noop : this.failInit;\n      this.compInjector = componentInjector;\n\n      if (options.trackOutputChanges) {\n        /** @type {?} */\n        const outputsDiffer = this.differs.find({}).create();\n\n        this.outputsChanged =\n        /**\n        * @param {?} outputs\n        * @return {?}\n        */\n        outputs => !!outputsDiffer.diff(outputs);\n      }\n    }\n    /**\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} inputsChanged\n     * @param {?} outputsChanged\n     * @return {?}\n     */\n\n\n    update(inputs, outputs, inputsChanged, outputsChanged) {\n      this.checkInit();\n      this.updateIO(inputs, outputs);\n      /** @type {?} */\n\n      const compChanged = this.componentInstChanged;\n\n      if (compChanged || inputsChanged) {\n        /** @type {?} */\n        const inputsChanges = this._getInputsChanges();\n\n        if (inputsChanges) {\n          this._updateInputChanges(inputsChanges);\n        }\n\n        this.updateInputs(compChanged || !this.lastInputChanges);\n      }\n\n      if (compChanged || outputsChanged) {\n        this.bindOutputs();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    maybeUpdate() {\n      this.checkInit();\n\n      if (this.componentInstChanged) {\n        this.updateInputs(true);\n        this.bindOutputs();\n        return;\n      }\n\n      if (this.outputsChanged(this.outputs)) {\n        this.bindOutputs();\n      }\n\n      if (!this.inputs) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const inputsChanges = this._getInputsChanges();\n\n      if (inputsChanges) {\n        /** @type {?} */\n        const isNotFirstChange = !!this.lastInputChanges;\n\n        this._updateInputChanges(inputsChanges);\n\n        if (isNotFirstChange) {\n          this.updateInputs();\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n\n\n    updateIO(inputs, outputs) {\n      this.inputs = inputs;\n      this.outputs = outputs;\n    }\n    /**\n     * @private\n     * @param {?=} isFirstChange\n     * @return {?}\n     */\n\n\n    updateInputs(isFirstChange = false) {\n      if (isFirstChange) {\n        this._updateCompFactory();\n      }\n      /** @type {?} */\n\n\n      const compInst = this.componentInst;\n      /** @type {?} */\n\n      let inputs = this.inputs;\n\n      if (!inputs || !compInst) {\n        return;\n      }\n\n      inputs = this._resolveInputs(inputs);\n      Object.keys(inputs).forEach(\n      /**\n      * @param {?} p\n      * @return {?}\n      */\n      p => compInst[p] = inputs[p]); // Mark component for check to re-render with new inputs\n\n      if (this.compCdr) {\n        this.compCdr.markForCheck();\n      }\n\n      this.notifyOnInputChanges(this.lastInputChanges, isFirstChange);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    bindOutputs() {\n      this._disconnectOutputs();\n      /** @type {?} */\n\n\n      const compInst = this.componentInst;\n      /** @type {?} */\n\n      let outputs = this.outputs;\n\n      if (!outputs || !compInst) {\n        return;\n      }\n\n      outputs = this._resolveOutputs(outputs);\n      Object.keys(outputs).filter(\n      /**\n      * @param {?} p\n      * @return {?}\n      */\n      p => compInst[p]).forEach(\n      /**\n      * @param {?} p\n      * @return {?}\n      */\n      p => compInst[p].pipe(takeUntil(this.outputsShouldDisconnect$)).subscribe(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => outputs[p](event)));\n    }\n    /**\n     * @private\n     * @param {?=} changes\n     * @param {?=} forceFirstChanges\n     * @return {?}\n     */\n\n\n    notifyOnInputChanges(changes = {}, forceFirstChanges) {\n      // Exit early if component not interested to receive changes\n      if (!this.componentInst.ngOnChanges) {\n        return;\n      }\n\n      if (forceFirstChanges) {\n        changes = this._collectFirstChanges();\n      }\n\n      this.componentInst.ngOnChanges(changes);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _disconnectOutputs() {\n      this.outputsShouldDisconnect$.next();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getInputsChanges() {\n      return this.inputsDiffer.diff(this.inputs);\n    }\n    /**\n     * @private\n     * @param {?} differ\n     * @return {?}\n     */\n\n\n    _updateInputChanges(differ) {\n      this.lastInputChanges = this._collectChangesFromDiffer(differ);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _collectFirstChanges() {\n      /** @type {?} */\n      const changes = {};\n      /** @type {?} */\n\n      const inputs = this.inputs;\n      Object.keys(inputs).forEach(\n      /**\n      * @param {?} prop\n      * @return {?}\n      */\n      prop => changes[prop] = createNewChange(inputs[prop]));\n      return this._resolveChanges(changes);\n    }\n    /**\n     * @private\n     * @param {?} differ\n     * @return {?}\n     */\n\n\n    _collectChangesFromDiffer(differ) {\n      /** @type {?} */\n      const changes = {};\n      differ.forEachAddedItem(\n      /**\n      * @param {?} record\n      * @return {?}\n      */\n      record => changes[record.key] = createNewChange(record.currentValue));\n      differ.forEachChangedItem(\n      /**\n      * @param {?} record\n      * @return {?}\n      */\n      record => changes[record.key] = createChange(record.currentValue, record.previousValue));\n      return this._resolveChanges(changes);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _resolveCompFactory() {\n      try {\n        try {\n          return this.cfr.resolveComponentFactory(this.compRef.componentType);\n        } catch (e) {\n          // Fallback if componentType does not exist (happens on NgComponentOutlet)\n          return this.cfr.resolveComponentFactory(this.compRef.instance.constructor);\n        }\n      } catch (e) {\n        // Factory not available - bailout\n        return null;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _updateCompFactory() {\n      this.compFactory = this._resolveCompFactory();\n    }\n    /**\n     * @private\n     * @param {?} inputs\n     * @return {?}\n     */\n\n\n    _resolveInputs(inputs) {\n      if (!this.compFactory) {\n        return inputs;\n      }\n\n      return this._remapIO(inputs, this.compFactory.inputs);\n    }\n    /**\n     * @private\n     * @param {?} outputs\n     * @return {?}\n     */\n\n\n    _resolveOutputs(outputs) {\n      outputs = this._processOutputs(outputs);\n\n      if (!this.compFactory) {\n        return outputs;\n      }\n\n      return this._remapIO(outputs, this.compFactory.outputs);\n    }\n    /**\n     * @private\n     * @param {?} outputs\n     * @return {?}\n     */\n\n\n    _processOutputs(outputs) {\n      /** @type {?} */\n      const processedOutputs = {};\n      Object.keys(outputs).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        /** @type {?} */\n        const outputExpr = outputs[key];\n\n        if (typeof outputExpr === 'function') {\n          processedOutputs[key] = outputExpr;\n        } else {\n          processedOutputs[key] = outputExpr && this._processOutputArgs(outputExpr);\n        }\n      });\n      return processedOutputs;\n    }\n    /**\n     * @private\n     * @param {?} output\n     * @return {?}\n     */\n\n\n    _processOutputArgs(output) {\n      const {\n        handler\n      } = output;\n      /** @type {?} */\n\n      const args = 'args' in output ? output.args || [] : [this.eventArgument];\n      return (\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => handler(...args.map(\n        /**\n        * @param {?} arg\n        * @return {?}\n        */\n        arg => arg === this.eventArgument ? event : arg))\n      );\n    }\n    /**\n     * @private\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    _resolveChanges(changes) {\n      if (!this.compFactory) {\n        return changes;\n      }\n\n      return this._remapIO(changes, this.compFactory.inputs);\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} io\n     * @param {?} mapping\n     * @return {?}\n     */\n\n\n    _remapIO(io, mapping) {\n      /** @type {?} */\n      const newIO = {};\n      Object.keys(io).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        /** @type {?} */\n        const newKey = this._findPropByTplInMapping(key, mapping) || key;\n        newIO[newKey] = io[key];\n      });\n      return newIO;\n    }\n    /**\n     * @private\n     * @param {?} tplName\n     * @param {?} mapping\n     * @return {?}\n     */\n\n\n    _findPropByTplInMapping(tplName, mapping) {\n      for (const map of mapping) {\n        if (map.templateName === tplName) {\n          return map.propName;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    failInit() {\n      throw Error('IoService: ComponentInjector was not set! Please call init() method!');\n    }\n\n  }\n\n  IoService.ɵfac = function IoService_Factory(t) {\n    return new (t || IoService)(ɵngcc0.ɵɵinject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(EventArgumentToken));\n  };\n\n  IoService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: IoService,\n    factory: IoService.ɵfac\n  });\n  /** @nocollapse */\n\n  return IoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  IoService.prototype.checkInit;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.lastComponentInst;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.lastInputChanges;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.inputsDiffer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.compFactory;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.outputsShouldDisconnect$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.inputs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.outputs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.compInjector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.outputsChanged;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.differs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.cfr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoService.prototype.eventArgument;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-io/dynamic-io.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable-next-line: no-conflicting-lifecycle\n\n\nlet DynamicIoDirective = /*#__PURE__*/(() => {\n  class DynamicIoDirective {\n    /**\n     * @param {?} ioService\n     * @param {?=} componentInjector\n     */\n    constructor(ioService, componentInjector) {\n      this.ioService = ioService;\n      this.componentInjector = componentInjector;\n      this.ioService.init(this.componentInjector);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get inputs() {\n      return this.ndcDynamicInputs || this.ngComponentOutletNdcDynamicInputs;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get outputs() {\n      return this.ndcDynamicOutputs || this.ngComponentOutletNdcDynamicOutputs;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.ioService.update(this.inputs, this.outputs, this.inputsChanged(changes), this.outputsChanged(changes));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      this.ioService.maybeUpdate();\n    }\n    /**\n     * @private\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    inputsChanged(changes) {\n      return 'ngComponentOutletNdcDynamicInputs' in changes || 'ndcDynamicInputs' in changes;\n    }\n    /**\n     * @private\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    outputsChanged(changes) {\n      return 'ngComponentOutletNdcDynamicOutputs' in changes || 'ndcDynamicOutputs' in changes;\n    }\n\n  }\n\n  DynamicIoDirective.ɵfac = function DynamicIoDirective_Factory(t) {\n    return new (t || DynamicIoDirective)(ɵngcc0.ɵɵdirectiveInject(IoService), ɵngcc0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n\n  DynamicIoDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DynamicIoDirective,\n    selectors: [[\"\", \"ndcDynamicInputs\", \"\"], [\"\", \"ndcDynamicOutputs\", \"\"], [\"\", \"ngComponentOutletNdcDynamicInputs\", \"\"], [\"\", \"ngComponentOutletNdcDynamicOutputs\", \"\"]],\n    inputs: {\n      ndcDynamicInputs: \"ndcDynamicInputs\",\n      ngComponentOutletNdcDynamicInputs: \"ngComponentOutletNdcDynamicInputs\",\n      ndcDynamicOutputs: \"ndcDynamicOutputs\",\n      ngComponentOutletNdcDynamicOutputs: \"ngComponentOutletNdcDynamicOutputs\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([IoService]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return DynamicIoDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  DynamicIoDirective.prototype.ndcDynamicInputs;\n  /** @type {?} */\n\n  DynamicIoDirective.prototype.ngComponentOutletNdcDynamicInputs;\n  /** @type {?} */\n\n  DynamicIoDirective.prototype.ndcDynamicOutputs;\n  /** @type {?} */\n\n  DynamicIoDirective.prototype.ngComponentOutletNdcDynamicOutputs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicIoDirective.prototype.ioService;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicIoDirective.prototype.componentInjector;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-io/dynamic-io.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DynamicIoModule = /*#__PURE__*/(() => {\n  class DynamicIoModule {}\n\n  DynamicIoModule.ɵfac = function DynamicIoModule_Factory(t) {\n    return new (t || DynamicIoModule)();\n  };\n\n  DynamicIoModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DynamicIoModule\n  });\n  DynamicIoModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicIoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DynamicIoModule, {\n    declarations: function () {\n      return [DynamicIoDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [DynamicIoDirective, ComponentOutletInjectorModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component-injector/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DynamicComponent = /*#__PURE__*/(() => {\n  class DynamicComponent {\n    /**\n     * @param {?} vcr\n     * @param {?} cfr\n     */\n    constructor(vcr, cfr) {\n      this.vcr = vcr;\n      this.cfr = cfr;\n      this.ndcDynamicCreated = new EventEmitter();\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.ndcDynamicComponent) {\n        this.createDynamicComponent();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    createDynamicComponent() {\n      this.vcr.clear();\n      this.componentRef = null;\n\n      if (this.ndcDynamicComponent) {\n        this.componentRef = this.vcr.createComponent(this.cfr.resolveComponentFactory(this.ndcDynamicComponent), 0, this._resolveInjector(), this.ndcDynamicContent);\n        this.ndcDynamicCreated.emit(this.componentRef);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _resolveInjector() {\n      /** @type {?} */\n      let injector = this.ndcDynamicInjector || this.vcr.injector;\n\n      if (this.ndcDynamicProviders) {\n        injector = Injector.create({\n          providers: this.ndcDynamicProviders,\n          parent: injector\n        });\n      }\n\n      return injector;\n    }\n\n  }\n\n  DynamicComponent.ɵfac = function DynamicComponent_Factory(t) {\n    return new (t || DynamicComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  DynamicComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DynamicComponent,\n    selectors: [[\"ndc-dynamic\"]],\n    inputs: {\n      ndcDynamicComponent: \"ndcDynamicComponent\",\n      ndcDynamicInjector: \"ndcDynamicInjector\",\n      ndcDynamicProviders: \"ndcDynamicProviders\",\n      ndcDynamicContent: \"ndcDynamicContent\"\n    },\n    outputs: {\n      ndcDynamicCreated: \"ndcDynamicCreated\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: DynamicComponentInjectorToken,\n      useExisting: DynamicComponent\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function DynamicComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return DynamicComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  DynamicComponent.prototype.ndcDynamicComponent;\n  /** @type {?} */\n\n  DynamicComponent.prototype.ndcDynamicInjector;\n  /** @type {?} */\n\n  DynamicComponent.prototype.ndcDynamicProviders;\n  /** @type {?} */\n\n  DynamicComponent.prototype.ndcDynamicContent;\n  /** @type {?} */\n\n  DynamicComponent.prototype.ndcDynamicCreated;\n  /** @type {?} */\n\n  DynamicComponent.prototype.componentRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicComponent.prototype.vcr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicComponent.prototype.cfr;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DynamicModule = /*#__PURE__*/(() => {\n  class DynamicModule {}\n\n  DynamicModule.ɵfac = function DynamicModule_Factory(t) {\n    return new (t || DynamicModule)();\n  };\n\n  DynamicModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DynamicModule\n  });\n  DynamicModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, DynamicIoModule], DynamicIoModule]\n  });\n  return DynamicModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DynamicModule, {\n    declarations: function () {\n      return [DynamicComponent];\n    },\n    imports: function () {\n      return [CommonModule, DynamicIoModule];\n    },\n    exports: function () {\n      return [DynamicComponent, DynamicIoModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-attributes/dynamic-attributes.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AttributesMap() {}\n/**\n * @record\n */\n\n\nfunction AttributeActions() {}\n\nif (false) {\n  /** @type {?} */\n  AttributeActions.prototype.set;\n  /** @type {?} */\n\n  AttributeActions.prototype.remove;\n}\n\nlet DynamicAttributesDirective = /*#__PURE__*/(() => {\n  class DynamicAttributesDirective {\n    /**\n     * @param {?} renderer\n     * @param {?} differs\n     * @param {?} injector\n     * @param {?=} componentInjector\n     */\n    constructor(renderer, differs, injector, componentInjector) {\n      this.renderer = renderer;\n      this.differs = differs;\n      this.injector = injector;\n      this.componentInjector = componentInjector;\n      this.attrsDiffer = this.differs.find({}).create();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get _attributes() {\n      return this.ndcDynamicAttributes || this.ngComponentOutletNdcDynamicAttributes;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get _nativeElement() {\n      var _a;\n\n      return (_a = this.componentInjector.componentRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get _compType() {\n      var _a;\n\n      return (_a = this.componentInjector.componentRef) === null || _a === void 0 ? void 0 : _a.componentType;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get _isCompChanged() {\n      if (this.lastCompType !== this._compType) {\n        this.lastCompType = this._compType;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      /** @type {?} */\n      const isCompChanged = this._isCompChanged;\n      /** @type {?} */\n\n      const changes = this.attrsDiffer.diff(this._attributes);\n\n      if (changes) {\n        this.lastAttrActions = this._changesToAttrActions(changes);\n      }\n\n      if (changes || isCompChanged && this.lastAttrActions) {\n        this._updateAttributes(this.lastAttrActions);\n      }\n    }\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} namespace\n     * @return {?}\n     */\n\n\n    setAttribute(name, value, namespace) {\n      if (this._nativeElement) {\n        this.renderer.setAttribute(this._nativeElement, name, value, namespace);\n      }\n    }\n    /**\n     * @param {?} name\n     * @param {?=} namespace\n     * @return {?}\n     */\n\n\n    removeAttribute(name, namespace) {\n      if (this._nativeElement) {\n        this.renderer.removeAttribute(this._nativeElement, name, namespace);\n      }\n    }\n    /**\n     * @private\n     * @param {?} actions\n     * @return {?}\n     */\n\n\n    _updateAttributes(actions) {\n      // ? Early exit if no dynamic component\n      if (!this._compType) {\n        return;\n      }\n\n      Object.keys(actions.set).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => this.setAttribute(key, actions.set[key]));\n      actions.remove.forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => this.removeAttribute(key));\n    }\n    /**\n     * @private\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    _changesToAttrActions(changes) {\n      /** @type {?} */\n      const attrActions = {\n        set: {},\n        remove: []\n      };\n      changes.forEachAddedItem(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => attrActions.set[r.key] = r.currentValue);\n      changes.forEachChangedItem(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => attrActions.set[r.key] = r.currentValue);\n      changes.forEachRemovedItem(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => attrActions.remove.push(r.key));\n      return attrActions;\n    }\n\n  }\n\n  DynamicAttributesDirective.ɵfac = function DynamicAttributesDirective_Factory(t) {\n    return new (t || DynamicAttributesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n\n  DynamicAttributesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DynamicAttributesDirective,\n    selectors: [[\"\", \"ndcDynamicAttributes\", \"\"], [\"\", \"ngComponentOutletNdcDynamicAttributes\", \"\"]],\n    inputs: {\n      ndcDynamicAttributes: \"ndcDynamicAttributes\",\n      ngComponentOutletNdcDynamicAttributes: \"ngComponentOutletNdcDynamicAttributes\"\n    },\n    exportAs: [\"ndcDynamicAttributes\"]\n  });\n  /** @nocollapse */\n\n  return DynamicAttributesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  DynamicAttributesDirective.prototype.ndcDynamicAttributes;\n  /** @type {?} */\n\n  DynamicAttributesDirective.prototype.ngComponentOutletNdcDynamicAttributes;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.attrsDiffer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.lastCompType;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.lastAttrActions;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.differs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.injector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicAttributesDirective.prototype.componentInjector;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-attributes/dynamic-attributes.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DynamicAttributesModule = /*#__PURE__*/(() => {\n  class DynamicAttributesModule {}\n\n  DynamicAttributesModule.ɵfac = function DynamicAttributesModule_Factory(t) {\n    return new (t || DynamicAttributesModule)();\n  };\n\n  DynamicAttributesModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DynamicAttributesModule\n  });\n  DynamicAttributesModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicAttributesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DynamicAttributesModule, {\n    declarations: function () {\n      return [DynamicAttributesDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [DynamicAttributesDirective, ComponentOutletInjectorModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/io/io-factory.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet IoFactoryService = /*#__PURE__*/(() => {\n  class IoFactoryService {\n    /**\n     * @param {?} differs\n     * @param {?} cfr\n     * @param {?} eventArgument\n     */\n    constructor(differs, cfr, eventArgument) {\n      this.differs = differs;\n      this.cfr = cfr;\n      this.eventArgument = eventArgument;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    create() {\n      return new IoService(this.differs, this.cfr, this.eventArgument);\n    }\n\n  }\n\n  IoFactoryService.ɵfac = function IoFactoryService_Factory(t) {\n    return new (t || IoFactoryService)(ɵngcc0.ɵɵinject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(EventArgumentToken));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  IoFactoryService.ɵprov = ɵɵdefineInjectable({\n    factory: function IoFactoryService_Factory() {\n      return new IoFactoryService(ɵɵinject(KeyValueDiffers), ɵɵinject(ComponentFactoryResolver), ɵɵinject(EventArgumentToken));\n    },\n    token: IoFactoryService,\n    providedIn: \"root\"\n  });\n  return IoFactoryService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  IoFactoryService.prototype.differs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoFactoryService.prototype.cfr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IoFactoryService.prototype.eventArgument;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/window-ref/window-ref-browser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction browserWindowFactory() {\n  return window;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/window-ref/window-ref.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst WindowRefToken = new InjectionToken('WindowRef', {\n  providedIn: 'root',\n  factory: browserWindowFactory\n});\nlet WindowRefService = /*#__PURE__*/(() => {\n  class WindowRefService {\n    /**\n     * @param {?} injector\n     */\n    constructor(injector) {\n      this.injector = injector;\n      this.nativeWindow = this.injector.get(WindowRefToken, null);\n    }\n\n  }\n\n  WindowRefService.ɵfac = function WindowRefService_Factory(t) {\n    return new (t || WindowRefService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  WindowRefService.ɵprov = ɵɵdefineInjectable({\n    factory: function WindowRefService_Factory() {\n      return new WindowRefService(ɵɵinject(INJECTOR));\n    },\n    token: WindowRefService,\n    providedIn: \"root\"\n  });\n  return WindowRefService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  WindowRefService.prototype.nativeWindow;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  WindowRefService.prototype.injector;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-directives/dynamic-directives.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\n\nfunction DynamicDirectiveDef() {}\n\nif (false) {\n  /** @type {?} */\n  DynamicDirectiveDef.prototype.type;\n  /** @type {?|undefined} */\n\n  DynamicDirectiveDef.prototype.inputs;\n  /** @type {?|undefined} */\n\n  DynamicDirectiveDef.prototype.outputs;\n}\n/**\n * @template T\n * @param {?} type\n * @param {?=} inputs\n * @param {?=} outputs\n * @return {?}\n */\n\n\nfunction dynamicDirectiveDef(type, inputs, outputs) {\n  return {\n    type,\n    inputs,\n    outputs\n  };\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DirectiveRef() {}\n\nif (false) {\n  /** @type {?} */\n  DirectiveRef.prototype.instance;\n  /** @type {?} */\n\n  DirectiveRef.prototype.type;\n  /** @type {?} */\n\n  DirectiveRef.prototype.injector;\n  /** @type {?} */\n\n  DirectiveRef.prototype.hostComponent;\n  /** @type {?} */\n\n  DirectiveRef.prototype.hostView;\n  /** @type {?} */\n\n  DirectiveRef.prototype.location;\n  /** @type {?} */\n\n  DirectiveRef.prototype.changeDetectorRef;\n  /** @type {?} */\n\n  DirectiveRef.prototype.onDestroy;\n}\n\nlet DynamicDirectivesDirective = /*#__PURE__*/(() => {\n  class DynamicDirectivesDirective {\n    /**\n     * @param {?} iterableDiffers\n     * @param {?} ioFactoryService\n     * @param {?} windowRef\n     * @param {?=} componentInjector\n     */\n    constructor(iterableDiffers, ioFactoryService, windowRef, componentInjector) {\n      this.iterableDiffers = iterableDiffers;\n      this.ioFactoryService = ioFactoryService;\n      this.windowRef = windowRef;\n      this.componentInjector = componentInjector;\n      this.ndcDynamicDirectivesCreated = new EventEmitter();\n      this.dirRef = new Map();\n      this.dirIo = new Map();\n      this.dirsDiffer = this.iterableDiffers.find([]).create(\n      /**\n      * @param {?} _\n      * @param {?} def\n      * @return {?}\n      */\n      (_, def) => def.type);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get directives() {\n      return this.ndcDynamicDirectives || this.ngComponentOutletNdcDynamicDirectives;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get componentRef() {\n      return this.componentInjector.componentRef;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get compInstance() {\n      return this.componentRef && this.componentRef.instance;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get isCompChanged() {\n      if (this.lastCompInstance !== this.compInstance) {\n        this.lastCompInstance = this.compInstance;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get hostInjector() {\n      return this.componentRef.injector;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get hostVcr() {\n      // NOTE: Accessing private APIs of Angular\n      // tslint:disable-next-line: no-string-literal\n      return this.componentRef['_viewRef']['_viewContainerRef'];\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get reflect() {\n      return this.windowRef.nativeWindow.Reflect;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      if (this.maybeDestroyDirectives()) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const dirsChanges = this.dirsDiffer.diff(this.directives);\n\n      if (!dirsChanges) {\n        return this.updateDirectives();\n      }\n\n      this.processDirChanges(dirsChanges);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroyAllDirectives();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    maybeDestroyDirectives() {\n      if (this.isCompChanged || !this.componentRef) {\n        this.dirsDiffer.diff([]);\n        this.destroyAllDirectives();\n      }\n\n      return !this.componentRef;\n    }\n    /**\n     * @private\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    processDirChanges(changes) {\n      changes.forEachRemovedItem(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        item\n      }) => this.destroyDirective(item));\n      /** @type {?} */\n\n      const createdDirs = [];\n      changes.forEachAddedItem(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        item\n      }) => createdDirs.push(this.initDirective(item)));\n\n      if (createdDirs.length) {\n        this.ndcDynamicDirectivesCreated.emit(createdDirs.filter(Boolean));\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    updateDirectives() {\n      this.directives.forEach(\n      /**\n      * @param {?} dir\n      * @return {?}\n      */\n      dir => this.updateDirective(dir));\n    }\n    /**\n     * @private\n     * @param {?} dirDef\n     * @return {?}\n     */\n\n\n    updateDirective(dirDef) {\n      /** @type {?} */\n      const io = this.dirIo.get(dirDef.type);\n      io.update(dirDef.inputs, dirDef.outputs, false, false);\n      io.maybeUpdate();\n    }\n    /**\n     * @private\n     * @param {?} dirDef\n     * @return {?}\n     */\n\n\n    initDirective(dirDef) {\n      if (this.dirRef.has(dirDef.type)) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const instance = this.createDirective(dirDef.type);\n      /** @type {?} */\n\n      const dir = {\n        instance,\n        type: dirDef.type,\n        injector: this.hostInjector,\n        hostComponent: this.componentRef.instance,\n        hostView: this.componentRef.hostView,\n        location: this.componentRef.location,\n        changeDetectorRef: this.componentRef.changeDetectorRef,\n        onDestroy: this.componentRef.onDestroy\n      };\n      this.initDirIO(dir, dirDef.inputs, dirDef.outputs);\n      this.callInitHooks(instance);\n      this.dirRef.set(dir.type, dir);\n      return dir;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    destroyAllDirectives() {\n      this.dirRef.forEach(\n      /**\n      * @param {?} dir\n      * @return {?}\n      */\n      dir => this.destroyDirRef(dir));\n      this.dirRef.clear();\n      this.dirIo.clear();\n    }\n    /**\n     * @private\n     * @param {?} dirDef\n     * @return {?}\n     */\n\n\n    destroyDirective(dirDef) {\n      this.destroyDirRef(this.dirRef.get(dirDef.type));\n      this.dirRef.delete(dirDef.type);\n      this.dirIo.delete(dirDef.type);\n    }\n    /**\n     * @private\n     * @param {?} dir\n     * @param {?=} inputs\n     * @param {?=} outputs\n     * @return {?}\n     */\n\n\n    initDirIO(dir, inputs, outputs) {\n      /** @type {?} */\n      const io = this.ioFactoryService.create();\n      io.init({\n        componentRef: this.dirToCompDef(dir)\n      }, {\n        trackOutputChanges: true\n      });\n      io.update(inputs, outputs, !!inputs, !!outputs);\n      this.dirIo.set(dir.type, io);\n    }\n    /**\n     * @private\n     * @param {?} dir\n     * @return {?}\n     */\n\n\n    dirToCompDef(dir) {\n      return {\n        changeDetectorRef: this.componentRef.changeDetectorRef,\n        hostView: this.componentRef.hostView,\n        location: this.componentRef.location,\n        destroy: this.componentRef.destroy,\n        onDestroy: this.componentRef.onDestroy,\n        injector: this.componentRef.injector,\n        instance: dir.instance,\n        componentType: dir.type\n      };\n    }\n    /**\n     * @private\n     * @param {?} dir\n     * @return {?}\n     */\n\n\n    destroyDirRef(dir) {\n      /** @type {?} */\n      const io = this.dirIo.get(dir.type);\n      io.ngOnDestroy();\n\n      if ('ngOnDestroy' in dir.instance) {\n        dir.instance.ngOnDestroy();\n      }\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} dirType\n     * @return {?}\n     */\n\n\n    createDirective(dirType) {\n      /** @type {?} */\n      const directiveInjector = Injector.create({\n        providers: [{\n          provide: dirType,\n          useClass: dirType,\n          deps: this.resolveDirParamTypes(dirType)\n        }, {\n          provide: ElementRef,\n          useValue: this.componentRef.location\n        }],\n        parent: this.hostInjector,\n        name: `DynamicDirectiveInjector:${dirType.name}@${this.componentRef.componentType.name}`\n      });\n      return directiveInjector.get(dirType);\n    }\n    /**\n     * @private\n     * @param {?} dirType\n     * @return {?}\n     */\n\n\n    resolveDirParamTypes(dirType) {\n      var _a, _b;\n\n      return (_b = (_a = // First try Angular Compiler's metadata\n      extractNgParamTypes(dirType)) !== null && _a !== void 0 ? _a : // Then fallback to Typescript Reflect API\n      getCtorParamTypes(dirType, this.reflect)) !== null && _b !== void 0 ? _b : // Bailout\n      [];\n    }\n    /**\n     * @private\n     * @param {?} obj\n     * @return {?}\n     */\n\n\n    callInitHooks(obj) {\n      this.callHook(obj, 'ngOnInit');\n      this.callHook(obj, 'ngDoCheck');\n      this.callHook(obj, 'ngAfterContentInit');\n      this.callHook(obj, 'ngAfterContentChecked');\n      this.callHook(obj, 'ngAfterViewInit');\n      this.callHook(obj, 'ngAfterViewChecked');\n    }\n    /**\n     * @private\n     * @param {?} obj\n     * @param {?} hook\n     * @param {?=} args\n     * @return {?}\n     */\n\n\n    callHook(obj, hook, args = []) {\n      if (obj[hook]) {\n        obj[hook](...args);\n      }\n    }\n\n  }\n\n  DynamicDirectivesDirective.ɵfac = function DynamicDirectivesDirective_Factory(t) {\n    return new (t || DynamicDirectivesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(IoFactoryService), ɵngcc0.ɵɵdirectiveInject(WindowRefService), ɵngcc0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n\n  DynamicDirectivesDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DynamicDirectivesDirective,\n    selectors: [[\"\", \"ndcDynamicDirectives\", \"\"], [\"\", \"ngComponentOutletNdcDynamicDirectives\", \"\"]],\n    inputs: {\n      ndcDynamicDirectives: \"ndcDynamicDirectives\",\n      ngComponentOutletNdcDynamicDirectives: \"ngComponentOutletNdcDynamicDirectives\"\n    },\n    outputs: {\n      ndcDynamicDirectivesCreated: \"ndcDynamicDirectivesCreated\"\n    }\n  });\n  /** @nocollapse */\n\n  return DynamicDirectivesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  DynamicDirectivesDirective.prototype.ndcDynamicDirectives;\n  /** @type {?} */\n\n  DynamicDirectivesDirective.prototype.ngComponentOutletNdcDynamicDirectives;\n  /** @type {?} */\n\n  DynamicDirectivesDirective.prototype.ndcDynamicDirectivesCreated;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.lastCompInstance;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.dirRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.dirIo;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.dirsDiffer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.iterableDiffers;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.ioFactoryService;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.windowRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DynamicDirectivesDirective.prototype.componentInjector;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/dynamic-directives/dynamic-directives.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DynamicDirectivesModule = /*#__PURE__*/(() => {\n  class DynamicDirectivesModule {}\n\n  DynamicDirectivesModule.ɵfac = function DynamicDirectivesModule_Factory(t) {\n    return new (t || DynamicDirectivesModule)();\n  };\n\n  DynamicDirectivesModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DynamicDirectivesModule\n  });\n  DynamicDirectivesModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicDirectivesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DynamicDirectivesModule, {\n    declarations: function () {\n      return [DynamicDirectivesDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [DynamicDirectivesDirective, ComponentOutletInjectorModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ng-dynamic-component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { COMPONENT_INJECTOR, ComponentOutletInjectorDirective, ComponentOutletInjectorModule, DynamicAttributesDirective, DynamicAttributesModule, DynamicComponent, DynamicComponentInjectorToken, DynamicDirectivesDirective, DynamicDirectivesModule, DynamicIoDirective, DynamicIoModule, DynamicModule, EventArgumentToken, defaultEventArgumentFactory, dynamicDirectiveDef, IoService as ɵa, DynamicComponentInjectorToken as ɵb, IoFactoryService as ɵc, WindowRefService as ɵd }; //# sourceMappingURL=ng-dynamic-component.js.map","map":null,"metadata":{},"sourceType":"module"}