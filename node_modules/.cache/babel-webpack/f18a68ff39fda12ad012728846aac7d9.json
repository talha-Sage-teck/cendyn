{"ast":null,"code":"import { isArray, isMatrix } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nimport { csIpvec } from '../sparse/csIpvec.js';\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    lup,\n    slu,\n    usolve,\n    lsolve,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  return typed(name, {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      a = matrix(a);\n      var d = lup(a);\n\n      var x = _lusolve(d.L, d.U, d.p, null, b);\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      var d = slu(a, order, threshold);\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  function _toMatrix(a) {\n    if (isMatrix(a)) {\n      return a;\n    }\n\n    if (isArray(a)) {\n      return matrix(a);\n    }\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n\n  function _lusolve(l, u, p, q, b) {\n    // verify decomposition\n    l = _toMatrix(l);\n    u = _toMatrix(u); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b = solveValidation(l, b, true);\n      b._data = csIpvec(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    }\n\n    return x;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}