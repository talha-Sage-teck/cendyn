import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
export class SvgRadialGradientComponent {
    constructor() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    get stops() {
        return this.stopsInput || this.stopsDefault;
    }
    set stops(value) {
        this.stopsInput = value;
    }
    ngOnChanges(changes) {
        this.r = '30%';
        if ('color' in changes || 'startOpacity' in changes || 'endOpacity' in changes) {
            this.stopsDefault = [
                {
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }
            ];
        }
    }
}
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
SvgRadialGradientComponent.propDecorators = {
    color: [{ type: Input }],
    name: [{ type: Input }],
    startOpacity: [{ type: Input }],
    endOpacity: [{ type: Input }],
    cx: [{ type: Input }],
    cy: [{ type: Input }],
    stops: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: `
    <svg:radialGradient [id]="name" [attr.cx]="cx" [attr.cy]="cy" [attr.r]="r" gradientUnits="userSpaceOnUse">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:radialGradient>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL3N3aW1sYW5lL25neC1jaGFydHMvc3JjL2xpYi9jb21tb24vc3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsdUJBQXVCLEVBQWlCLE1BQU0sZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7O0FBZ0JwRyxNQUFNLE9BQU8sMEJBQTBCO0FBQUcsSUFkMUM7QUFDRyxRQWlCUSxlQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLFFBQVcsT0FBRSxHQUFXLENBQUMsQ0FBQztBQUMxQixRQUFXLE9BQUUsR0FBVyxDQUFDLENBQUM7QUFDMUIsSUFnQ0EsQ0FBQztBQUNELElBaENFLElBQ0ksS0FBSztBQUFLLFFBQ1osT0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDaEQsSUFBRSxDQUFDO0FBQ0gsSUFDRSxJQUFJLEtBQUssQ0FBQyxLQUFZO0FBQ3hCLFFBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7QUFDNUIsSUFBRSxDQUFDO0FBQ0gsSUFNRSxXQUFXLENBQUMsT0FBc0I7QUFBSSxRQUNwQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUNuQixRQUFJLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxjQUFjLElBQUksT0FBTyxJQUFJLFlBQVksSUFBSSxPQUFPLEVBQUU7QUFDcEYsWUFBTSxJQUFJLENBQUMsWUFBWSxHQUFHO0FBQzFCLGdCQUFRO0FBQ1Isb0JBQVUsTUFBTSxFQUFFLENBQUM7QUFDbkIsb0JBQVUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0FBQzNCLG9CQUFVLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWTtBQUNwQyxpQkFBUztBQUNULGdCQUFRO0FBQ1Isb0JBQVUsTUFBTSxFQUFFLEdBQUc7QUFDckIsb0JBQVUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0FBQzNCLG9CQUFVLE9BQU8sRUFBRSxJQUFJLENBQUMsVUFBVTtBQUNsQyxpQkFBUztBQUNULGFBQU8sQ0FBQztBQUNSLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDtzREFyREMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRTtDQUFtQyxrQkFDN0MsUUFBUSxFQUFFLHdVQVNULGtCQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNLGNBQ2hEOzs7Ozs7Ozs7OytFQUNJO0FBQUM7QUFBOEMsb0JBQ2pELEtBQUs7QUFBSyxtQkFDVixLQUFLO0FBQUssMkJBQ1YsS0FBSztBQUFLLHlCQUNWLEtBQUs7QUFBSyxpQkFDVixLQUFLO0FBQUssaUJBQ1YsS0FBSztBQUFLLG9CQUVWLEtBQUs7QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc3ZnLXJhZGlhbC1ncmFkaWVudF0nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6cmFkaWFsR3JhZGllbnQgW2lkXT1cIm5hbWVcIiBbYXR0ci5jeF09XCJjeFwiIFthdHRyLmN5XT1cImN5XCIgW2F0dHIucl09XCJyXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCI+XG4gICAgICA8c3ZnOnN0b3BcbiAgICAgICAgKm5nRm9yPVwibGV0IHN0b3Agb2Ygc3RvcHNcIlxuICAgICAgICBbYXR0ci5vZmZzZXRdPVwic3RvcC5vZmZzZXQgKyAnJSdcIlxuICAgICAgICBbc3R5bGUuc3RvcC1jb2xvcl09XCJzdG9wLmNvbG9yXCJcbiAgICAgICAgW3N0eWxlLnN0b3Atb3BhY2l0eV09XCJzdG9wLm9wYWNpdHlcIlxuICAgICAgLz5cbiAgICA8L3N2ZzpyYWRpYWxHcmFkaWVudD5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBuYW1lOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHN0YXJ0T3BhY2l0eTogbnVtYmVyO1xuICBASW5wdXQoKSBlbmRPcGFjaXR5ID0gMTtcbiAgQElucHV0KCkgY3g6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIGN5OiBudW1iZXIgPSAwO1xuXG4gIEBJbnB1dCgpXG4gIGdldCBzdG9wcygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcHNJbnB1dCB8fCB0aGlzLnN0b3BzRGVmYXVsdDtcbiAgfVxuXG4gIHNldCBzdG9wcyh2YWx1ZTogYW55W10pIHtcbiAgICB0aGlzLnN0b3BzSW5wdXQgPSB2YWx1ZTtcbiAgfVxuXG4gIHI6IHN0cmluZztcblxuICBwcml2YXRlIHN0b3BzSW5wdXQ6IGFueVtdO1xuICBwcml2YXRlIHN0b3BzRGVmYXVsdDogYW55W107XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIHRoaXMuciA9ICczMCUnO1xuICAgIGlmICgnY29sb3InIGluIGNoYW5nZXMgfHwgJ3N0YXJ0T3BhY2l0eScgaW4gY2hhbmdlcyB8fCAnZW5kT3BhY2l0eScgaW4gY2hhbmdlcykge1xuICAgICAgdGhpcy5zdG9wc0RlZmF1bHQgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGFydE9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9mZnNldDogMTAwLFxuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZW5kT3BhY2l0eVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuIl19