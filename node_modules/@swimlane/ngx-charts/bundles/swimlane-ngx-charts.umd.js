(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/platform-browser'),exports, require('@angular/core'), require('@angular/common'), require('@angular/animations'), require('@angular/cdk/portal'), require('rxjs'), require('rxjs/operators'), require('d3-selection'), require('d3-brush'), require('d3-scale'), require('@angular/platform-browser'), require('d3-shape'), require('d3-array'), require('d3-interpolate'), require('d3-format'), require('d3-color'), require('d3-hierarchy'), require('d3-time-format')) :
    typeof define === 'function' && define.amd ? define('@swimlane/ngx-charts', ['@angular/core','@angular/common','@angular/platform-browser','exports', '@angular/core', '@angular/common', '@angular/animations', '@angular/cdk/portal', 'rxjs', 'rxjs/operators', 'd3-selection', 'd3-brush', 'd3-scale', '@angular/platform-browser', 'd3-shape', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-color', 'd3-hierarchy', 'd3-time-format'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global.ng.platformBrowser,(global.swimlane = global.swimlane || {}, global.swimlane['ngx-charts'] = {}), global.ng.core, global.ng.common, global.ng.animations, global.ng.cdk.portal, global.rxjs, global.rxjs.operators, global.d3Selection, global.d3Brush, global.d3Scale, global.ng.platformBrowser, global.d3Shape, global.d3Array, global.d3Interpolate, global.d3Format, global.d3_color, global.d3Hierarchy, global.d3TimeFormat));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports, core, common, animations, portal, rxjs, operators, d3Selection, d3Brush, d3Scale, platformBrowser, d3Shape, d3Array, d3Interpolate, d3Format, d3_color, d3Hierarchy, d3TimeFormat) { 
var _c0 = ["caretElm"];
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) { }
var _c1 = function (a0) { return { model: a0 }; };
function TooltipContentComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1.context));
} }
function TooltipContentComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r2.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "ngx-charts-scale-legend", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === "below")("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
} }
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "ngx-charts-legend", 5);
    ɵngcc0.ɵɵlistener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.legendLabelClick.emit($event); })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.legendLabelActivate.emit($event); })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.legendLabelDeactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r1.legendOptions && ctx_r1.legendOptions.position === "below")("data", ctx_r1.legendOptions.domain)("title", ctx_r1.legendOptions.title)("colors", ctx_r1.legendOptions.colors)("height", ctx_r1.view[1])("width", ctx_r1.legendWidth)("activeEntries", ctx_r1.activeEntries);
} }
var _c2 = ["*"];
var _c3 = ["ngx-charts-axis-label", ""];
var _c4 = ["ticksel"];
var _c5 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.tickTransform(tick_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r1.textAnchor)("transform", ctx_r1.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r3)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r5.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", -ctx_r5.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r2.tickTransform(tick_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showGridLines);
} }
var _c6 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c7 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 5);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transform(tick_r5));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("dy", ctx_r1.dy)("x", ctx_r1.x1)("y", ctx_r1.y1)("text-anchor", ctx_r1.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r5)), " ");
} }
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", ctx_r8.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", -ctx_r9.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r7.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "left");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "right");
} }
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r6 = ctx.$implicit;
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r3.transform(tick_r6));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showGridLines);
} }
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    var ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.tickTrim(ctx_r12.tickFormat(refLine_r10.value)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dy", ctx_r12.dy)("y", -6)("x", ctx_r12.gridLineWidth)("text-anchor", ctx_r12.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", refLine_r10.name, " ");
} }
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 10);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r11.transform(refLine_r10.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("x2", ctx_r11.gridLineWidth)("transform", ctx_r11.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r11.showRefLabels);
} }
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRefLines);
} }
var _c8 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function YAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickValues", ctx_r0.ticks)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.yScale)("orient", ctx_r0.yOrient)("showGridLines", ctx_r0.showGridLines)("gridLineWidth", ctx_r0.dims.width)("referenceLines", ctx_r0.referenceLines)("showRefLines", ctx_r0.showRefLines)("showRefLabels", ctx_r0.showRefLabels)("height", ctx_r0.dims.height);
} }
function YAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c9 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
} }
var _c10 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(ctx_r2.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.barVisible && ctx_r0.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r0.isActive(ɵngcc0.ɵɵpureFunction1(18, _c10, ctx_r0.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r0.circle.cx)("cy", ctx_r0.circle.cy)("r", ctx_r0.circle.radius)("fill", ctx_r0.circle.color)("pointerEvents", ctx_r0.circle.value === 0 ? "none" : "all")("data", ctx_r0.circle.value)("classNames", ctx_r0.circle.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(ctx_r0.circle))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ctx_r0.circle.data);
} }
var _c11 = ["ngx-charts-circle", ""];
var _c12 = ["ngx-charts-grid-panel", ""];
var _c13 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 1);
} if (rf & 2) {
    var gridPanel_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    ɵngcc0.ɵɵproperty("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
} }
var _c14 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c15 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c16 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c17 = ["ngx-charts-count-up", ""];
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__svg_ng_template_2__xhtml_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "span", 7);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tooltipItem_r5 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", tooltipItem_r5.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.getToolTipText(tooltipItem_r5), " ");
} }
function TooltipArea__svg_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, TooltipArea__svg_ng_template_2__xhtml_div_1_Template, 3, 3, "div", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var model_r3 = ctx.model;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", model_r3);
} }
var _c20 = ["ngx-charts-timeline", ""];
function LegendComponent_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 4);
    ɵngcc0.ɵɵelementStart(1, "span", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function LegendComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 6);
    ɵngcc0.ɵɵelementStart(1, "ngx-charts-legend-entry", 7);
    ɵngcc0.ɵɵlistener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.labelClick.emit($event); })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate($event); })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var entry_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", entry_r2.label)("formattedLabel", entry_r2.formattedLabel)("color", entry_r2.color)("isActive", ctx_r1.isActive(entry_r2));
} }
function AdvancedLegendComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
} }
function AdvancedLegendComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.valueFormatting ? ctx_r1.valueFormatting(ctx_r1.roundedTotal) : ctx_r1.defaultValueFormatting(ctx_r1.roundedTotal), " ");
} }
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 16);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3._value)("valueFormatting", ctx_r4.valueFormatting);
} }
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.valueFormatting ? ctx_r5.valueFormatting(legendItem_r3.value) : ctx_r5.defaultValueFormatting(legendItem_r3.value), " ");
} }
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 18);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3.percentage)("countSuffix", "%");
} }
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
} }
function AdvancedLegendComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.activate.emit(legendItem_r3.data); })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = restoredCtx.$implicit; var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.deactivate.emit(legendItem_r3.data); })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = restoredCtx.$implicit; var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.select.emit(legendItem_r3.data); });
    ɵngcc0.ɵɵelement(1, "div", 10);
    ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11);
    ɵngcc0.ɵɵtemplate(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    ɵngcc0.ɵɵelementStart(4, "div", 13);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14);
    ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("border-left-color", legendItem_r3.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(legendItem_r3.displayLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
} }
var _c21 = ["tooltipTemplate"];
var _c22 = ["seriesTooltipTemplate"];
function AreaChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("baseValue", ctx_r2.baseValue)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("baseValue", ctx_r19.baseValue)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
var _c23 = function (a0, a1) { return [a0, a1]; };
function AreaChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("activeEntries", ctx_r2.activeEntries)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("showPercentage", true)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c24 = ".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}";
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("activeEntries", ctx_r2.activeEntries)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 12);
    ɵngcc0.ɵɵlistener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartStackedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results)("ngForTrackBy", ctx_r3.trackBy);
} }
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 13);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c25 = ["ngx-charts-area-series", ""];
var _c26 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.valueScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_activate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_deactivate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_dataLabelWidthChanged_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = restoredCtx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.valueScale)("activeEntries", ctx_r2.activeEntries)("yScale", ctx_r2.innerScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_dataLabelWidthChanged_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = restoredCtx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("series", group_r7.series)("activeEntries", ctx_r2.activeEntries)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.groupScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarVertical2DComponent__svg_g_5_Template__svg_g_select_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVertical2DComponent__svg_g_5_Template__svg_g_activate_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVertical2DComponent__svg_g_5_Template__svg_g_deactivate_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5_Template__svg_g_dataLabelHeightChanged_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = restoredCtx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("activeEntries", ctx_r2.activeEntries)("xScale", ctx_r2.innerScale)("yScale", ctx_r2.valueScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
} }
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = restoredCtx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_dataLabelHeightChanged_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = restoredCtx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
var _c27 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesVerticalComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onClick($event); })("activate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx_r0.animations)("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "vertical")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("ariaLabel", bar_r2.ariaLabel)("isActive", ctx_r0.isActive(bar_r2.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero)("animations", ctx_r0.animations);
} }
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = restoredCtx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelHeightChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "vertical");
} }
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c28 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesHorizontal__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.click($event); })("activate", function SeriesHorizontal__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesHorizontal__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "horizontal")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("isActive", ctx_r0.isActive(bar_r2.data))("ariaLabel", bar_r2.ariaLabel)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero);
} }
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = restoredCtx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelWidthChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "horizontal");
} }
function SeriesHorizontal__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c29 = ["ngx-charts-bar-label", ""];
function BubbleChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r0.showGridLines)("dims", ctx_r0.dims)("xScale", ctx_r0.xScale)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BubbleChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BubbleChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BubbleChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9); var series_r7 = restoredCtx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, series_r7); })("activate", function BubbleChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event); })("deactivate", function BubbleChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("rScale", ctx_r2.rScale)("xScaleType", ctx_r2.xScaleType)("yScaleType", ctx_r2.yScaleType)("xAxisLabel", ctx_r2.xAxisLabel)("yAxisLabel", ctx_r2.yAxisLabel)("colors", ctx_r2.colors)("data", series_r7)("activeEntries", ctx_r2.activeEntries)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate);
} }
var _c30 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g");
    ɵngcc0.ɵɵelementStart(2, "g", 1);
    ɵngcc0.ɵɵlistener("select", function BubbleSeriesComponent__svg_g_0_Template__svg_g_select_2_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = restoredCtx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(circle_r1.data); })("activate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = restoredCtx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(circle_r1); })("deactivate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = restoredCtx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(circle_r1); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("transform", circle_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("opacity", circle_r1.opacity);
    ɵngcc0.ɵɵclassProp("active", circle_r1.isActive);
    ɵngcc0.ɵɵproperty("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r1.radius)("fill", circle_r1.color)("pointerEvents", "all")("data", circle_r1.value)("classNames", circle_r1.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(circle_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r1.data);
} }
var _c31 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c32 = ["ngx-charts-heat-map-cell-series", ""];
var _c33 = function (a0, a1, a2) { return { series: a0, name: a1, value: a2 }; };
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = restoredCtx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(c_r1.cell); })("activate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_activate_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = restoredCtx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit(c_r1.cell); })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_deactivate_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = restoredCtx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit(c_r1.cell); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("data", c_r1.data)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ɵngcc0.ɵɵpureFunction3(14, _c33, c_r1.series, c_r1.label, c_r1.data));
} }
function HeatMapComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function HeatMapComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function HeatMapComponent__svg_rect_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect");
} if (rf & 2) {
    var rect_r7 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("x", rect_r7.x)("y", rect_r7.y)("rx", rect_r7.rx)("width", rect_r7.width)("height", rect_r7.height)("fill", rect_r7.fill);
} }
var _c34 = ["ngx-charts-line", ""];
function LineChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function LineChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels);
} }
function LineChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("curve", ctx_r2.curve)("rangeFillOpacity", ctx_r2.rangeFillOpacity)("hasRange", ctx_r2.hasRange)("animations", ctx_r2.animations);
} }
function LineChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event); })("activate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("activeEntries", ctx_r10.activeEntries)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function LineChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function LineChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, LineChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function LineChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("curve", ctx_r19.curve)("hasRange", ctx_r19.hasRange)("animations", ctx_r19.animations);
} }
function LineChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function LineChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, LineChartComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("scaleType", ctx_r4.scaleType)("legend", ctx_r4.legend);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c35 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function LineSeriesComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 5);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.isActive(ctx_r1.data))("inactive", ctx_r1.isInactive(ctx_r1.data));
    ɵngcc0.ɵɵproperty("data", ctx_r1.data)("path", ctx_r1.outerPath)("fill", ctx_r1.hasGradient ? ctx_r1.gradientUrl : ctx_r1.colors.getColor(ctx_r1.data.name))("opacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations);
} }
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 8);
} if (rf & 2) {
    var r_r6 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("r", r_r6);
} }
function PolarChartComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.radiusTicks);
} }
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 10);
} if (rf & 2) {
    var tick_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("data", tick_r8)("radius", ctx_r7.outerRadius)("label", tick_r8.label)("max", ctx_r7.outerRadius)("value", ctx_r7.showGridLines ? 1 : ctx_r7.outerRadius)("explodeSlices", true)("animations", ctx_r7.animations)("labelTrim", ctx_r7.labelTrim)("labelTrimSize", ctx_r7.labelTrimSize);
} }
function PolarChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.thetaTicks);
} }
function PolarChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 11);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r2.yAxisScale)("dims", ctx_r2.yAxisDims)("showGridLines", ctx_r2.showGridLines)("showLabel", ctx_r2.showYAxisLabel)("labelText", ctx_r2.yAxisLabel)("trimTicks", ctx_r2.trimYAxisTicks)("maxTickLength", ctx_r2.maxYAxisTickLength)("tickFormatting", ctx_r2.yAxisTickFormatting);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.transformYAxis);
} }
function PolarChartComponent__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 12);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r3.xAxisLabel)("offset", ctx_r3.labelOffset)("orient", "bottom")("height", ctx_r3.dims.height)("width", ctx_r3.dims.width);
} }
function PolarChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function PolarChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onClick($event); })("activate", function PolarChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onActivate($event); })("deactivate", function PolarChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("gradient", ctx_r4.gradient)("xScale", ctx_r4.xScale)("yScale", ctx_r4.yScale)("colors", ctx_r4.colors)("data", series_r11)("activeEntries", ctx_r4.activeEntries)("scaleType", ctx_r4.scaleType)("curve", ctx_r4.curve)("rangeFillOpacity", ctx_r4.rangeFillOpacity)("animations", ctx_r4.animations)("tooltipDisabled", ctx_r4.tooltipDisabled)("tooltipTemplate", ctx_r4.tooltipTemplate);
} }
var _c36 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
} }
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("select", function PolarSeriesComponent__svg_g_4_Template__svg_g_select_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = restoredCtx.$implicit; var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.select.emit(circle_r2.data); })("activate", function PolarSeriesComponent__svg_g_4_Template__svg_g_activate_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = restoredCtx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit({ name: circle_r2.data.series }); })("deactivate", function PolarSeriesComponent__svg_g_4_Template__svg_g_deactivate_0_listener() { var restoredCtx = ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = restoredCtx.$implicit; var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit({ name: circle_r2.data.series }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("opacity", ctx_r1.inactive ? 0.2 : 1);
    ɵngcc0.ɵɵproperty("cx", circle_r2.cx)("cy", circle_r2.cy)("r", ctx_r1.circleRadius)("fill", circle_r2.color)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : ctx_r1.tooltipText(circle_r2))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", circle_r2.data);
} }
var _c37 = ["ngx-charts-pie-label", ""];
var _c38 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
} }
var _c39 = ".pie-label{font-size:11px}.pie-label.animation{-webkit-animation:fadeIn .75s ease-in;animation:fadeIn .75s ease-in}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{-webkit-animation:drawOut 3s linear;animation:drawOut 3s linear;transition:d .75s}@-webkit-keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}";
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 10);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", series_r1.percent)("countSuffix", "%");
} }
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.percent.toLocaleString(), " ");
} }
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 12);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", series_r1.total)("countPrefix", ctx_r4.label + ": ");
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
} }
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r5.label, ": ", series_r1.total.toLocaleString(), " ");
} }
var _c40 = function (a0) { return { data: a0 }; };
function PieGridComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "g", 4);
    ɵngcc0.ɵɵlistener("select", function PieGridComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onClick($event); })("activate", function PieGridComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onActivate($event); })("deactivate", function PieGridComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5);
    ɵngcc0.ɵɵtemplate(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    ɵngcc0.ɵɵelementStart(4, "text", 7);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8);
    ɵngcc0.ɵɵtemplate(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", series_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("colors", series_r1.colors)("data", series_r1.data)("innerRadius", series_r1.innerRadius)("outerRadius", series_r1.outerRadius)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(ɵngcc0.ɵɵpureFunction1(17, _c40, series_r1)))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", series_r1.data[0].data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.label, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
} }
var _c41 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieGridSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); })("activate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit($event); })("deactivate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("data", arc_r1.data)("gradient", false)("pointerEvents", arc_r1.pointerEvents)("animate", arc_r1.animate);
    ɵngcc0.ɵɵattribute("class", arc_r1.class);
} }
var _c42 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var arc_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", arc_r1)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r1))("label", ctx_r2.labelText(arc_r1))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r1.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
} }
function PieSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    ɵngcc0.ɵɵelementStart(2, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function PieSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.activate.emit($event); })("deactivate", function PieSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.deactivate.emit($event); })("dblclick", function PieSeriesComponent__svg_g_0_Template__svg_g_dblclick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.dblclick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.labelVisible(arc_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("gradient", ctx_r0.gradient)("data", arc_r1.data)("max", ctx_r0.max)("explodeSlices", ctx_r0.explodeSlices)("isActive", ctx_r0.isActive(arc_r1.data))("animate", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.getTooltipTitle(arc_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", arc_r1.data);
} }
var _c43 = ["textEl"];
var _c44 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("fill", ctx_r0.bandColor)("transform", ctx_r0.transformBand)("d", ctx_r0.bandPath);
} }
var _c45 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 2);
} if (rf & 2) {
    var c_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r0.emptyColor);
    ɵngcc0.ɵɵattribute("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height);
} }
function CardSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CardSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("color", c_r3.color)("bandColor", c_r3.bandColor)("textColor", c_r3.textColor)("data", c_r3.data)("label", c_r3.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
} }
var _c46 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("countTo", ctx_r2.value)("valueFormatting", ctx_r2.valueFormatting);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedValue, " ");
} }
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "foreignObject", 4);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵelement(2, "span", 5);
    ɵngcc0.ɵɵelement(3, "br");
    ɵngcc0.ɵɵtemplate(4, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template, 1, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(5, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("pointer-events", "none");
    ɵngcc0.ɵɵattribute("x", ctx_r1.x)("y", ctx_r1.y)("width", ctx_r1.width)("height", ctx_r1.height);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("color", ctx_r1.getTextColor())("height", ctx_r1.height + "px")("width", ctx_r1.width + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.animations);
} }
var _c47 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function TreeMapCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", c_r1.data)("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("label", c_r1.label)("value", c_r1.value)("valueType", c_r1.valueType)("valueFormatting", ctx_r0.valueFormatting)("labelFormatting", ctx_r0.labelFormatting)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", c_r1.data);
} }
var _c48 = ["valueTextEl"];
var _c49 = ["unitsTextEl"];
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 10);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.transformLine)("stroke", ctx_r0.colors.getColor(ctx_r0.units));
} }
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 11);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
} }
var _c50 = function () { return {}; };
function GaugeComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 5);
    ɵngcc0.ɵɵlistener("select", function GaugeComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function GaugeComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onActivate($event); })("deactivate", function GaugeComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r3 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.rotation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r0.cornerRadius)("colors", ctx_r0.colors)("isActive", ctx_r0.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipTemplate", ctx_r0.tooltipTemplate)("valueFormatting", ctx_r0.valueFormatting)("animations", ctx_r0.animations);
} }
function GaugeComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 6);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
} }
function GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 7, 8);
    ɵngcc0.ɵɵelementStart(2, "tspan", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "tspan", 10);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.textTransform);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.displayValue);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.units);
} }
var _c51 = ["ngx-charts-gauge-arc", ""];
var _c52 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    function isViewContainerRef(x) {
        return x.element;
    }
    /**
     * Injection service is a helper to append components
     * dynamically to a known location in the DOM, most
     * noteably for dialogs/tooltips appending to body.
     *
     * @export
     */
    var InjectionService = /** @class */ (function () {
        function InjectionService(applicationRef, componentFactoryResolver, injector) {
            this.applicationRef = applicationRef;
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
        }
        /**
         * Sets a default global root view container. This is useful for
         * things like ngUpgrade that doesn't have a ApplicationRef root.
         *
         * @param container
         */
        InjectionService.setGlobalRootViewContainer = function (container) {
            InjectionService.globalRootViewContainer = container;
        };
        /**
         * Gets the root view container to inject the component to.
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.getRootViewContainer = function () {
            if (this._container)
                return this._container;
            if (InjectionService.globalRootViewContainer)
                return InjectionService.globalRootViewContainer;
            if (this.applicationRef.components.length)
                return this.applicationRef.components[0];
            throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer or setGlobalRootViewContainer.');
        };
        /**
         * Overrides the default root view container. This is useful for
         * things like ngUpgrade that doesn't have a ApplicationRef root.
         *
         * @param container
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.setRootViewContainer = function (container) {
            this._container = container;
        };
        /**
         * Gets the html element for a component ref.
         *
         * @param componentRef
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.getComponentRootNode = function (component) {
            if (isViewContainerRef(component)) {
                return component.element.nativeElement;
            }
            if (component.hostView && component.hostView.rootNodes.length > 0) {
                return component.hostView.rootNodes[0];
            }
            // the top most component root node has no `hostView`
            return component.location.nativeElement;
        };
        /**
         * Gets the root component container html element.
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.getRootViewContainerNode = function (component) {
            return this.getComponentRootNode(component);
        };
        /**
         * Projects the bindings onto the component
         *
         * @param component
         * @param options
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.projectComponentBindings = function (component, bindings) {
            var e_1, _a, e_2, _b;
            if (bindings) {
                if (bindings.inputs !== undefined) {
                    var bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
                    try {
                        for (var bindingKeys_1 = __values(bindingKeys), bindingKeys_1_1 = bindingKeys_1.next(); !bindingKeys_1_1.done; bindingKeys_1_1 = bindingKeys_1.next()) {
                            var bindingName = bindingKeys_1_1.value;
                            component.instance[bindingName] = bindings.inputs[bindingName];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (bindingKeys_1_1 && !bindingKeys_1_1.done && (_a = bindingKeys_1.return)) _a.call(bindingKeys_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                if (bindings.outputs !== undefined) {
                    var eventKeys = Object.getOwnPropertyNames(bindings.outputs);
                    try {
                        for (var eventKeys_1 = __values(eventKeys), eventKeys_1_1 = eventKeys_1.next(); !eventKeys_1_1.done; eventKeys_1_1 = eventKeys_1.next()) {
                            var eventName = eventKeys_1_1.value;
                            component.instance[eventName] = bindings.outputs[eventName];
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (eventKeys_1_1 && !eventKeys_1_1.done && (_b = eventKeys_1.return)) _b.call(eventKeys_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            return component;
        };
        /**
         * Appends a component to a adjacent location
         *
         * @param componentClass
         * @param [options={}]
         * @param [location]
         *
         * @memberOf InjectionService
         */
        InjectionService.prototype.appendComponent = function (componentClass, bindings, location) {
            if (bindings === void 0) { bindings = {}; }
            if (!location)
                location = this.getRootViewContainer();
            var appendLocation = this.getComponentRootNode(location);
            var portalHost = new portal.DomPortalHost(appendLocation, this.componentFactoryResolver, this.applicationRef, this.injector);
            var portal$1 = new portal.ComponentPortal(componentClass);
            var componentRef = portalHost.attach(portal$1);
            this.projectComponentBindings(componentRef, bindings);
            return componentRef;
        };
InjectionService.ɵfac = function InjectionService_Factory(t) { return new (t || InjectionService)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
InjectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: InjectionService, factory: function (t) { return InjectionService.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InjectionService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }]; }, null); })();
        return InjectionService;
    }());
    InjectionService.globalRootViewContainer = null;
    InjectionService.ctorParameters = function () { return [
        { type: core.ApplicationRef },
        { type: core.ComponentFactoryResolver },
        { type: core.Injector }
    ]; };

    /**
     * Throttle a function
     *
     */
    function throttle(func, wait, options) {
        options = options || {};
        var context;
        var args;
        var result;
        var timeout = null;
        var previous = 0;
        function later() {
            previous = options.leading === false ? 0 : +new Date();
            timeout = null;
            result = func.apply(context, args);
        }
        return function () {
            var now = +new Date();
            if (!previous && options.leading === false) {
                previous = now;
            }
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
            }
            else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }
    /**
     * Throttle decorator
     *
     *  class MyClass {
     *    throttleable(10)
     *    myFn() { ... }
     *  }
     */
    function throttleable(duration, options) {
        return function innerDecorator(target, key, descriptor) {
            return {
                configurable: true,
                enumerable: descriptor.enumerable,
                get: function getter() {
                    Object.defineProperty(this, key, {
                        configurable: true,
                        enumerable: descriptor.enumerable,
                        value: throttle(descriptor.value, duration, options)
                    });
                    return this[key];
                }
            };
        };
    }

    (function (PlacementTypes) {
        PlacementTypes[PlacementTypes["top"] = 'top'] = "top";
        PlacementTypes[PlacementTypes["bottom"] = 'bottom'] = "bottom";
        PlacementTypes[PlacementTypes["left"] = 'left'] = "left";
        PlacementTypes[PlacementTypes["right"] = 'right'] = "right";
    })(exports.PlacementTypes || (exports.PlacementTypes = {}));

    var caretOffset = 7;
    function verticalPosition(elDimensions, popoverDimensions, alignment) {
        if (alignment === 'top') {
            return elDimensions.top - caretOffset;
        }
        if (alignment === 'bottom') {
            return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
        }
        if (alignment === 'center') {
            return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
        }
        return undefined;
    }
    function horizontalPosition(elDimensions, popoverDimensions, alignment) {
        if (alignment === 'left') {
            return elDimensions.left - caretOffset;
        }
        if (alignment === 'right') {
            return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
        }
        if (alignment === 'center') {
            return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
        }
        return undefined;
    }
    /**
     * Position helper for the popover directive.
     *
     * @export
     */
    var PositionHelper = /** @class */ (function () {
        function PositionHelper() {
        }
        /**
         * Calculate vertical alignment position
         *
         * @memberOf PositionHelper
         */
        PositionHelper.calculateVerticalAlignment = function (elDimensions, popoverDimensions, alignment) {
            var result = verticalPosition(elDimensions, popoverDimensions, alignment);
            if (result + popoverDimensions.height > window.innerHeight) {
                result = window.innerHeight - popoverDimensions.height;
            }
            return result;
        };
        /**
         * Calculate vertical caret position
         *
         * @memberOf PositionHelper
         */
        PositionHelper.calculateVerticalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
            var result;
            if (alignment === 'top') {
                result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
            }
            if (alignment === 'bottom') {
                result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
            }
            if (alignment === 'center') {
                result = popoverDimensions.height / 2 - caretDimensions.height / 2;
            }
            var popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
            if (popoverPosition + popoverDimensions.height > window.innerHeight) {
                result += popoverPosition + popoverDimensions.height - window.innerHeight;
            }
            return result;
        };
        /**
         * Calculate horz alignment position
         *
         * @memberOf PositionHelper
         */
        PositionHelper.calculateHorizontalAlignment = function (elDimensions, popoverDimensions, alignment) {
            var result = horizontalPosition(elDimensions, popoverDimensions, alignment);
            if (result + popoverDimensions.width > window.innerWidth) {
                result = window.innerWidth - popoverDimensions.width;
            }
            return result;
        };
        /**
         * Calculate horz caret position
         *
         * @memberOf PositionHelper
         */
        PositionHelper.calculateHorizontalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
            var result;
            if (alignment === 'left') {
                result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
            }
            if (alignment === 'right') {
                result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
            }
            if (alignment === 'center') {
                result = popoverDimensions.width / 2 - caretDimensions.width / 2;
            }
            var popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
            if (popoverPosition + popoverDimensions.width > window.innerWidth) {
                result += popoverPosition + popoverDimensions.width - window.innerWidth;
            }
            return result;
        };
        /**
         * Checks if the element's position should be flipped
         *
         * @memberOf PositionHelper
         */
        PositionHelper.shouldFlip = function (elDimensions, popoverDimensions, placement, spacing) {
            var flip = false;
            if (placement === 'right') {
                if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
                    flip = true;
                }
            }
            if (placement === 'left') {
                if (elDimensions.left - popoverDimensions.width - spacing < 0) {
                    flip = true;
                }
            }
            if (placement === 'top') {
                if (elDimensions.top - popoverDimensions.height - spacing < 0) {
                    flip = true;
                }
            }
            if (placement === 'bottom') {
                if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
                    flip = true;
                }
            }
            return flip;
        };
        /**
         * Position caret
         *
         * @memberOf PositionHelper
         */
        PositionHelper.positionCaret = function (placement, elmDim, hostDim, caretDimensions, alignment) {
            var top = 0;
            var left = 0;
            if (placement === exports.PlacementTypes.right) {
                left = -7;
                top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
            }
            else if (placement === exports.PlacementTypes.left) {
                left = elmDim.width;
                top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
            }
            else if (placement === exports.PlacementTypes.top) {
                top = elmDim.height;
                left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
            }
            else if (placement === exports.PlacementTypes.bottom) {
                top = -7;
                left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
            }
            return { top: top, left: left };
        };
        /**
         * Position content
         *
         * @memberOf PositionHelper
         */
        PositionHelper.positionContent = function (placement, elmDim, hostDim, spacing, alignment) {
            var top = 0;
            var left = 0;
            if (placement === exports.PlacementTypes.right) {
                left = hostDim.left + hostDim.width + spacing;
                top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
            }
            else if (placement === exports.PlacementTypes.left) {
                left = hostDim.left - elmDim.width - spacing;
                top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
            }
            else if (placement === exports.PlacementTypes.top) {
                top = hostDim.top - elmDim.height - spacing;
                left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
            }
            else if (placement === exports.PlacementTypes.bottom) {
                top = hostDim.top + hostDim.height + spacing;
                left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
            }
            return { top: top, left: left };
        };
        /**
         * Determine placement based on flip
         *
         * @memberOf PositionHelper
         */
        PositionHelper.determinePlacement = function (placement, elmDim, hostDim, spacing) {
            var shouldFlip = PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
            if (shouldFlip) {
                if (placement === exports.PlacementTypes.right) {
                    return exports.PlacementTypes.left;
                }
                else if (placement === exports.PlacementTypes.left) {
                    return exports.PlacementTypes.right;
                }
                else if (placement === exports.PlacementTypes.top) {
                    return exports.PlacementTypes.bottom;
                }
                else if (placement === exports.PlacementTypes.bottom) {
                    return exports.PlacementTypes.top;
                }
            }
            return placement;
        };
        return PositionHelper;
    }());

    var TooltipContentComponent = /** @class */ (function () {
        function TooltipContentComponent(element, renderer, platformId) {
            this.element = element;
            this.renderer = renderer;
            this.platformId = platformId;
        }
        Object.defineProperty(TooltipContentComponent.prototype, "cssClasses", {
            get: function () {
                var clz = 'ngx-charts-tooltip-content';
                clz += " position-" + this.placement;
                clz += " type-" + this.type;
                clz += " " + this.cssClass;
                return clz;
            },
            enumerable: false,
            configurable: true
        });
        TooltipContentComponent.prototype.ngAfterViewInit = function () {
            setTimeout(this.position.bind(this));
        };
        TooltipContentComponent.prototype.position = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            var nativeElm = this.element.nativeElement;
            var hostDim = this.host.nativeElement.getBoundingClientRect();
            // if no dims were found, never show
            if (!hostDim.height && !hostDim.width)
                return;
            var elmDim = nativeElm.getBoundingClientRect();
            this.checkFlip(hostDim, elmDim);
            this.positionContent(nativeElm, hostDim, elmDim);
            if (this.showCaret) {
                this.positionCaret(hostDim, elmDim);
            }
            // animate its entry
            setTimeout(function () { return _this.renderer.addClass(nativeElm, 'animate'); }, 1);
        };
        TooltipContentComponent.prototype.positionContent = function (nativeElm, hostDim, elmDim) {
            var _a = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment), top = _a.top, left = _a.left;
            this.renderer.setStyle(nativeElm, 'top', top + "px");
            this.renderer.setStyle(nativeElm, 'left', left + "px");
        };
        TooltipContentComponent.prototype.positionCaret = function (hostDim, elmDim) {
            var caretElm = this.caretElm.nativeElement;
            var caretDimensions = caretElm.getBoundingClientRect();
            var _a = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment), top = _a.top, left = _a.left;
            this.renderer.setStyle(caretElm, 'top', top + "px");
            this.renderer.setStyle(caretElm, 'left', left + "px");
        };
        TooltipContentComponent.prototype.checkFlip = function (hostDim, elmDim) {
            this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
        };
        TooltipContentComponent.prototype.onWindowResize = function () {
            this.position();
        };
TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) { return new (t || TooltipContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
TooltipContentComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TooltipContentComponent, selectors: [["ngx-tooltip-content"]], viewQuery: function TooltipContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.caretElm = _t.first);
    } }, hostVars: 2, hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function TooltipContentComponent_resize_HostBindingHandler() { return ctx.onWindowResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { placement: "placement", host: "host", showCaret: "showCaret", type: "type", alignment: "alignment", spacing: "spacing", cssClass: "cssClass", title: "title", template: "template", context: "context" }, decls: 6, vars: 6, consts: [[3, "hidden"], ["caretElm", ""], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]], template: function TooltipContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelement(1, "span", 0, 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3);
        ɵngcc0.ɵɵtemplate(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("tooltip-caret position-", ctx.placement, "");
        ɵngcc0.ɵɵproperty("hidden", !ctx.showCaret);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-charts-tooltip-content{border-radius:3px;display:block;font-weight:400;opacity:0;pointer-events:none!important;position:fixed;z-index:5000}.ngx-charts-tooltip-content.type-popover{background:#fff;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);color:#060709;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{height:0;position:absolute;width:0;z-index:5001}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-bottom:7px solid transparent;border-left:7px solid #fff;border-top:7px solid transparent}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-bottom:7px solid transparent;border-right:7px solid #fff;border-top:7px solid transparent}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-bottom:7px solid #fff;border-left:7px solid transparent;border-right:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip{background:rgba(0,0,0,.75);color:#fff;font-size:12px;padding:0 10px;pointer-events:auto;text-align:center}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75);border-top:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75);border-top:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-bottom:7px solid rgba(0,0,0,.75);border-left:7px solid transparent;border-right:7px solid transparent}.ngx-charts-tooltip-content .tooltip-label{display:block;font-size:1em;line-height:1em;padding:8px 5px 5px}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{height:0;position:absolute;width:0;z-index:5001}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;pointer-events:auto;transform:translateZ(0);transition:opacity .3s,transform .3s}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{line-height:1.2em;padding:5px 0;text-align:left}.tooltip-item .tooltip-item-color{border-radius:3px;color:#5b646b;display:inline-block;height:12px;margin-right:5px;width:12px}"], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipContentComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-tooltip-content',
                template: "\n    <div>\n      <span #caretElm [hidden]=\"!showCaret\" class=\"tooltip-caret position-{{ this.placement }}\"> </span>\n      <div class=\"tooltip-content\">\n        <span *ngIf=\"!title\">\n          <ng-template [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ model: context }\"> </ng-template>\n        </span>\n        <span *ngIf=\"title\" [innerHTML]=\"title\"> </span>\n      </div>\n    </div>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts-tooltip-content{border-radius:3px;display:block;font-weight:400;opacity:0;pointer-events:none!important;position:fixed;z-index:5000}.ngx-charts-tooltip-content.type-popover{background:#fff;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);color:#060709;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{height:0;position:absolute;width:0;z-index:5001}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-bottom:7px solid transparent;border-left:7px solid #fff;border-top:7px solid transparent}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-bottom:7px solid transparent;border-right:7px solid #fff;border-top:7px solid transparent}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-bottom:7px solid #fff;border-left:7px solid transparent;border-right:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip{background:rgba(0,0,0,.75);color:#fff;font-size:12px;padding:0 10px;pointer-events:auto;text-align:center}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75);border-top:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75);border-top:7px solid transparent}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-bottom:7px solid rgba(0,0,0,.75);border-left:7px solid transparent;border-right:7px solid transparent}.ngx-charts-tooltip-content .tooltip-label{display:block;font-size:1em;line-height:1em;padding:8px 5px 5px}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{height:0;position:absolute;width:0;z-index:5001}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;pointer-events:auto;transform:translateZ(0);transition:opacity .3s,transform .3s}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{line-height:1.2em;padding:5px 0;text-align:left}.tooltip-item .tooltip-item-color{border-radius:3px;color:#5b646b;display:inline-block;height:12px;margin-right:5px;width:12px}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { cssClasses: [{
            type: core.HostBinding,
            args: ['class']
        }], placement: [{
            type: core.Input
        }], onWindowResize: [{
            type: core.HostListener,
            args: ['window:resize']
        }], host: [{
            type: core.Input
        }], showCaret: [{
            type: core.Input
        }], type: [{
            type: core.Input
        }], alignment: [{
            type: core.Input
        }], spacing: [{
            type: core.Input
        }], cssClass: [{
            type: core.Input
        }], title: [{
            type: core.Input
        }], template: [{
            type: core.Input
        }], context: [{
            type: core.Input
        }], caretElm: [{
            type: core.ViewChild,
            args: ['caretElm']
        }] }); })();
        return TooltipContentComponent;
    }());
    TooltipContentComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    TooltipContentComponent.propDecorators = {
        host: [{ type: core.Input }],
        showCaret: [{ type: core.Input }],
        type: [{ type: core.Input }],
        placement: [{ type: core.Input }],
        alignment: [{ type: core.Input }],
        spacing: [{ type: core.Input }],
        cssClass: [{ type: core.Input }],
        title: [{ type: core.Input }],
        template: [{ type: core.Input }],
        context: [{ type: core.Input }],
        caretElm: [{ type: core.ViewChild, args: ['caretElm',] }],
        cssClasses: [{ type: core.HostBinding, args: ['class',] }],
        onWindowResize: [{ type: core.HostListener, args: ['window:resize',] }]
    };
    __decorate([
        throttleable(100)
    ], TooltipContentComponent.prototype, "onWindowResize", null);

    var InjectionRegisteryService = /** @class */ (function () {
        function InjectionRegisteryService(injectionService) {
            this.injectionService = injectionService;
            this.defaults = {};
            this.components = new Map();
        }
        InjectionRegisteryService.prototype.getByType = function (type) {
            if (type === void 0) { type = this.type; }
            return this.components.get(type);
        };
        InjectionRegisteryService.prototype.create = function (bindings) {
            return this.createByType(this.type, bindings);
        };
        InjectionRegisteryService.prototype.createByType = function (type, bindings) {
            bindings = this.assignDefaults(bindings);
            var component = this.injectComponent(type, bindings);
            this.register(type, component);
            return component;
        };
        InjectionRegisteryService.prototype.destroy = function (instance) {
            var compsByType = this.components.get(instance.componentType);
            if (compsByType && compsByType.length) {
                var idx = compsByType.indexOf(instance);
                if (idx > -1) {
                    var component = compsByType[idx];
                    component.destroy();
                    compsByType.splice(idx, 1);
                }
            }
        };
        InjectionRegisteryService.prototype.destroyAll = function () {
            this.destroyByType(this.type);
        };
        InjectionRegisteryService.prototype.destroyByType = function (type) {
            var comps = this.components.get(type);
            if (comps && comps.length) {
                var i = comps.length - 1;
                while (i >= 0) {
                    this.destroy(comps[i--]);
                }
            }
        };
        InjectionRegisteryService.prototype.injectComponent = function (type, bindings) {
            return this.injectionService.appendComponent(type, bindings);
        };
        InjectionRegisteryService.prototype.assignDefaults = function (bindings) {
            var inputs = Object.assign({}, this.defaults.inputs);
            var outputs = Object.assign({}, this.defaults.outputs);
            if (!bindings.inputs && !bindings.outputs) {
                bindings = { inputs: bindings };
            }
            if (inputs) {
                bindings.inputs = Object.assign(Object.assign({}, inputs), bindings.inputs);
            }
            if (outputs) {
                bindings.outputs = Object.assign(Object.assign({}, outputs), bindings.outputs);
            }
            return bindings;
        };
        InjectionRegisteryService.prototype.register = function (type, component) {
            if (!this.components.has(type)) {
                this.components.set(type, []);
            }
            var types = this.components.get(type);
            types.push(component);
        };
        return InjectionRegisteryService;
    }());

    var TooltipService = /** @class */ (function (_super) {
        __extends(TooltipService, _super);
        function TooltipService(injectionService) {
            var _this = _super.call(this, injectionService) || this;
            _this.type = TooltipContentComponent;
            return _this;
        }
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(ɵngcc0.ɵɵinject(InjectionService)); };
TooltipService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TooltipService, factory: function (t) { return TooltipService.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipService, [{
        type: core.Injectable
    }], function () { return [{ type: InjectionService }]; }, null); })();
        return TooltipService;
    }(InjectionRegisteryService));
    TooltipService.ctorParameters = function () { return [
        { type: InjectionService }
    ]; };

    var ChartComponent = /** @class */ (function () {
        function ChartComponent() {
            this.showLegend = false;
            this.animations = true;
            this.legendLabelClick = new core.EventEmitter();
            this.legendLabelActivate = new core.EventEmitter();
            this.legendLabelDeactivate = new core.EventEmitter();
        }
        ChartComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        ChartComponent.prototype.update = function () {
            var legendColumns = 0;
            if (this.showLegend) {
                this.legendType = this.getLegendType();
                if (!this.legendOptions || this.legendOptions.position === 'right') {
                    if (this.legendType === 'scaleLegend') {
                        legendColumns = 1;
                    }
                    else {
                        legendColumns = 2;
                    }
                }
            }
            var chartColumns = 12 - legendColumns;
            this.chartWidth = Math.floor((this.view[0] * chartColumns) / 12.0);
            this.legendWidth =
                !this.legendOptions || this.legendOptions.position === 'right'
                    ? Math.floor((this.view[0] * legendColumns) / 12.0)
                    : this.chartWidth;
        };
        ChartComponent.prototype.getLegendType = function () {
            if (this.legendOptions.scaleType === 'linear') {
                return 'scaleLegend';
            }
            else {
                return 'legend';
            }
        };
ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(); };
ChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ChartComponent, selectors: [["ngx-charts-chart"]], inputs: { showLegend: "showLegend", animations: "animations", legendType: "legendType", view: "view", legendOptions: "legendOptions", data: "data", legendData: "legendData", colors: "colors", activeEntries: "activeEntries" }, outputs: { legendLabelClick: "legendLabelClick", legendLabelActivate: "legendLabelActivate", legendLabelDeactivate: "legendLabelDeactivate" }, features: [ɵngcc0.ɵɵProvidersFeature([TooltipService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 5, vars: 8, consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate"]], template: function ChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2);
        ɵngcc0.ɵɵtemplate(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.view[0], "px");
        ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.chartWidth)("height", ctx.view[1]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "scaleLegend");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "legend");
    } }, directives: function () { return [ɵngcc1.NgIf, ScaleLegendComponent, LegendComponent]; }, encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('500ms 100ms', animations.style({ opacity: 1 }))])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
        type: core.Component,
        args: [{
                providers: [TooltipService],
                selector: 'ngx-charts-chart',
                template: "\n    <div class=\"ngx-charts-outer\" [style.width.px]=\"view[0]\" [@animationState]=\"'active'\" [@.disabled]=\"!animations\">\n      <svg class=\"ngx-charts\" [attr.width]=\"chartWidth\" [attr.height]=\"view[1]\">\n        <ng-content></ng-content>\n      </svg>\n      <ngx-charts-scale-legend\n        *ngIf=\"showLegend && legendType === 'scaleLegend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [valueRange]=\"legendOptions.domain\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\"\n      >\n      </ngx-charts-scale-legend>\n      <ngx-charts-legend\n        *ngIf=\"showLegend && legendType === 'legend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [data]=\"legendOptions.domain\"\n        [title]=\"legendOptions.title\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\"\n        [activeEntries]=\"activeEntries\"\n        (labelClick)=\"legendLabelClick.emit($event)\"\n        (labelActivate)=\"legendLabelActivate.emit($event)\"\n        (labelDeactivate)=\"legendLabelDeactivate.emit($event)\"\n      >\n      </ngx-charts-legend>\n    </div>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('500ms 100ms', animations.style({ opacity: 1 }))])
                    ])
                ]
            }]
    }], function () { return []; }, { showLegend: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], legendLabelClick: [{
            type: core.Output
        }], legendLabelActivate: [{
            type: core.Output
        }], legendLabelDeactivate: [{
            type: core.Output
        }], legendType: [{
            type: core.Input
        }], view: [{
            type: core.Input
        }], legendOptions: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], legendData: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }] }); })();
        return ChartComponent;
    }());
    ChartComponent.propDecorators = {
        view: [{ type: core.Input }],
        showLegend: [{ type: core.Input }],
        legendOptions: [{ type: core.Input }],
        data: [{ type: core.Input }],
        legendData: [{ type: core.Input }],
        legendType: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        legendLabelClick: [{ type: core.Output }],
        legendLabelActivate: [{ type: core.Output }],
        legendLabelDeactivate: [{ type: core.Output }]
    };

    /**
     * Visibility Observer
     */
    var VisibilityObserver = /** @class */ (function () {
        function VisibilityObserver(element, zone) {
            this.element = element;
            this.zone = zone;
            this.visible = new core.EventEmitter();
            this.isVisible = false;
            this.runCheck();
        }
        VisibilityObserver.prototype.destroy = function () {
            clearTimeout(this.timeout);
        };
        VisibilityObserver.prototype.onVisibilityChange = function () {
            var _this = this;
            // trigger zone recalc for columns
            this.zone.run(function () {
                _this.isVisible = true;
                _this.visible.emit(true);
            });
        };
        VisibilityObserver.prototype.runCheck = function () {
            var _this = this;
            var check = function () {
                if (!_this.element) {
                    return;
                }
                // https://davidwalsh.name/offsetheight-visibility
                var _a = _this.element.nativeElement, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;
                if (offsetHeight && offsetWidth) {
                    clearTimeout(_this.timeout);
                    _this.onVisibilityChange();
                }
                else {
                    clearTimeout(_this.timeout);
                    _this.zone.runOutsideAngular(function () {
                        _this.timeout = setTimeout(function () { return check(); }, 100);
                    });
                }
            };
            this.zone.runOutsideAngular(function () {
                _this.timeout = setTimeout(function () { return check(); });
            });
        };
VisibilityObserver.ɵfac = function VisibilityObserver_Factory(t) { return new (t || VisibilityObserver)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
VisibilityObserver.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: VisibilityObserver, selectors: [["visibility-observer"]], outputs: { visible: "visible" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VisibilityObserver, [{
        type: core.Directive,
        args: [{
                selector: 'visibility-observer'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { visible: [{
            type: core.Output
        }] }); })();
        return VisibilityObserver;
    }());
    VisibilityObserver.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.NgZone }
    ]; };
    VisibilityObserver.propDecorators = {
        visible: [{ type: core.Output }]
    };

    var BaseChartComponent = /** @class */ (function () {
        function BaseChartComponent(chartElement, zone, cd, platformId) {
            this.chartElement = chartElement;
            this.zone = zone;
            this.cd = cd;
            this.platformId = platformId;
            this.scheme = 'cool';
            this.schemeType = 'ordinal';
            this.animations = true;
            this.select = new core.EventEmitter();
        }
        BaseChartComponent.prototype.ngOnInit = function () {
            if (common.isPlatformServer(this.platformId)) {
                this.animations = false;
            }
        };
        BaseChartComponent.prototype.ngAfterViewInit = function () {
            this.bindWindowResizeEvent();
            // listen for visibility of the element for hidden by default scenario
            this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
            this.visibilityObserver.visible.subscribe(this.update.bind(this));
        };
        BaseChartComponent.prototype.ngOnDestroy = function () {
            this.unbindEvents();
            if (this.visibilityObserver) {
                this.visibilityObserver.visible.unsubscribe();
                this.visibilityObserver.destroy();
            }
        };
        BaseChartComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        BaseChartComponent.prototype.update = function () {
            if (this.results) {
                this.results = this.cloneData(this.results);
            }
            else {
                this.results = [];
            }
            if (this.view) {
                this.width = this.view[0];
                this.height = this.view[1];
            }
            else {
                var dims = this.getContainerDims();
                if (dims) {
                    this.width = dims.width;
                    this.height = dims.height;
                }
            }
            // default values if width or height are 0 or undefined
            if (!this.width) {
                this.width = 600;
            }
            if (!this.height) {
                this.height = 400;
            }
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height);
            if (this.cd) {
                this.cd.markForCheck();
            }
        };
        BaseChartComponent.prototype.getContainerDims = function () {
            var width;
            var height;
            var hostElem = this.chartElement.nativeElement;
            if (common.isPlatformBrowser(this.platformId) && hostElem.parentNode !== null) {
                // Get the container dimensions
                var dims = hostElem.parentNode.getBoundingClientRect();
                width = dims.width;
                height = dims.height;
            }
            if (width && height) {
                return { width: width, height: height };
            }
            return null;
        };
        /**
         * Converts all date objects that appear as name
         * into formatted date strings
         */
        BaseChartComponent.prototype.formatDates = function () {
            for (var i = 0; i < this.results.length; i++) {
                var g = this.results[i];
                g.label = g.name;
                if (g.label instanceof Date) {
                    g.label = g.label.toLocaleDateString();
                }
                if (g.series) {
                    for (var j = 0; j < g.series.length; j++) {
                        var d = g.series[j];
                        d.label = d.name;
                        if (d.label instanceof Date) {
                            d.label = d.label.toLocaleDateString();
                        }
                    }
                }
            }
        };
        BaseChartComponent.prototype.unbindEvents = function () {
            if (this.resizeSubscription) {
                this.resizeSubscription.unsubscribe();
            }
        };
        BaseChartComponent.prototype.bindWindowResizeEvent = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            var source = rxjs.fromEvent(window, 'resize');
            var subscription = source.pipe(operators.debounceTime(200)).subscribe(function (e) {
                _this.update();
                if (_this.cd) {
                    _this.cd.markForCheck();
                }
            });
            this.resizeSubscription = subscription;
        };
        /**
         * Clones the data into a new object
         *
         * @memberOf BaseChart
         */
        BaseChartComponent.prototype.cloneData = function (data) {
            var e_1, _a, e_2, _b;
            var results = [];
            try {
                for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                    var item = data_1_1.value;
                    var copy = {
                        name: item['name']
                    };
                    if (item['value'] !== undefined) {
                        copy['value'] = item['value'];
                    }
                    if (item['series'] !== undefined) {
                        copy['series'] = [];
                        try {
                            for (var _c = (e_2 = void 0, __values(item['series'])), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var seriesItem = _d.value;
                                var seriesItemCopy = Object.assign({}, seriesItem);
                                copy['series'].push(seriesItemCopy);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    if (item['extra'] !== undefined) {
                        copy['extra'] = JSON.parse(JSON.stringify(item['extra']));
                    }
                    results.push(copy);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return results;
        };
BaseChartComponent.ɵfac = function BaseChartComponent_Factory(t) { return new (t || BaseChartComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
BaseChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BaseChartComponent, selectors: [["base-chart"]], inputs: { scheme: "scheme", schemeType: "schemeType", animations: "animations", results: "results", view: "view", customColors: "customColors" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, template: function BaseChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'base-chart',
                template: " <div></div> "
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { scheme: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], results: [{
            type: core.Input
        }], view: [{
            type: core.Input
        }], customColors: [{
            type: core.Input
        }] }); })();
        return BaseChartComponent;
    }());
    BaseChartComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.NgZone },
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    BaseChartComponent.propDecorators = {
        results: [{ type: core.Input }],
        view: [{ type: core.Input }],
        scheme: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        customColors: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var AxisLabelComponent = /** @class */ (function () {
        function AxisLabelComponent(element) {
            this.textHeight = 25;
            this.margin = 5;
            this.element = element.nativeElement;
        }
        AxisLabelComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        AxisLabelComponent.prototype.update = function () {
            this.strokeWidth = '0.01';
            this.textAnchor = 'middle';
            this.transform = '';
            switch (this.orient) {
                case 'top':
                    this.y = this.offset;
                    this.x = this.width / 2;
                    break;
                case 'bottom':
                    this.y = this.offset;
                    this.x = this.width / 2;
                    break;
                case 'left':
                    this.y = -(this.offset + this.textHeight + this.margin);
                    this.x = -this.height / 2;
                    this.transform = 'rotate(270)';
                    break;
                case 'right':
                    this.y = this.offset + this.margin;
                    this.x = -this.height / 2;
                    this.transform = 'rotate(270)';
                    break;
                default:
            }
        };
AxisLabelComponent.ɵfac = function AxisLabelComponent_Factory(t) { return new (t || AxisLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AxisLabelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AxisLabelComponent, selectors: [["g", "ngx-charts-axis-label", ""]], inputs: { orient: "orient", label: "label", offset: "offset", width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c3, decls: 2, vars: 6, template: function AxisLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisLabelComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-axis-label]',
                template: "\n    <svg:text\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n    >\n      {{ label }}\n    </svg:text>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { orient: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], offset: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }] }); })();
        return AxisLabelComponent;
    }());
    AxisLabelComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    AxisLabelComponent.propDecorators = {
        orient: [{ type: core.Input }],
        label: [{ type: core.Input }],
        offset: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }]
    };

    function trimLabel(s, max) {
        if (max === void 0) { max = 16; }
        if (typeof s !== 'string') {
            if (typeof s === 'number') {
                return s + '';
            }
            else {
                return '';
            }
        }
        s = s.trim();
        if (s.length <= max) {
            return s;
        }
        else {
            return s.slice(0, max) + "...";
        }
    }

    function reduceTicks(ticks, maxTicks) {
        if (ticks.length > maxTicks) {
            var reduced = [];
            var modulus = Math.floor(ticks.length / maxTicks);
            for (var i = 0; i < ticks.length; i++) {
                if (i % modulus === 0) {
                    reduced.push(ticks[i]);
                }
            }
            ticks = reduced;
        }
        return ticks;
    }

    var XAxisTicksComponent = /** @class */ (function () {
        function XAxisTicksComponent(platformId) {
            this.platformId = platformId;
            this.tickArguments = [5];
            this.tickStroke = '#ccc';
            this.trimTicks = true;
            this.maxTickLength = 16;
            this.showGridLines = false;
            this.rotateTicks = true;
            this.dimensionsChanged = new core.EventEmitter();
            this.verticalSpacing = 20;
            this.rotateLabels = false;
            this.innerTickSize = 6;
            this.outerTickSize = 6;
            this.tickPadding = 3;
            this.textAnchor = 'middle';
            this.maxTicksLength = 0;
            this.maxAllowedLength = 16;
            this.height = 0;
            this.approxHeight = 10;
        }
        XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        XAxisTicksComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () { return _this.updateDims(); });
        };
        XAxisTicksComponent.prototype.updateDims = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                // for SSR, use approximate value instead of measured
                this.dimensionsChanged.emit({ height: this.approxHeight });
                return;
            }
            var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
            if (height !== this.height) {
                this.height = height;
                this.dimensionsChanged.emit({ height: this.height });
                setTimeout(function () { return _this.updateDims(); });
            }
        };
        XAxisTicksComponent.prototype.update = function () {
            var _this = this;
            var scale = this.scale;
            this.ticks = this.getTicks();
            if (this.tickFormatting) {
                this.tickFormat = this.tickFormatting;
            }
            else if (scale.tickFormat) {
                this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
            }
            else {
                this.tickFormat = function (d) {
                    if (d.constructor.name === 'Date') {
                        return d.toLocaleDateString();
                    }
                    return d.toLocaleString();
                };
            }
            var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
            this.adjustedScale = this.scale.bandwidth
                ? function (d) {
                    return this.scale(d) + this.scale.bandwidth() * 0.5;
                }
                : this.scale;
            this.textTransform = '';
            if (angle && angle !== 0) {
                this.textTransform = "rotate(" + angle + ")";
                this.textAnchor = 'end';
                this.verticalSpacing = 10;
            }
            else {
                this.textAnchor = 'middle';
            }
            setTimeout(function () { return _this.updateDims(); });
        };
        XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
            var angle = 0;
            this.maxTicksLength = 0;
            for (var i = 0; i < ticks.length; i++) {
                var tick = this.tickFormat(ticks[i]).toString();
                var tickLength = tick.length;
                if (this.trimTicks) {
                    tickLength = this.tickTrim(tick).length;
                }
                if (tickLength > this.maxTicksLength) {
                    this.maxTicksLength = tickLength;
                }
            }
            var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
            var charWidth = 7; // need to measure this
            var wordWidth = len * charWidth;
            var baseWidth = wordWidth;
            var maxBaseWidth = Math.floor(this.width / ticks.length);
            // calculate optimal angle
            while (baseWidth > maxBaseWidth && angle > -90) {
                angle -= 30;
                baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
            }
            this.approxHeight = Math.max(Math.abs(Math.sin(angle * (Math.PI / 180)) * wordWidth), 10);
            return angle;
        };
        XAxisTicksComponent.prototype.getTicks = function () {
            var ticks;
            var maxTicks = this.getMaxTicks(20);
            var maxScaleTicks = this.getMaxTicks(100);
            if (this.tickValues) {
                ticks = this.tickValues;
            }
            else if (this.scale.ticks) {
                ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
            }
            else {
                ticks = this.scale.domain();
                ticks = reduceTicks(ticks, maxTicks);
            }
            return ticks;
        };
        XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
            return Math.floor(this.width / tickWidth);
        };
        XAxisTicksComponent.prototype.tickTransform = function (tick) {
            return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
        };
        XAxisTicksComponent.prototype.gridLineTransform = function () {
            return "translate(0," + (-this.verticalSpacing - 5) + ")";
        };
        XAxisTicksComponent.prototype.tickTrim = function (label) {
            return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
        };
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
XAxisTicksComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { tickArguments: [{
            type: core.Input
        }], tickStroke: [{
            type: core.Input
        }], trimTicks: [{
            type: core.Input
        }], maxTickLength: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], rotateTicks: [{
            type: core.Input
        }], dimensionsChanged: [{
            type: core.Output
        }], scale: [{
            type: core.Input
        }], orient: [{
            type: core.Input
        }], tickValues: [{
            type: core.Input
        }], tickFormatting: [{
            type: core.Input
        }], gridLineHeight: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], ticksElement: [{
            type: core.ViewChild,
            args: ['ticksel']
        }] }); })();
        return XAxisTicksComponent;
    }());
    XAxisTicksComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    XAxisTicksComponent.propDecorators = {
        scale: [{ type: core.Input }],
        orient: [{ type: core.Input }],
        tickArguments: [{ type: core.Input }],
        tickValues: [{ type: core.Input }],
        tickStroke: [{ type: core.Input }],
        trimTicks: [{ type: core.Input }],
        maxTickLength: [{ type: core.Input }],
        tickFormatting: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        gridLineHeight: [{ type: core.Input }],
        width: [{ type: core.Input }],
        rotateTicks: [{ type: core.Input }],
        dimensionsChanged: [{ type: core.Output }],
        ticksElement: [{ type: core.ViewChild, args: ['ticksel',] }]
    };

    var XAxisComponent = /** @class */ (function () {
        function XAxisComponent() {
            this.rotateTicks = true;
            this.showGridLines = false;
            this.xOrient = 'bottom';
            this.xAxisOffset = 0;
            this.dimensionsChanged = new core.EventEmitter();
            this.xAxisClassName = 'x axis';
            this.labelOffset = 0;
            this.fill = 'none';
            this.stroke = 'stroke';
            this.tickStroke = '#ccc';
            this.strokeWidth = 'none';
            this.padding = 5;
        }
        XAxisComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        XAxisComponent.prototype.update = function () {
            this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
            if (typeof this.xAxisTickCount !== 'undefined') {
                this.tickArguments = [this.xAxisTickCount];
            }
        };
        XAxisComponent.prototype.emitTicksHeight = function (_a) {
            var _this = this;
            var height = _a.height;
            var newLabelOffset = height + 25 + 5;
            if (newLabelOffset !== this.labelOffset) {
                this.labelOffset = newLabelOffset;
                setTimeout(function () {
                    _this.dimensionsChanged.emit({ height: height });
                }, 0);
            }
        };
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, XAxisTicksComponent, AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], xOrient: [{
            type: core.Input
        }], xAxisOffset: [{
            type: core.Input
        }], dimensionsChanged: [{
            type: core.Output
        }], xScale: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], trimTicks: [{
            type: core.Input
        }], maxTickLength: [{
            type: core.Input
        }], tickFormatting: [{
            type: core.Input
        }], showLabel: [{
            type: core.Input
        }], labelText: [{
            type: core.Input
        }], ticks: [{
            type: core.Input
        }], xAxisTickInterval: [{
            type: core.Input
        }], xAxisTickCount: [{
            type: core.Input
        }], ticksComponent: [{
            type: core.ViewChild,
            args: [XAxisTicksComponent]
        }] }); })();
        return XAxisComponent;
    }());
    XAxisComponent.propDecorators = {
        xScale: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        trimTicks: [{ type: core.Input }],
        rotateTicks: [{ type: core.Input }],
        maxTickLength: [{ type: core.Input }],
        tickFormatting: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        showLabel: [{ type: core.Input }],
        labelText: [{ type: core.Input }],
        ticks: [{ type: core.Input }],
        xAxisTickInterval: [{ type: core.Input }],
        xAxisTickCount: [{ type: core.Input }],
        xOrient: [{ type: core.Input }],
        xAxisOffset: [{ type: core.Input }],
        dimensionsChanged: [{ type: core.Output }],
        ticksComponent: [{ type: core.ViewChild, args: [XAxisTicksComponent,] }]
    };

    /**
     * Generates a rounded rectanglar path
     *
     * @export
     * @param x, y, w, h, r, tl, tr, bl, br
     */
    function roundedRect(x, y, w, h, r, _a) {
        var _b = __read(_a, 4), tl = _b[0], tr = _b[1], bl = _b[2], br = _b[3];
        var retval = '';
        w = Math.floor(w);
        h = Math.floor(h);
        w = w === 0 ? 1 : w;
        h = h === 0 ? 1 : h;
        retval = "M" + [x + r, y];
        retval += "h" + (w - 2 * r);
        if (tr) {
            retval += "a" + [r, r] + " 0 0 1 " + [r, r];
        }
        else {
            retval += "h" + r + "v" + r;
        }
        retval += "v" + (h - 2 * r);
        if (br) {
            retval += "a" + [r, r] + " 0 0 1 " + [-r, r];
        }
        else {
            retval += "v" + r + "h" + -r;
        }
        retval += "h" + (2 * r - w);
        if (bl) {
            retval += "a" + [r, r] + " 0 0 1 " + [-r, -r];
        }
        else {
            retval += "h" + -r + "v" + -r;
        }
        retval += "v" + (2 * r - h);
        if (tl) {
            retval += "a" + [r, r] + " 0 0 1 " + [r, -r];
        }
        else {
            retval += "v" + -r + "h" + r;
        }
        retval += "z";
        return retval;
    }

    var YAxisTicksComponent = /** @class */ (function () {
        function YAxisTicksComponent(platformId) {
            this.platformId = platformId;
            this.tickArguments = [5];
            this.tickStroke = '#ccc';
            this.trimTicks = true;
            this.maxTickLength = 16;
            this.showGridLines = false;
            this.showRefLabels = false;
            this.showRefLines = false;
            this.dimensionsChanged = new core.EventEmitter();
            this.innerTickSize = 6;
            this.tickPadding = 3;
            this.verticalSpacing = 20;
            this.textAnchor = 'middle';
            this.width = 0;
            this.outerTickSize = 6;
            this.rotateLabels = false;
            this.referenceLineLength = 0;
        }
        YAxisTicksComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        YAxisTicksComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () { return _this.updateDims(); });
        };
        YAxisTicksComponent.prototype.updateDims = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                // for SSR, use approximate value instead of measured
                this.width = this.getApproximateAxisWidth();
                this.dimensionsChanged.emit({ width: this.width });
                return;
            }
            var width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
            if (width !== this.width) {
                this.width = width;
                this.dimensionsChanged.emit({ width: width });
                setTimeout(function () { return _this.updateDims(); });
            }
        };
        YAxisTicksComponent.prototype.update = function () {
            var _this = this;
            var scale;
            var sign = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
            this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
            scale = this.scale;
            this.ticks = this.getTicks();
            if (this.tickFormatting) {
                this.tickFormat = this.tickFormatting;
            }
            else if (scale.tickFormat) {
                this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
            }
            else {
                this.tickFormat = function (d) {
                    if (d.constructor.name === 'Date') {
                        return d.toLocaleDateString();
                    }
                    return d.toLocaleString();
                };
            }
            this.adjustedScale = scale.bandwidth
                ? function (d) {
                    return scale(d) + scale.bandwidth() * 0.5;
                }
                : scale;
            if (this.showRefLines && this.referenceLines) {
                this.setReferencelines();
            }
            switch (this.orient) {
                case 'top':
                    this.transform = function (tick) {
                        return 'translate(' + this.adjustedScale(tick) + ',0)';
                    };
                    this.textAnchor = 'middle';
                    this.y2 = this.innerTickSize * sign;
                    this.y1 = this.tickSpacing * sign;
                    this.dy = sign < 0 ? '0em' : '.71em';
                    break;
                case 'bottom':
                    this.transform = function (tick) {
                        return 'translate(' + this.adjustedScale(tick) + ',0)';
                    };
                    this.textAnchor = 'middle';
                    this.y2 = this.innerTickSize * sign;
                    this.y1 = this.tickSpacing * sign;
                    this.dy = sign < 0 ? '0em' : '.71em';
                    break;
                case 'left':
                    this.transform = function (tick) {
                        return 'translate(0,' + this.adjustedScale(tick) + ')';
                    };
                    this.textAnchor = 'end';
                    this.x2 = this.innerTickSize * -sign;
                    this.x1 = this.tickSpacing * -sign;
                    this.dy = '.32em';
                    break;
                case 'right':
                    this.transform = function (tick) {
                        return 'translate(0,' + this.adjustedScale(tick) + ')';
                    };
                    this.textAnchor = 'start';
                    this.x2 = this.innerTickSize * -sign;
                    this.x1 = this.tickSpacing * -sign;
                    this.dy = '.32em';
                    break;
                default:
            }
            setTimeout(function () { return _this.updateDims(); });
        };
        YAxisTicksComponent.prototype.setReferencelines = function () {
            this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map(function (item) { return item.value; })));
            this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map(function (item) { return item.value; })));
            this.referenceLineLength = this.referenceLines.length;
            this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [
                false,
                false,
                false,
                false
            ]);
        };
        YAxisTicksComponent.prototype.getTicks = function () {
            var ticks;
            var maxTicks = this.getMaxTicks(20);
            var maxScaleTicks = this.getMaxTicks(50);
            if (this.tickValues) {
                ticks = this.tickValues;
            }
            else if (this.scale.ticks) {
                ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
            }
            else {
                ticks = this.scale.domain();
                ticks = reduceTicks(ticks, maxTicks);
            }
            return ticks;
        };
        YAxisTicksComponent.prototype.getMaxTicks = function (tickHeight) {
            return Math.floor(this.height / tickHeight);
        };
        YAxisTicksComponent.prototype.tickTransform = function (tick) {
            return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
        };
        YAxisTicksComponent.prototype.gridLineTransform = function () {
            return "translate(5,0)";
        };
        YAxisTicksComponent.prototype.tickTrim = function (label) {
            return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
        };
        YAxisTicksComponent.prototype.getApproximateAxisWidth = function () {
            var _this = this;
            var maxChars = Math.max.apply(Math, __spread(this.ticks.map(function (t) { return _this.tickTrim(_this.tickFormat(t)).length; })));
            var charWidth = 7;
            return maxChars * charWidth;
        };
YAxisTicksComponent.ɵfac = function YAxisTicksComponent_Factory(t) { return new (t || YAxisTicksComponent)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
YAxisTicksComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: YAxisTicksComponent, selectors: [["g", "ngx-charts-y-axis-ticks", ""]], viewQuery: function YAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", showRefLabels: "showRefLabels", showRefLines: "showRefLines", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineWidth: "gridLineWidth", height: "height", referenceLines: "referenceLines" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, decls: 6, vars: 4, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [1, "reference-area"], [4, "ngIf"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]], template: function YAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_2_Template, 5, 9, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 2);
        ɵngcc0.ɵɵtemplate(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 3);
        ɵngcc0.ɵɵtemplate(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.referenceLines);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisTicksComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-y-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"transform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.dy]=\"dy\"\n          [attr.x]=\"x1\"\n          [attr.y]=\"y1\"\n          [attr.text-anchor]=\"textAnchor\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:path\n      *ngIf=\"referenceLineLength > 1 && refMax && refMin && showRefLines\"\n      class=\"reference-area\"\n      [attr.d]=\"referenceAreaPath\"\n      [attr.transform]=\"gridLineTransform()\"\n    />\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"transform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line\n          *ngIf=\"orient === 'left'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n        />\n        <svg:line\n          *ngIf=\"orient === 'right'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"-gridLineWidth\"\n        />\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let refLine of referenceLines\">\n      <svg:g *ngIf=\"showRefLines\" [attr.transform]=\"transform(refLine.value)\">\n        <svg:line\n          class=\"refline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n          [attr.transform]=\"gridLineTransform()\"\n        />\n        <svg:g *ngIf=\"showRefLabels\">\n          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>\n          <svg:text\n            class=\"refline-label\"\n            [attr.dy]=\"dy\"\n            [attr.y]=\"-6\"\n            [attr.x]=\"gridLineWidth\"\n            [attr.text-anchor]=\"textAnchor\"\n          >\n            {{ refLine.name }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { tickArguments: [{
            type: core.Input
        }], tickStroke: [{
            type: core.Input
        }], trimTicks: [{
            type: core.Input
        }], maxTickLength: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], showRefLabels: [{
            type: core.Input
        }], showRefLines: [{
            type: core.Input
        }], dimensionsChanged: [{
            type: core.Output
        }], scale: [{
            type: core.Input
        }], orient: [{
            type: core.Input
        }], tickValues: [{
            type: core.Input
        }], tickFormatting: [{
            type: core.Input
        }], gridLineWidth: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], referenceLines: [{
            type: core.Input
        }], ticksElement: [{
            type: core.ViewChild,
            args: ['ticksel']
        }] }); })();
        return YAxisTicksComponent;
    }());
    YAxisTicksComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    YAxisTicksComponent.propDecorators = {
        scale: [{ type: core.Input }],
        orient: [{ type: core.Input }],
        tickArguments: [{ type: core.Input }],
        tickValues: [{ type: core.Input }],
        tickStroke: [{ type: core.Input }],
        trimTicks: [{ type: core.Input }],
        maxTickLength: [{ type: core.Input }],
        tickFormatting: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        gridLineWidth: [{ type: core.Input }],
        height: [{ type: core.Input }],
        referenceLines: [{ type: core.Input }],
        showRefLabels: [{ type: core.Input }],
        showRefLines: [{ type: core.Input }],
        dimensionsChanged: [{ type: core.Output }],
        ticksElement: [{ type: core.ViewChild, args: ['ticksel',] }]
    };

    var YAxisComponent = /** @class */ (function () {
        function YAxisComponent() {
            this.showGridLines = false;
            this.yOrient = 'left';
            this.yAxisOffset = 0;
            this.dimensionsChanged = new core.EventEmitter();
            this.yAxisClassName = 'y axis';
            this.labelOffset = 15;
            this.fill = 'none';
            this.stroke = '#CCC';
            this.tickStroke = '#CCC';
            this.strokeWidth = 1;
            this.padding = 5;
        }
        YAxisComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        YAxisComponent.prototype.update = function () {
            this.offset = -(this.yAxisOffset + this.padding);
            if (this.yOrient === 'right') {
                this.labelOffset = 65;
                this.transform = "translate(" + (this.offset + this.dims.width) + " , 0)";
            }
            else {
                this.offset = this.offset;
                this.transform = "translate(" + this.offset + " , 0)";
            }
            if (this.yAxisTickCount !== undefined) {
                this.tickArguments = [this.yAxisTickCount];
            }
        };
        YAxisComponent.prototype.emitTicksWidth = function (_a) {
            var _this = this;
            var width = _a.width;
            if (width !== this.labelOffset && this.yOrient === 'right') {
                this.labelOffset = width + this.labelOffset;
                setTimeout(function () {
                    _this.dimensionsChanged.emit({ width: width });
                }, 0);
            }
            else if (width !== this.labelOffset) {
                this.labelOffset = width;
                setTimeout(function () {
                    _this.dimensionsChanged.emit({ width: width });
                }, 0);
            }
        };
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(); };
YAxisComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["g", "ngx-charts-y-axis", ""]], viewQuery: function YAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(YAxisTicksComponent, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { showGridLines: "showGridLines", yOrient: "yOrient", yAxisOffset: "yAxisOffset", yScale: "yScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", ticks: "ticks", showLabel: "showLabel", labelText: "labelText", yAxisTickInterval: "yAxisTickInterval", yAxisTickCount: "yAxisTickCount", referenceLines: "referenceLines", showRefLines: "showRefLines", showRefLabels: "showRefLabels" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c8, decls: 3, vars: 4, consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function YAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, YAxisComponent__svg_g_1_Template, 1, 14, "g", 0);
        ɵngcc0.ɵɵtemplate(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.yAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, YAxisTicksComponent, AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-y-axis]',
                template: "\n    <svg:g [attr.class]=\"yAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-y-axis-ticks\n        *ngIf=\"yScale\"\n        [trimTicks]=\"trimTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickValues]=\"ticks\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"yScale\"\n        [orient]=\"yOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineWidth]=\"dims.width\"\n        [referenceLines]=\"referenceLines\"\n        [showRefLines]=\"showRefLines\"\n        [showRefLabels]=\"showRefLabels\"\n        [height]=\"dims.height\"\n        (dimensionsChanged)=\"emitTicksWidth($event)\"\n      />\n\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"yOrient\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { showGridLines: [{
            type: core.Input
        }], yOrient: [{
            type: core.Input
        }], yAxisOffset: [{
            type: core.Input
        }], dimensionsChanged: [{
            type: core.Output
        }], yScale: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], trimTicks: [{
            type: core.Input
        }], maxTickLength: [{
            type: core.Input
        }], tickFormatting: [{
            type: core.Input
        }], ticks: [{
            type: core.Input
        }], showLabel: [{
            type: core.Input
        }], labelText: [{
            type: core.Input
        }], yAxisTickInterval: [{
            type: core.Input
        }], yAxisTickCount: [{
            type: core.Input
        }], referenceLines: [{
            type: core.Input
        }], showRefLines: [{
            type: core.Input
        }], showRefLabels: [{
            type: core.Input
        }], ticksComponent: [{
            type: core.ViewChild,
            args: [YAxisTicksComponent]
        }] }); })();
        return YAxisComponent;
    }());
    YAxisComponent.propDecorators = {
        yScale: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        trimTicks: [{ type: core.Input }],
        maxTickLength: [{ type: core.Input }],
        tickFormatting: [{ type: core.Input }],
        ticks: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        showLabel: [{ type: core.Input }],
        labelText: [{ type: core.Input }],
        yAxisTickInterval: [{ type: core.Input }],
        yAxisTickCount: [{ type: core.Input }],
        yOrient: [{ type: core.Input }],
        referenceLines: [{ type: core.Input }],
        showRefLines: [{ type: core.Input }],
        showRefLabels: [{ type: core.Input }],
        yAxisOffset: [{ type: core.Input }],
        dimensionsChanged: [{ type: core.Output }],
        ticksComponent: [{ type: core.ViewChild, args: [YAxisTicksComponent,] }]
    };

    var AxesModule = /** @class */ (function () {
        function AxesModule() {
        }
AxesModule.ɵfac = function AxesModule_Factory(t) { return new (t || AxesModule)(); };
AxesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: AxesModule });
AxesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[common.CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxesModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
                exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AxesModule, { declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent], imports: [ɵngcc1.CommonModule], exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent] }); })();
        return AxesModule;
    }());

    (function (StyleTypes) {
        StyleTypes[StyleTypes["popover"] = 'popover'] = "popover";
        StyleTypes[StyleTypes["tooltip"] = 'tooltip'] = "tooltip";
    })(exports.StyleTypes || (exports.StyleTypes = {}));

    (function (AlignmentTypes) {
        AlignmentTypes[AlignmentTypes["left"] = 'left'] = "left";
        AlignmentTypes[AlignmentTypes["center"] = 'center'] = "center";
        AlignmentTypes[AlignmentTypes["right"] = 'right'] = "right";
    })(exports.AlignmentTypes || (exports.AlignmentTypes = {}));

    (function (ShowTypes) {
        ShowTypes[ShowTypes["all"] = 'all'] = "all";
        ShowTypes[ShowTypes["focus"] = 'focus'] = "focus";
        ShowTypes[ShowTypes["mouseover"] = 'mouseover'] = "mouseover";
    })(exports.ShowTypes || (exports.ShowTypes = {}));

    var TooltipDirective = /** @class */ (function () {
        function TooltipDirective(tooltipService, viewContainerRef, renderer) {
            this.tooltipService = tooltipService;
            this.viewContainerRef = viewContainerRef;
            this.renderer = renderer;
            this.tooltipCssClass = '';
            this.tooltipTitle = '';
            this.tooltipAppendToBody = true;
            this.tooltipSpacing = 10;
            this.tooltipDisabled = false;
            this.tooltipShowCaret = true;
            this.tooltipPlacement = exports.PlacementTypes.top;
            this.tooltipAlignment = exports.AlignmentTypes.center;
            this.tooltipType = exports.StyleTypes.popover;
            this.tooltipCloseOnClickOutside = true;
            this.tooltipCloseOnMouseLeave = true;
            this.tooltipHideTimeout = 300;
            this.tooltipShowTimeout = 100;
            this.tooltipShowEvent = exports.ShowTypes.all;
            this.tooltipImmediateExit = false;
            this.show = new core.EventEmitter();
            this.hide = new core.EventEmitter();
        }
        Object.defineProperty(TooltipDirective.prototype, "listensForFocus", {
            get: function () {
                return this.tooltipShowEvent === exports.ShowTypes.all || this.tooltipShowEvent === exports.ShowTypes.focus;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "listensForHover", {
            get: function () {
                return this.tooltipShowEvent === exports.ShowTypes.all || this.tooltipShowEvent === exports.ShowTypes.mouseover;
            },
            enumerable: false,
            configurable: true
        });
        TooltipDirective.prototype.ngOnDestroy = function () {
            this.hideTooltip(true);
        };
        TooltipDirective.prototype.onFocus = function () {
            if (this.listensForFocus) {
                this.showTooltip();
            }
        };
        TooltipDirective.prototype.onBlur = function () {
            if (this.listensForFocus) {
                this.hideTooltip(true);
            }
        };
        TooltipDirective.prototype.onMouseEnter = function () {
            if (this.listensForHover) {
                this.showTooltip();
            }
        };
        TooltipDirective.prototype.onMouseLeave = function (target) {
            if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
                clearTimeout(this.timeout);
                if (this.component) {
                    var contentDom = this.component.instance.element.nativeElement;
                    var contains = contentDom.contains(target);
                    if (contains)
                        return;
                }
                this.hideTooltip(this.tooltipImmediateExit);
            }
        };
        TooltipDirective.prototype.onMouseClick = function () {
            if (this.listensForHover) {
                this.hideTooltip(true);
            }
        };
        TooltipDirective.prototype.showTooltip = function (immediate) {
            var _this = this;
            if (this.component || this.tooltipDisabled)
                return;
            var time = immediate
                ? 0
                : this.tooltipShowTimeout + (navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) ? 300 : 0);
            clearTimeout(this.timeout);
            this.timeout = setTimeout(function () {
                _this.tooltipService.destroyAll();
                var options = _this.createBoundOptions();
                _this.component = _this.tooltipService.create(options);
                // add a tiny timeout to avoid event re-triggers
                setTimeout(function () {
                    if (_this.component) {
                        _this.addHideListeners(_this.component.instance.element.nativeElement);
                    }
                }, 10);
                _this.show.emit(true);
            }, time);
        };
        TooltipDirective.prototype.addHideListeners = function (tooltip) {
            var _this = this;
            // on mouse enter, cancel the hide triggered by the leave
            this.mouseEnterContentEvent = this.renderer.listen(tooltip, 'mouseenter', function () {
                clearTimeout(_this.timeout);
            });
            // content mouse leave listener
            if (this.tooltipCloseOnMouseLeave) {
                this.mouseLeaveContentEvent = this.renderer.listen(tooltip, 'mouseleave', function () {
                    _this.hideTooltip(_this.tooltipImmediateExit);
                });
            }
            // content close on click outside
            if (this.tooltipCloseOnClickOutside) {
                this.documentClickEvent = this.renderer.listen('window', 'click', function (event) {
                    var contains = tooltip.contains(event.target);
                    if (!contains)
                        _this.hideTooltip();
                });
            }
        };
        TooltipDirective.prototype.hideTooltip = function (immediate) {
            var _this = this;
            if (immediate === void 0) { immediate = false; }
            if (!this.component)
                return;
            var destroyFn = function () {
                // remove events
                if (_this.mouseLeaveContentEvent)
                    _this.mouseLeaveContentEvent();
                if (_this.mouseEnterContentEvent)
                    _this.mouseEnterContentEvent();
                if (_this.documentClickEvent)
                    _this.documentClickEvent();
                // emit events
                _this.hide.emit(true);
                // destroy component
                _this.tooltipService.destroy(_this.component);
                _this.component = undefined;
            };
            clearTimeout(this.timeout);
            if (!immediate) {
                this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
            }
            else {
                destroyFn();
            }
        };
        TooltipDirective.prototype.createBoundOptions = function () {
            return {
                title: this.tooltipTitle,
                template: this.tooltipTemplate,
                host: this.viewContainerRef.element,
                placement: this.tooltipPlacement,
                alignment: this.tooltipAlignment,
                type: this.tooltipType,
                showCaret: this.tooltipShowCaret,
                cssClass: this.tooltipCssClass,
                spacing: this.tooltipSpacing,
                context: this.tooltipContext
            };
        };
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(TooltipService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
TooltipDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "ngx-tooltip", ""]], hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function TooltipDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("blur", function TooltipDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event.target); })("click", function TooltipDirective_click_HostBindingHandler() { return ctx.onMouseClick(); });
    } }, inputs: { tooltipCssClass: "tooltipCssClass", tooltipTitle: "tooltipTitle", tooltipAppendToBody: "tooltipAppendToBody", tooltipSpacing: "tooltipSpacing", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipPlacement: "tooltipPlacement", tooltipAlignment: "tooltipAlignment", tooltipType: "tooltipType", tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside", tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave", tooltipHideTimeout: "tooltipHideTimeout", tooltipShowTimeout: "tooltipShowTimeout", tooltipShowEvent: "tooltipShowEvent", tooltipImmediateExit: "tooltipImmediateExit", tooltipTemplate: "tooltipTemplate", tooltipContext: "tooltipContext" }, outputs: { show: "show", hide: "hide" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: core.Directive,
        args: [{ selector: '[ngx-tooltip]' }]
    }], function () { return [{ type: TooltipService }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Renderer2 }]; }, { tooltipCssClass: [{
            type: core.Input
        }], tooltipTitle: [{
            type: core.Input
        }], tooltipAppendToBody: [{
            type: core.Input
        }], tooltipSpacing: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], tooltipShowCaret: [{
            type: core.Input
        }], tooltipPlacement: [{
            type: core.Input
        }], tooltipAlignment: [{
            type: core.Input
        }], tooltipType: [{
            type: core.Input
        }], tooltipCloseOnClickOutside: [{
            type: core.Input
        }], tooltipCloseOnMouseLeave: [{
            type: core.Input
        }], tooltipHideTimeout: [{
            type: core.Input
        }], tooltipShowTimeout: [{
            type: core.Input
        }], tooltipShowEvent: [{
            type: core.Input
        }], tooltipImmediateExit: [{
            type: core.Input
        }], show: [{
            type: core.Output
        }], hide: [{
            type: core.Output
        }], onFocus: [{
            type: core.HostListener,
            args: ['focusin']
        }], onBlur: [{
            type: core.HostListener,
            args: ['blur']
        }], onMouseEnter: [{
            type: core.HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: core.HostListener,
            args: ['mouseleave', ['$event.target']]
        }], onMouseClick: [{
            type: core.HostListener,
            args: ['click']
        }], tooltipTemplate: [{
            type: core.Input
        }], tooltipContext: [{
            type: core.Input
        }] }); })();
        return TooltipDirective;
    }());
    TooltipDirective.ctorParameters = function () { return [
        { type: TooltipService },
        { type: core.ViewContainerRef },
        { type: core.Renderer2 }
    ]; };
    TooltipDirective.propDecorators = {
        tooltipCssClass: [{ type: core.Input }],
        tooltipTitle: [{ type: core.Input }],
        tooltipAppendToBody: [{ type: core.Input }],
        tooltipSpacing: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipShowCaret: [{ type: core.Input }],
        tooltipPlacement: [{ type: core.Input }],
        tooltipAlignment: [{ type: core.Input }],
        tooltipType: [{ type: core.Input }],
        tooltipCloseOnClickOutside: [{ type: core.Input }],
        tooltipCloseOnMouseLeave: [{ type: core.Input }],
        tooltipHideTimeout: [{ type: core.Input }],
        tooltipShowTimeout: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        tooltipShowEvent: [{ type: core.Input }],
        tooltipContext: [{ type: core.Input }],
        tooltipImmediateExit: [{ type: core.Input }],
        show: [{ type: core.Output }],
        hide: [{ type: core.Output }],
        onFocus: [{ type: core.HostListener, args: ['focusin',] }],
        onBlur: [{ type: core.HostListener, args: ['blur',] }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave', ['$event.target'],] }],
        onMouseClick: [{ type: core.HostListener, args: ['click',] }]
    };

    var TooltipModule = /** @class */ (function () {
        function TooltipModule() {
        }
TooltipModule.ɵfac = function TooltipModule_Factory(t) { return new (t || TooltipModule)(); };
TooltipModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TooltipModule });
TooltipModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [InjectionService, TooltipService], imports: [[common.CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipModule, [{
        type: core.NgModule,
        args: [{
                declarations: [TooltipContentComponent, TooltipDirective],
                providers: [InjectionService, TooltipService],
                exports: [TooltipContentComponent, TooltipDirective],
                imports: [common.CommonModule],
                entryComponents: [TooltipContentComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TooltipModule, { declarations: [TooltipContentComponent, TooltipDirective], imports: [ɵngcc1.CommonModule], exports: [TooltipContentComponent, TooltipDirective] }); })();
        return TooltipModule;
    }());

    /**
     * Formats a label given a date, number or string.
     *
     * @export
     */
    function formatLabel(label) {
        if (label instanceof Date) {
            label = label.toLocaleDateString();
        }
        else {
            label = label.toLocaleString();
        }
        return label;
    }
    /**
     * Escapes a label.
     *
     * @export
     */
    function escapeLabel(label) {
        return label.toLocaleString().replace(/[&'`"<>]/g, function (match) {
            return {
                '&': '&amp;',
                // tslint:disable-next-line: quotemark
                "'": '&#x27;',
                '`': '&#x60;',
                '"': '&quot;',
                '<': '&lt;',
                '>': '&gt;'
            }[match];
        });
    }

    var cache = {};
    /**
     * Generates a short id.
     *
     * Description:
     *   A 4-character alphanumeric sequence (364 = 1.6 million)
     *   This should only be used for JavaScript specific models.
     *   http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
     *
     *   Example: `ebgf`
     */
    function id() {
        var newId = ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);
        // append a 'a' because neo gets mad
        newId = "a" + newId;
        // ensure not already used
        if (!cache[newId]) {
            cache[newId] = true;
            return newId;
        }
        return id();
    }

    var CircleSeriesComponent = /** @class */ (function () {
        function CircleSeriesComponent() {
            this.type = 'standard';
            this.tooltipDisabled = false;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.barVisible = false;
        }
        CircleSeriesComponent.prototype.ngOnInit = function () {
            this.gradientId = 'grad' + id().toString();
            this.gradientFill = "url(#" + this.gradientId + ")";
        };
        CircleSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        CircleSeriesComponent.prototype.update = function () {
            this.circle = this.getActiveCircle();
        };
        CircleSeriesComponent.prototype.getActiveCircle = function () {
            var _this = this;
            var indexActiveDataPoint = this.data.series.findIndex(function (d) {
                var label = d.name;
                return label && _this.visibleValue && label.toString() === _this.visibleValue.toString() && d.value !== undefined;
            });
            if (indexActiveDataPoint === -1) {
                // No valid point is 'active/hovered over' at this moment.
                return undefined;
            }
            return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
        };
        CircleSeriesComponent.prototype.mapDataPointToCircle = function (d, i) {
            var seriesName = this.data.name;
            var value = d.value;
            var label = d.name;
            var tooltipLabel = formatLabel(label);
            var cx;
            if (this.scaleType === 'time') {
                cx = this.xScale(label);
            }
            else if (this.scaleType === 'linear') {
                cx = this.xScale(Number(label));
            }
            else {
                cx = this.xScale(label);
            }
            var cy = this.yScale(this.type === 'standard' ? value : d.d1);
            var radius = 5;
            var height = this.yScale.range()[0] - cy;
            var opacity = 1;
            var color;
            if (this.colors.scaleType === 'linear') {
                if (this.type === 'standard') {
                    color = this.colors.getColor(value);
                }
                else {
                    color = this.colors.getColor(d.d1);
                }
            }
            else {
                color = this.colors.getColor(seriesName);
            }
            var data = Object.assign({}, d, {
                series: seriesName,
                value: value,
                name: label
            });
            return {
                classNames: ["circle-data-" + i],
                value: value,
                label: label,
                data: data,
                cx: cx,
                cy: cy,
                radius: radius,
                height: height,
                tooltipLabel: tooltipLabel,
                color: color,
                opacity: opacity,
                seriesName: seriesName,
                gradientStops: this.getGradientStops(color),
                min: d.min,
                max: d.max
            };
        };
        CircleSeriesComponent.prototype.getTooltipText = function (_a) {
            var tooltipLabel = _a.tooltipLabel, value = _a.value, seriesName = _a.seriesName, min = _a.min, max = _a.max;
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(seriesName) + " \u2022 " + escapeLabel(tooltipLabel) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + this.getTooltipMinMaxText(min, max) + "</span>\n    ";
        };
        CircleSeriesComponent.prototype.getTooltipMinMaxText = function (min, max) {
            if (min !== undefined || max !== undefined) {
                var result = ' (';
                if (min !== undefined) {
                    if (max === undefined) {
                        result += '≥';
                    }
                    result += min.toLocaleString();
                    if (max !== undefined) {
                        result += ' - ';
                    }
                }
                else if (max !== undefined) {
                    result += '≤';
                }
                if (max !== undefined) {
                    result += max.toLocaleString();
                }
                result += ')';
                return result;
            }
            else {
                return '';
            }
        };
        CircleSeriesComponent.prototype.getGradientStops = function (color) {
            return [
                {
                    offset: 0,
                    color: color,
                    opacity: 0.2
                },
                {
                    offset: 100,
                    color: color,
                    opacity: 1
                }
            ];
        };
        CircleSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        CircleSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item !== undefined;
        };
        CircleSeriesComponent.prototype.activateCircle = function () {
            this.barVisible = true;
            this.activate.emit({ name: this.data.name });
        };
        CircleSeriesComponent.prototype.deactivateCircle = function () {
            this.barVisible = false;
            this.circle.opacity = 0;
            this.deactivate.emit({ name: this.data.name });
        };
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c9, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: function () { return [ɵngcc1.NgIf, SvgLinearGradientComponent, CircleComponent, TooltipDirective]; }, encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':enter', [
                    animations.style({
                        opacity: 0
                    }),
                    animations.animate(250, animations.style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: "\n    <svg:g *ngIf=\"circle\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"circle.gradientStops\"\n        />\n      </defs>\n      <svg:rect\n        *ngIf=\"barVisible && type === 'standard'\"\n        [@animationState]=\"'active'\"\n        [attr.x]=\"circle.cx - circle.radius\"\n        [attr.y]=\"circle.cy\"\n        [attr.width]=\"circle.radius * 2\"\n        [attr.height]=\"circle.height\"\n        [attr.fill]=\"gradientFill\"\n        class=\"tooltip-bar\"\n      />\n      <svg:g\n        ngx-charts-circle\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circle.radius\"\n        [fill]=\"circle.color\"\n        [class.active]=\"isActive({ name: circle.seriesName })\"\n        [pointerEvents]=\"circle.value === 0 ? 'none' : 'all'\"\n        [data]=\"circle.value\"\n        [classNames]=\"circle.classNames\"\n        (select)=\"onClick(circle.data)\"\n        (activate)=\"activateCircle()\"\n        (deactivate)=\"deactivateCircle()\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':enter', [
                            animations.style({
                                opacity: 0
                            }),
                            animations.animate(250, animations.style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }], visibleValue: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return CircleSeriesComponent;
    }());
    CircleSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        type: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        visibleValue: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var CircleComponent = /** @class */ (function () {
        function CircleComponent() {
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
        }
        CircleComponent.prototype.onClick = function () {
            this.select.emit(this.data);
        };
        CircleComponent.prototype.onMouseEnter = function () {
            this.activate.emit(this.data);
        };
        CircleComponent.prototype.onMouseLeave = function () {
            this.deactivate.emit(this.data);
        };
        CircleComponent.prototype.ngOnChanges = function (changes) {
            this.classNames = Array.isArray(this.classNames) ? this.classNames.join(' ') : '';
            this.classNames += 'circle';
        };
CircleComponent.ɵfac = function CircleComponent_Factory(t) { return new (t || CircleComponent)(); };
CircleComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CircleComponent, selectors: [["g", "ngx-charts-circle", ""]], hostBindings: function CircleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CircleComponent_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { classNames: "classNames", cx: "cx", cy: "cy", r: "r", fill: "fill", stroke: "stroke", data: "data", circleOpacity: "circleOpacity", pointerEvents: "pointerEvents" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c11, decls: 1, vars: 8, template: function CircleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "circle");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CircleComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-circle]',
                template: "\n    <svg:circle\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      [attr.opacity]=\"circleOpacity\"\n      [attr.class]=\"classNames\"\n      [attr.pointer-events]=\"pointerEvents\"\n    />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], onClick: [{
            type: core.HostListener,
            args: ['click']
        }], onMouseEnter: [{
            type: core.HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], classNames: [{
            type: core.Input
        }], cx: [{
            type: core.Input
        }], cy: [{
            type: core.Input
        }], r: [{
            type: core.Input
        }], fill: [{
            type: core.Input
        }], stroke: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], circleOpacity: [{
            type: core.Input
        }], pointerEvents: [{
            type: core.Input
        }] }); })();
        return CircleComponent;
    }());
    CircleComponent.propDecorators = {
        cx: [{ type: core.Input }],
        cy: [{ type: core.Input }],
        r: [{ type: core.Input }],
        fill: [{ type: core.Input }],
        stroke: [{ type: core.Input }],
        data: [{ type: core.Input }],
        classNames: [{ type: core.Input }],
        circleOpacity: [{ type: core.Input }],
        pointerEvents: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        onClick: [{ type: core.HostListener, args: ['click',] }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var GridPanelComponent = /** @class */ (function () {
        function GridPanelComponent() {
        }
GridPanelComponent.ɵfac = function GridPanelComponent_Factory(t) { return new (t || GridPanelComponent)(); };
GridPanelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridPanelComponent, selectors: [["g", "ngx-charts-grid-panel", ""]], inputs: { path: "path", width: "width", height: "height", x: "x", y: "y" }, attrs: _c12, decls: 1, vars: 4, consts: [["stroke", "none", 1, "gridpanel"]], template: function GridPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "rect", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridPanelComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel]',
                template: "\n    <svg:rect [attr.height]=\"height\" [attr.width]=\"width\" [attr.x]=\"x\" [attr.y]=\"y\" stroke=\"none\" class=\"gridpanel\" />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { path: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], x: [{
            type: core.Input
        }], y: [{
            type: core.Input
        }] }); })();
        return GridPanelComponent;
    }());
    GridPanelComponent.propDecorators = {
        path: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        x: [{ type: core.Input }],
        y: [{ type: core.Input }]
    };

    var GridPanelSeriesComponent = /** @class */ (function () {
        function GridPanelSeriesComponent() {
        }
        GridPanelSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        GridPanelSeriesComponent.prototype.update = function () {
            this.gridPanels = this.getGridPanels();
        };
        GridPanelSeriesComponent.prototype.getGridPanels = function () {
            var _this = this;
            return this.data.map(function (d) {
                var offset;
                var width;
                var height;
                var x;
                var y;
                var className = 'odd';
                if (_this.orient === 'vertical') {
                    var position = _this.xScale(d.name);
                    var positionIndex = Number.parseInt((position / _this.xScale.step()).toString(), 10);
                    if (positionIndex % 2 === 1) {
                        className = 'even';
                    }
                    offset = _this.xScale.bandwidth() * _this.xScale.paddingInner();
                    width = _this.xScale.bandwidth() + offset;
                    height = _this.dims.height;
                    x = _this.xScale(d.name) - offset / 2;
                    y = 0;
                }
                else if (_this.orient === 'horizontal') {
                    var position = _this.yScale(d.name);
                    var positionIndex = Number.parseInt((position / _this.yScale.step()).toString(), 10);
                    if (positionIndex % 2 === 1) {
                        className = 'even';
                    }
                    offset = _this.yScale.bandwidth() * _this.yScale.paddingInner();
                    width = _this.dims.width;
                    height = _this.yScale.bandwidth() + offset;
                    x = 0;
                    y = _this.yScale(d.name) - offset / 2;
                }
                return {
                    name: d.name,
                    class: className,
                    height: height,
                    width: width,
                    x: x,
                    y: y
                };
            });
        };
GridPanelSeriesComponent.ɵfac = function GridPanelSeriesComponent_Factory(t) { return new (t || GridPanelSeriesComponent)(); };
GridPanelSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GridPanelSeriesComponent, selectors: [["g", "ngx-charts-grid-panel-series", ""]], inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale", orient: "orient" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c13, decls: 1, vars: 1, consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]], template: function GridPanelSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.gridPanels);
    } }, directives: [ɵngcc1.NgForOf, GridPanelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridPanelSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel-series]',
                template: "\n    <svg:g\n      ngx-charts-grid-panel\n      *ngFor=\"let gridPanel of gridPanels\"\n      [height]=\"gridPanel.height\"\n      [width]=\"gridPanel.width\"\n      [x]=\"gridPanel.x\"\n      [y]=\"gridPanel.y\"\n      [class.grid-panel]=\"true\"\n      [class.odd]=\"gridPanel.class === 'odd'\"\n      [class.even]=\"gridPanel.class === 'even'\"\n    ></svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { data: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], orient: [{
            type: core.Input
        }] }); })();
        return GridPanelSeriesComponent;
    }());
    GridPanelSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        orient: [{ type: core.Input }]
    };

    var SvgLinearGradientComponent = /** @class */ (function () {
        function SvgLinearGradientComponent() {
            this.orientation = 'vertical';
        }
        SvgLinearGradientComponent.prototype.ngOnChanges = function (changes) {
            this.x1 = '0%';
            this.x2 = '0%';
            this.y1 = '0%';
            this.y2 = '0%';
            if (this.orientation === 'horizontal') {
                this.x2 = '100%';
            }
            else if (this.orientation === 'vertical') {
                this.y1 = '100%';
            }
        };
SvgLinearGradientComponent.ɵfac = function SvgLinearGradientComponent_Factory(t) { return new (t || SvgLinearGradientComponent)(); };
SvgLinearGradientComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SvgLinearGradientComponent, selectors: [["g", "ngx-charts-svg-linear-gradient", ""]], inputs: { orientation: "orientation", name: "name", stops: "stops" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c14, decls: 2, vars: 6, consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgLinearGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "linearGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgLinearGradientComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-svg-linear-gradient]',
                template: "\n    <svg:linearGradient [id]=\"name\" [attr.x1]=\"x1\" [attr.y1]=\"y1\" [attr.x2]=\"x2\" [attr.y2]=\"y2\">\n      <svg:stop\n        *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:linearGradient>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { orientation: [{
            type: core.Input
        }], name: [{
            type: core.Input
        }], stops: [{
            type: core.Input
        }] }); })();
        return SvgLinearGradientComponent;
    }());
    SvgLinearGradientComponent.propDecorators = {
        orientation: [{ type: core.Input }],
        name: [{ type: core.Input }],
        stops: [{ type: core.Input }]
    };

    var SvgRadialGradientComponent = /** @class */ (function () {
        function SvgRadialGradientComponent() {
            this.endOpacity = 1;
            this.cx = 0;
            this.cy = 0;
        }
        Object.defineProperty(SvgRadialGradientComponent.prototype, "stops", {
            get: function () {
                return this.stopsInput || this.stopsDefault;
            },
            set: function (value) {
                this.stopsInput = value;
            },
            enumerable: false,
            configurable: true
        });
        SvgRadialGradientComponent.prototype.ngOnChanges = function (changes) {
            this.r = '30%';
            if ('color' in changes || 'startOpacity' in changes || 'endOpacity' in changes) {
                this.stopsDefault = [
                    {
                        offset: 0,
                        color: this.color,
                        opacity: this.startOpacity
                    },
                    {
                        offset: 100,
                        color: this.color,
                        opacity: this.endOpacity
                    }
                ];
            }
        };
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c15, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: "\n    <svg:radialGradient [id]=\"name\" [attr.cx]=\"cx\" [attr.cy]=\"cy\" [attr.r]=\"r\" gradientUnits=\"userSpaceOnUse\">\n      <svg:stop\n        *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:radialGradient>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: core.Input
        }], cx: [{
            type: core.Input
        }], cy: [{
            type: core.Input
        }], stops: [{
            type: core.Input
        }], color: [{
            type: core.Input
        }], name: [{
            type: core.Input
        }], startOpacity: [{
            type: core.Input
        }] }); })();
        return SvgRadialGradientComponent;
    }());
    SvgRadialGradientComponent.propDecorators = {
        color: [{ type: core.Input }],
        name: [{ type: core.Input }],
        startOpacity: [{ type: core.Input }],
        endOpacity: [{ type: core.Input }],
        cx: [{ type: core.Input }],
        cy: [{ type: core.Input }],
        stops: [{ type: core.Input }]
    };

    var AreaComponent = /** @class */ (function () {
        function AreaComponent(element) {
            this.opacity = 1;
            this.startOpacity = 0.5;
            this.endOpacity = 1;
            this.gradient = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.initialized = false;
            this.hasGradient = false;
            this.element = element.nativeElement;
        }
        AreaComponent.prototype.ngOnChanges = function (changes) {
            if (!this.initialized) {
                this.loadAnimation();
                this.initialized = true;
            }
            else {
                this.update();
            }
        };
        AreaComponent.prototype.update = function () {
            this.gradientId = 'grad' + id().toString();
            this.gradientFill = "url(#" + this.gradientId + ")";
            if (this.gradient || this.stops) {
                this.gradientStops = this.getGradient();
                this.hasGradient = true;
            }
            else {
                this.hasGradient = false;
            }
            this.updatePathEl();
        };
        AreaComponent.prototype.loadAnimation = function () {
            this.areaPath = this.startingPath;
            setTimeout(this.update.bind(this), 100);
        };
        AreaComponent.prototype.updatePathEl = function () {
            var node = d3Selection.select(this.element).select('.area');
            if (this.animations) {
                node.transition().duration(750).attr('d', this.path);
            }
            else {
                node.attr('d', this.path);
            }
        };
        AreaComponent.prototype.getGradient = function () {
            if (this.stops) {
                return this.stops;
            }
            return [
                {
                    offset: 0,
                    color: this.fill,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.fill,
                    opacity: this.endOpacity
                }
            ];
        };
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AreaComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["g", "ngx-charts-area", ""]], inputs: { opacity: "opacity", startOpacity: "startOpacity", endOpacity: "endOpacity", gradient: "gradient", animations: "animations", data: "data", path: "path", startingPath: "startingPath", fill: "fill", activeLabel: "activeLabel", stops: "stops" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c16, decls: 2, vars: 5, consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent__svg_defs_0_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity);
        ɵngcc0.ɵɵattribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-area]',
                template: "\n    <svg:defs *ngIf=\"gradient\">\n      <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path class=\"area\" [attr.d]=\"areaPath\" [attr.fill]=\"gradient ? gradientFill : fill\" [style.opacity]=\"opacity\" />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { opacity: [{
            type: core.Input
        }], startOpacity: [{
            type: core.Input
        }], endOpacity: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], path: [{
            type: core.Input
        }], startingPath: [{
            type: core.Input
        }], fill: [{
            type: core.Input
        }], activeLabel: [{
            type: core.Input
        }], stops: [{
            type: core.Input
        }] }); })();
        return AreaComponent;
    }());
    AreaComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    AreaComponent.propDecorators = {
        data: [{ type: core.Input }],
        path: [{ type: core.Input }],
        startingPath: [{ type: core.Input }],
        fill: [{ type: core.Input }],
        opacity: [{ type: core.Input }],
        startOpacity: [{ type: core.Input }],
        endOpacity: [{ type: core.Input }],
        activeLabel: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        stops: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    // Robert Penner's easeOutExpo
    function easeOutExpo(t, b, c, d) {
        return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b;
    }
    /**
     * Counts from a number to the end incrementally.
     */
    function count(countFrom, countTo, countDecimals, countDuration, callback) {
        var startVal = Number(countFrom);
        var endVal = Number(countTo);
        var countDown = startVal > endVal;
        var decimals = Math.max(0, countDecimals);
        var dec = Math.pow(10, decimals);
        var duration = Number(countDuration) * 1000;
        var startTime;
        function runCount(timestamp) {
            var frameVal;
            var progress = timestamp - startTime;
            if (countDown) {
                frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
            }
            else {
                frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
            }
            if (countDown) {
                frameVal = frameVal < endVal ? endVal : frameVal;
            }
            else {
                frameVal = frameVal > endVal ? endVal : frameVal;
            }
            frameVal = Math.round(frameVal * dec) / dec;
            var tick = progress < duration;
            callback({
                value: frameVal,
                progress: progress,
                timestamp: timestamp,
                finished: !tick
            });
            if (tick) {
                return requestAnimationFrame(function (val) { return runCount(val); });
            }
        }
        return requestAnimationFrame(function (timestamp) {
            startTime = timestamp;
            return runCount(timestamp);
        });
    }
    /**
     * Determine decimals places
     *
     * @export
     */
    function decimalChecker(countTo) {
        var endVal = Number(countTo);
        if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
            return 2;
        }
        return 0;
    }

    /**
     * Count up component
     *
     * Loosely inspired by:
     *  - https://github.com/izupet/angular2-counto
     *  - https://inorganik.github.io/countUp.js/
     *
     * @export
     */
    var CountUpDirective = /** @class */ (function () {
        function CountUpDirective(cd, element) {
            this.cd = cd;
            this.countDuration = 1;
            this.countPrefix = '';
            this.countSuffix = '';
            this.countChange = new core.EventEmitter();
            this.countFinish = new core.EventEmitter();
            this.value = '';
            this._countDecimals = 0;
            this._countTo = 0;
            this._countFrom = 0;
            this.nativeElement = element.nativeElement;
        }
        Object.defineProperty(CountUpDirective.prototype, "countDecimals", {
            get: function () {
                if (this._countDecimals)
                    return this._countDecimals;
                return decimalChecker(this.countTo);
            },
            set: function (val) {
                this._countDecimals = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CountUpDirective.prototype, "countTo", {
            get: function () {
                return this._countTo;
            },
            set: function (val) {
                this._countTo = parseFloat(val);
                this.start();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CountUpDirective.prototype, "countFrom", {
            get: function () {
                return this._countFrom;
            },
            set: function (val) {
                this._countFrom = parseFloat(val);
                this.start();
            },
            enumerable: false,
            configurable: true
        });
        CountUpDirective.prototype.ngOnDestroy = function () {
            cancelAnimationFrame(this.animationReq);
        };
        CountUpDirective.prototype.start = function () {
            var _this = this;
            cancelAnimationFrame(this.animationReq);
            var valueFormatting = this.valueFormatting || (function (value) { return "" + _this.countPrefix + value.toLocaleString() + _this.countSuffix; });
            var callback = function (_a) {
                var value = _a.value, progress = _a.progress, finished = _a.finished;
                _this.value = valueFormatting(value);
                _this.cd.markForCheck();
                if (!finished)
                    _this.countChange.emit({ value: _this.value, progress: progress });
                if (finished)
                    _this.countFinish.emit({ value: _this.value, progress: progress });
            };
            this.animationReq = count(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
        };
CountUpDirective.ɵfac = function CountUpDirective_Factory(t) { return new (t || CountUpDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CountUpDirective.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CountUpDirective, selectors: [["", "ngx-charts-count-up", ""]], inputs: { countDuration: "countDuration", countPrefix: "countPrefix", countSuffix: "countSuffix", countDecimals: "countDecimals", countTo: "countTo", countFrom: "countFrom", valueFormatting: "valueFormatting" }, outputs: { countChange: "countChange", countFinish: "countFinish" }, attrs: _c17, decls: 1, vars: 1, template: function CountUpDirective_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.value, " ");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CountUpDirective, [{
        type: core.Component,
        args: [{
                selector: '[ngx-charts-count-up]',
                template: " {{ value }} "
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { countDuration: [{
            type: core.Input
        }], countPrefix: [{
            type: core.Input
        }], countSuffix: [{
            type: core.Input
        }], countChange: [{
            type: core.Output
        }], countFinish: [{
            type: core.Output
        }], countDecimals: [{
            type: core.Input
        }], countTo: [{
            type: core.Input
        }], countFrom: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }] }); })();
        return CountUpDirective;
    }());
    CountUpDirective.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: core.ElementRef }
    ]; };
    CountUpDirective.propDecorators = {
        countDuration: [{ type: core.Input }],
        countPrefix: [{ type: core.Input }],
        countSuffix: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        countDecimals: [{ type: core.Input }],
        countTo: [{ type: core.Input }],
        countFrom: [{ type: core.Input }],
        countChange: [{ type: core.Output }],
        countFinish: [{ type: core.Output }]
    };

    // If we don't check whether 'window' and 'global' variables are defined,
    // code will fail in browser/node with 'variable is undefined' error.
    var root;
    if (typeof window !== 'undefined') {
        root = window;
    }
    else if (typeof global !== 'undefined') {
        root = global;
    }
    // tslint:disable-next-line:variable-name
    var MouseEvent = root.MouseEvent;
    function createMouseEvent(name, bubbles, cancelable) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = true; }
        // Calling new of an event does not work correctly on IE. The following is a tested workaround
        // See https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11
        if (typeof MouseEvent === 'function') {
            // Sane browsers
            return new MouseEvent(name, { bubbles: bubbles, cancelable: cancelable });
        }
        else {
            // IE
            var event = document.createEvent('MouseEvent');
            event.initEvent(name, bubbles, cancelable);
            return event;
        }
    }

    var TooltipArea = /** @class */ (function () {
        function TooltipArea(platformId) {
            this.platformId = platformId;
            this.anchorOpacity = 0;
            this.anchorPos = -1;
            this.anchorValues = [];
            this.showPercentage = false;
            this.tooltipDisabled = false;
            this.hover = new core.EventEmitter();
        }
        TooltipArea.prototype.getValues = function (xVal) {
            var e_1, _a;
            var results = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    var item = group.series.find(function (d) { return d.name.toString() === xVal.toString(); });
                    var groupName = group.name;
                    if (groupName instanceof Date) {
                        groupName = groupName.toLocaleDateString();
                    }
                    if (item) {
                        var label = item.name;
                        var val = item.value;
                        if (this.showPercentage) {
                            val = (item.d1 - item.d0).toFixed(2) + '%';
                        }
                        var color = void 0;
                        if (this.colors.scaleType === 'linear') {
                            var v = val;
                            if (item.d1) {
                                v = item.d1;
                            }
                            color = this.colors.getColor(v);
                        }
                        else {
                            color = this.colors.getColor(group.name);
                        }
                        var data = Object.assign({}, item, {
                            value: val,
                            name: label,
                            series: groupName,
                            min: item.min,
                            max: item.max,
                            color: color
                        });
                        results.push(data);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return results;
        };
        TooltipArea.prototype.mouseMove = function (event) {
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            var xPos = event.pageX - event.target.getBoundingClientRect().left;
            var closestIndex = this.findClosestPointIndex(xPos);
            var closestPoint = this.xSet[closestIndex];
            this.anchorPos = this.xScale(closestPoint);
            this.anchorPos = Math.max(0, this.anchorPos);
            this.anchorPos = Math.min(this.dims.width, this.anchorPos);
            this.anchorValues = this.getValues(closestPoint);
            if (this.anchorPos !== this.lastAnchorPos) {
                var ev = createMouseEvent('mouseleave');
                this.tooltipAnchor.nativeElement.dispatchEvent(ev);
                this.anchorOpacity = 0.7;
                this.hover.emit({
                    value: closestPoint
                });
                this.showTooltip();
                this.lastAnchorPos = this.anchorPos;
            }
        };
        TooltipArea.prototype.findClosestPointIndex = function (xPos) {
            var minIndex = 0;
            var maxIndex = this.xSet.length - 1;
            var minDiff = Number.MAX_VALUE;
            var closestIndex = 0;
            while (minIndex <= maxIndex) {
                var currentIndex = ((minIndex + maxIndex) / 2) | 0;
                var currentElement = this.xScale(this.xSet[currentIndex]);
                var curDiff = Math.abs(currentElement - xPos);
                if (curDiff < minDiff) {
                    minDiff = curDiff;
                    closestIndex = currentIndex;
                }
                if (currentElement < xPos) {
                    minIndex = currentIndex + 1;
                }
                else if (currentElement > xPos) {
                    maxIndex = currentIndex - 1;
                }
                else {
                    minDiff = 0;
                    closestIndex = currentIndex;
                    break;
                }
            }
            return closestIndex;
        };
        TooltipArea.prototype.showTooltip = function () {
            var event = createMouseEvent('mouseenter');
            this.tooltipAnchor.nativeElement.dispatchEvent(event);
        };
        TooltipArea.prototype.hideTooltip = function () {
            var event = createMouseEvent('mouseleave');
            this.tooltipAnchor.nativeElement.dispatchEvent(event);
            this.anchorOpacity = 0;
            this.lastAnchorPos = -1;
        };
        TooltipArea.prototype.getToolTipText = function (tooltipItem) {
            var result = '';
            if (tooltipItem.series !== undefined) {
                result += tooltipItem.series;
            }
            else {
                result += '???';
            }
            result += ': ';
            if (tooltipItem.value !== undefined) {
                result += tooltipItem.value.toLocaleString();
            }
            if (tooltipItem.min !== undefined || tooltipItem.max !== undefined) {
                result += ' (';
                if (tooltipItem.min !== undefined) {
                    if (tooltipItem.max === undefined) {
                        result += '≥';
                    }
                    result += tooltipItem.min.toLocaleString();
                    if (tooltipItem.max !== undefined) {
                        result += ' - ';
                    }
                }
                else if (tooltipItem.max !== undefined) {
                    result += '≤';
                }
                if (tooltipItem.max !== undefined) {
                    result += tooltipItem.max.toLocaleString();
                }
                result += ')';
            }
            return result;
        };
TooltipArea.ɵfac = function TooltipArea_Factory(t) { return new (t || TooltipArea)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
TooltipArea.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TooltipArea, selectors: [["g", "ngx-charts-tooltip-area", ""]], viewQuery: function TooltipArea_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c18, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipAnchor = _t.first);
    } }, inputs: { showPercentage: "showPercentage", tooltipDisabled: "tooltipDisabled", dims: "dims", xSet: "xSet", xScale: "xScale", yScale: "yScale", results: "results", colors: "colors", tooltipTemplate: "tooltipTemplate" }, outputs: { hover: "hover" }, attrs: _c19, decls: 6, vars: 18, consts: [["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "auto", 3, "mousemove", "mouseleave"], ["defaultTooltipTemplate", ""], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], ["tooltipAnchor", ""], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]], template: function TooltipArea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "rect", 0);
        ɵngcc0.ɵɵlistener("mousemove", function TooltipArea_Template__svg_rect_mousemove_1_listener($event) { return ctx.mouseMove($event); })("mouseleave", function TooltipArea_Template__svg_rect_mouseleave_1_listener() { return ctx.hideTooltip(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, TooltipArea__svg_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(4, "rect", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        var _r0 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
        ɵngcc0.ɵɵproperty("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "right")("tooltipType", "tooltip")("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : _r0)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
        ɵngcc0.ɵɵattribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
    } }, directives: [TooltipDirective, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition('inactive => active', [
                    animations.style({
                        opacity: 0
                    }),
                    animations.animate(250, animations.style({ opacity: 0.7 }))
                ]),
                animations.transition('active => inactive', [
                    animations.style({
                        opacity: 0.7
                    }),
                    animations.animate(250, animations.style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipArea, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-tooltip-area]',
                template: "\n    <svg:g>\n      <svg:rect\n        class=\"tooltip-area\"\n        [attr.x]=\"0\"\n        y=\"0\"\n        [attr.width]=\"dims.width\"\n        [attr.height]=\"dims.height\"\n        style=\"opacity: 0; cursor: 'auto';\"\n        (mousemove)=\"mouseMove($event)\"\n        (mouseleave)=\"hideTooltip()\"\n      />\n      <ng-template #defaultTooltipTemplate let-model=\"model\">\n        <xhtml:div class=\"area-tooltip-container\">\n          <xhtml:div *ngFor=\"let tooltipItem of model\" class=\"tooltip-item\">\n            <xhtml:span class=\"tooltip-item-color\" [style.background-color]=\"tooltipItem.color\"></xhtml:span>\n            {{ getToolTipText(tooltipItem) }}\n          </xhtml:div>\n        </xhtml:div>\n      </ng-template>\n      <svg:rect\n        #tooltipAnchor\n        [@animationState]=\"anchorOpacity !== 0 ? 'active' : 'inactive'\"\n        class=\"tooltip-anchor\"\n        [attr.x]=\"anchorPos\"\n        y=\"0\"\n        [attr.width]=\"1\"\n        [attr.height]=\"dims.height\"\n        [style.opacity]=\"anchorOpacity\"\n        [style.pointer-events]=\"'none'\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'right'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipSpacing]=\"15\"\n        [tooltipTemplate]=\"tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate\"\n        [tooltipContext]=\"anchorValues\"\n        [tooltipImmediateExit]=\"true\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition('inactive => active', [
                            animations.style({
                                opacity: 0
                            }),
                            animations.animate(250, animations.style({ opacity: 0.7 }))
                        ]),
                        animations.transition('active => inactive', [
                            animations.style({
                                opacity: 0.7
                            }),
                            animations.animate(250, animations.style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { showPercentage: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], hover: [{
            type: core.Output
        }], dims: [{
            type: core.Input
        }], xSet: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], results: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }], tooltipAnchor: [{
            type: core.ViewChild,
            args: ['tooltipAnchor', { static: false }]
        }] }); })();
        return TooltipArea;
    }());
    TooltipArea.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    TooltipArea.propDecorators = {
        dims: [{ type: core.Input }],
        xSet: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        results: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        showPercentage: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        hover: [{ type: core.Output }],
        tooltipAnchor: [{ type: core.ViewChild, args: ['tooltipAnchor', { static: false },] }]
    };

    var Timeline = /** @class */ (function () {
        function Timeline(element, cd) {
            this.cd = cd;
            this.height = 50;
            this.select = new core.EventEmitter();
            this.onDomainChange = new core.EventEmitter();
            this.initialized = false;
            this.element = element.nativeElement;
        }
        Timeline.prototype.ngOnChanges = function (changes) {
            this.update();
            if (!this.initialized) {
                this.addBrush();
                this.initialized = true;
            }
        };
        Timeline.prototype.update = function () {
            this.dims = this.getDims();
            this.height = this.dims.height;
            var offsetY = this.view[1] - this.height;
            this.xDomain = this.getXDomain();
            this.xScale = this.getXScale();
            if (this.brush) {
                this.updateBrush();
            }
            this.transform = "translate(0 , " + offsetY + ")";
            this.filterId = 'filter' + id().toString();
            this.filter = "url(#" + this.filterId + ")";
            this.cd.markForCheck();
        };
        Timeline.prototype.getXDomain = function () {
            var e_1, _a, e_2, _b;
            var values = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!values.includes(d.name)) {
                                values.push(d.name);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var domain = [];
            if (this.scaleType === 'time') {
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                domain = [min, max];
            }
            else if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                domain = [min, max];
            }
            else {
                domain = values;
            }
            return domain;
        };
        Timeline.prototype.getXScale = function () {
            var scale;
            if (this.scaleType === 'time') {
                scale = d3Scale.scaleTime().range([0, this.dims.width]).domain(this.xDomain);
            }
            else if (this.scaleType === 'linear') {
                scale = d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.xDomain);
            }
            else if (this.scaleType === 'ordinal') {
                scale = d3Scale.scalePoint().range([0, this.dims.width]).padding(0.1).domain(this.xDomain);
            }
            return scale;
        };
        Timeline.prototype.addBrush = function () {
            var _this = this;
            if (this.brush)
                return;
            var height = this.height;
            var width = this.view[0];
            this.brush = d3Brush.brushX()
                .extent([
                [0, 0],
                [width, height]
            ])
                .on('brush end', function (_a) {
                var d3selection = _a.d3selection;
                var selection = d3selection || _this.xScale.range();
                var newDomain = selection.map(_this.xScale.invert);
                _this.onDomainChange.emit(newDomain);
                _this.cd.markForCheck();
            });
            d3Selection.select(this.element).select('.brush').call(this.brush);
        };
        Timeline.prototype.updateBrush = function () {
            if (!this.brush)
                return;
            var height = this.height;
            var width = this.view[0];
            this.brush.extent([
                [0, 0],
                [width, height]
            ]);
            d3Selection.select(this.element).select('.brush').call(this.brush);
            // clear hardcoded properties so they can be defined by CSS
            d3Selection.select(this.element)
                .select('.selection')
                .attr('fill', undefined)
                .attr('stroke', undefined)
                .attr('fill-opacity', undefined);
            this.cd.markForCheck();
        };
        Timeline.prototype.getDims = function () {
            var width = this.view[0];
            var dims = {
                width: width,
                height: this.height
            };
            return dims;
        };
Timeline.ɵfac = function Timeline_Factory(t) { return new (t || Timeline)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
Timeline.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Timeline, selectors: [["g", "ngx-charts-timeline", ""]], inputs: { height: "height", view: "view", state: "state", results: "results", scheme: "scheme", customColors: "customColors", legend: "legend", miniChart: "miniChart", autoScale: "autoScale", scaleType: "scaleType" }, outputs: { select: "select", onDomainChange: "onDomainChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c20, ngContentSelectors: _c2, decls: 7, vars: 4, consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]], template: function Timeline_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "filter");
        ɵngcc0.ɵɵelement(2, "feColorMatrix", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "rect", 3);
        ɵngcc0.ɵɵelement(6, "g", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("id", ctx.filterId);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵattribute("width", ctx.view[0])("height", ctx.height);
    } }, styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke:#888;stroke-width:1px}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Timeline, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-timeline]',
                template: "\n    <svg:g class=\"timeline\" [attr.transform]=\"transform\">\n      <svg:filter [attr.id]=\"filterId\">\n        <svg:feColorMatrix\n          in=\"SourceGraphic\"\n          type=\"matrix\"\n          values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\"\n        />\n      </svg:filter>\n      <svg:g class=\"embedded-chart\">\n        <ng-content></ng-content>\n      </svg:g>\n      <svg:rect x=\"0\" [attr.width]=\"view[0]\" y=\"0\" [attr.height]=\"height\" class=\"brush-background\" />\n      <svg:g class=\"brush\"></svg:g>\n    </svg:g>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke:#888;stroke-width:1px}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { height: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], onDomainChange: [{
            type: core.Output
        }], view: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }], results: [{
            type: core.Input
        }], scheme: [{
            type: core.Input
        }], customColors: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], miniChart: [{
            type: core.Input
        }], autoScale: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }] }); })();
        return Timeline;
    }());
    Timeline.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef }
    ]; };
    Timeline.propDecorators = {
        view: [{ type: core.Input }],
        state: [{ type: core.Input }],
        results: [{ type: core.Input }],
        scheme: [{ type: core.Input }],
        customColors: [{ type: core.Input }],
        legend: [{ type: core.Input }],
        miniChart: [{ type: core.Input }],
        autoScale: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        height: [{ type: core.Input }],
        select: [{ type: core.Output }],
        onDomainChange: [{ type: core.Output }]
    };

    var LegendComponent = /** @class */ (function () {
        function LegendComponent(cd) {
            this.cd = cd;
            this.horizontal = false;
            this.labelClick = new core.EventEmitter();
            this.labelActivate = new core.EventEmitter();
            this.labelDeactivate = new core.EventEmitter();
            this.legendEntries = [];
        }
        LegendComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        LegendComponent.prototype.update = function () {
            this.cd.markForCheck();
            this.legendEntries = this.getLegendEntries();
        };
        LegendComponent.prototype.getLegendEntries = function () {
            var e_1, _a;
            var items = [];
            var _loop_1 = function (label) {
                var formattedLabel = formatLabel(label);
                var idx = items.findIndex(function (i) {
                    return i.label === formattedLabel;
                });
                if (idx === -1) {
                    items.push({
                        label: label,
                        formattedLabel: formattedLabel,
                        color: this_1.colors.getColor(label)
                    });
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(this.data), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var label = _c.value;
                    _loop_1(label);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return items;
        };
        LegendComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.label === d.name;
            });
            return item !== undefined;
        };
        LegendComponent.prototype.activate = function (item) {
            this.labelActivate.emit(item);
        };
        LegendComponent.prototype.deactivate = function (item) {
            this.labelDeactivate.emit(item);
        };
        LegendComponent.prototype.trackBy = function (index, item) {
            return item.label;
        };
LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
LegendComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LegendComponent, selectors: [["ngx-charts-legend"]], inputs: { horizontal: "horizontal", data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 9, consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "label", "formattedLabel", "color", "isActive", "select", "activate", "deactivate"]], template: function LegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "ul", 2);
        ɵngcc0.ɵɵtemplate(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.height - 45, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, LegendEntryComponent]; }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{font-size:14px;font-weight:700;margin-bottom:5px;margin-left:10px;overflow:hidden;white-space:nowrap}.chart-legend li,.chart-legend ul{list-style:none;margin:0;padding:0}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{background:rgba(0,0,0,.05);border-radius:3px;float:left;line-height:85%;list-style:none;overflow-x:hidden;overflow-y:auto;text-align:left;white-space:nowrap;width:100%}.chart-legend .legend-label{color:#afb7c8;cursor:pointer;font-size:90%;margin:8px}.chart-legend .legend-label:hover{color:#000;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{border-radius:3px;color:#5b646b;display:inline-block;height:15px;margin-right:5px;width:15px}.chart-legend .legend-label-text{font-size:12px;line-height:15px;vertical-align:top;width:calc(100% - 20px)}.chart-legend .legend-label-text,.chart-legend .legend-title-text{display:inline-block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.chart-legend .legend-title-text{line-height:16px;vertical-align:bottom}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-legend',
                template: "\n    <div [style.width.px]=\"width\">\n      <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n        <span class=\"legend-title-text\">{{ title }}</span>\n      </header>\n      <div class=\"legend-wrap\">\n        <ul class=\"legend-labels\" [class.horizontal-legend]=\"horizontal\" [style.max-height.px]=\"height - 45\">\n          <li *ngFor=\"let entry of legendEntries; trackBy: trackBy\" class=\"legend-label\">\n            <ngx-charts-legend-entry\n              [label]=\"entry.label\"\n              [formattedLabel]=\"entry.formattedLabel\"\n              [color]=\"entry.color\"\n              [isActive]=\"isActive(entry)\"\n              (select)=\"labelClick.emit($event)\"\n              (activate)=\"activate($event)\"\n              (deactivate)=\"deactivate($event)\"\n            >\n            </ngx-charts-legend-entry>\n          </li>\n        </ul>\n      </div>\n    </div>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{font-size:14px;font-weight:700;margin-bottom:5px;margin-left:10px;overflow:hidden;white-space:nowrap}.chart-legend li,.chart-legend ul{list-style:none;margin:0;padding:0}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{background:rgba(0,0,0,.05);border-radius:3px;float:left;line-height:85%;list-style:none;overflow-x:hidden;overflow-y:auto;text-align:left;white-space:nowrap;width:100%}.chart-legend .legend-label{color:#afb7c8;cursor:pointer;font-size:90%;margin:8px}.chart-legend .legend-label:hover{color:#000;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{border-radius:3px;color:#5b646b;display:inline-block;height:15px;margin-right:5px;width:15px}.chart-legend .legend-label-text{font-size:12px;line-height:15px;vertical-align:top;width:calc(100% - 20px)}.chart-legend .legend-label-text,.chart-legend .legend-title-text{display:inline-block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.chart-legend .legend-title-text{line-height:16px;vertical-align:bottom}"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { horizontal: [{
            type: core.Input
        }], labelClick: [{
            type: core.Output
        }], labelActivate: [{
            type: core.Output
        }], labelDeactivate: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], title: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }] }); })();
        return LegendComponent;
    }());
    LegendComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef }
    ]; };
    LegendComponent.propDecorators = {
        data: [{ type: core.Input }],
        title: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        height: [{ type: core.Input }],
        width: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        horizontal: [{ type: core.Input }],
        labelClick: [{ type: core.Output }],
        labelActivate: [{ type: core.Output }],
        labelDeactivate: [{ type: core.Output }]
    };

    var LegendEntryComponent = /** @class */ (function () {
        function LegendEntryComponent() {
            this.isActive = false;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.toggle = new core.EventEmitter();
        }
        Object.defineProperty(LegendEntryComponent.prototype, "trimmedLabel", {
            get: function () {
                return this.formattedLabel || '(empty)';
            },
            enumerable: false,
            configurable: true
        });
        LegendEntryComponent.prototype.onMouseEnter = function () {
            this.activate.emit({ name: this.label });
        };
        LegendEntryComponent.prototype.onMouseLeave = function () {
            this.deactivate.emit({ name: this.label });
        };
LegendEntryComponent.ɵfac = function LegendEntryComponent_Factory(t) { return new (t || LegendEntryComponent)(); };
LegendEntryComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LegendEntryComponent, selectors: [["ngx-charts-legend-entry"]], hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { isActive: "isActive", color: "color", label: "label", formattedLabel: "formattedLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", toggle: "toggle" }, decls: 4, vars: 6, consts: [["tabindex", "-1", 3, "title", "click"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]], template: function LegendEntryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_0_listener() { return ctx.select.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_1_listener() { return ctx.toggle.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵproperty("title", ctx.formattedLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.trimmedLabel, " ");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendEntryComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-legend-entry',
                template: "\n    <span [title]=\"formattedLabel\" tabindex=\"-1\" [class.active]=\"isActive\" (click)=\"select.emit(formattedLabel)\">\n      <span class=\"legend-label-color\" [style.background-color]=\"color\" (click)=\"toggle.emit(formattedLabel)\"> </span>\n      <span class=\"legend-label-text\">\n        {{ trimmedLabel }}\n      </span>\n    </span>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], toggle: [{
            type: core.Output
        }], onMouseEnter: [{
            type: core.HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], color: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], formattedLabel: [{
            type: core.Input
        }] }); })();
        return LegendEntryComponent;
    }());
    LegendEntryComponent.propDecorators = {
        color: [{ type: core.Input }],
        label: [{ type: core.Input }],
        formattedLabel: [{ type: core.Input }],
        isActive: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        toggle: [{ type: core.Output }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var ScaleLegendComponent = /** @class */ (function () {
        function ScaleLegendComponent(sanitizer) {
            this.sanitizer = sanitizer;
            this.horizontal = false;
        }
        ScaleLegendComponent.prototype.ngOnChanges = function (changes) {
            var gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
            var direction = this.horizontal ? 'right' : 'bottom';
            this.gradient = "linear-gradient(to " + direction + ", " + gradientValues + ")";
        };
        /**
         * Generates the string used in the gradient stylesheet properties
         * @param colors array of colors
         * @param splits array of splits on a scale of (0, 1)
         */
        ScaleLegendComponent.prototype.gradientString = function (colors, splits) {
            // add the 100%
            splits.push(1);
            var pairs = [];
            colors.reverse().forEach(function (c, i) {
                pairs.push(c + " " + Math.round(splits[i] * 100) + "%");
            });
            return pairs.join(', ');
        };
ScaleLegendComponent.ɵfac = function ScaleLegendComponent_Factory(t) { return new (t || ScaleLegendComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DomSanitizer)); };
ScaleLegendComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ScaleLegendComponent, selectors: [["ngx-charts-scale-legend"]], inputs: { horizontal: "horizontal", valueRange: "valueRange", colors: "colors", height: "height", width: "width" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 10, consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]], template: function ScaleLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "div", 1);
        ɵngcc0.ɵɵelementStart(6, "span");
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.horizontal ? undefined : ctx.height, "px")("width", ctx.width, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[1].toLocaleString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background", ctx.gradient);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[0].toLocaleString());
    } }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{display:flex;flex-direction:column;text-align:center}.chart-legend .scale-legend-wrap{border-radius:5px;display:inline-block;flex:1;margin:0 auto;width:30px}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{height:30px;margin:0 16px;width:auto}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScaleLegendComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-scale-legend',
                template: "\n    <div\n      class=\"scale-legend\"\n      [class.horizontal-legend]=\"horizontal\"\n      [style.height.px]=\"horizontal ? undefined : height\"\n      [style.width.px]=\"width\"\n    >\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[1].toLocaleString() }}</span>\n      </div>\n      <div class=\"scale-legend-wrap\" [style.background]=\"gradient\"></div>\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[0].toLocaleString() }}</span>\n      </div>\n    </div>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{display:flex;flex-direction:column;text-align:center}.chart-legend .scale-legend-wrap{border-radius:5px;display:inline-block;flex:1;margin:0 auto;width:30px}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{height:30px;margin:0 16px;width:auto}"]
            }]
    }], function () { return [{ type: ɵngcc2.DomSanitizer }]; }, { horizontal: [{
            type: core.Input
        }], valueRange: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }] }); })();
        return ScaleLegendComponent;
    }());
    ScaleLegendComponent.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer }
    ]; };
    ScaleLegendComponent.propDecorators = {
        valueRange: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        height: [{ type: core.Input }],
        width: [{ type: core.Input }],
        horizontal: [{ type: core.Input }]
    };

    var AdvancedLegendComponent = /** @class */ (function () {
        function AdvancedLegendComponent() {
            this.label = 'Total';
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.legendItems = [];
            this.labelFormatting = function (label) { return label; };
            this.percentageFormatting = function (percentage) { return percentage; };
            this.defaultValueFormatting = function (value) { return value.toLocaleString(); };
        }
        AdvancedLegendComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        AdvancedLegendComponent.prototype.getTotal = function () {
            return this.data.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        };
        AdvancedLegendComponent.prototype.update = function () {
            this.total = this.getTotal();
            this.roundedTotal = this.total;
            this.legendItems = this.getLegendItems();
        };
        AdvancedLegendComponent.prototype.getLegendItems = function () {
            var _this = this;
            return this.data.map(function (d) {
                var label = formatLabel(d.name);
                var value = d.value;
                var color = _this.colors.getColor(label);
                var percentage = _this.total > 0 ? (value / _this.total) * 100 : 0;
                var formattedLabel = typeof _this.labelFormatting === 'function' ? _this.labelFormatting(label) : label;
                return {
                    _value: value,
                    data: d,
                    value: value,
                    color: color,
                    label: formattedLabel,
                    displayLabel: trimLabel(formattedLabel, 20),
                    origialLabel: d.name,
                    percentage: _this.percentageFormatting ? _this.percentageFormatting(percentage) : percentage.toLocaleString()
                };
            });
        };
        AdvancedLegendComponent.prototype.trackBy = function (item) {
            return item.formattedLabel;
        };
AdvancedLegendComponent.ɵfac = function AdvancedLegendComponent_Factory(t) { return new (t || AdvancedLegendComponent)(); };
AdvancedLegendComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AdvancedLegendComponent, selectors: [["ngx-charts-advanced-legend"]], inputs: { label: "label", animations: "animations", labelFormatting: "labelFormatting", percentageFormatting: "percentageFormatting", width: "width", data: "data", colors: "colors", valueFormatting: "valueFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 7, consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]], template: function AdvancedLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1);
        ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, CountUpDirective], styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{overflow:auto;white-space:nowrap}.advanced-pie-legend .legend-items-container .legend-items .legend-item{cursor:pointer;display:inline-block;margin-right:20px}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;margin-left:11px;margin-top:-6px;opacity:.7}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;margin-left:11px;opacity:.7}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;float:left;height:42px;margin-right:7px;width:4px}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AdvancedLegendComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-advanced-legend',
                template: "\n    <div class=\"advanced-pie-legend\" [style.width.px]=\"width\">\n      <div\n        *ngIf=\"animations\"\n        class=\"total-value\"\n        ngx-charts-count-up\n        [countTo]=\"roundedTotal\"\n        [valueFormatting]=\"valueFormatting\"\n      ></div>\n      <div class=\"total-value\" *ngIf=\"!animations\">\n        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}\n      </div>\n      <div class=\"total-label\">\n        {{ label }}\n      </div>\n      <div class=\"legend-items-container\">\n        <div class=\"legend-items\">\n          <div\n            *ngFor=\"let legendItem of legendItems; trackBy: trackBy\"\n            tabindex=\"-1\"\n            class=\"legend-item\"\n            (mouseenter)=\"activate.emit(legendItem.data)\"\n            (mouseleave)=\"deactivate.emit(legendItem.data)\"\n            (click)=\"select.emit(legendItem.data)\"\n          >\n            <div class=\"item-color\" [style.border-left-color]=\"legendItem.color\"></div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-value\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem._value\"\n              [valueFormatting]=\"valueFormatting\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-value\">\n              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}\n            </div>\n            <div class=\"item-label\">{{ legendItem.displayLabel }}</div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-percent\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem.percentage\"\n              [countSuffix]=\"'%'\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-percent\">{{ legendItem.percentage.toLocaleString() }}%</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{overflow:auto;white-space:nowrap}.advanced-pie-legend .legend-items-container .legend-items .legend-item{cursor:pointer;display:inline-block;margin-right:20px}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;margin-left:11px;margin-top:-6px;opacity:.7}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;margin-left:11px;opacity:.7}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;float:left;height:42px;margin-right:7px;width:4px}"]
            }]
    }], function () { return []; }, { label: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], labelFormatting: [{
            type: core.Input
        }], percentageFormatting: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }] }); })();
        return AdvancedLegendComponent;
    }());
    AdvancedLegendComponent.propDecorators = {
        width: [{ type: core.Input }],
        data: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        label: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        percentageFormatting: [{ type: core.Input }]
    };

    var COMPONENTS = [
        AreaComponent,
        BaseChartComponent,
        CountUpDirective,
        TooltipArea,
        ChartComponent,
        LegendComponent,
        LegendEntryComponent,
        ScaleLegendComponent,
        CircleComponent,
        CircleSeriesComponent,
        GridPanelComponent,
        GridPanelSeriesComponent,
        SvgLinearGradientComponent,
        SvgRadialGradientComponent,
        Timeline,
        AdvancedLegendComponent
    ];
    var ChartCommonModule = /** @class */ (function () {
        function ChartCommonModule() {
        }
ChartCommonModule.ɵfac = function ChartCommonModule_Factory(t) { return new (t || ChartCommonModule)(); };
ChartCommonModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ChartCommonModule });
ChartCommonModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[common.CommonModule, AxesModule, TooltipModule], ɵngcc1.CommonModule, AxesModule, TooltipModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartCommonModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, AxesModule, TooltipModule],
                declarations: __spread(COMPONENTS, [VisibilityObserver]),
                exports: __spread([common.CommonModule, AxesModule, TooltipModule], COMPONENTS, [VisibilityObserver])
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartCommonModule, { declarations: [AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent, VisibilityObserver], imports: [ɵngcc1.CommonModule, AxesModule, TooltipModule], exports: [ɵngcc1.CommonModule, AxesModule, TooltipModule, AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent, VisibilityObserver] }); })();
        return ChartCommonModule;
    }());

    function calculateViewDimensions(_a) {
        var width = _a.width, height = _a.height, margins = _a.margins, _b = _a.showXAxis, showXAxis = _b === void 0 ? false : _b, _c = _a.showYAxis, showYAxis = _c === void 0 ? false : _c, _d = _a.xAxisHeight, xAxisHeight = _d === void 0 ? 0 : _d, _e = _a.yAxisWidth, yAxisWidth = _e === void 0 ? 0 : _e, _f = _a.showXLabel, showXLabel = _f === void 0 ? false : _f, _g = _a.showYLabel, showYLabel = _g === void 0 ? false : _g, _h = _a.showLegend, showLegend = _h === void 0 ? false : _h, _j = _a.legendType, legendType = _j === void 0 ? 'ordinal' : _j, _k = _a.legendPosition, legendPosition = _k === void 0 ? 'right' : _k, _l = _a.columns, columns = _l === void 0 ? 12 : _l;
        var xOffset = margins[3];
        var chartWidth = width;
        var chartHeight = height - margins[0] - margins[2];
        if (showLegend && legendPosition === 'right') {
            if (legendType === 'ordinal') {
                columns -= 2;
            }
            else {
                columns -= 1;
            }
        }
        chartWidth = (chartWidth * columns) / 12;
        chartWidth = chartWidth - margins[1] - margins[3];
        if (showXAxis) {
            chartHeight -= 5;
            chartHeight -= xAxisHeight;
            if (showXLabel) {
                // text height + spacing between axis label and tick labels
                var offset = 25 + 5;
                chartHeight -= offset;
            }
        }
        if (showYAxis) {
            chartWidth -= 5;
            chartWidth -= yAxisWidth;
            xOffset += yAxisWidth;
            xOffset += 10;
            if (showYLabel) {
                // text height + spacing between axis label and tick labels
                var offset = 25 + 5;
                chartWidth -= offset;
                xOffset += offset;
            }
        }
        chartWidth = Math.max(0, chartWidth);
        chartHeight = Math.max(0, chartHeight);
        return {
            width: Math.floor(chartWidth),
            height: Math.floor(chartHeight),
            xOffset: Math.floor(xOffset)
        };
    }

    var colorSets = [
        {
            name: 'vivid',
            selectable: true,
            group: 'Ordinal',
            domain: [
                '#647c8a',
                '#3f51b5',
                '#2196f3',
                '#00b862',
                '#afdf0a',
                '#a7b61a',
                '#f3e562',
                '#ff9800',
                '#ff5722',
                '#ff4514'
            ]
        },
        {
            name: 'natural',
            selectable: true,
            group: 'Ordinal',
            domain: [
                '#bf9d76',
                '#e99450',
                '#d89f59',
                '#f2dfa7',
                '#a5d7c6',
                '#7794b1',
                '#afafaf',
                '#707160',
                '#ba9383',
                '#d9d5c3'
            ]
        },
        {
            name: 'cool',
            selectable: true,
            group: 'Ordinal',
            domain: [
                '#a8385d',
                '#7aa3e5',
                '#a27ea8',
                '#aae3f5',
                '#adcded',
                '#a95963',
                '#8796c0',
                '#7ed3ed',
                '#50abcc',
                '#ad6886'
            ]
        },
        {
            name: 'fire',
            selectable: true,
            group: 'Ordinal',
            domain: ['#ff3d00', '#bf360c', '#ff8f00', '#ff6f00', '#ff5722', '#e65100', '#ffca28', '#ffab00']
        },
        {
            name: 'solar',
            selectable: true,
            group: 'Continuous',
            domain: [
                '#fff8e1',
                '#ffecb3',
                '#ffe082',
                '#ffd54f',
                '#ffca28',
                '#ffc107',
                '#ffb300',
                '#ffa000',
                '#ff8f00',
                '#ff6f00'
            ]
        },
        {
            name: 'air',
            selectable: true,
            group: 'Continuous',
            domain: [
                '#e1f5fe',
                '#b3e5fc',
                '#81d4fa',
                '#4fc3f7',
                '#29b6f6',
                '#03a9f4',
                '#039be5',
                '#0288d1',
                '#0277bd',
                '#01579b'
            ]
        },
        {
            name: 'aqua',
            selectable: true,
            group: 'Continuous',
            domain: [
                '#e0f7fa',
                '#b2ebf2',
                '#80deea',
                '#4dd0e1',
                '#26c6da',
                '#00bcd4',
                '#00acc1',
                '#0097a7',
                '#00838f',
                '#006064'
            ]
        },
        {
            name: 'flame',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#A10A28',
                '#D3342D',
                '#EF6D49',
                '#FAAD67',
                '#FDDE90',
                '#DBED91',
                '#A9D770',
                '#6CBA67',
                '#2C9653',
                '#146738'
            ]
        },
        {
            name: 'ocean',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#1D68FB',
                '#33C0FC',
                '#4AFFFE',
                '#AFFFFF',
                '#FFFC63',
                '#FDBD2D',
                '#FC8A25',
                '#FA4F1E',
                '#FA141B',
                '#BA38D1'
            ]
        },
        {
            name: 'forest',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#55C22D',
                '#C1F33D',
                '#3CC099',
                '#AFFFFF',
                '#8CFC9D',
                '#76CFFA',
                '#BA60FB',
                '#EE6490',
                '#C42A1C',
                '#FC9F32'
            ]
        },
        {
            name: 'horizon',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#2597FB',
                '#65EBFD',
                '#99FDD0',
                '#FCEE4B',
                '#FEFCFA',
                '#FDD6E3',
                '#FCB1A8',
                '#EF6F7B',
                '#CB96E8',
                '#EFDEE0'
            ]
        },
        {
            name: 'neons',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#FF3333',
                '#FF33FF',
                '#CC33FF',
                '#0000FF',
                '#33CCFF',
                '#33FFFF',
                '#33FF66',
                '#CCFF33',
                '#FFCC00',
                '#FF6600'
            ]
        },
        {
            name: 'picnic',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#FAC51D',
                '#66BD6D',
                '#FAA026',
                '#29BB9C',
                '#E96B56',
                '#55ACD2',
                '#B7332F',
                '#2C83C9',
                '#9166B8',
                '#92E7E8'
            ]
        },
        {
            name: 'night',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#2B1B5A',
                '#501356',
                '#183356',
                '#28203F',
                '#391B3C',
                '#1E2B3C',
                '#120634',
                '#2D0432',
                '#051932',
                '#453080',
                '#75267D',
                '#2C507D',
                '#4B3880',
                '#752F7D',
                '#35547D'
            ]
        },
        {
            name: 'nightLights',
            selectable: false,
            group: 'Ordinal',
            domain: [
                '#4e31a5',
                '#9c25a7',
                '#3065ab',
                '#57468b',
                '#904497',
                '#46648b',
                '#32118d',
                '#a00fb3',
                '#1052a2',
                '#6e51bd',
                '#b63cc3',
                '#6c97cb',
                '#8671c1',
                '#b455be',
                '#7496c3'
            ]
        }
    ];

    var ColorHelper = /** @class */ (function () {
        function ColorHelper(scheme, type, domain, customColors) {
            if (typeof scheme === 'string') {
                scheme = colorSets.find(function (cs) {
                    return cs.name === scheme;
                });
            }
            this.colorDomain = scheme.domain;
            this.scaleType = type;
            this.domain = domain;
            this.customColors = customColors;
            this.scale = this.generateColorScheme(scheme, type, this.domain);
        }
        ColorHelper.prototype.generateColorScheme = function (scheme, type, domain) {
            if (typeof scheme === 'string') {
                scheme = colorSets.find(function (cs) {
                    return cs.name === scheme;
                });
            }
            var colorScale;
            if (type === 'quantile') {
                colorScale = d3Scale.scaleQuantile().range(scheme.domain).domain(domain);
            }
            else if (type === 'ordinal') {
                colorScale = d3Scale.scaleOrdinal().range(scheme.domain).domain(domain);
            }
            else if (type === 'linear') {
                // linear schemes must have at least 2 colors
                var colorDomain = __spread(scheme.domain);
                if (colorDomain.length === 1) {
                    colorDomain.push(colorDomain[0]);
                    this.colorDomain = colorDomain;
                }
                var points = d3Array.range(0, 1, 1.0 / colorDomain.length);
                colorScale = d3Scale.scaleLinear().domain(points).range(colorDomain);
            }
            return colorScale;
        };
        ColorHelper.prototype.getColor = function (value) {
            if (value === undefined || value === null) {
                throw new Error('Value can not be null');
            }
            if (this.scaleType === 'linear') {
                var valueScale = d3Scale.scaleLinear().domain(this.domain).range([0, 1]);
                return this.scale(valueScale(value));
            }
            else {
                if (typeof this.customColors === 'function') {
                    return this.customColors(value);
                }
                var formattedValue_1 = value.toString();
                var found = // todo type customColors
                 void 0; // todo type customColors
                if (this.customColors && this.customColors.length > 0) {
                    found = this.customColors.find(function (mapping) {
                        return mapping.name.toLowerCase() === formattedValue_1.toLowerCase();
                    });
                }
                if (found) {
                    return found.value;
                }
                else {
                    return this.scale(value);
                }
            }
        };
        ColorHelper.prototype.getLinearGradientStops = function (value, start) {
            var e_1, _a;
            if (start === undefined) {
                start = this.domain[0];
            }
            var valueScale = d3Scale.scaleLinear().domain(this.domain).range([0, 1]);
            var colorValueScale = d3Scale.scaleBand().domain(this.colorDomain).range([0, 1]);
            var endColor = this.getColor(value);
            // generate the stops
            var startVal = valueScale(start);
            var startColor = this.getColor(start);
            var endVal = valueScale(value);
            var i = 1;
            var currentVal = startVal;
            var stops = [];
            stops.push({
                color: startColor,
                offset: startVal,
                originalOffset: startVal,
                opacity: 1
            });
            while (currentVal < endVal && i < this.colorDomain.length) {
                var color = this.colorDomain[i];
                var offset = colorValueScale(color);
                if (offset <= startVal) {
                    i++;
                    continue;
                }
                if (offset.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
                    break;
                }
                stops.push({
                    color: color,
                    offset: offset,
                    opacity: 1
                });
                currentVal = offset;
                i++;
            }
            if (stops[stops.length - 1].offset < 100) {
                stops.push({
                    color: endColor,
                    offset: endVal,
                    opacity: 1
                });
            }
            if (endVal === startVal) {
                stops[0].offset = 0;
                stops[1].offset = 100;
            }
            else {
                // normalize the offsets into percentages
                if (stops[stops.length - 1].offset !== 100) {
                    try {
                        for (var stops_1 = __values(stops), stops_1_1 = stops_1.next(); !stops_1_1.done; stops_1_1 = stops_1.next()) {
                            var s = stops_1_1.value;
                            s.offset = ((s.offset - startVal) / (endVal - startVal)) * 100;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (stops_1_1 && !stops_1_1.done && (_a = stops_1.return)) _a.call(stops_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            return stops;
        };
        return ColorHelper;
    }());

    /**
     * Based on the data, return an array with unique values.
     *
     * @export
     * @returns array
     */
    function getUniqueXDomainValues(results) {
        var e_1, _a, e_2, _b;
        var valueSet = new Set();
        try {
            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                var result = results_1_1.value;
                try {
                    for (var _c = (e_2 = void 0, __values(result.series)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var d = _d.value;
                        valueSet.add(d.name);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Array.from(valueSet);
    }
    /**
     * Get the scaleType of enumerable of values.
     * @returns  'time', 'linear' or 'ordinal'
     */
    function getScaleType(values, checkDateType) {
        if (checkDateType === void 0) { checkDateType = true; }
        if (checkDateType) {
            var allDates = values.every(function (value) { return value instanceof Date; });
            if (allDates) {
                return 'time';
            }
        }
        var allNumbers = values.every(function (value) { return typeof value === 'number'; });
        if (allNumbers) {
            return 'linear';
        }
        return 'ordinal';
    }

    var AreaChartComponent = /** @class */ (function (_super) {
        __extends(AreaChartComponent, _super);
        function AreaChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.baseValue = 'auto';
            _this.showGridLines = true;
            _this.curve = d3Shape.curveLinear;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.tooltipDisabled = false;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.timelineHeight = 50;
            _this.timelinePadding = 10;
            return _this;
        }
        AreaChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.timeline) {
                this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
            }
            this.xDomain = this.getXDomain();
            if (this.filteredDomain) {
                this.xDomain = this.filteredDomain;
            }
            this.yDomain = this.getYDomain();
            this.seriesDomain = this.getSeriesDomain();
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
            this.yScale = this.getYScale(this.yDomain, this.dims.height);
            this.updateTimeline();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
            this.clipPathId = 'clip' + id().toString();
            this.clipPath = "url(#" + this.clipPathId + ")";
        };
        AreaChartComponent.prototype.updateTimeline = function () {
            if (this.timeline) {
                this.timelineWidth = this.dims.width;
                this.timelineXDomain = this.getXDomain();
                this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
                this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
                this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
            }
        };
        AreaChartComponent.prototype.getXDomain = function () {
            var values = getUniqueXDomainValues(this.results);
            this.scaleType = getScaleType(values);
            var domain = [];
            if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
            }
            var min;
            var max;
            if (this.scaleType === 'time' || this.scaleType === 'linear') {
                min = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, __spread(values));
                max = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, __spread(values));
            }
            if (this.scaleType === 'time') {
                domain = [new Date(min), new Date(max)];
                this.xSet = __spread(values).sort(function (a, b) {
                    var aDate = a.getTime();
                    var bDate = b.getTime();
                    if (aDate > bDate)
                        return 1;
                    if (bDate > aDate)
                        return -1;
                    return 0;
                });
            }
            else if (this.scaleType === 'linear') {
                domain = [min, max];
                // Use compare function to sort numbers numerically
                this.xSet = __spread(values).sort(function (a, b) { return a - b; });
            }
            else {
                domain = values;
                this.xSet = values;
            }
            return domain;
        };
        AreaChartComponent.prototype.getYDomain = function () {
            var e_1, _a, e_2, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.value)) {
                                domain.push(d.value);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var values = __spread(domain);
            if (!this.autoScale) {
                values.push(0);
            }
            if (this.baseValue !== 'auto') {
                values.push(this.baseValue);
            }
            var min = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, __spread(values));
            var max = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, __spread(values));
            return [min, max];
        };
        AreaChartComponent.prototype.getSeriesDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        AreaChartComponent.prototype.getXScale = function (domain, width) {
            var scale;
            if (this.scaleType === 'time') {
                scale = d3Scale.scaleTime();
            }
            else if (this.scaleType === 'linear') {
                scale = d3Scale.scaleLinear();
            }
            else if (this.scaleType === 'ordinal') {
                scale = d3Scale.scalePoint().padding(0.1);
            }
            scale.range([0, width]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartComponent.prototype.getYScale = function (domain, height) {
            var scale = d3Scale.scaleLinear().range([height, 0]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartComponent.prototype.getScaleType = function (values) {
            var e_3, _a;
            var date = true;
            var num = true;
            try {
                for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                    var value = values_1_1.value;
                    if (!this.isDate(value)) {
                        date = false;
                    }
                    if (typeof value !== 'number') {
                        num = false;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (date) {
                return 'time';
            }
            if (num) {
                return 'linear';
            }
            return 'ordinal';
        };
        AreaChartComponent.prototype.isDate = function (value) {
            if (value instanceof Date) {
                return true;
            }
            return false;
        };
        AreaChartComponent.prototype.updateDomain = function (domain) {
            this.filteredDomain = domain;
            this.xDomain = this.filteredDomain;
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
        };
        AreaChartComponent.prototype.updateHoveredVertical = function (item) {
            this.hoveredVertical = item.value;
            this.deactivateAll();
        };
        AreaChartComponent.prototype.hideCircles = function () {
            this.hoveredVertical = null;
            this.deactivateAll();
        };
        AreaChartComponent.prototype.onClick = function (data, series) {
            if (series) {
                data.series = series.name;
            }
            this.select.emit(data);
        };
        AreaChartComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        AreaChartComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.seriesDomain;
            }
            else {
                domain = this.yDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        AreaChartComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.seriesDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.yDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        AreaChartComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        AreaChartComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        AreaChartComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartComponent.prototype.deactivateAll = function () {
            var e_4, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.activeEntries = [];
        };
AreaChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵAreaChartComponent_BaseFactory; return function AreaChartComponent_Factory(t) { return (ɵAreaChartComponent_BaseFactory || (ɵAreaChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartComponent)))(t || AreaChartComponent); }; }();
AreaChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaChartComponent, selectors: [["ngx-charts-area-chart"]], contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", state: "state", xAxis: "xAxis", yAxis: "yAxis", baseValue: "baseValue", autoScale: "autoScale", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-area-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [baseValue]=\"baseValue\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [baseValue]=\"baseValue\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { hideCircles: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], baseValue: [{
            type: core.Input
        }], autoScale: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], timeline: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], xScaleMin: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], yScaleMin: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], seriesTooltipTemplate: [{
            type: core.ContentChild,
            args: ['seriesTooltipTemplate']
        }] }); })();
        return AreaChartComponent;
    }(BaseChartComponent));
    AreaChartComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        state: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        baseValue: [{ type: core.Input }],
        autoScale: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        timeline: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        xScaleMin: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        yScaleMin: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        seriesTooltipTemplate: [{ type: core.ContentChild, args: ['seriesTooltipTemplate',] }],
        hideCircles: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var AreaChartNormalizedComponent = /** @class */ (function (_super) {
        __extends(AreaChartNormalizedComponent, _super);
        function AreaChartNormalizedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.showGridLines = true;
            _this.curve = d3Shape.curveLinear;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.tooltipDisabled = false;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.timelineHeight = 50;
            _this.timelinePadding = 10;
            return _this;
        }
        AreaChartNormalizedComponent.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.timeline) {
                this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
            }
            this.xDomain = this.getXDomain();
            if (this.filteredDomain) {
                this.xDomain = this.filteredDomain;
            }
            this.yDomain = this.getYDomain();
            this.seriesDomain = this.getSeriesDomain();
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
            this.yScale = this.getYScale(this.yDomain, this.dims.height);
            var _loop_1 = function (i) {
                var e_1, _a, e_2, _b;
                var val = this_1.xSet[i];
                var d0 = 0;
                var total = 0;
                try {
                    for (var _c = (e_1 = void 0, __values(this_1.results)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var group = _d.value;
                        var d = group.series.find(function (item) {
                            var a = item.name;
                            var b = val;
                            if (_this.scaleType === 'time') {
                                a = a.valueOf();
                                b = b.valueOf();
                            }
                            return a === b;
                        });
                        if (d) {
                            total += d.value;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                try {
                    for (var _e = (e_2 = void 0, __values(this_1.results)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var group = _f.value;
                        var d = group.series.find(function (item) {
                            var a = item.name;
                            var b = val;
                            if (_this.scaleType === 'time') {
                                a = a.valueOf();
                                b = b.valueOf();
                            }
                            return a === b;
                        });
                        if (d) {
                            d.d0 = d0;
                            d.d1 = d0 + d.value;
                            d0 += d.value;
                        }
                        else {
                            d = {
                                name: val,
                                value: 0,
                                d0: d0,
                                d1: d0
                            };
                            group.series.push(d);
                        }
                        if (total > 0) {
                            d.d0 = (d.d0 * 100) / total;
                            d.d1 = (d.d1 * 100) / total;
                        }
                        else {
                            d.d0 = 0;
                            d.d1 = 0;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            };
            var this_1 = this;
            for (var i = 0; i < this.xSet.length; i++) {
                _loop_1(i);
            }
            this.updateTimeline();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
            this.clipPathId = 'clip' + id().toString();
            this.clipPath = "url(#" + this.clipPathId + ")";
        };
        AreaChartNormalizedComponent.prototype.updateTimeline = function () {
            if (this.timeline) {
                this.timelineWidth = this.dims.width;
                this.timelineXDomain = this.getXDomain();
                this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
                this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
                this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
            }
        };
        AreaChartNormalizedComponent.prototype.getXDomain = function () {
            var values = getUniqueXDomainValues(this.results);
            this.scaleType = getScaleType(values);
            var domain = [];
            if (this.scaleType === 'time') {
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                domain = [new Date(min), new Date(max)];
                this.xSet = __spread(values).sort(function (a, b) {
                    var aDate = a.getTime();
                    var bDate = b.getTime();
                    if (aDate > bDate)
                        return 1;
                    if (bDate > aDate)
                        return -1;
                    return 0;
                });
            }
            else if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                domain = [min, max];
                // Use compare function to sort numbers numerically
                this.xSet = __spread(values).sort(function (a, b) { return a - b; });
            }
            else {
                domain = values;
                this.xSet = values;
            }
            return domain;
        };
        AreaChartNormalizedComponent.prototype.getYDomain = function () {
            return [0, 100];
        };
        AreaChartNormalizedComponent.prototype.getSeriesDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        AreaChartNormalizedComponent.prototype.getXScale = function (domain, width) {
            var scale;
            if (this.scaleType === 'time') {
                scale = d3Scale.scaleTime();
            }
            else if (this.scaleType === 'linear') {
                scale = d3Scale.scaleLinear();
            }
            else if (this.scaleType === 'ordinal') {
                scale = d3Scale.scalePoint().padding(0.1);
            }
            scale.range([0, width]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartNormalizedComponent.prototype.getYScale = function (domain, height) {
            var scale = d3Scale.scaleLinear().range([height, 0]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartNormalizedComponent.prototype.updateDomain = function (domain) {
            this.filteredDomain = domain;
            this.xDomain = this.filteredDomain;
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
        };
        AreaChartNormalizedComponent.prototype.updateHoveredVertical = function (item) {
            this.hoveredVertical = item.value;
            this.deactivateAll();
        };
        AreaChartNormalizedComponent.prototype.hideCircles = function () {
            this.hoveredVertical = null;
            this.deactivateAll();
        };
        AreaChartNormalizedComponent.prototype.onClick = function (data, series) {
            if (series) {
                data.series = series.name;
            }
            this.select.emit(data);
        };
        AreaChartNormalizedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        AreaChartNormalizedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.seriesDomain;
            }
            else {
                domain = this.yDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        AreaChartNormalizedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.seriesDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.yDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        AreaChartNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        AreaChartNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        AreaChartNormalizedComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartNormalizedComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartNormalizedComponent.prototype.deactivateAll = function () {
            var e_3, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.activeEntries = [];
        };
AreaChartNormalizedComponent.ɵfac = /*@__PURE__*/ function () { var ɵAreaChartNormalizedComponent_BaseFactory; return function AreaChartNormalizedComponent_Factory(t) { return (ɵAreaChartNormalizedComponent_BaseFactory || (ɵAreaChartNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartNormalizedComponent)))(t || AreaChartNormalizedComponent); }; }();
AreaChartNormalizedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaChartNormalizedComponent, selectors: [["ngx-charts-area-chart-normalized"]], contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartNormalizedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-area-chart-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [activeEntries]=\"activeEntries\"\n              [gradient]=\"gradient\"\n              normalized=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [showPercentage]=\"true\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            normalized=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { hideCircles: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], timeline: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], seriesTooltipTemplate: [{
            type: core.ContentChild,
            args: ['seriesTooltipTemplate']
        }] }); })();
        return AreaChartNormalizedComponent;
    }(BaseChartComponent));
    AreaChartNormalizedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        timeline: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        seriesTooltipTemplate: [{ type: core.ContentChild, args: ['seriesTooltipTemplate',] }],
        hideCircles: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var AreaChartStackedComponent = /** @class */ (function (_super) {
        __extends(AreaChartStackedComponent, _super);
        function AreaChartStackedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.showGridLines = true;
            _this.curve = d3Shape.curveLinear;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.tooltipDisabled = false;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.timelineHeight = 50;
            _this.timelinePadding = 10;
            return _this;
        }
        AreaChartStackedComponent.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.timeline) {
                this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
            }
            this.xDomain = this.getXDomain();
            if (this.filteredDomain) {
                this.xDomain = this.filteredDomain;
            }
            this.yDomain = this.getYDomain();
            this.seriesDomain = this.getSeriesDomain();
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
            this.yScale = this.getYScale(this.yDomain, this.dims.height);
            var _loop_1 = function (i) {
                var e_1, _a;
                var val = this_1.xSet[i];
                var d0 = 0;
                try {
                    for (var _b = (e_1 = void 0, __values(this_1.results)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var group = _c.value;
                        var d = group.series.find(function (item) {
                            var a = item.name;
                            var b = val;
                            if (_this.scaleType === 'time') {
                                a = a.valueOf();
                                b = b.valueOf();
                            }
                            return a === b;
                        });
                        if (d) {
                            d.d0 = d0;
                            d.d1 = d0 + d.value;
                            d0 += d.value;
                        }
                        else {
                            d = {
                                name: val,
                                value: 0,
                                d0: d0,
                                d1: d0
                            };
                            group.series.push(d);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            };
            var this_1 = this;
            for (var i = 0; i < this.xSet.length; i++) {
                _loop_1(i);
            }
            this.updateTimeline();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
            this.clipPathId = 'clip' + id().toString();
            this.clipPath = "url(#" + this.clipPathId + ")";
        };
        AreaChartStackedComponent.prototype.updateTimeline = function () {
            if (this.timeline) {
                this.timelineWidth = this.dims.width;
                this.timelineXDomain = this.getXDomain();
                this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
                this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
                this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
            }
        };
        AreaChartStackedComponent.prototype.getXDomain = function () {
            var values = getUniqueXDomainValues(this.results);
            this.scaleType = getScaleType(values);
            var domain = [];
            if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
            }
            var min;
            var max;
            if (this.scaleType === 'time' || this.scaleType === 'linear') {
                min = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, __spread(values));
                max = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, __spread(values));
            }
            if (this.scaleType === 'time') {
                domain = [new Date(min), new Date(max)];
                this.xSet = __spread(values).sort(function (a, b) {
                    var aDate = a.getTime();
                    var bDate = b.getTime();
                    if (aDate > bDate)
                        return 1;
                    if (bDate > aDate)
                        return -1;
                    return 0;
                });
            }
            else if (this.scaleType === 'linear') {
                domain = [min, max];
                // Use compare function to sort numbers numerically
                this.xSet = __spread(values).sort(function (a, b) { return a - b; });
            }
            else {
                domain = values;
                this.xSet = values;
            }
            return domain;
        };
        AreaChartStackedComponent.prototype.getYDomain = function () {
            var _this = this;
            var domain = [];
            var _loop_2 = function (i) {
                var e_2, _a;
                var val = this_2.xSet[i];
                var sum = 0;
                try {
                    for (var _b = (e_2 = void 0, __values(this_2.results)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var group = _c.value;
                        var d = group.series.find(function (item) {
                            var a = item.name;
                            var b = val;
                            if (_this.scaleType === 'time') {
                                a = a.valueOf();
                                b = b.valueOf();
                            }
                            return a === b;
                        });
                        if (d) {
                            sum += d.value;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                domain.push(sum);
            };
            var this_2 = this;
            for (var i = 0; i < this.xSet.length; i++) {
                _loop_2(i);
            }
            var min = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, __spread([0], domain));
            var max = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, __spread(domain));
            return [min, max];
        };
        AreaChartStackedComponent.prototype.getSeriesDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        AreaChartStackedComponent.prototype.getXScale = function (domain, width) {
            var scale;
            if (this.scaleType === 'time') {
                scale = d3Scale.scaleTime();
            }
            else if (this.scaleType === 'linear') {
                scale = d3Scale.scaleLinear();
            }
            else if (this.scaleType === 'ordinal') {
                scale = d3Scale.scalePoint().padding(0.1);
            }
            scale.range([0, width]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartStackedComponent.prototype.getYScale = function (domain, height) {
            var scale = d3Scale.scaleLinear().range([height, 0]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        AreaChartStackedComponent.prototype.updateDomain = function (domain) {
            this.filteredDomain = domain;
            this.xDomain = this.filteredDomain;
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
        };
        AreaChartStackedComponent.prototype.updateHoveredVertical = function (item) {
            this.hoveredVertical = item.value;
            this.deactivateAll();
        };
        AreaChartStackedComponent.prototype.hideCircles = function () {
            this.hoveredVertical = null;
            this.deactivateAll();
        };
        AreaChartStackedComponent.prototype.onClick = function (data, series) {
            if (series) {
                data.series = series.name;
            }
            this.select.emit(data);
        };
        AreaChartStackedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        AreaChartStackedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.seriesDomain;
            }
            else {
                domain = this.yDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        AreaChartStackedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.seriesDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.yDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        AreaChartStackedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        AreaChartStackedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        AreaChartStackedComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartStackedComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        AreaChartStackedComponent.prototype.deactivateAll = function () {
            var e_3, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.activeEntries = [];
        };
AreaChartStackedComponent.ɵfac = /*@__PURE__*/ function () { var ɵAreaChartStackedComponent_BaseFactory; return function AreaChartStackedComponent_Factory(t) { return (ɵAreaChartStackedComponent_BaseFactory || (ɵAreaChartStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartStackedComponent)))(t || AreaChartStackedComponent); }; }();
AreaChartStackedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaChartStackedComponent, selectors: [["ngx-charts-area-chart-stacked"]], contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartStackedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartStackedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartStackedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartStackedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-area-chart-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [activeEntries]=\"activeEntries\"\n              stacked=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            stacked=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { hideCircles: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], timeline: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], xScaleMin: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], yScaleMin: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], seriesTooltipTemplate: [{
            type: core.ContentChild,
            args: ['seriesTooltipTemplate']
        }] }); })();
        return AreaChartStackedComponent;
    }(BaseChartComponent));
    AreaChartStackedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        timeline: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        xScaleMin: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        yScaleMin: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        seriesTooltipTemplate: [{ type: core.ContentChild, args: ['seriesTooltipTemplate',] }],
        hideCircles: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    function sortLinear(data, property, direction) {
        if (direction === void 0) { direction = 'asc'; }
        return data.sort(function (a, b) {
            if (direction === 'asc') {
                return a[property] - b[property];
            }
            else {
                return b[property] - a[property];
            }
        });
    }
    function sortByDomain(data, property, direction, domain) {
        if (direction === void 0) { direction = 'asc'; }
        return data.sort(function (a, b) {
            var aVal = a[property];
            var bVal = b[property];
            var aIdx = domain.indexOf(aVal);
            var bIdx = domain.indexOf(bVal);
            if (direction === 'asc') {
                return aIdx - bIdx;
            }
            else {
                return bIdx - aIdx;
            }
        });
    }
    function sortByTime(data, property, direction) {
        if (direction === void 0) { direction = 'asc'; }
        return data.sort(function (a, b) {
            var aDate = a[property].getTime();
            var bDate = b[property].getTime();
            if (direction === 'asc') {
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            }
            else {
                if (aDate > bDate)
                    return -1;
                if (bDate > aDate)
                    return 1;
                return 0;
            }
        });
    }

    var AreaSeriesComponent = /** @class */ (function () {
        function AreaSeriesComponent() {
            this.baseValue = 'auto';
            this.stacked = false;
            this.normalized = false;
            this.animations = true;
            this.select = new core.EventEmitter();
        }
        AreaSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        AreaSeriesComponent.prototype.update = function () {
            var _this = this;
            this.updateGradient();
            var currentArea;
            var startingArea;
            var xProperty = function (d) {
                var label = d.name;
                return _this.xScale(label);
            };
            if (this.stacked || this.normalized) {
                currentArea = d3Shape.area()
                    .x(xProperty)
                    .y0(function (d, i) { return _this.yScale(d.d0); })
                    .y1(function (d, i) { return _this.yScale(d.d1); });
                startingArea = d3Shape.area()
                    .x(xProperty)
                    .y0(function (d) { return _this.yScale.range()[0]; })
                    .y1(function (d) { return _this.yScale.range()[0]; });
            }
            else {
                currentArea = d3Shape.area()
                    .x(xProperty)
                    .y0(function () { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); })
                    .y1(function (d) { return _this.yScale(d.value); });
                startingArea = d3Shape.area()
                    .x(xProperty)
                    .y0(function (d) { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); })
                    .y1(function (d) { return (_this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue)); });
            }
            currentArea.curve(this.curve);
            startingArea.curve(this.curve);
            this.opacity = 0.8;
            var data = this.data.series;
            if (this.scaleType === 'linear') {
                data = sortLinear(data, 'name');
            }
            else if (this.scaleType === 'time') {
                data = sortByTime(data, 'name');
            }
            else {
                data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
            }
            this.path = currentArea(data);
            this.startingPath = startingArea(data);
        };
        AreaSeriesComponent.prototype.updateGradient = function () {
            if (this.colors.scaleType === 'linear') {
                this.hasGradient = true;
                if (this.stacked || this.normalized) {
                    var d0values = this.data.series.map(function (d) { return d.d0; });
                    var d1values = this.data.series.map(function (d) { return d.d1; });
                    var max = Math.max.apply(Math, __spread(d1values));
                    var min = Math.min.apply(Math, __spread(d0values));
                    this.gradientStops = this.colors.getLinearGradientStops(max, min);
                }
                else {
                    var values = this.data.series.map(function (d) { return d.value; });
                    var max = Math.max.apply(Math, __spread(values));
                    this.gradientStops = this.colors.getLinearGradientStops(max);
                }
            }
            else {
                this.hasGradient = false;
                this.gradientStops = undefined;
            }
        };
        AreaSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item !== undefined;
        };
        AreaSeriesComponent.prototype.isInactive = function (entry) {
            if (!this.activeEntries || this.activeEntries.length === 0)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item === undefined;
        };
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c25, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [AreaComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: "\n    <svg:g\n      ngx-charts-area\n      class=\"area-series\"\n      [data]=\"data\"\n      [path]=\"path\"\n      [fill]=\"colors.getColor(data.name)\"\n      [stops]=\"gradientStops\"\n      [startingPath]=\"startingPath\"\n      [opacity]=\"opacity\"\n      [gradient]=\"gradient || hasGradient\"\n      [animations]=\"animations\"\n      [class.active]=\"isActive(data)\"\n      [class.inactive]=\"isInactive(data)\"\n    />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: core.Input
        }], stacked: [{
            type: core.Input
        }], normalized: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }] }); })();
        return AreaSeriesComponent;
    }());
    AreaSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        baseValue: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        stacked: [{ type: core.Input }],
        normalized: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var AreaChartModule = /** @class */ (function () {
        function AreaChartModule() {
        }
AreaChartModule.ɵfac = function AreaChartModule_Factory(t) { return new (t || AreaChartModule)(); };
AreaChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: AreaChartModule });
AreaChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent],
                exports: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AreaChartModule, { declarations: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent], imports: [ChartCommonModule], exports: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent] }); })();
        return AreaChartModule;
    }());

    var BarComponent = /** @class */ (function () {
        function BarComponent(element) {
            this.roundEdges = true;
            this.gradient = false;
            this.offset = 0;
            this.isActive = false;
            this.animations = true;
            this.noBarWhenZero = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.hasGradient = false;
            this.hideBar = false;
            this.element = element.nativeElement;
        }
        BarComponent.prototype.ngOnChanges = function (changes) {
            if (changes.roundEdges) {
                this.loadAnimation();
            }
            this.update();
        };
        BarComponent.prototype.update = function () {
            this.gradientId = 'grad' + id().toString();
            this.gradientFill = "url(#" + this.gradientId + ")";
            if (this.gradient || this.stops) {
                this.gradientStops = this.getGradient();
                this.hasGradient = true;
            }
            else {
                this.hasGradient = false;
            }
            this.updatePathEl();
            this.checkToHideBar();
        };
        BarComponent.prototype.loadAnimation = function () {
            this.path = this.getStartingPath();
            setTimeout(this.update.bind(this), 100);
        };
        BarComponent.prototype.updatePathEl = function () {
            var node = d3Selection.select(this.element).select('.bar');
            var path = this.getPath();
            if (this.animations) {
                node.transition().duration(500).attr('d', path);
            }
            else {
                node.attr('d', path);
            }
        };
        BarComponent.prototype.getGradient = function () {
            if (this.stops) {
                return this.stops;
            }
            return [
                {
                    offset: 0,
                    color: this.fill,
                    opacity: this.getStartOpacity()
                },
                {
                    offset: 100,
                    color: this.fill,
                    opacity: 1
                }
            ];
        };
        BarComponent.prototype.getStartingPath = function () {
            if (!this.animations) {
                return this.getPath();
            }
            var radius = this.getRadius();
            var path;
            if (this.roundEdges) {
                if (this.orientation === 'vertical') {
                    radius = Math.min(this.height, radius);
                    path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
                }
                else if (this.orientation === 'horizontal') {
                    radius = Math.min(this.width, radius);
                    path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
                }
            }
            else {
                if (this.orientation === 'vertical') {
                    path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
                }
                else if (this.orientation === 'horizontal') {
                    path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
                }
            }
            return path;
        };
        BarComponent.prototype.getPath = function () {
            var radius = this.getRadius();
            var path;
            if (this.roundEdges) {
                if (this.orientation === 'vertical') {
                    radius = Math.min(this.height, radius);
                    path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
                }
                else if (this.orientation === 'horizontal') {
                    radius = Math.min(this.width, radius);
                    path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
                }
            }
            else {
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
            return path;
        };
        BarComponent.prototype.getRadius = function () {
            var radius = 0;
            if (this.roundEdges && this.height > 5 && this.width > 5) {
                radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
            }
            return radius;
        };
        BarComponent.prototype.getStartOpacity = function () {
            if (this.roundEdges) {
                return 0.2;
            }
            else {
                return 0.5;
            }
        };
        Object.defineProperty(BarComponent.prototype, "edges", {
            get: function () {
                var edges = [false, false, false, false];
                if (this.roundEdges) {
                    if (this.orientation === 'vertical') {
                        if (this.data.value > 0) {
                            edges = [true, true, false, false];
                        }
                        else {
                            edges = [false, false, true, true];
                        }
                    }
                    else if (this.orientation === 'horizontal') {
                        if (this.data.value > 0) {
                            edges = [false, true, false, true];
                        }
                        else {
                            edges = [true, false, true, false];
                        }
                    }
                }
                return edges;
            },
            enumerable: false,
            configurable: true
        });
        BarComponent.prototype.onMouseEnter = function () {
            this.activate.emit(this.data);
        };
        BarComponent.prototype.onMouseLeave = function () {
            this.deactivate.emit(this.data);
        };
        BarComponent.prototype.checkToHideBar = function () {
            this.hideBar =
                this.noBarWhenZero &&
                    ((this.orientation === 'vertical' && this.height === 0) ||
                        (this.orientation === 'horizontal' && this.width === 0));
        };
BarComponent.ɵfac = function BarComponent_Factory(t) { return new (t || BarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
BarComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarComponent, selectors: [["g", "ngx-charts-bar", ""]], hostBindings: function BarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { roundEdges: "roundEdges", gradient: "gradient", offset: "offset", isActive: "isActive", animations: "animations", noBarWhenZero: "noBarWhenZero", fill: "fill", data: "data", width: "width", height: "height", x: "x", y: "y", orientation: "orientation", stops: "stops", ariaLabel: "ariaLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c26, decls: 2, vars: 8, consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]], template: function BarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "path", 1);
        ɵngcc0.ɵɵlistener("click", function BarComponent_Template__svg_path_click_1_listener() { return ctx.select.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("hidden", ctx.hideBar);
        ɵngcc0.ɵɵattribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-bar]',
                template: "\n    <svg:defs *ngIf=\"hasGradient\">\n      <svg:g ngx-charts-svg-linear-gradient [orientation]=\"orientation\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path\n      class=\"bar\"\n      stroke=\"none\"\n      role=\"img\"\n      tabIndex=\"-1\"\n      [class.active]=\"isActive\"\n      [class.hidden]=\"hideBar\"\n      [attr.d]=\"path\"\n      [attr.aria-label]=\"ariaLabel\"\n      [attr.fill]=\"hasGradient ? gradientFill : fill\"\n      (click)=\"select.emit(data)\"\n    />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { roundEdges: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], offset: [{
            type: core.Input
        }], isActive: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], onMouseEnter: [{
            type: core.HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], x: [{
            type: core.Input
        }], y: [{
            type: core.Input
        }], orientation: [{
            type: core.Input
        }], stops: [{
            type: core.Input
        }], ariaLabel: [{
            type: core.Input
        }] }); })();
        return BarComponent;
    }());
    BarComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    BarComponent.propDecorators = {
        fill: [{ type: core.Input }],
        data: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        x: [{ type: core.Input }],
        y: [{ type: core.Input }],
        orientation: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        offset: [{ type: core.Input }],
        isActive: [{ type: core.Input }],
        stops: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        ariaLabel: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var BarHorizontalComponent = /** @class */ (function (_super) {
        __extends(BarHorizontalComponent, _super);
        function BarHorizontalComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.roundEdges = true;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            return _this;
        }
        BarHorizontalComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            }
            this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        BarHorizontalComponent.prototype.getXScale = function () {
            this.xDomain = this.getXDomain();
            var scale = d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.xDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarHorizontalComponent.prototype.getYScale = function () {
            this.yDomain = this.getYDomain();
            var spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.yDomain);
        };
        BarHorizontalComponent.prototype.getXDomain = function () {
            var values = this.results.map(function (d) { return d.value; });
            var min = this.xScaleMin ? Math.min.apply(Math, __spread([this.xScaleMin], values)) : Math.min.apply(Math, __spread([0], values));
            var max = this.xScaleMax ? Math.max.apply(Math, __spread([this.xScaleMax], values)) : Math.max.apply(Math, __spread([0], values));
            return [min, max];
        };
        BarHorizontalComponent.prototype.getYDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        BarHorizontalComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        BarHorizontalComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.yDomain;
            }
            else {
                domain = this.xDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarHorizontalComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.yDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.xDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarHorizontalComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarHorizontalComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarHorizontalComponent.prototype.onDataLabelMaxWidthChanged = function (event) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
            }
            else {
                this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
            }
            if (event.index === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarHorizontalComponent.prototype.onActivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarHorizontalComponent.prototype.onDeactivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarHorizontalComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarHorizontalComponent_BaseFactory; return function BarHorizontalComponent_Factory(t) { return (ɵBarHorizontalComponent_BaseFactory || (ɵBarHorizontalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalComponent)))(t || BarHorizontalComponent); }; }();
BarHorizontalComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalComponent, selectors: [["ngx-charts-bar-horizontal"]], contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", xScaleMin: "xScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"]], template: function BarHorizontalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("select", function BarHorizontalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function BarHorizontalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarHorizontalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("dataLabelWidthChanged", function BarHorizontalComponent_Template__svg_g_dataLabelWidthChanged_4_listener($event) { return ctx.onDataLabelMaxWidthChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesHorizontal, XAxisComponent, YAxisComponent]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-horizontal\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], xScaleMin: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarHorizontalComponent;
    }(BaseChartComponent));
    BarHorizontalComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        xScaleMin: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarHorizontal2DComponent = /** @class */ (function (_super) {
        __extends(BarHorizontal2DComponent, _super);
        function BarHorizontal2DComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.groupPadding = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.roundEdges = true;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            return _this;
        }
        BarHorizontal2DComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            }
            this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valuesDomain = this.getValueDomain();
            this.groupScale = this.getGroupScale();
            this.innerScale = this.getInnerScale();
            this.valueScale = this.getValueScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        BarHorizontal2DComponent.prototype.getGroupScale = function () {
            var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
            return d3Scale.scaleBand()
                .rangeRound([0, this.dims.height])
                .paddingInner(spacing)
                .paddingOuter(spacing / 2)
                .domain(this.groupDomain);
        };
        BarHorizontal2DComponent.prototype.getInnerScale = function () {
            var height = this.groupScale.bandwidth();
            var spacing = this.innerDomain.length / (height / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, height]).paddingInner(spacing).domain(this.innerDomain);
        };
        BarHorizontal2DComponent.prototype.getValueScale = function () {
            var scale = d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.valuesDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarHorizontal2DComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarHorizontal2DComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarHorizontal2DComponent.prototype.getValueDomain = function () {
            var e_4, _a, e_5, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_5 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.value)) {
                                domain.push(d.value);
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var min = Math.min.apply(Math, __spread([0], domain));
            var max = this.xScaleMax ? Math.max.apply(Math, __spread([this.xScaleMax], domain)) : Math.max.apply(Math, __spread([0], domain));
            return [min, max];
        };
        BarHorizontal2DComponent.prototype.groupTransform = function (group) {
            return "translate(0, " + this.groupScale(group.label) + ")";
        };
        BarHorizontal2DComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarHorizontal2DComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarHorizontal2DComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valuesDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarHorizontal2DComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valuesDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarHorizontal2DComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarHorizontal2DComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarHorizontal2DComponent.prototype.onDataLabelMaxWidthChanged = function (event, groupIndex) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
            }
            else {
                this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
            }
            if (groupIndex === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarHorizontal2DComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarHorizontal2DComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarHorizontal2DComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarHorizontal2DComponent_BaseFactory; return function BarHorizontal2DComponent_Factory(t) { return (ɵBarHorizontal2DComponent_BaseFactory || (ɵBarHorizontal2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontal2DComponent)))(t || BarHorizontal2DComponent); }; }();
BarHorizontal2DComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarHorizontal2DComponent, selectors: [["ngx-charts-bar-horizontal-2d"]], contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "horizontal", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", 3, "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontal2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontal2DComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"valueScale\"\n          [yScale]=\"groupScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"horizontal\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            [xScale]=\"valueScale\"\n            [activeEntries]=\"activeEntries\"\n            [yScale]=\"innerScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [roundEdges]=\"roundEdges\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], groupPadding: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarHorizontal2DComponent;
    }(BaseChartComponent));
    BarHorizontal2DComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        groupPadding: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarHorizontalNormalizedComponent = /** @class */ (function (_super) {
        __extends(BarHorizontalNormalizedComponent, _super);
        function BarHorizontalNormalizedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            return _this;
        }
        BarHorizontalNormalizedComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valueDomain = this.getValueDomain();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        BarHorizontalNormalizedComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarHorizontalNormalizedComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarHorizontalNormalizedComponent.prototype.getValueDomain = function () {
            return [0, 100];
        };
        BarHorizontalNormalizedComponent.prototype.getYScale = function () {
            var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
        };
        BarHorizontalNormalizedComponent.prototype.getXScale = function () {
            var scale = d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarHorizontalNormalizedComponent.prototype.groupTransform = function (group) {
            return "translate(0, " + this.yScale(group.name) + ")";
        };
        BarHorizontalNormalizedComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarHorizontalNormalizedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarHorizontalNormalizedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valueDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarHorizontalNormalizedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valueDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarHorizontalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarHorizontalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarHorizontalNormalizedComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarHorizontalNormalizedComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarHorizontalNormalizedComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarHorizontalNormalizedComponent_BaseFactory; return function BarHorizontalNormalizedComponent_Factory(t) { return (ɵBarHorizontalNormalizedComponent_BaseFactory || (ɵBarHorizontalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalNormalizedComponent)))(t || BarHorizontalNormalizedComponent); }; }();
BarHorizontalNormalizedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalNormalizedComponent, selectors: [["ngx-charts-bar-horizontal-normalized"]], contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarHorizontalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalNormalizedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarHorizontalNormalizedComponent;
    }(BaseChartComponent));
    BarHorizontalNormalizedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarHorizontalStackedComponent = /** @class */ (function (_super) {
        __extends(BarHorizontalStackedComponent, _super);
        function BarHorizontalStackedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            return _this;
        }
        BarHorizontalStackedComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxWidth = { negative: 0, positive: 0 };
            }
            this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valueDomain = this.getValueDomain();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        BarHorizontalStackedComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarHorizontalStackedComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarHorizontalStackedComponent.prototype.getValueDomain = function () {
            var e_4, _a, e_5, _b;
            var domain = [];
            var smallest = 0;
            var biggest = 0;
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    var smallestSum = 0;
                    var biggestSum = 0;
                    try {
                        for (var _e = (e_5 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (d.value < 0) {
                                smallestSum += d.value;
                            }
                            else {
                                biggestSum += d.value;
                            }
                            smallest = d.value < smallest ? d.value : smallest;
                            biggest = d.value > biggest ? d.value : biggest;
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    domain.push(smallestSum);
                    domain.push(biggestSum);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            domain.push(smallest);
            domain.push(biggest);
            var min = Math.min.apply(Math, __spread([0], domain));
            var max = this.xScaleMax ? Math.max.apply(Math, __spread([this.xScaleMax], domain)) : Math.max.apply(Math, __spread(domain));
            return [min, max];
        };
        BarHorizontalStackedComponent.prototype.getYScale = function () {
            var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
        };
        BarHorizontalStackedComponent.prototype.getXScale = function () {
            var scale = d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarHorizontalStackedComponent.prototype.groupTransform = function (group) {
            return "translate(0, " + this.yScale(group.name) + ")";
        };
        BarHorizontalStackedComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarHorizontalStackedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarHorizontalStackedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valueDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarHorizontalStackedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valueDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarHorizontalStackedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarHorizontalStackedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarHorizontalStackedComponent.prototype.onDataLabelMaxWidthChanged = function (event, groupIndex) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
            }
            else {
                this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
            }
            if (groupIndex === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarHorizontalStackedComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarHorizontalStackedComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarHorizontalStackedComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarHorizontalStackedComponent_BaseFactory; return function BarHorizontalStackedComponent_Factory(t) { return (ɵBarHorizontalStackedComponent_BaseFactory || (ɵBarHorizontalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalStackedComponent)))(t || BarHorizontalStackedComponent); }; }();
BarHorizontalStackedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalStackedComponent, selectors: [["ngx-charts-bar-horizontal-stacked"]], contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "stacked", 3, "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalStackedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [activeEntries]=\"activeEntries\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarHorizontalStackedComponent;
    }(BaseChartComponent));
    BarHorizontalStackedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarVerticalComponent = /** @class */ (function (_super) {
        __extends(BarVerticalComponent, _super);
        function BarVerticalComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.roundEdges = true;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            return _this;
        }
        BarVerticalComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            }
            this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            if (this.showDataLabel) {
                this.dims.height -= this.dataLabelMaxHeight.negative;
            }
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
        };
        BarVerticalComponent.prototype.getXScale = function () {
            this.xDomain = this.getXDomain();
            var spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
            return d3Scale.scaleBand().range([0, this.dims.width]).paddingInner(spacing).domain(this.xDomain);
        };
        BarVerticalComponent.prototype.getYScale = function () {
            this.yDomain = this.getYDomain();
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.yDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarVerticalComponent.prototype.getXDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        BarVerticalComponent.prototype.getYDomain = function () {
            var values = this.results.map(function (d) { return d.value; });
            var min = this.yScaleMin ? Math.min.apply(Math, __spread([this.yScaleMin], values)) : Math.min.apply(Math, __spread([0], values));
            if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
                min = Math.min.apply(Math, __spread([min], this.yAxisTicks));
            }
            var max = this.yScaleMax ? Math.max.apply(Math, __spread([this.yScaleMax], values)) : Math.max.apply(Math, __spread([0], values));
            if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
                max = Math.max.apply(Math, __spread([max], this.yAxisTicks));
            }
            return [min, max];
        };
        BarVerticalComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        BarVerticalComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.xDomain;
            }
            else {
                domain = this.yDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarVerticalComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.xDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.yDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarVerticalComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarVerticalComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarVerticalComponent.prototype.onDataLabelMaxHeightChanged = function (event) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
            }
            else {
                this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
            }
            if (event.index === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarVerticalComponent.prototype.onActivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarVerticalComponent.prototype.onDeactivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarVerticalComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarVerticalComponent_BaseFactory; return function BarVerticalComponent_Factory(t) { return (ɵBarVerticalComponent_BaseFactory || (ɵBarVerticalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalComponent)))(t || BarVerticalComponent); }; }();
BarVerticalComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarVerticalComponent, selectors: [["ngx-charts-bar-vertical"]], contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", yScaleMin: "yScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero", "activate", "deactivate", "select", "dataLabelHeightChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function BarVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("activate", function BarVerticalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarVerticalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("select", function BarVerticalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("dataLabelHeightChanged", function BarVerticalComponent_Template__svg_g_dataLabelHeightChanged_4_listener($event) { return ctx.onDataLabelMaxHeightChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesVerticalComponent, XAxisComponent, YAxisComponent]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-vertical',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (select)=\"onClick($event)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], yScaleMin: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarVerticalComponent;
    }(BaseChartComponent));
    BarVerticalComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        yScaleMin: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarVertical2DComponent = /** @class */ (function (_super) {
        __extends(BarVertical2DComponent, _super);
        function BarVertical2DComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.scaleType = 'ordinal';
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.groupPadding = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.roundEdges = true;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            return _this;
        }
        BarVertical2DComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            }
            this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.showDataLabel) {
                this.dims.height -= this.dataLabelMaxHeight.negative;
            }
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valuesDomain = this.getValueDomain();
            this.groupScale = this.getGroupScale();
            this.innerScale = this.getInnerScale();
            this.valueScale = this.getValueScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
        };
        BarVertical2DComponent.prototype.onDataLabelMaxHeightChanged = function (event, groupIndex) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
            }
            else {
                this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
            }
            if (groupIndex === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarVertical2DComponent.prototype.getGroupScale = function () {
            var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
            return d3Scale.scaleBand()
                .rangeRound([0, this.dims.width])
                .paddingInner(spacing)
                .paddingOuter(spacing / 2)
                .domain(this.groupDomain);
        };
        BarVertical2DComponent.prototype.getInnerScale = function () {
            var width = this.groupScale.bandwidth();
            var spacing = this.innerDomain.length / (width / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, width]).paddingInner(spacing).domain(this.innerDomain);
        };
        BarVertical2DComponent.prototype.getValueScale = function () {
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.valuesDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarVertical2DComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarVertical2DComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarVertical2DComponent.prototype.getValueDomain = function () {
            var e_4, _a, e_5, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_5 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.value)) {
                                domain.push(d.value);
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var min = Math.min.apply(Math, __spread([0], domain));
            var max = this.yScaleMax ? Math.max.apply(Math, __spread([this.yScaleMax], domain)) : Math.max.apply(Math, __spread([0], domain));
            return [min, max];
        };
        BarVertical2DComponent.prototype.groupTransform = function (group) {
            return "translate(" + this.groupScale(group.label) + ", 0)";
        };
        BarVertical2DComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarVertical2DComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarVertical2DComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valuesDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarVertical2DComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valuesDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarVertical2DComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarVertical2DComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarVertical2DComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarVertical2DComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarVertical2DComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarVertical2DComponent_BaseFactory; return function BarVertical2DComponent_Factory(t) { return (ɵBarVertical2DComponent_BaseFactory || (ɵBarVertical2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVertical2DComponent)))(t || BarVertical2DComponent); }; }();
BarVertical2DComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarVertical2DComponent, selectors: [["ngx-charts-bar-vertical-2d"]], contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", scaleType: "scaleType", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "vertical", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVertical2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVertical2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVertical2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarVertical2DComponent__svg_g_5_Template, 1, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVertical2DComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"groupScale\"\n          [yScale]=\"valueScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"vertical\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n          [activeEntries]=\"activeEntries\"\n          [xScale]=\"innerScale\"\n          [yScale]=\"valueScale\"\n          [colors]=\"colors\"\n          [series]=\"group.series\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [seriesName]=\"group.name\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event, group)\"\n          (activate)=\"onActivate($event, group)\"\n          (deactivate)=\"onDeactivate($event, group)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], groupPadding: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarVertical2DComponent;
    }(BaseChartComponent));
    BarVertical2DComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        groupPadding: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarVerticalNormalizedComponent = /** @class */ (function (_super) {
        __extends(BarVerticalNormalizedComponent, _super);
        function BarVerticalNormalizedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            return _this;
        }
        BarVerticalNormalizedComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valueDomain = this.getValueDomain();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        BarVerticalNormalizedComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarVerticalNormalizedComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarVerticalNormalizedComponent.prototype.getValueDomain = function () {
            return [0, 100];
        };
        BarVerticalNormalizedComponent.prototype.getXScale = function () {
            var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
        };
        BarVerticalNormalizedComponent.prototype.getYScale = function () {
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarVerticalNormalizedComponent.prototype.groupTransform = function (group) {
            return "translate(" + this.xScale(group.name) + ", 0)";
        };
        BarVerticalNormalizedComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarVerticalNormalizedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarVerticalNormalizedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valueDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarVerticalNormalizedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valueDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarVerticalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarVerticalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarVerticalNormalizedComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarVerticalNormalizedComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarVerticalNormalizedComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarVerticalNormalizedComponent_BaseFactory; return function BarVerticalNormalizedComponent_Factory(t) { return (ɵBarVerticalNormalizedComponent_BaseFactory || (ɵBarVerticalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalNormalizedComponent)))(t || BarVerticalNormalizedComponent); }; }();
BarVerticalNormalizedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarVerticalNormalizedComponent, selectors: [["ngx-charts-bar-vertical-normalized"]], contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarVerticalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalNormalizedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarVerticalNormalizedComponent;
    }(BaseChartComponent));
    BarVerticalNormalizedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var BarVerticalStackedComponent = /** @class */ (function (_super) {
        __extends(BarVerticalStackedComponent, _super);
        function BarVerticalStackedComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.tooltipDisabled = false;
            _this.showGridLines = true;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.barPadding = 8;
            _this.roundDomains = false;
            _this.showDataLabel = false;
            _this.noBarWhenZero = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            return _this;
        }
        BarVerticalStackedComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            }
            this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.showDataLabel) {
                this.dims.height -= this.dataLabelMaxHeight.negative;
            }
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.valueDomain = this.getValueDomain();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
        };
        BarVerticalStackedComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.label)) {
                        domain.push(group.label);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        BarVerticalStackedComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.label)) {
                                domain.push(d.label);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        BarVerticalStackedComponent.prototype.getValueDomain = function () {
            var e_4, _a, e_5, _b;
            var domain = [];
            var smallest = 0;
            var biggest = 0;
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    var smallestSum = 0;
                    var biggestSum = 0;
                    try {
                        for (var _e = (e_5 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (d.value < 0) {
                                smallestSum += d.value;
                            }
                            else {
                                biggestSum += d.value;
                            }
                            smallest = d.value < smallest ? d.value : smallest;
                            biggest = d.value > biggest ? d.value : biggest;
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    domain.push(smallestSum);
                    domain.push(biggestSum);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            domain.push(smallest);
            domain.push(biggest);
            var min = Math.min.apply(Math, __spread([0], domain));
            var max = this.yScaleMax ? Math.max.apply(Math, __spread([this.yScaleMax], domain)) : Math.max.apply(Math, __spread(domain));
            return [min, max];
        };
        BarVerticalStackedComponent.prototype.getXScale = function () {
            var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
        };
        BarVerticalStackedComponent.prototype.getYScale = function () {
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BarVerticalStackedComponent.prototype.onDataLabelMaxHeightChanged = function (event, groupIndex) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
            }
            else {
                this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
            }
            if (groupIndex === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        BarVerticalStackedComponent.prototype.groupTransform = function (group) {
            return "translate(" + (this.xScale(group.name) || 0) + ", 0)";
        };
        BarVerticalStackedComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        BarVerticalStackedComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        BarVerticalStackedComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.innerDomain;
            }
            else {
                domain = this.valueDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        BarVerticalStackedComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valueDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BarVerticalStackedComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BarVerticalStackedComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BarVerticalStackedComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BarVerticalStackedComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
BarVerticalStackedComponent.ɵfac = /*@__PURE__*/ function () { var ɵBarVerticalStackedComponent_BaseFactory; return function BarVerticalStackedComponent_Factory(t) { return (ɵBarVerticalStackedComponent_BaseFactory || (ɵBarVerticalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalStackedComponent)))(t || BarVerticalStackedComponent); }; }();
BarVerticalStackedComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarVerticalStackedComponent, selectors: [["ngx-charts-bar-vertical-stacked"]], contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "stacked", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVerticalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalStackedComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], barPadding: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BarVerticalStackedComponent;
    }(BaseChartComponent));
    BarVerticalStackedComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        barPadding: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    (function (D0Types) {
        D0Types["positive"] = "positive";
        D0Types["negative"] = "negative";
    })(exports.D0Types || (exports.D0Types = {}));
    var SeriesVerticalComponent = /** @class */ (function () {
        function SeriesVerticalComponent() {
            this.type = 'standard';
            this.tooltipDisabled = false;
            this.animations = true;
            this.showDataLabel = false;
            this.noBarWhenZero = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.dataLabelHeightChanged = new core.EventEmitter();
            this.barsForDataLabels = [];
        }
        SeriesVerticalComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        SeriesVerticalComponent.prototype.update = function () {
            var _a;
            var _this = this;
            this.updateTooltipSettings();
            var width;
            if (this.series.length) {
                width = this.xScale.bandwidth();
            }
            width = Math.round(width);
            var yScaleMin = Math.max(this.yScale.domain()[0], 0);
            var d0 = (_a = {},
                _a[exports.D0Types.positive] = 0,
                _a[exports.D0Types.negative] = 0,
                _a);
            var d0Type = exports.D0Types.positive;
            var total;
            if (this.type === 'normalized') {
                total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
            }
            this.bars = this.series.map(function (d, index) {
                var value = d.value;
                var label = _this.getLabel(d);
                var formattedLabel = formatLabel(label);
                var roundEdges = _this.roundEdges;
                d0Type = value > 0 ? exports.D0Types.positive : exports.D0Types.negative;
                var bar = {
                    value: value,
                    label: label,
                    roundEdges: roundEdges,
                    data: d,
                    width: width,
                    formattedLabel: formattedLabel,
                    height: 0,
                    x: 0,
                    y: 0
                };
                if (_this.type === 'standard') {
                    bar.height = Math.abs(_this.yScale(value) - _this.yScale(yScaleMin));
                    bar.x = _this.xScale(label);
                    if (value < 0) {
                        bar.y = _this.yScale(0);
                    }
                    else {
                        bar.y = _this.yScale(value);
                    }
                }
                else if (_this.type === 'stacked') {
                    var offset0 = d0[d0Type];
                    var offset1 = offset0 + value;
                    d0[d0Type] += value;
                    bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                    bar.x = 0;
                    bar.y = _this.yScale(offset1);
                    bar.offset0 = offset0;
                    bar.offset1 = offset1;
                }
                else if (_this.type === 'normalized') {
                    var offset0 = d0[d0Type];
                    var offset1 = offset0 + value;
                    d0[d0Type] += value;
                    if (total > 0) {
                        offset0 = (offset0 * 100) / total;
                        offset1 = (offset1 * 100) / total;
                    }
                    else {
                        offset0 = 0;
                        offset1 = 0;
                    }
                    bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                    bar.x = 0;
                    bar.y = _this.yScale(offset1);
                    bar.offset0 = offset0;
                    bar.offset1 = offset1;
                    value = (offset1 - offset0).toFixed(2) + '%';
                }
                if (_this.colors.scaleType === 'ordinal') {
                    bar.color = _this.colors.getColor(label);
                }
                else {
                    if (_this.type === 'standard') {
                        bar.color = _this.colors.getColor(value);
                        bar.gradientStops = _this.colors.getLinearGradientStops(value);
                    }
                    else {
                        bar.color = _this.colors.getColor(bar.offset1);
                        bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                    }
                }
                var tooltipLabel = formattedLabel;
                bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
                if (_this.seriesName) {
                    tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                    bar.data.series = _this.seriesName;
                    bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
                }
                bar.tooltipText = _this.tooltipDisabled
                    ? undefined
                    : "\n        <span class=\"tooltip-label\">" + escapeLabel(tooltipLabel) + "</span>\n        <span class=\"tooltip-val\">" + (_this.dataLabelFormatting ? _this.dataLabelFormatting(value) : value.toLocaleString()) + "</span>\n      ";
                return bar;
            });
            this.updateDataLabels();
        };
        SeriesVerticalComponent.prototype.updateDataLabels = function () {
            var _this = this;
            if (this.type === 'stacked') {
                this.barsForDataLabels = [];
                var section = {};
                section.series = this.seriesName;
                var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
                var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
                section.total = totalPositive + totalNegative;
                section.x = 0;
                section.y = 0;
                if (section.total > 0) {
                    section.height = this.yScale(totalPositive);
                }
                else {
                    section.height = this.yScale(totalNegative);
                }
                section.width = this.xScale.bandwidth();
                this.barsForDataLabels.push(section);
            }
            else {
                this.barsForDataLabels = this.series.map(function (d) {
                    var section = {};
                    section.series = _this.seriesName ? _this.seriesName : d.label;
                    section.total = d.value;
                    section.x = _this.xScale(d.label);
                    section.y = _this.yScale(0);
                    section.height = _this.yScale(section.total) - _this.yScale(0);
                    section.width = _this.xScale.bandwidth();
                    return section;
                });
            }
        };
        SeriesVerticalComponent.prototype.updateTooltipSettings = function () {
            this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
            this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
        };
        SeriesVerticalComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name && entry.series === d.series;
            });
            return item !== undefined;
        };
        SeriesVerticalComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        SeriesVerticalComponent.prototype.getLabel = function (dataItem) {
            if (dataItem.label) {
                return dataItem.label;
            }
            return dataItem.name;
        };
        SeriesVerticalComponent.prototype.trackBy = function (index, bar) {
            return bar.label;
        };
        SeriesVerticalComponent.prototype.trackDataLabelBy = function (index, barLabel) {
            return index + '#' + barLabel.series + '#' + barLabel.total;
        };
SeriesVerticalComponent.ɵfac = function SeriesVerticalComponent_Factory(t) { return new (t || SeriesVerticalComponent)(); };
SeriesVerticalComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SeriesVerticalComponent, selectors: [["g", "ngx-charts-series-vertical", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c27, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesVerticalComponent__svg_g_0_Template, 1, 22, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent, TooltipDirective, BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1
                    }),
                    animations.animate(500, animations.style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesVerticalComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-series-vertical]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'vertical'\"\n      [roundEdges]=\"bar.roundEdges\"\n      [gradient]=\"gradient\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [isActive]=\"isActive(bar.data)\"\n      (select)=\"onClick($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n      [animations]=\"animations\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'vertical'\"\n        (dimensionsChanged)=\"dataLabelHeightChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1
                            }),
                            animations.animate(500, animations.style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], dataLabelHeightChanged: [{
            type: core.Output
        }], dims: [{
            type: core.Input
        }], series: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], seriesName: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }] }); })();
        return SeriesVerticalComponent;
    }());
    SeriesVerticalComponent.propDecorators = {
        dims: [{ type: core.Input }],
        type: [{ type: core.Input }],
        series: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        seriesName: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        dataLabelHeightChanged: [{ type: core.Output }]
    };

    var SeriesHorizontal = /** @class */ (function () {
        function SeriesHorizontal() {
            this.barsForDataLabels = [];
            this.type = 'standard';
            this.tooltipDisabled = false;
            this.animations = true;
            this.showDataLabel = false;
            this.noBarWhenZero = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.dataLabelWidthChanged = new core.EventEmitter();
        }
        SeriesHorizontal.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        SeriesHorizontal.prototype.update = function () {
            var _a;
            var _this = this;
            this.updateTooltipSettings();
            var d0 = (_a = {},
                _a[exports.D0Types.positive] = 0,
                _a[exports.D0Types.negative] = 0,
                _a);
            var d0Type;
            d0Type = exports.D0Types.positive;
            var total;
            if (this.type === 'normalized') {
                total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
            }
            var xScaleMin = Math.max(this.xScale.domain()[0], 0);
            this.bars = this.series.map(function (d, index) {
                var value = d.value;
                var label = _this.getLabel(d);
                var formattedLabel = formatLabel(label);
                var roundEdges = _this.roundEdges;
                d0Type = value > 0 ? exports.D0Types.positive : exports.D0Types.negative;
                var bar = {
                    value: value,
                    label: label,
                    roundEdges: roundEdges,
                    data: d,
                    formattedLabel: formattedLabel
                };
                bar.height = _this.yScale.bandwidth();
                if (_this.type === 'standard') {
                    bar.width = Math.abs(_this.xScale(value) - _this.xScale(xScaleMin));
                    if (value < 0) {
                        bar.x = _this.xScale(value);
                    }
                    else {
                        bar.x = _this.xScale(xScaleMin);
                    }
                    bar.y = _this.yScale(label);
                }
                else if (_this.type === 'stacked') {
                    var offset0 = d0[d0Type];
                    var offset1 = offset0 + value;
                    d0[d0Type] += value;
                    bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                    bar.x = _this.xScale(offset0);
                    bar.y = 0;
                    bar.offset0 = offset0;
                    bar.offset1 = offset1;
                }
                else if (_this.type === 'normalized') {
                    var offset0 = d0[d0Type];
                    var offset1 = offset0 + value;
                    d0[d0Type] += value;
                    if (total > 0) {
                        offset0 = (offset0 * 100) / total;
                        offset1 = (offset1 * 100) / total;
                    }
                    else {
                        offset0 = 0;
                        offset1 = 0;
                    }
                    bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                    bar.x = _this.xScale(offset0);
                    bar.y = 0;
                    bar.offset0 = offset0;
                    bar.offset1 = offset1;
                    value = (offset1 - offset0).toFixed(2) + '%';
                }
                if (_this.colors.scaleType === 'ordinal') {
                    bar.color = _this.colors.getColor(label);
                }
                else {
                    if (_this.type === 'standard') {
                        bar.color = _this.colors.getColor(value);
                        bar.gradientStops = _this.colors.getLinearGradientStops(value);
                    }
                    else {
                        bar.color = _this.colors.getColor(bar.offset1);
                        bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                    }
                }
                var tooltipLabel = formattedLabel;
                bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
                if (_this.seriesName) {
                    tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                    bar.data.series = _this.seriesName;
                    bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
                }
                bar.tooltipText = _this.tooltipDisabled
                    ? undefined
                    : "\n        <span class=\"tooltip-label\">" + escapeLabel(tooltipLabel) + "</span>\n        <span class=\"tooltip-val\">" + (_this.dataLabelFormatting ? _this.dataLabelFormatting(value) : value.toLocaleString()) + "</span>\n      ";
                return bar;
            });
            this.updateDataLabels();
        };
        SeriesHorizontal.prototype.updateDataLabels = function () {
            var _this = this;
            if (this.type === 'stacked') {
                this.barsForDataLabels = [];
                var section = {};
                section.series = this.seriesName;
                var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
                var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
                section.total = totalPositive + totalNegative;
                section.x = 0;
                section.y = 0;
                // if total is positive then we show it on the right, otherwise on the left
                if (section.total > 0) {
                    section.width = this.xScale(totalPositive);
                }
                else {
                    section.width = this.xScale(totalNegative);
                }
                section.height = this.yScale.bandwidth();
                this.barsForDataLabels.push(section);
            }
            else {
                this.barsForDataLabels = this.series.map(function (d) {
                    var section = {};
                    section.series = _this.seriesName ? _this.seriesName : d.label;
                    section.total = d.value;
                    section.x = _this.xScale(0);
                    section.y = _this.yScale(d.label);
                    section.width = _this.xScale(section.total) - _this.xScale(0);
                    section.height = _this.yScale.bandwidth();
                    return section;
                });
            }
        };
        SeriesHorizontal.prototype.updateTooltipSettings = function () {
            this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
            this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
        };
        SeriesHorizontal.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name && entry.series === d.series;
            });
            return item !== undefined;
        };
        SeriesHorizontal.prototype.getLabel = function (dataItem) {
            if (dataItem.label) {
                return dataItem.label;
            }
            return dataItem.name;
        };
        SeriesHorizontal.prototype.trackBy = function (index, bar) {
            return bar.label;
        };
        SeriesHorizontal.prototype.trackDataLabelBy = function (index, barLabel) {
            return index + '#' + barLabel.series + '#' + barLabel.total;
        };
        SeriesHorizontal.prototype.click = function (data) {
            this.select.emit(data);
        };
SeriesHorizontal.ɵfac = function SeriesHorizontal_Factory(t) { return new (t || SeriesHorizontal)(); };
SeriesHorizontal.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SeriesHorizontal, selectors: [["g", "ngx-charts-series-horizontal", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelWidthChanged: "dataLabelWidthChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c28, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesHorizontal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent, TooltipDirective, BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1
                    }),
                    animations.animate(500, animations.style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesHorizontal, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-series-horizontal]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'horizontal'\"\n      [roundEdges]=\"bar.roundEdges\"\n      (select)=\"click($event)\"\n      [gradient]=\"gradient\"\n      [isActive]=\"isActive(bar.data)\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [animations]=\"animations\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'horizontal'\"\n        (dimensionsChanged)=\"dataLabelWidthChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1
                            }),
                            animations.animate(500, animations.style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], showDataLabel: [{
            type: core.Input
        }], noBarWhenZero: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], dataLabelWidthChanged: [{
            type: core.Output
        }], dims: [{
            type: core.Input
        }], series: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], seriesName: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }], roundEdges: [{
            type: core.Input
        }], dataLabelFormatting: [{
            type: core.Input
        }] }); })();
        return SeriesHorizontal;
    }());
    SeriesHorizontal.propDecorators = {
        dims: [{ type: core.Input }],
        type: [{ type: core.Input }],
        series: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        seriesName: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        roundEdges: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        showDataLabel: [{ type: core.Input }],
        dataLabelFormatting: [{ type: core.Input }],
        noBarWhenZero: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        dataLabelWidthChanged: [{ type: core.Output }]
    };

    var BarLabelComponent = /** @class */ (function () {
        function BarLabelComponent(element) {
            this.dimensionsChanged = new core.EventEmitter();
            this.horizontalPadding = 2;
            this.verticalPadding = 5;
            this.element = element.nativeElement;
        }
        BarLabelComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        BarLabelComponent.prototype.getSize = function () {
            var h = this.element.getBoundingClientRect().height;
            var w = this.element.getBoundingClientRect().width;
            return { height: h, width: w, negative: this.value < 0 };
        };
        BarLabelComponent.prototype.ngAfterViewInit = function () {
            this.dimensionsChanged.emit(this.getSize());
        };
        BarLabelComponent.prototype.update = function () {
            if (this.valueFormatting) {
                this.formatedValue = this.valueFormatting(this.value);
            }
            else {
                this.formatedValue = formatLabel(this.value);
            }
            if (this.orientation === 'horizontal') {
                this.x = this.barX + this.barWidth;
                // if the value is negative then it's on the left of the x0.
                // we need to put the data label in front of the bar
                if (this.value < 0) {
                    this.x = this.x - this.horizontalPadding;
                    this.textAnchor = 'end';
                }
                else {
                    this.x = this.x + this.horizontalPadding;
                    this.textAnchor = 'start';
                }
                this.y = this.barY + this.barHeight / 2;
            }
            else {
                // orientation must be "vertical"
                this.x = this.barX + this.barWidth / 2;
                this.y = this.barY + this.barHeight;
                if (this.value < 0) {
                    this.y = this.y + this.verticalPadding;
                    this.textAnchor = 'end';
                }
                else {
                    this.y = this.y - this.verticalPadding;
                    this.textAnchor = 'start';
                }
                this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
            }
        };
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
BarLabelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c29, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "\n    <svg:text\n      class=\"textDataLabel\"\n      alignment-baseline=\"middle\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n    >\n      {{ formatedValue }}\n    </svg:text>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".textDataLabel{font-size:11px}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { dimensionsChanged: [{
            type: core.Output
        }], value: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], barX: [{
            type: core.Input
        }], barY: [{
            type: core.Input
        }], barWidth: [{
            type: core.Input
        }], barHeight: [{
            type: core.Input
        }], orientation: [{
            type: core.Input
        }] }); })();
        return BarLabelComponent;
    }());
    BarLabelComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    BarLabelComponent.propDecorators = {
        value: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        barX: [{ type: core.Input }],
        barY: [{ type: core.Input }],
        barWidth: [{ type: core.Input }],
        barHeight: [{ type: core.Input }],
        orientation: [{ type: core.Input }],
        dimensionsChanged: [{ type: core.Output }]
    };

    var BarChartModule = /** @class */ (function () {
        function BarChartModule() {
        }
BarChartModule.ɵfac = function BarChartModule_Factory(t) { return new (t || BarChartModule)(); };
BarChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BarChartModule });
BarChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ],
                exports: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BarChartModule, { declarations: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent], imports: [ChartCommonModule], exports: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent] }); })();
        return BarChartModule;
    }());

    function getDomain(values, scaleType, autoScale, minVal, maxVal) {
        var domain = [];
        if (scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            if (!autoScale) {
                values.push(0);
            }
        }
        if (scaleType === 'time' || scaleType === 'linear') {
            var min = minVal ? minVal : Math.min.apply(Math, __spread(values));
            var max = maxVal ? maxVal : Math.max.apply(Math, __spread(values));
            domain = [min, max];
        }
        else {
            domain = values;
        }
        return domain;
    }
    function getScale(domain, range, scaleType, roundDomains) {
        var scale;
        if (scaleType === 'time') {
            scale = d3Scale.scaleTime().range(range).domain(domain);
        }
        else if (scaleType === 'linear') {
            scale = d3Scale.scaleLinear().range(range).domain(domain);
            if (roundDomains) {
                scale = scale.nice();
            }
        }
        else if (scaleType === 'ordinal') {
            scale = d3Scale.scalePoint().range([range[0], range[1]]).domain(domain);
        }
        return scale;
    }

    var BubbleChartComponent = /** @class */ (function (_super) {
        __extends(BubbleChartComponent, _super);
        function BubbleChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.showGridLines = true;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.xAxis = true;
            _this.yAxis = true;
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.maxRadius = 10;
            _this.minRadius = 3;
            _this.schemeType = 'ordinal';
            _this.tooltipDisabled = false;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.scaleType = 'linear';
            _this.margin = [10, 20, 10, 20];
            _this.bubblePadding = [0, 0, 0, 0];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.activeEntries = [];
            return _this;
        }
        BubbleChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            this.seriesDomain = this.results.map(function (d) { return d.name; });
            this.rDomain = this.getRDomain();
            this.xDomain = this.getXDomain();
            this.yDomain = this.getYDomain();
            this.transform = "translate(" + this.dims.xOffset + "," + this.margin[0] + ")";
            var colorDomain = this.schemeType === 'ordinal' ? this.seriesDomain : this.rDomain;
            this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
            this.data = this.results;
            this.minRadius = Math.max(this.minRadius, 1);
            this.maxRadius = Math.max(this.maxRadius, 1);
            this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
            this.bubblePadding = [0, 0, 0, 0];
            this.setScales();
            this.bubblePadding = this.getBubblePadding();
            this.setScales();
            this.legendOptions = this.getLegendOptions();
            this.clipPathId = 'clip' + id().toString();
            this.clipPath = "url(#" + this.clipPathId + ")";
        };
        BubbleChartComponent.prototype.hideCircles = function () {
            this.deactivateAll();
        };
        BubbleChartComponent.prototype.onClick = function (data, series) {
            if (series) {
                data.series = series.name;
            }
            this.select.emit(data);
        };
        BubbleChartComponent.prototype.getBubblePadding = function () {
            var e_1, _a, e_2, _b;
            var yMin = 0;
            var xMin = 0;
            var yMax = this.dims.height;
            var xMax = this.dims.width;
            try {
                for (var _c = __values(this.data), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(s.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            var r = this.rScale(d.r);
                            var cx = this.xScaleType === 'linear' ? this.xScale(Number(d.x)) : this.xScale(d.x);
                            var cy = this.yScaleType === 'linear' ? this.yScale(Number(d.y)) : this.yScale(d.y);
                            xMin = Math.max(r - cx, xMin);
                            yMin = Math.max(r - cy, yMin);
                            yMax = Math.max(cy + r, yMax);
                            xMax = Math.max(cx + r, xMax);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            xMax = Math.max(xMax - this.dims.width, 0);
            yMax = Math.max(yMax - this.dims.height, 0);
            return [yMin, xMax, yMax, xMin];
        };
        BubbleChartComponent.prototype.setScales = function () {
            var width = this.dims.width;
            if (this.xScaleMin === undefined && this.xScaleMax === undefined) {
                width = width - this.bubblePadding[1];
            }
            var height = this.dims.height;
            if (this.yScaleMin === undefined && this.yScaleMax === undefined) {
                height = height - this.bubblePadding[2];
            }
            this.xScale = this.getXScale(this.xDomain, width);
            this.yScale = this.getYScale(this.yDomain, height);
        };
        BubbleChartComponent.prototype.getYScale = function (domain, height) {
            return getScale(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
        };
        BubbleChartComponent.prototype.getXScale = function (domain, width) {
            return getScale(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
        };
        BubbleChartComponent.prototype.getRScale = function (domain, range) {
            var scale = d3Scale.scaleLinear().range(range).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        BubbleChartComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                position: this.legendPosition,
                title: undefined
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.seriesDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.rDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        BubbleChartComponent.prototype.getXDomain = function () {
            var e_3, _a, e_4, _b;
            var values = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_4 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!values.includes(d.x)) {
                                values.push(d.x);
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.xScaleType = getScaleType(values);
            return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
        };
        BubbleChartComponent.prototype.getYDomain = function () {
            var e_5, _a, e_6, _b;
            var values = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_6 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!values.includes(d.y)) {
                                values.push(d.y);
                            }
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            this.yScaleType = getScaleType(values);
            return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
        };
        BubbleChartComponent.prototype.getRDomain = function () {
            var e_7, _a, e_8, _b;
            var min = Infinity;
            var max = -Infinity;
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_8 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            var value = Number(d.r) || 1;
                            min = Math.min(min, value);
                            max = Math.max(max, value);
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_7) throw e_7.error; }
            }
            return [min, max];
        };
        BubbleChartComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        BubbleChartComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        BubbleChartComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        BubbleChartComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        BubbleChartComponent.prototype.deactivateAll = function () {
            var e_9, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            this.activeEntries = [];
        };
        BubbleChartComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
BubbleChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵBubbleChartComponent_BaseFactory; return function BubbleChartComponent_Factory(t) { return (ɵBubbleChartComponent_BaseFactory || (ɵBubbleChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BubbleChartComponent)))(t || BubbleChartComponent); }; }();
BubbleChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BubbleChartComponent, selectors: [["ngx-charts-bubble-chart"]], contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { minRadius: "minRadius", maxRadius: "maxRadius", showGridLines: "showGridLines", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", autoScale: "autoScale", schemeType: "schemeType", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 20, consts: [[3, "view", "showLegend", "activeEntries", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "auto", 3, "mouseenter"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-bubble-series", "", 3, "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function BubbleChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, BubbleChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, BubbleChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "rect", 4);
        ɵngcc0.ɵɵlistener("mouseenter", function BubbleChartComponent_Template__svg_rect_mouseenter_7_listener() { return ctx.deactivateAll(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, BubbleChartComponent__svg_g_9_Template, 2, 13, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, BubbleSeriesComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1
                    }),
                    animations.animate(500, animations.style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-bubble-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [activeEntries]=\"activeEntries\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"bubble-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [showGridLines]=\"showGridLines\"\n          [dims]=\"dims\"\n          [xScale]=\"xScale\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        />\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [showGridLines]=\"showGridLines\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        />\n        <svg:rect\n          class=\"bubble-chart-area\"\n          x=\"0\"\n          y=\"0\"\n          [attr.width]=\"dims.width\"\n          [attr.height]=\"dims.height\"\n          style=\"fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';\"\n          (mouseenter)=\"deactivateAll()\"\n        />\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of data; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-bubble-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [rScale]=\"rScale\"\n              [xScaleType]=\"xScaleType\"\n              [yScaleType]=\"yScaleType\"\n              [xAxisLabel]=\"xAxisLabel\"\n              [yAxisLabel]=\"yAxisLabel\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event, series)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1
                            }),
                            animations.animate(500, animations.style({
                                opacity: 0
                            }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { minRadius: [{
            type: core.Input
        }], maxRadius: [{
            type: core.Input
        }], hideCircles: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], showGridLines: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], autoScale: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], xScaleMin: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], yScaleMin: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return BubbleChartComponent;
    }(BaseChartComponent));
    BubbleChartComponent.propDecorators = {
        showGridLines: [{ type: core.Input }],
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        maxRadius: [{ type: core.Input }],
        minRadius: [{ type: core.Input }],
        autoScale: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        xScaleMin: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        yScaleMin: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        hideCircles: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var BubbleSeriesComponent = /** @class */ (function () {
        function BubbleSeriesComponent() {
            this.tooltipDisabled = false;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
        }
        BubbleSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        BubbleSeriesComponent.prototype.update = function () {
            this.circles = this.getCircles();
        };
        BubbleSeriesComponent.prototype.getCircles = function () {
            var _this = this;
            var seriesName = this.data.name;
            return this.data.series
                .map(function (d, i) {
                if (typeof d.y !== 'undefined' && typeof d.x !== 'undefined') {
                    var y = d.y;
                    var x = d.x;
                    var r = d.r;
                    var radius = _this.rScale(r || 1);
                    var tooltipLabel = formatLabel(d.name);
                    var cx = _this.xScaleType === 'linear' ? _this.xScale(Number(x)) : _this.xScale(x);
                    var cy = _this.yScaleType === 'linear' ? _this.yScale(Number(y)) : _this.yScale(y);
                    var color = _this.colors.scaleType === 'linear' ? _this.colors.getColor(r) : _this.colors.getColor(seriesName);
                    var isActive = !_this.activeEntries.length ? true : _this.isActive({ name: seriesName });
                    var opacity = isActive ? 1 : 0.3;
                    var data = Object.assign({}, d, {
                        series: seriesName,
                        name: d.name,
                        value: d.y,
                        x: d.x,
                        radius: d.r
                    });
                    return {
                        data: data,
                        x: x,
                        y: y,
                        r: r,
                        classNames: ["circle-data-" + i],
                        value: y,
                        label: x,
                        cx: cx,
                        cy: cy,
                        radius: radius,
                        tooltipLabel: tooltipLabel,
                        color: color,
                        opacity: opacity,
                        seriesName: seriesName,
                        isActive: isActive,
                        transform: "translate(" + cx + "," + cy + ")"
                    };
                }
            })
                .filter(function (circle) { return circle !== undefined; });
        };
        BubbleSeriesComponent.prototype.getTooltipText = function (circle) {
            var hasRadius = typeof circle.r !== 'undefined';
            var hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
            var hasSeriesName = circle.seriesName && circle.seriesName.length;
            var radiusValue = hasRadius ? formatLabel(circle.r) : '';
            var xAxisLabel = this.xAxisLabel && this.xAxisLabel !== '' ? this.xAxisLabel + ":" : '';
            var yAxisLabel = this.yAxisLabel && this.yAxisLabel !== '' ? this.yAxisLabel + ":" : '';
            var x = formatLabel(circle.x);
            var y = formatLabel(circle.y);
            var name = hasSeriesName && hasTooltipLabel
                ? circle.seriesName + " \u2022 " + circle.tooltipLabel
                : circle.seriesName + circle.tooltipLabel;
            var tooltipTitle = hasSeriesName || hasTooltipLabel ? "<span class=\"tooltip-label\">" + escapeLabel(name) + "</span>" : '';
            return "\n      " + tooltipTitle + "\n      <span class=\"tooltip-label\">\n        <label>" + escapeLabel(xAxisLabel) + "</label> " + escapeLabel(x) + "<br />\n        <label>" + escapeLabel(yAxisLabel) + "</label> " + escapeLabel(y) + "\n      </span>\n      <span class=\"tooltip-val\">\n        " + escapeLabel(radiusValue) + "\n      </span>\n    ";
        };
        BubbleSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        BubbleSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item !== undefined;
        };
        BubbleSeriesComponent.prototype.isVisible = function (circle) {
            if (this.activeEntries.length > 0) {
                return this.isActive({ name: circle.seriesName });
            }
            return circle.opacity !== 0;
        };
        BubbleSeriesComponent.prototype.activateCircle = function (circle) {
            circle.barVisible = true;
            this.activate.emit({ name: this.data.name });
        };
        BubbleSeriesComponent.prototype.deactivateCircle = function (circle) {
            circle.barVisible = false;
            this.deactivate.emit({ name: this.data.name });
        };
        BubbleSeriesComponent.prototype.trackBy = function (index, circle) {
            return circle.data.series + " " + circle.data.name;
        };
BubbleSeriesComponent.ɵfac = function BubbleSeriesComponent_Factory(t) { return new (t || BubbleSeriesComponent)(); };
BubbleSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: BubbleSeriesComponent, selectors: [["g", "ngx-charts-bubble-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", rScale: "rScale", xScaleType: "xScaleType", yScaleType: "yScaleType", colors: "colors", visibleValue: "visibleValue", activeEntries: "activeEntries", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c30, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function BubbleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BubbleSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CircleComponent, TooltipDirective], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':enter', [
                    animations.style({
                        opacity: 0,
                        transform: 'scale(0)'
                    }),
                    animations.animate(250, animations.style({ opacity: 1, transform: 'scale(1)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-bubble-series]',
                template: "\n    <svg:g *ngFor=\"let circle of circles; trackBy: trackBy\">\n      <svg:g [attr.transform]=\"circle.transform\">\n        <svg:g\n          ngx-charts-circle\n          [@animationState]=\"'active'\"\n          class=\"circle\"\n          [cx]=\"0\"\n          [cy]=\"0\"\n          [r]=\"circle.radius\"\n          [fill]=\"circle.color\"\n          [style.opacity]=\"circle.opacity\"\n          [class.active]=\"circle.isActive\"\n          [pointerEvents]=\"'all'\"\n          [data]=\"circle.value\"\n          [classNames]=\"circle.classNames\"\n          (select)=\"onClick(circle.data)\"\n          (activate)=\"activateCircle(circle)\"\n          (deactivate)=\"deactivateCircle(circle)\"\n          ngx-tooltip\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipPlacement]=\"'top'\"\n          [tooltipType]=\"'tooltip'\"\n          [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipContext]=\"circle.data\"\n        />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':enter', [
                            animations.style({
                                opacity: 0,
                                transform: 'scale(0)'
                            }),
                            animations.animate(250, animations.style({ opacity: 1, transform: 'scale(1)' }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], rScale: [{
            type: core.Input
        }], xScaleType: [{
            type: core.Input
        }], yScaleType: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], visibleValue: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return BubbleSeriesComponent;
    }());
    BubbleSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        rScale: [{ type: core.Input }],
        xScaleType: [{ type: core.Input }],
        yScaleType: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        visibleValue: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var BubbleChartModule = /** @class */ (function () {
        function BubbleChartModule() {
        }
BubbleChartModule.ɵfac = function BubbleChartModule_Factory(t) { return new (t || BubbleChartModule)(); };
BubbleChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BubbleChartModule });
BubbleChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [BubbleChartComponent, BubbleSeriesComponent],
                exports: [BubbleChartComponent, BubbleSeriesComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BubbleChartModule, { declarations: [BubbleChartComponent, BubbleSeriesComponent], imports: [ChartCommonModule], exports: [BubbleChartComponent, BubbleSeriesComponent] }); })();
        return BubbleChartModule;
    }());

    var HeatMapCellComponent = /** @class */ (function () {
        function HeatMapCellComponent(element) {
            this.gradient = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.element = element.nativeElement;
        }
        HeatMapCellComponent.prototype.ngOnChanges = function (changes) {
            this.transform = "translate(" + this.x + " , " + this.y + ")";
            this.startOpacity = 0.3;
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            this.gradientStops = this.getGradientStops();
            if (this.animations) {
                this.loadAnimation();
            }
        };
        HeatMapCellComponent.prototype.getGradientStops = function () {
            return [
                {
                    offset: 0,
                    color: this.fill,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.fill,
                    opacity: 1
                }
            ];
        };
        HeatMapCellComponent.prototype.loadAnimation = function () {
            var node = d3Selection.select(this.element).select('.cell');
            node.attr('opacity', 0);
            this.animateToCurrentForm();
        };
        HeatMapCellComponent.prototype.animateToCurrentForm = function () {
            var node = d3Selection.select(this.element).select('.cell');
            node.transition().duration(750).attr('opacity', 1);
        };
        HeatMapCellComponent.prototype.onClick = function () {
            this.select.emit(this.data);
        };
        HeatMapCellComponent.prototype.onMouseEnter = function () {
            this.activate.emit(this.data);
        };
        HeatMapCellComponent.prototype.onMouseLeave = function () {
            this.deactivate.emit(this.data);
        };
HeatMapCellComponent.ɵfac = function HeatMapCellComponent_Factory(t) { return new (t || HeatMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
HeatMapCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HeatMapCellComponent, selectors: [["g", "ngx-charts-heat-map-cell", ""]], hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { gradient: "gradient", animations: "animations", fill: "fill", x: "x", y: "y", width: "width", height: "height", data: "data", label: "label" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c31, decls: 3, vars: 5, consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 2, "cursor", "pointer", 3, "click"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function HeatMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, HeatMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "rect", 2);
        ɵngcc0.ɵɵlistener("click", function HeatMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapCellComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\">\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        rx=\"3\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"cell\"\n        style=\"cursor: pointer\"\n        (click)=\"onClick()\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { gradient: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], onMouseEnter: [{
            type: core.HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: core.Input
        }], x: [{
            type: core.Input
        }], y: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }] }); })();
        return HeatMapCellComponent;
    }());
    HeatMapCellComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    HeatMapCellComponent.propDecorators = {
        fill: [{ type: core.Input }],
        x: [{ type: core.Input }],
        y: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        data: [{ type: core.Input }],
        label: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var HeatCellSeriesComponent = /** @class */ (function () {
        function HeatCellSeriesComponent() {
            this.tooltipDisabled = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
        }
        HeatCellSeriesComponent.prototype.ngOnInit = function () {
            if (!this.tooltipText) {
                this.tooltipText = this.getTooltipText;
            }
        };
        HeatCellSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        HeatCellSeriesComponent.prototype.update = function () {
            this.cells = this.getCells();
        };
        HeatCellSeriesComponent.prototype.getCells = function () {
            var _this = this;
            var cells = [];
            this.data.map(function (row) {
                row.series.map(function (cell) {
                    var value = cell.value;
                    cell.series = row.name;
                    cells.push({
                        row: row,
                        cell: cell,
                        x: _this.xScale(row.name),
                        y: _this.yScale(cell.name),
                        width: _this.xScale.bandwidth(),
                        height: _this.yScale.bandwidth(),
                        fill: _this.colors.getColor(value),
                        data: value,
                        label: formatLabel(cell.name),
                        series: row.name
                    });
                });
            });
            return cells;
        };
        HeatCellSeriesComponent.prototype.getTooltipText = function (_a) {
            var label = _a.label, data = _a.data, series = _a.series;
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(series) + " \u2022 " + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + data.toLocaleString() + "</span>\n    ";
        };
        HeatCellSeriesComponent.prototype.trackBy = function (index, item) {
            return item.tooltipText;
        };
        HeatCellSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
HeatCellSeriesComponent.ɵfac = function HeatCellSeriesComponent_Factory(t) { return new (t || HeatCellSeriesComponent)(); };
HeatCellSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HeatCellSeriesComponent, selectors: [["g", "ngx-charts-heat-map-cell-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", data: "data", colors: "colors", xScale: "xScale", yScale: "yScale", gradient: "gradient", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c32, decls: 1, vars: 2, consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function HeatCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, HeatMapCellComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatCellSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-heat-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [data]=\"c.data\"\n      (select)=\"onClick(c.cell)\"\n      (activate)=\"activate.emit(c.cell)\"\n      (deactivate)=\"deactivate.emit(c.cell)\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"{ series: c.series, name: c.label, value: c.data }\"\n    ></svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipText: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return HeatCellSeriesComponent;
    }());
    HeatCellSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var HeatMapComponent = /** @class */ (function (_super) {
        __extends(HeatMapComponent, _super);
        function HeatMapComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.innerPadding = 8;
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.tooltipDisabled = false;
            _this.activeEntries = [];
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.scaleType = 'linear';
            return _this;
        }
        HeatMapComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.formatDates();
            this.xDomain = this.getXDomain();
            this.yDomain = this.getYDomain();
            this.valueDomain = this.getValueDomain();
            this.scaleType = getScaleType(this.valueDomain, false);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.scaleType,
                legendPosition: this.legendPosition
            });
            if (this.scaleType === 'linear') {
                var min = this.min;
                var max = this.max;
                if (!this.min) {
                    min = Math.min.apply(Math, __spread([0], this.valueDomain));
                }
                if (!this.max) {
                    max = Math.max.apply(Math, __spread(this.valueDomain));
                }
                this.valueDomain = [min, max];
            }
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
            this.rects = this.getRects();
        };
        HeatMapComponent.prototype.getXDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.name)) {
                        domain.push(group.name);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        HeatMapComponent.prototype.getYDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.name)) {
                                domain.push(d.name);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        HeatMapComponent.prototype.getValueDomain = function () {
            var e_4, _a, e_5, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_5 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.value)) {
                                domain.push(d.value);
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return domain;
        };
        /**
         * Converts the input to gap paddingInner in fraction
         * Supports the following inputs:
         *    Numbers: 8
         *    Strings: "8", "8px", "8%"
         *    Arrays: [8,2], "8,2", "[8,2]"
         *    Mixed: [8,"2%"], ["8px","2%"], "8,2%", "[8,2%]"
         *
         * @memberOf HeatMapComponent
         */
        HeatMapComponent.prototype.getDimension = function (value, index, N, L) {
            if (index === void 0) { index = 0; }
            if (typeof value === 'string') {
                value = value
                    .replace('[', '')
                    .replace(']', '')
                    .replace('px', '')
                    // tslint:disable-next-line: quotemark
                    .replace("'", '');
                if (value.includes(',')) {
                    value = value.split(',');
                }
            }
            if (Array.isArray(value) && typeof index === 'number') {
                return this.getDimension(value[index], null, N, L);
            }
            if (typeof value === 'string' && value.includes('%')) {
                return +value.replace('%', '') / 100;
            }
            return N / (L / +value + 1);
        };
        HeatMapComponent.prototype.getXScale = function () {
            var f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
            return d3Scale.scaleBand().rangeRound([0, this.dims.width]).domain(this.xDomain).paddingInner(f);
        };
        HeatMapComponent.prototype.getYScale = function () {
            var f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
            return d3Scale.scaleBand().rangeRound([this.dims.height, 0]).domain(this.yDomain).paddingInner(f);
        };
        HeatMapComponent.prototype.getRects = function () {
            var _this = this;
            var rects = [];
            this.xDomain.map(function (xVal) {
                _this.yDomain.map(function (yVal) {
                    rects.push({
                        x: _this.xScale(xVal),
                        y: _this.yScale(yVal),
                        rx: 3,
                        width: _this.xScale.bandwidth(),
                        height: _this.yScale.bandwidth(),
                        fill: 'rgba(200,200,200,0.03)'
                    });
                });
            });
            return rects;
        };
        HeatMapComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        HeatMapComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
        };
        HeatMapComponent.prototype.getLegendOptions = function () {
            return {
                scaleType: this.scaleType,
                domain: this.valueDomain,
                colors: this.scaleType === 'ordinal' ? this.colors : this.colors.scale,
                title: this.scaleType === 'ordinal' ? this.legendTitle : undefined,
                position: this.legendPosition
            };
        };
        HeatMapComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        HeatMapComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        HeatMapComponent.prototype.onActivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var items = this.results
                .map(function (g) { return g.series; })
                .flat()
                .filter(function (i) {
                if (fromLegend) {
                    return i.label === item.name;
                }
                else {
                    return i.name === item.name && i.series === item.series;
                }
            });
            this.activeEntries = __spread(items);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        HeatMapComponent.prototype.onDeactivate = function (event, group, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            this.activeEntries = this.activeEntries.filter(function (i) {
                if (fromLegend) {
                    return i.label !== item.name;
                }
                else {
                    return !(i.name === item.name && i.series === item.series);
                }
            });
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
HeatMapComponent.ɵfac = /*@__PURE__*/ function () { var ɵHeatMapComponent_BaseFactory; return function HeatMapComponent_Factory(t) { return (ɵHeatMapComponent_BaseFactory || (ɵHeatMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(HeatMapComponent)))(t || HeatMapComponent); }; }();
HeatMapComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: HeatMapComponent, selectors: [["ngx-charts-heat-map"]], contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", gradient: "gradient", innerPadding: "innerPadding", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", min: "min", max: "max" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 20, consts: [[3, "view", "showLegend", "animations", "legendOptions", "legendLabelClick"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "select", "activate", "deactivate"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function HeatMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, HeatMapComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, HeatMapComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
        ɵngcc0.ɵɵelementStart(5, "g", 5);
        ɵngcc0.ɵɵlistener("select", function HeatMapComponent_Template__svg_g_select_5_listener($event) { return ctx.onClick($event); })("activate", function HeatMapComponent_Template__svg_g_activate_5_listener($event) { return ctx.onActivate($event, undefined); })("deactivate", function HeatMapComponent_Template__svg_g_deactivate_5_listener($event) { return ctx.onDeactivate($event, undefined); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.rects);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, HeatCellSeriesComponent, XAxisComponent, YAxisComponent], styles: [_c24], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-heat-map',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [animations]=\"animations\"\n      [legendOptions]=\"legendOptions\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"heat-map chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:rect\n          *ngFor=\"let rect of rects\"\n          [attr.x]=\"rect.x\"\n          [attr.y]=\"rect.y\"\n          [attr.rx]=\"rect.rx\"\n          [attr.width]=\"rect.width\"\n          [attr.height]=\"rect.height\"\n          [attr.fill]=\"rect.fill\"\n        />\n        <svg:g\n          ngx-charts-heat-map-cell-series\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [data]=\"results\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, undefined)\"\n          (deactivate)=\"onDeactivate($event, undefined)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], innerPadding: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], tooltipText: [{
            type: core.Input
        }], min: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return HeatMapComponent;
    }(BaseChartComponent));
    HeatMapComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        innerPadding: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var HeatMapModule = /** @class */ (function () {
        function HeatMapModule() {
        }
HeatMapModule.ɵfac = function HeatMapModule_Factory(t) { return new (t || HeatMapModule)(); };
HeatMapModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: HeatMapModule });
HeatMapModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent],
                exports: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeatMapModule, { declarations: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent], imports: [ChartCommonModule], exports: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent] }); })();
        return HeatMapModule;
    }());

    var LineComponent = /** @class */ (function () {
        function LineComponent(element) {
            this.element = element;
            this.fill = 'none';
            this.animations = true;
            this.select = new core.EventEmitter();
            this.initialized = false;
        }
        LineComponent.prototype.ngOnChanges = function (changes) {
            if (!this.initialized) {
                this.initialized = true;
                this.initialPath = this.path;
            }
            else {
                this.updatePathEl();
            }
        };
        LineComponent.prototype.updatePathEl = function () {
            var node = d3Selection.select(this.element.nativeElement).select('.line');
            if (this.animations) {
                node.transition().duration(750).attr('d', this.path);
            }
            else {
                node.attr('d', this.path);
            }
        };
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
LineComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c34, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':enter', [
                    animations.style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animations.animate(1000, animations.style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: "\n    <svg:path\n      [@animationState]=\"'active'\"\n      class=\"line\"\n      [attr.d]=\"initialPath\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      stroke-width=\"1.5px\"\n    />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':enter', [
                            animations.style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animations.animate(1000, animations.style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { fill: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], path: [{
            type: core.Input
        }], stroke: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }] }); })();
        return LineComponent;
    }());
    LineComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    LineComponent.propDecorators = {
        path: [{ type: core.Input }],
        stroke: [{ type: core.Input }],
        data: [{ type: core.Input }],
        fill: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var LineChartComponent = /** @class */ (function (_super) {
        __extends(LineChartComponent, _super);
        function LineChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.showGridLines = true;
            _this.curve = d3Shape.curveLinear;
            _this.activeEntries = [];
            _this.trimXAxisTicks = true;
            _this.trimYAxisTicks = true;
            _this.rotateXAxisTicks = true;
            _this.maxXAxisTickLength = 16;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.tooltipDisabled = false;
            _this.showRefLines = false;
            _this.showRefLabels = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.timelineHeight = 50;
            _this.timelinePadding = 10;
            return _this;
        }
        LineChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            if (this.timeline) {
                this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
            }
            this.xDomain = this.getXDomain();
            if (this.filteredDomain) {
                this.xDomain = this.filteredDomain;
            }
            this.yDomain = this.getYDomain();
            this.seriesDomain = this.getSeriesDomain();
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
            this.yScale = this.getYScale(this.yDomain, this.dims.height);
            this.updateTimeline();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
            this.clipPathId = 'clip' + id().toString();
            this.clipPath = "url(#" + this.clipPathId + ")";
        };
        LineChartComponent.prototype.updateTimeline = function () {
            if (this.timeline) {
                this.timelineWidth = this.dims.width;
                this.timelineXDomain = this.getXDomain();
                this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
                this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
                this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
            }
        };
        LineChartComponent.prototype.getXDomain = function () {
            var values = getUniqueXDomainValues(this.results);
            this.scaleType = getScaleType(values);
            var domain = [];
            if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
            }
            var min;
            var max;
            if (this.scaleType === 'time' || this.scaleType === 'linear') {
                min = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, __spread(values));
                max = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, __spread(values));
            }
            if (this.scaleType === 'time') {
                domain = [new Date(min), new Date(max)];
                this.xSet = __spread(values).sort(function (a, b) {
                    var aDate = a.getTime();
                    var bDate = b.getTime();
                    if (aDate > bDate)
                        return 1;
                    if (bDate > aDate)
                        return -1;
                    return 0;
                });
            }
            else if (this.scaleType === 'linear') {
                domain = [min, max];
                // Use compare function to sort numbers numerically
                this.xSet = __spread(values).sort(function (a, b) { return a - b; });
            }
            else {
                domain = values;
                this.xSet = values;
            }
            return domain;
        };
        LineChartComponent.prototype.getYDomain = function () {
            var e_1, _a, e_2, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (domain.indexOf(d.value) < 0) {
                                domain.push(d.value);
                            }
                            if (d.min !== undefined) {
                                this.hasRange = true;
                                if (domain.indexOf(d.min) < 0) {
                                    domain.push(d.min);
                                }
                            }
                            if (d.max !== undefined) {
                                this.hasRange = true;
                                if (domain.indexOf(d.max) < 0) {
                                    domain.push(d.max);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var values = __spread(domain);
            if (!this.autoScale) {
                values.push(0);
            }
            var min = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, __spread(values));
            var max = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, __spread(values));
            return [min, max];
        };
        LineChartComponent.prototype.getSeriesDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        LineChartComponent.prototype.getXScale = function (domain, width) {
            var scale;
            if (this.scaleType === 'time') {
                scale = d3Scale.scaleTime().range([0, width]).domain(domain);
            }
            else if (this.scaleType === 'linear') {
                scale = d3Scale.scaleLinear().range([0, width]).domain(domain);
                if (this.roundDomains) {
                    scale = scale.nice();
                }
            }
            else if (this.scaleType === 'ordinal') {
                scale = d3Scale.scalePoint().range([0, width]).padding(0.1).domain(domain);
            }
            return scale;
        };
        LineChartComponent.prototype.getYScale = function (domain, height) {
            var scale = d3Scale.scaleLinear().range([height, 0]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        LineChartComponent.prototype.updateDomain = function (domain) {
            this.filteredDomain = domain;
            this.xDomain = this.filteredDomain;
            this.xScale = this.getXScale(this.xDomain, this.dims.width);
        };
        LineChartComponent.prototype.updateHoveredVertical = function (item) {
            this.hoveredVertical = item.value;
            this.deactivateAll();
        };
        LineChartComponent.prototype.hideCircles = function () {
            this.hoveredVertical = null;
            this.deactivateAll();
        };
        LineChartComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        LineChartComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        LineChartComponent.prototype.setColors = function () {
            var domain;
            if (this.schemeType === 'ordinal') {
                domain = this.seriesDomain;
            }
            else {
                domain = this.yDomain;
            }
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        LineChartComponent.prototype.getLegendOptions = function () {
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: undefined,
                position: this.legendPosition
            };
            if (opts.scaleType === 'ordinal') {
                opts.domain = this.seriesDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.yDomain;
                opts.colors = this.colors.scale;
            }
            return opts;
        };
        LineChartComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        LineChartComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        LineChartComponent.prototype.onActivate = function (item) {
            this.deactivateAll();
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = [item];
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        LineChartComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        LineChartComponent.prototype.deactivateAll = function () {
            var e_3, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.activeEntries = [];
        };
LineChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵLineChartComponent_BaseFactory; return function LineChartComponent_Factory(t) { return (ɵLineChartComponent_BaseFactory || (ɵLineChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LineChartComponent)))(t || LineChartComponent); }; }();
LineChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LineChartComponent, selectors: [["ngx-charts-line-chart"]], contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function LineChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showRefLines: "showRefLines", referenceLines: "referenceLines", showRefLabels: "showRefLabels", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]], template: function LineChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, LineChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, LineChartComponent__svg_g_6_Template, 1, 12, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, LineChartComponent__svg_g_8_Template, 2, 11, "g", 4);
        ɵngcc0.ɵɵtemplate(9, LineChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, LineChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, LineSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1
                    }),
                    animations.animate(500, animations.style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-line-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"line-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [referenceLines]=\"referenceLines\"\n          [showRefLines]=\"showRefLines\"\n          [showRefLabels]=\"showRefLabels\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-line-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [hasRange]=\"hasRange\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [activeEntries]=\"activeEntries\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [scaleType]=\"scaleType\"\n        [legend]=\"legend\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-line-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [curve]=\"curve\"\n            [hasRange]=\"hasRange\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1
                            }),
                            animations.animate(500, animations.style({
                                opacity: 0
                            }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"]
            }]
    }], null, { hideCircles: [{
            type: core.HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], autoScale: [{
            type: core.Input
        }], timeline: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], rangeFillOpacity: [{
            type: core.Input
        }], trimXAxisTicks: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], rotateXAxisTicks: [{
            type: core.Input
        }], maxXAxisTickLength: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], xAxisTicks: [{
            type: core.Input
        }], yAxisTicks: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], showRefLines: [{
            type: core.Input
        }], referenceLines: [{
            type: core.Input
        }], showRefLabels: [{
            type: core.Input
        }], xScaleMin: [{
            type: core.Input
        }], xScaleMax: [{
            type: core.Input
        }], yScaleMin: [{
            type: core.Input
        }], yScaleMax: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], seriesTooltipTemplate: [{
            type: core.ContentChild,
            args: ['seriesTooltipTemplate']
        }] }); })();
        return LineChartComponent;
    }(BaseChartComponent));
    LineChartComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        autoScale: [{ type: core.Input }],
        timeline: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        rangeFillOpacity: [{ type: core.Input }],
        trimXAxisTicks: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        rotateXAxisTicks: [{ type: core.Input }],
        maxXAxisTickLength: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        xAxisTicks: [{ type: core.Input }],
        yAxisTicks: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        showRefLines: [{ type: core.Input }],
        referenceLines: [{ type: core.Input }],
        showRefLabels: [{ type: core.Input }],
        xScaleMin: [{ type: core.Input }],
        xScaleMax: [{ type: core.Input }],
        yScaleMin: [{ type: core.Input }],
        yScaleMax: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        seriesTooltipTemplate: [{ type: core.ContentChild, args: ['seriesTooltipTemplate',] }],
        hideCircles: [{ type: core.HostListener, args: ['mouseleave',] }]
    };

    var LineSeriesComponent = /** @class */ (function () {
        function LineSeriesComponent() {
            this.animations = true;
        }
        LineSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        LineSeriesComponent.prototype.update = function () {
            this.updateGradients();
            var data = this.sortData(this.data.series);
            var lineGen = this.getLineGenerator();
            this.path = lineGen(data) || '';
            var areaGen = this.getAreaGenerator();
            this.areaPath = areaGen(data) || '';
            if (this.hasRange) {
                var range = this.getRangeGenerator();
                this.outerPath = range(data) || '';
            }
            if (this.hasGradient) {
                this.stroke = this.gradientUrl;
                var values = this.data.series.map(function (d) { return d.value; });
                var max = Math.max.apply(Math, __spread(values));
                var min = Math.min.apply(Math, __spread(values));
                if (max === min) {
                    this.stroke = this.colors.getColor(max);
                }
            }
            else {
                this.stroke = this.colors.getColor(this.data.name);
            }
        };
        LineSeriesComponent.prototype.getLineGenerator = function () {
            var _this = this;
            return d3Shape.line()
                .x(function (d) {
                var label = d.name;
                var value;
                if (_this.scaleType === 'time') {
                    value = _this.xScale(label);
                }
                else if (_this.scaleType === 'linear') {
                    value = _this.xScale(Number(label));
                }
                else {
                    value = _this.xScale(label);
                }
                return value;
            })
                .y(function (d) { return _this.yScale(d.value); })
                .curve(this.curve);
        };
        LineSeriesComponent.prototype.getRangeGenerator = function () {
            var _this = this;
            return d3Shape.area()
                .x(function (d) {
                var label = d.name;
                var value;
                if (_this.scaleType === 'time') {
                    value = _this.xScale(label);
                }
                else if (_this.scaleType === 'linear') {
                    value = _this.xScale(Number(label));
                }
                else {
                    value = _this.xScale(label);
                }
                return value;
            })
                .y0(function (d) { return _this.yScale(typeof d.min === 'number' ? d.min : d.value); })
                .y1(function (d) { return _this.yScale(typeof d.max === 'number' ? d.max : d.value); })
                .curve(this.curve);
        };
        LineSeriesComponent.prototype.getAreaGenerator = function () {
            var _this = this;
            var xProperty = function (d) {
                var label = d.name;
                return _this.xScale(label);
            };
            return d3Shape.area()
                .x(xProperty)
                .y0(function () { return _this.yScale.range()[0]; })
                .y1(function (d) { return _this.yScale(d.value); })
                .curve(this.curve);
        };
        LineSeriesComponent.prototype.sortData = function (data) {
            if (this.scaleType === 'linear') {
                data = sortLinear(data, 'name');
            }
            else if (this.scaleType === 'time') {
                data = sortByTime(data, 'name');
            }
            else {
                data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
            }
            return data;
        };
        LineSeriesComponent.prototype.updateGradients = function () {
            if (this.colors.scaleType === 'linear') {
                this.hasGradient = true;
                this.gradientId = 'grad' + id().toString();
                this.gradientUrl = "url(#" + this.gradientId + ")";
                var values = this.data.series.map(function (d) { return d.value; });
                var max = Math.max.apply(Math, __spread(values));
                var min = Math.min.apply(Math, __spread(values));
                this.gradientStops = this.colors.getLinearGradientStops(max, min);
                this.areaGradientStops = this.colors.getLinearGradientStops(max);
            }
            else {
                this.hasGradient = false;
                this.gradientStops = undefined;
                this.areaGradientStops = undefined;
            }
        };
        LineSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item !== undefined;
        };
        LineSeriesComponent.prototype.isInactive = function (entry) {
            if (!this.activeEntries || this.activeEntries.length === 0)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item === undefined;
        };
LineSeriesComponent.ɵfac = function LineSeriesComponent_Factory(t) { return new (t || LineSeriesComponent)(); };
LineSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LineSeriesComponent, selectors: [["g", "ngx-charts-line-series", ""]], inputs: { animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", hasRange: "hasRange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c35, decls: 6, vars: 22, consts: [["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]], template: function LineSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, LineSeriesComponent__svg_g_2_Template, 1, 2, "g", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 1);
        ɵngcc0.ɵɵelement(4, "g", 2);
        ɵngcc0.ɵɵtemplate(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRange);
    } }, directives: [ɵngcc1.NgIf, AreaComponent, LineComponent, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-line-series]',
                template: "\n    <svg:g>\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-area\n        class=\"line-highlight\"\n        [data]=\"data\"\n        [path]=\"areaPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [opacity]=\"0.25\"\n        [startOpacity]=\"0\"\n        [gradient]=\"true\"\n        [stops]=\"areaGradientStops\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-line\n        class=\"line-series\"\n        [data]=\"data\"\n        [path]=\"path\"\n        [stroke]=\"stroke\"\n        [animations]=\"animations\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n      />\n      <svg:g\n        ngx-charts-area\n        *ngIf=\"hasRange\"\n        class=\"line-series-range\"\n        [data]=\"data\"\n        [path]=\"outerPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [opacity]=\"rangeFillOpacity\"\n        [animations]=\"animations\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], rangeFillOpacity: [{
            type: core.Input
        }], hasRange: [{
            type: core.Input
        }] }); })();
        return LineSeriesComponent;
    }());
    LineSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        rangeFillOpacity: [{ type: core.Input }],
        hasRange: [{ type: core.Input }],
        animations: [{ type: core.Input }]
    };

    var LineChartModule = /** @class */ (function () {
        function LineChartModule() {
        }
LineChartModule.ɵfac = function LineChartModule_Factory(t) { return new (t || LineChartModule)(); };
LineChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LineChartModule });
LineChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [LineComponent, LineChartComponent, LineSeriesComponent],
                exports: [LineComponent, LineChartComponent, LineSeriesComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LineChartModule, { declarations: [LineComponent, LineChartComponent, LineSeriesComponent], imports: [ChartCommonModule], exports: [LineComponent, LineChartComponent, LineSeriesComponent] }); })();
        return LineChartModule;
    }());

    function isDate(value) {
        return toString.call(value) === '[object Date]';
    }
    function isNumber(value) {
        return typeof value === 'number';
    }

    var twoPI = 2 * Math.PI;
    var PolarChartComponent = /** @class */ (function (_super) {
        __extends(PolarChartComponent, _super);
        function PolarChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.showGridLines = true;
            _this.curve = d3Shape.curveCardinalClosed;
            _this.activeEntries = [];
            _this.rangeFillOpacity = 0.15;
            _this.trimYAxisTicks = true;
            _this.maxYAxisTickLength = 16;
            _this.roundDomains = false;
            _this.tooltipDisabled = false;
            _this.showSeriesOnHover = true;
            _this.gradient = false;
            _this.yAxisMinScale = 0;
            _this.labelTrim = true;
            _this.labelTrimSize = 10;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            return _this;
        }
        PolarChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.setDims();
            this.setScales();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            this.setTicks();
        };
        PolarChartComponent.prototype.setDims = function () {
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
                legendPosition: this.legendPosition
            });
            var halfWidth = Math.floor(this.dims.width / 2);
            var halfHeight = Math.floor(this.dims.height / 2);
            var outerRadius = (this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5));
            var yOffset = Math.max(0, halfHeight - outerRadius);
            this.yAxisDims = Object.assign(Object.assign({}, this.dims), { width: halfWidth });
            this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
            this.transformYAxis = "translate(0, " + yOffset + ")";
            this.labelOffset = this.dims.height + 40;
            this.transformPlot = "translate(" + halfWidth + ", " + halfHeight + ")";
        };
        PolarChartComponent.prototype.setScales = function () {
            var xValues = this.getXValues();
            this.scaleType = getScaleType(xValues);
            this.xDomain = this.filteredDomain || this.getXDomain(xValues);
            this.yDomain = this.getYDomain();
            this.seriesDomain = this.getSeriesDomain();
            this.xScale = this.getXScale(this.xDomain, twoPI);
            this.yScale = this.getYScale(this.yDomain, this.outerRadius);
            this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
        };
        PolarChartComponent.prototype.setTicks = function () {
            var _this = this;
            var tickFormat;
            if (this.xAxisTickFormatting) {
                tickFormat = this.xAxisTickFormatting;
            }
            else if (this.xScale.tickFormat) {
                tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
            }
            else {
                tickFormat = function (d) {
                    if (isDate(d)) {
                        return d.toLocaleDateString();
                    }
                    return d.toLocaleString();
                };
            }
            var outerRadius = this.outerRadius;
            var s = 1.1;
            this.thetaTicks = this.xDomain.map(function (d) {
                var startAngle = _this.xScale(d);
                var dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
                var label = tickFormat(d);
                var startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
                var pos = [dd, s * startPos[1]];
                return {
                    innerRadius: 0,
                    outerRadius: outerRadius,
                    startAngle: startAngle,
                    endAngle: startAngle,
                    value: outerRadius,
                    label: label,
                    startPos: startPos,
                    pos: pos
                };
            });
            var minDistance = 10;
            /* from pie chart, abstract out -*/
            for (var i = 0; i < this.thetaTicks.length - 1; i++) {
                var a = this.thetaTicks[i];
                for (var j = i + 1; j < this.thetaTicks.length; j++) {
                    var b = this.thetaTicks[j];
                    // if they're on the same side
                    if (b.pos[0] * a.pos[0] > 0) {
                        // if they're overlapping
                        var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                        if (o > 0) {
                            // push the second up or down
                            b.pos[1] += Math.sign(b.pos[0]) * o;
                        }
                    }
                }
            }
            this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map(function (d) { return _this.yScale(d); });
        };
        PolarChartComponent.prototype.getXValues = function () {
            var e_1, _a, e_2, _b;
            var values = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_2 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!values.includes(d.name)) {
                                values.push(d.name);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return values;
        };
        PolarChartComponent.prototype.getXDomain = function (values) {
            if (values === void 0) { values = this.getXValues(); }
            if (this.scaleType === 'time') {
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                return [min, max];
            }
            else if (this.scaleType === 'linear') {
                values = values.map(function (v) { return Number(v); });
                var min = Math.min.apply(Math, __spread(values));
                var max = Math.max.apply(Math, __spread(values));
                return [min, max];
            }
            return values;
        };
        PolarChartComponent.prototype.getYValues = function () {
            var e_3, _a, e_4, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var results = _d.value;
                    try {
                        for (var _e = (e_4 = void 0, __values(results.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (domain.indexOf(d.value) < 0) {
                                domain.push(d.value);
                            }
                            if (d.min !== undefined) {
                                if (domain.indexOf(d.min) < 0) {
                                    domain.push(d.min);
                                }
                            }
                            if (d.max !== undefined) {
                                if (domain.indexOf(d.max) < 0) {
                                    domain.push(d.max);
                                }
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return domain;
        };
        PolarChartComponent.prototype.getYDomain = function (domain) {
            if (domain === void 0) { domain = this.getYValues(); }
            var min = Math.min.apply(Math, __spread(domain));
            var max = Math.max.apply(Math, __spread([this.yAxisMinScale], domain));
            min = Math.max(0, min);
            if (!this.autoScale) {
                min = Math.min(0, min);
            }
            return [min, max];
        };
        PolarChartComponent.prototype.getSeriesDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        PolarChartComponent.prototype.getXScale = function (domain, width) {
            switch (this.scaleType) {
                case 'time':
                    return d3Scale.scaleTime().range([0, width]).domain(domain);
                case 'linear':
                    var scale = d3Scale.scaleLinear().range([0, width]).domain(domain);
                    return this.roundDomains ? scale.nice() : scale;
                default:
                    return d3Scale.scalePoint()
                        .range([0, width - twoPI / domain.length])
                        .padding(0)
                        .domain(domain);
            }
        };
        PolarChartComponent.prototype.getYScale = function (domain, height) {
            var scale = d3Scale.scaleLinear().range([0, height]).domain(domain);
            return this.roundDomains ? scale.nice() : scale;
        };
        PolarChartComponent.prototype.onClick = function (data, series) {
            if (series) {
                data.series = series.name;
            }
            this.select.emit(data);
        };
        PolarChartComponent.prototype.setColors = function () {
            var domain = this.schemeType === 'ordinal' ? this.seriesDomain : this.yDomain.reverse();
            this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        PolarChartComponent.prototype.getLegendOptions = function () {
            if (this.schemeType === 'ordinal') {
                return {
                    scaleType: this.schemeType,
                    colors: this.colors,
                    domain: this.seriesDomain,
                    title: this.legendTitle,
                    position: this.legendPosition
                };
            }
            return {
                scaleType: this.schemeType,
                colors: this.colors.scale,
                domain: this.yDomain,
                title: undefined,
                position: this.legendPosition
            };
        };
        PolarChartComponent.prototype.updateYAxisWidth = function (_a) {
            var width = _a.width;
            this.yAxisWidth = width;
            this.update();
        };
        PolarChartComponent.prototype.updateXAxisHeight = function (_a) {
            var height = _a.height;
            this.xAxisHeight = height;
            this.update();
        };
        PolarChartComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = this.showSeriesOnHover ? __spread([item], this.activeEntries) : this.activeEntries;
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        PolarChartComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        PolarChartComponent.prototype.deactivateAll = function () {
            var e_5, _a;
            this.activeEntries = __spread(this.activeEntries);
            try {
                for (var _b = __values(this.activeEntries), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    this.deactivate.emit({ value: entry, entries: [] });
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
            this.activeEntries = [];
        };
        PolarChartComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
PolarChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵPolarChartComponent_BaseFactory; return function PolarChartComponent_Factory(t) { return (ɵPolarChartComponent_BaseFactory || (ɵPolarChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PolarChartComponent)))(t || PolarChartComponent); }; }();
PolarChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PolarChartComponent, selectors: [["ngx-charts-polar-chart"]], contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimYAxisTicks: "trimYAxisTicks", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showSeriesOnHover: "showSeriesOnHover", gradient: "gradient", yAxisMinScale: "yAxisMinScale", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 18, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], ["ngx-charts-polar-series", "", 3, "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function PolarChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵtemplate(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵtemplate(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, PolarChartComponent__svg_g_6_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5);
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, PolarChartComponent__svg_g_9_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(15, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("r", ctx.outerRadius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGridLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis && ctx.showXAxisLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, PieLabelComponent, YAxisComponent, AxisLabelComponent, PolarSeriesComponent]; }, styles: [_c24, _c39, ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{fill:none;stroke-dasharray:10 10}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}"], encapsulation: 2, data: { animation: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1
                    }),
                    animations.animate(500, animations.style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-polar-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g class=\"polar-chart chart\" [attr.transform]=\"transform\">\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:circle class=\"polar-chart-background\" cx=\"0\" cy=\"0\" [attr.r]=\"this.outerRadius\" />\n          <svg:g *ngIf=\"showGridLines\">\n            <svg:circle\n              *ngFor=\"let r of radiusTicks\"\n              class=\"gridline-path radial-gridline-path\"\n              cx=\"0\"\n              cy=\"0\"\n              [attr.r]=\"r\"\n            />\n          </svg:g>\n          <svg:g *ngIf=\"xAxis\">\n            <svg:g\n              ngx-charts-pie-label\n              *ngFor=\"let tick of thetaTicks\"\n              [data]=\"tick\"\n              [radius]=\"outerRadius\"\n              [label]=\"tick.label\"\n              [max]=\"outerRadius\"\n              [value]=\"showGridLines ? 1 : outerRadius\"\n              [explodeSlices]=\"true\"\n              [animations]=\"animations\"\n              [labelTrim]=\"labelTrim\"\n              [labelTrimSize]=\"labelTrimSize\"\n            ></svg:g>\n          </svg:g>\n        </svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          [attr.transform]=\"transformYAxis\"\n          *ngIf=\"yAxis\"\n          [yScale]=\"yAxisScale\"\n          [dims]=\"yAxisDims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-axis-label\n          *ngIf=\"xAxis && showXAxisLabel\"\n          [label]=\"xAxisLabel\"\n          [offset]=\"labelOffset\"\n          [orient]=\"'bottom'\"\n          [height]=\"dims.height\"\n          [width]=\"dims.width\"\n        ></svg:g>\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-polar-series\n              [gradient]=\"gradient\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [animations]=\"animations\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    animations.trigger('animationState', [
                        animations.transition(':leave', [
                            animations.style({
                                opacity: 1
                            }),
                            animations.animate(500, animations.style({
                                opacity: 0
                            }))
                        ])
                    ])
                ],
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{-webkit-animation:fadeIn .75s ease-in;animation:fadeIn .75s ease-in}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{-webkit-animation:drawOut 3s linear;animation:drawOut 3s linear;transition:d .75s}@-webkit-keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{fill:none;stroke-dasharray:10 10}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], xAxis: [{
            type: core.Input
        }], yAxis: [{
            type: core.Input
        }], showXAxisLabel: [{
            type: core.Input
        }], showYAxisLabel: [{
            type: core.Input
        }], xAxisLabel: [{
            type: core.Input
        }], yAxisLabel: [{
            type: core.Input
        }], autoScale: [{
            type: core.Input
        }], showGridLines: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], schemeType: [{
            type: core.Input
        }], rangeFillOpacity: [{
            type: core.Input
        }], trimYAxisTicks: [{
            type: core.Input
        }], maxYAxisTickLength: [{
            type: core.Input
        }], xAxisTickFormatting: [{
            type: core.Input
        }], yAxisTickFormatting: [{
            type: core.Input
        }], roundDomains: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], showSeriesOnHover: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], yAxisMinScale: [{
            type: core.Input
        }], labelTrim: [{
            type: core.Input
        }], labelTrimSize: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return PolarChartComponent;
    }(BaseChartComponent));
    PolarChartComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        xAxis: [{ type: core.Input }],
        yAxis: [{ type: core.Input }],
        showXAxisLabel: [{ type: core.Input }],
        showYAxisLabel: [{ type: core.Input }],
        xAxisLabel: [{ type: core.Input }],
        yAxisLabel: [{ type: core.Input }],
        autoScale: [{ type: core.Input }],
        showGridLines: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        schemeType: [{ type: core.Input }],
        rangeFillOpacity: [{ type: core.Input }],
        trimYAxisTicks: [{ type: core.Input }],
        maxYAxisTickLength: [{ type: core.Input }],
        xAxisTickFormatting: [{ type: core.Input }],
        yAxisTickFormatting: [{ type: core.Input }],
        roundDomains: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        showSeriesOnHover: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        yAxisMinScale: [{ type: core.Input }],
        labelTrim: [{ type: core.Input }],
        labelTrimSize: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var PolarSeriesComponent = /** @class */ (function () {
        function PolarSeriesComponent() {
            this.tooltipDisabled = false;
            this.gradient = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.circleRadius = 3;
        }
        PolarSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        PolarSeriesComponent.prototype.update = function () {
            var _this = this;
            this.updateGradients();
            var line = this.getLineGenerator();
            var data = this.sortData(this.data.series);
            var seriesName = this.data.name;
            var linearScaleType = this.colors.scaleType === 'linear';
            var min = this.yScale.domain()[0];
            this.seriesColor = this.colors.getColor(linearScaleType ? min : seriesName);
            this.path = line(data) || '';
            this.circles = data.map(function (d) {
                var a = _this.getAngle(d);
                var r = _this.getRadius(d);
                var value = d.value;
                var color = _this.colors.getColor(linearScaleType ? Math.abs(value) : seriesName);
                var cData = Object.assign({}, d, {
                    series: seriesName,
                    value: value,
                    name: d.name
                });
                return {
                    data: cData,
                    cx: r * Math.sin(a),
                    cy: -r * Math.cos(a),
                    value: value,
                    color: color,
                    label: d.name
                };
            });
            this.active = this.isActive(this.data);
            this.inactive = this.isInactive(this.data);
            this.tooltipText = this.tooltipText || (function (c) { return _this.defaultTooltipText(c); });
        };
        PolarSeriesComponent.prototype.getAngle = function (d) {
            var label = d.name;
            if (this.scaleType === 'time') {
                return this.xScale(label);
            }
            else if (this.scaleType === 'linear') {
                return this.xScale(Number(label));
            }
            return this.xScale(label);
        };
        PolarSeriesComponent.prototype.getRadius = function (d) {
            return this.yScale(d.value);
        };
        PolarSeriesComponent.prototype.getLineGenerator = function () {
            var _this = this;
            return d3Shape.lineRadial()
                .angle(function (d) { return _this.getAngle(d); })
                .radius(function (d) { return _this.getRadius(d); })
                .curve(this.curve);
        };
        PolarSeriesComponent.prototype.sortData = function (data) {
            if (this.scaleType === 'linear') {
                return sortLinear(data, 'name');
            }
            else if (this.scaleType === 'time') {
                return sortByTime(data, 'name');
            }
            return sortByDomain(data, 'name', 'asc', this.xScale.domain());
        };
        PolarSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item !== undefined;
        };
        PolarSeriesComponent.prototype.isInactive = function (entry) {
            if (!this.activeEntries || this.activeEntries.length === 0)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name;
            });
            return item === undefined;
        };
        PolarSeriesComponent.prototype.defaultTooltipText = function (_a) {
            var label = _a.label, value = _a.value;
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(this.data.name) + " \u2022 " + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
        };
        PolarSeriesComponent.prototype.updateGradients = function () {
            this.hasGradient = this.gradient || this.colors.scaleType === 'linear';
            if (!this.hasGradient) {
                return;
            }
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            if (this.colors.scaleType === 'linear') {
                var values = this.data.series.map(function (d) { return d.value; });
                var max = Math.max.apply(Math, __spread(values));
                var min = Math.min.apply(Math, __spread(values));
                this.gradientStops = this.colors.getLinearGradientStops(max, min);
            }
            else {
                this.gradientStops = undefined;
            }
        };
PolarSeriesComponent.ɵfac = function PolarSeriesComponent_Factory(t) { return new (t || PolarSeriesComponent)(); };
PolarSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PolarSeriesComponent, selectors: [["g", "ngx-charts-polar-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", gradient: "gradient", animations: "animations", tooltipText: "tooltipText", name: "name", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c36, decls: 5, vars: 11, consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", "tooltipType", "tooltip", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", "tooltipType", "tooltip", 1, "circle", 3, "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function PolarSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 2);
        ɵngcc0.ɵɵtemplate(4, PolarSeriesComponent__svg_g_4_Template, 1, 11, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.active)("inactive", ctx.inactive);
        ɵngcc0.ɵɵproperty("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
        ɵngcc0.ɵɵattribute("fill-opacity", ctx.rangeFillOpacity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles);
    } }, directives: [ɵngcc1.NgIf, LineComponent, ɵngcc1.NgForOf, SvgRadialGradientComponent, CircleComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-polar-series]',
                template: "\n    <svg:g class=\"polar-charts-series\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-radial-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [color]=\"seriesColor\"\n          [name]=\"gradientId\"\n          [startOpacity]=\"0.25\"\n          [endOpacity]=\"1\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-line\n        class=\"polar-series-path\"\n        [path]=\"path\"\n        [stroke]=\"hasGradient ? gradientUrl : seriesColor\"\n        [class.active]=\"active\"\n        [class.inactive]=\"inactive\"\n        [attr.fill-opacity]=\"rangeFillOpacity\"\n        [fill]=\"hasGradient ? gradientUrl : seriesColor\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-circle\n        *ngFor=\"let circle of circles\"\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circleRadius\"\n        [fill]=\"circle.color\"\n        [style.opacity]=\"inactive ? 0.2 : 1\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        tooltipType=\"tooltip\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n        (select)=\"select.emit(circle.data)\"\n        (activate)=\"activate.emit({ name: circle.data.series })\"\n        (deactivate)=\"deactivate.emit({ name: circle.data.series })\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipText: [{
            type: core.Input
        }], name: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], xScale: [{
            type: core.Input
        }], yScale: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], scaleType: [{
            type: core.Input
        }], curve: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], rangeFillOpacity: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return PolarSeriesComponent;
    }());
    PolarSeriesComponent.propDecorators = {
        name: [{ type: core.Input }],
        data: [{ type: core.Input }],
        xScale: [{ type: core.Input }],
        yScale: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        scaleType: [{ type: core.Input }],
        curve: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        rangeFillOpacity: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var AdvancedPieChartComponent = /** @class */ (function (_super) {
        __extends(AdvancedPieChartComponent, _super);
        function AdvancedPieChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.activeEntries = [];
            _this.tooltipDisabled = false;
            _this.label = 'Total';
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [20, 20, 20, 20];
            return _this;
        }
        AdvancedPieChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: (this.width * 4) / 12.0,
                height: this.height,
                margins: this.margin
            });
            this.formatDates();
            this.domain = this.getDomain();
            this.setColors();
            var xOffset = this.dims.width / 2;
            var yOffset = this.margin[0] + this.dims.height / 2;
            this.legendWidth = this.width - this.dims.width - this.margin[1];
            this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
            this.innerRadius = this.outerRadius * 0.75;
            this.transform = "translate(" + xOffset + " , " + yOffset + ")";
        };
        AdvancedPieChartComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        AdvancedPieChartComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        AdvancedPieChartComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
        AdvancedPieChartComponent.prototype.onActivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        AdvancedPieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
AdvancedPieChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵAdvancedPieChartComponent_BaseFactory; return function AdvancedPieChartComponent_Factory(t) { return (ɵAdvancedPieChartComponent_BaseFactory || (ɵAdvancedPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AdvancedPieChartComponent)))(t || AdvancedPieChartComponent); }; }();
AdvancedPieChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AdvancedPieChartComponent, selectors: [["ngx-charts-advanced-pie-chart"]], contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", gradient: "gradient", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", label: "label", valueFormatting: "valueFormatting", nameFormatting: "nameFormatting", percentageFormatting: "percentageFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 37, consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations", "select", "activate", "deactivate"], [1, "advanced-pie-legend-wrapper"], [3, "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting", "select", "activate", "deactivate"]], template: function AdvancedPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "ngx-charts-chart", 1);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵelementStart(4, "g", 3);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function AdvancedPieChartComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "ngx-charts-advanced-legend", 5);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) { return ctx.onActivate($event, true); })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(34, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
    } }, directives: function () { return [ChartComponent, PieSeriesComponent, AdvancedLegendComponent]; }, styles: [_c24, ".advanced-pie{float:left}.advanced-pie,.advanced-pie-legend-wrapper{display:inline-block}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AdvancedPieChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-advanced-pie-chart',
                template: "\n    <div [style.width.px]=\"width\" [style.height.px]=\"height\">\n      <div class=\"advanced-pie chart\" [style.width.px]=\"dims.width\" [style.height.px]=\"dims.height\">\n        <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n          <svg:g [attr.transform]=\"transform\" class=\"pie chart\">\n            <svg:g\n              ngx-charts-pie-series\n              [colors]=\"colors\"\n              [series]=\"results\"\n              [innerRadius]=\"innerRadius\"\n              [activeEntries]=\"activeEntries\"\n              [outerRadius]=\"outerRadius\"\n              [gradient]=\"gradient\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              [tooltipText]=\"tooltipText\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n              [animations]=\"animations\"\n            ></svg:g>\n          </svg:g>\n        </ngx-charts-chart>\n      </div>\n      <div class=\"advanced-pie-legend-wrapper\" [style.width.px]=\"width - dims.width\" [style.height.px]=\"height\">\n        <ngx-charts-advanced-legend\n          [data]=\"results\"\n          [colors]=\"colors\"\n          [width]=\"width - dims.width - margin[1]\"\n          [label]=\"label\"\n          [animations]=\"animations\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"nameFormatting\"\n          [percentageFormatting]=\"percentageFormatting\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, true)\"\n          (deactivate)=\"onDeactivate($event, true)\"\n        >\n        </ngx-charts-advanced-legend>\n      </div>\n    </div>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{float:left}.advanced-pie,.advanced-pie-legend-wrapper{display:inline-block}"]
            }]
    }], null, { activeEntries: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], tooltipText: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], valueFormatting: [{
            type: core.Input
        }], nameFormatting: [{
            type: core.Input
        }], percentageFormatting: [{
            type: core.Input
        }] }); })();
        return AdvancedPieChartComponent;
    }(BaseChartComponent));
    AdvancedPieChartComponent.propDecorators = {
        gradient: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        label: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        valueFormatting: [{ type: core.Input }],
        nameFormatting: [{ type: core.Input }],
        percentageFormatting: [{ type: core.Input }]
    };

    var PieLabelComponent = /** @class */ (function () {
        function PieLabelComponent(platformId) {
            this.platformId = platformId;
            this.animations = true;
            this.labelTrim = true;
            this.labelTrimSize = 10;
            this.trimLabel = trimLabel;
        }
        PieLabelComponent.prototype.ngOnChanges = function (changes) {
            this.setTransforms();
            this.update();
        };
        PieLabelComponent.prototype.setTransforms = function () {
            if (common.isPlatformServer(this.platformId)) {
                this.styleTransform = "translate3d(" + this.textX + "px," + this.textY + "px, 0)";
                this.attrTransform = "translate(" + this.textX + "," + this.textY + ")";
                this.textTransition = !this.animations ? null : 'transform 0.75s';
            }
            else {
                var isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
                this.styleTransform = isIE ? null : "translate3d(" + this.textX + "px," + this.textY + "px, 0)";
                this.attrTransform = !isIE ? null : "translate(" + this.textX + "," + this.textY + ")";
                this.textTransition = isIE || !this.animations ? null : 'transform 0.75s';
            }
        };
        PieLabelComponent.prototype.update = function () {
            var startRadius = this.radius;
            if (this.explodeSlices) {
                startRadius = (this.radius * this.value) / this.max;
            }
            var innerArc = d3Shape.arc().innerRadius(startRadius).outerRadius(startRadius);
            // Calculate innerPos then scale outer position to match label position
            var innerPos = innerArc.centroid(this.data);
            var scale = this.data.pos[1] / innerPos[1];
            if (this.data.pos[1] === 0 || innerPos[1] === 0) {
                scale = 1;
            }
            var outerPos = [scale * innerPos[0], scale * innerPos[1]];
            this.line = "M" + innerPos + "L" + outerPos + "L" + this.data.pos;
        };
        Object.defineProperty(PieLabelComponent.prototype, "textX", {
            get: function () {
                return this.data.pos[0];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PieLabelComponent.prototype, "textY", {
            get: function () {
                return this.data.pos[1];
            },
            enumerable: false,
            configurable: true
        });
        PieLabelComponent.prototype.textAnchor = function () {
            return this.midAngle(this.data) < Math.PI ? 'start' : 'end';
        };
        PieLabelComponent.prototype.midAngle = function (d) {
            return d.startAngle + (d.endAngle - d.startAngle) / 2;
        };
PieLabelComponent.ɵfac = function PieLabelComponent_Factory(t) { return new (t || PieLabelComponent)(ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
PieLabelComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieLabelComponent, selectors: [["g", "ngx-charts-pie-label", ""]], inputs: { animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", data: "data", radius: "radius", label: "label", color: "color", max: "max", value: "value", explodeSlices: "explodeSlices" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c37, decls: 6, vars: 17, consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]], template: function PieLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "title");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelementStart(3, "text", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
        ɵngcc0.ɵɵattribute("transform", ctx.attrTransform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵattribute("d", ctx.line)("stroke", ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieLabelComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-pie-label]',
                template: "\n    <title>{{ label }}</title>\n    <svg:g [attr.transform]=\"attrTransform\" [style.transform]=\"styleTransform\" [style.transition]=\"textTransition\">\n      <svg:text\n        class=\"pie-label\"\n        [class.animation]=\"animations\"\n        dy=\".35em\"\n        [style.textAnchor]=\"textAnchor()\"\n        [style.shapeRendering]=\"'crispEdges'\"\n      >\n        {{ labelTrim ? trimLabel(label, labelTrimSize) : label }}\n      </svg:text>\n    </svg:g>\n    <svg:path\n      [attr.d]=\"line\"\n      [attr.stroke]=\"color\"\n      fill=\"none\"\n      class=\"pie-label-line line\"\n      [class.animation]=\"animations\"\n    ></svg:path>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { animations: [{
            type: core.Input
        }], labelTrim: [{
            type: core.Input
        }], labelTrimSize: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], radius: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], color: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], value: [{
            type: core.Input
        }], explodeSlices: [{
            type: core.Input
        }] }); })();
        return PieLabelComponent;
    }());
    PieLabelComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    PieLabelComponent.propDecorators = {
        data: [{ type: core.Input }],
        radius: [{ type: core.Input }],
        label: [{ type: core.Input }],
        color: [{ type: core.Input }],
        max: [{ type: core.Input }],
        value: [{ type: core.Input }],
        explodeSlices: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        labelTrim: [{ type: core.Input }],
        labelTrimSize: [{ type: core.Input }]
    };

    var PieArcComponent = /** @class */ (function () {
        function PieArcComponent(element) {
            this.startAngle = 0;
            this.endAngle = Math.PI * 2;
            this.cornerRadius = 0;
            this.explodeSlices = false;
            this.gradient = false;
            this.animate = true;
            this.pointerEvents = true;
            this.isActive = false;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.dblclick = new core.EventEmitter();
            this.initialized = false;
            this.element = element.nativeElement;
        }
        PieArcComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        PieArcComponent.prototype.getGradient = function () {
            return this.gradient ? this.gradientFill : this.fill;
        };
        PieArcComponent.prototype.getPointerEvents = function () {
            return this.pointerEvents ? 'auto' : 'none';
        };
        PieArcComponent.prototype.update = function () {
            var calc = this.calculateArc();
            this.startOpacity = 0.5;
            this.radialGradientId = 'linearGrad' + id().toString();
            this.gradientFill = "url(#" + this.radialGradientId + ")";
            if (this.animate) {
                if (this.initialized) {
                    this.updateAnimation();
                }
                else {
                    this.loadAnimation();
                    this.initialized = true;
                }
            }
            else {
                this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
            }
        };
        PieArcComponent.prototype.calculateArc = function () {
            var outerRadius = this.outerRadius;
            if (this.explodeSlices && this.innerRadius === 0) {
                outerRadius = (this.outerRadius * this.value) / this.max;
            }
            return d3Shape.arc().innerRadius(this.innerRadius).outerRadius(outerRadius).cornerRadius(this.cornerRadius);
        };
        PieArcComponent.prototype.loadAnimation = function () {
            var node = d3Selection.select(this.element)
                .selectAll('.arc')
                .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
            var calc = this.calculateArc();
            node
                .transition()
                .attrTween('d', function (d) {
                this._current = this._current || d;
                var copyOfD = Object.assign({}, d);
                copyOfD.endAngle = copyOfD.startAngle;
                var interpolater = d3Interpolate.interpolate(copyOfD, copyOfD);
                this._current = interpolater(0);
                return function (t) {
                    return calc(interpolater(t));
                };
            })
                .transition()
                .duration(750)
                .attrTween('d', function (d) {
                this._current = this._current || d;
                var interpolater = d3Interpolate.interpolate(this._current, d);
                this._current = interpolater(0);
                return function (t) {
                    return calc(interpolater(t));
                };
            });
        };
        PieArcComponent.prototype.updateAnimation = function () {
            var node = d3Selection.select(this.element)
                .selectAll('.arc')
                .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
            var calc = this.calculateArc();
            node
                .transition()
                .duration(750)
                .attrTween('d', function (d) {
                this._current = this._current || d;
                var interpolater = d3Interpolate.interpolate(this._current, d);
                this._current = interpolater(0);
                return function (t) {
                    return calc(interpolater(t));
                };
            });
        };
        PieArcComponent.prototype.onClick = function () {
            var _this = this;
            clearTimeout(this._timeout);
            this._timeout = setTimeout(function () { return _this.select.emit(_this.data); }, 200);
        };
        PieArcComponent.prototype.onDblClick = function (event) {
            event.preventDefault();
            event.stopPropagation();
            clearTimeout(this._timeout);
            this.dblclick.emit({
                data: this.data,
                nativeEvent: event
            });
        };
PieArcComponent.ɵfac = function PieArcComponent_Factory(t) { return new (t || PieArcComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PieArcComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieArcComponent, selectors: [["g", "ngx-charts-pie-arc", ""]], inputs: { startAngle: "startAngle", endAngle: "endAngle", cornerRadius: "cornerRadius", explodeSlices: "explodeSlices", gradient: "gradient", animate: "animate", pointerEvents: "pointerEvents", isActive: "isActive", fill: "fill", innerRadius: "innerRadius", outerRadius: "outerRadius", value: "value", max: "max", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c38, decls: 3, vars: 7, consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity"]], template: function PieArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "path", 2);
        ɵngcc0.ɵɵlistener("click", function PieArcComponent_Template__svg_path_click_2_listener() { return ctx.onClick(); })("dblclick", function PieArcComponent_Template__svg_path_dblclick_2_listener($event) { return ctx.onDblClick($event); })("mouseenter", function PieArcComponent_Template__svg_path_mouseenter_2_listener() { return ctx.activate.emit(ctx.data); })("mouseleave", function PieArcComponent_Template__svg_path_mouseleave_2_listener() { return ctx.deactivate.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("pointer-events", ctx.getPointerEvents());
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵattribute("d", ctx.path)("fill", ctx.getGradient());
    } }, directives: [ɵngcc1.NgIf, SvgRadialGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieArcComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-pie-arc]',
                template: "\n    <svg:g class=\"arc-group\">\n      <svg:defs *ngIf=\"gradient\">\n        <svg:g\n          ngx-charts-svg-radial-gradient\n          [color]=\"fill\"\n          orientation=\"vertical\"\n          [name]=\"radialGradientId\"\n          [startOpacity]=\"startOpacity\"\n        />\n      </svg:defs>\n      <svg:path\n        [attr.d]=\"path\"\n        class=\"arc\"\n        [class.active]=\"isActive\"\n        [attr.fill]=\"getGradient()\"\n        (click)=\"onClick()\"\n        (dblclick)=\"onDblClick($event)\"\n        (mouseenter)=\"activate.emit(data)\"\n        (mouseleave)=\"deactivate.emit(data)\"\n        [style.pointer-events]=\"getPointerEvents()\"\n      />\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { startAngle: [{
            type: core.Input
        }], endAngle: [{
            type: core.Input
        }], cornerRadius: [{
            type: core.Input
        }], explodeSlices: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], animate: [{
            type: core.Input
        }], pointerEvents: [{
            type: core.Input
        }], isActive: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], dblclick: [{
            type: core.Output
        }], fill: [{
            type: core.Input
        }], innerRadius: [{
            type: core.Input
        }], outerRadius: [{
            type: core.Input
        }], value: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }] }); })();
        return PieArcComponent;
    }());
    PieArcComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    PieArcComponent.propDecorators = {
        fill: [{ type: core.Input }],
        startAngle: [{ type: core.Input }],
        endAngle: [{ type: core.Input }],
        innerRadius: [{ type: core.Input }],
        outerRadius: [{ type: core.Input }],
        cornerRadius: [{ type: core.Input }],
        value: [{ type: core.Input }],
        max: [{ type: core.Input }],
        data: [{ type: core.Input }],
        explodeSlices: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        animate: [{ type: core.Input }],
        pointerEvents: [{ type: core.Input }],
        isActive: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        dblclick: [{ type: core.Output }]
    };

    var PieChartComponent = /** @class */ (function (_super) {
        __extends(PieChartComponent, _super);
        function PieChartComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.labels = false;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.explodeSlices = false;
            _this.doughnut = false;
            _this.arcWidth = 0.25;
            _this.activeEntries = [];
            _this.tooltipDisabled = false;
            _this.trimLabels = true;
            _this.maxLabelLength = 10;
            _this.dblclick = new core.EventEmitter();
            _this.select = new core.EventEmitter();
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            return _this;
        }
        PieChartComponent.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            if (this.labels && this.hasNoOptionalMarginsSet()) {
                this.margins = [30, 80, 30, 80];
            }
            else if (!this.labels && this.hasNoOptionalMarginsSet()) {
                // default value for margins
                this.margins = [20, 20, 20, 20];
            }
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margins,
                showLegend: this.legend,
                legendPosition: this.legendPosition
            });
            this.formatDates();
            var xOffset = this.margins[3] + this.dims.width / 2;
            var yOffset = this.margins[0] + this.dims.height / 2;
            this.translation = "translate(" + xOffset + ", " + yOffset + ")";
            this.outerRadius = Math.min(this.dims.width, this.dims.height);
            if (this.labels) {
                // make room for labels
                this.outerRadius /= 3;
            }
            else {
                this.outerRadius /= 2;
            }
            this.innerRadius = 0;
            if (this.doughnut) {
                this.innerRadius = this.outerRadius * (1 - this.arcWidth);
            }
            this.domain = this.getDomain();
            // sort data according to domain
            this.data = this.results.sort(function (a, b) {
                return _this.domain.indexOf(a.name) - _this.domain.indexOf(b.name);
            });
            this.setColors();
            this.legendOptions = this.getLegendOptions();
        };
        PieChartComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        PieChartComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        PieChartComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
        PieChartComponent.prototype.getLegendOptions = function () {
            return {
                scaleType: 'ordinal',
                domain: this.domain,
                colors: this.colors,
                title: this.legendTitle,
                position: this.legendPosition
            };
        };
        PieChartComponent.prototype.onActivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        PieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        PieChartComponent.prototype.hasNoOptionalMarginsSet = function () {
            return !this.margins || this.margins.length <= 0;
        };
PieChartComponent.ɵfac = /*@__PURE__*/ function () { var ɵPieChartComponent_BaseFactory; return function PieChartComponent_Factory(t) { return (ɵPieChartComponent_BaseFactory || (ɵPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieChartComponent)))(t || PieChartComponent); }; }();
PieChartComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieChartComponent, selectors: [["ngx-charts-pie-chart"]], contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { margins: "margins", activeEntries: "activeEntries", labels: "labels", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", explodeSlices: "explodeSlices", doughnut: "doughnut", arcWidth: "arcWidth", gradient: "gradient", tooltipDisabled: "tooltipDisabled", labelFormatting: "labelFormatting", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText" }, outputs: { dblclick: "dblclick", select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 24, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "dblclick", "select", "activate", "deactivate"]], template: function PieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("dblclick", function PieChartComponent_Template__svg_g_dblclick_2_listener($event) { return ctx.dblclick.emit($event); })("select", function PieChartComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); })("activate", function PieChartComponent_Template__svg_g_activate_2_listener($event) { return ctx.onActivate($event); })("deactivate", function PieChartComponent_Template__svg_g_deactivate_2_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(21, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.translation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: function () { return [ChartComponent, PieSeriesComponent]; }, styles: [_c24, _c39], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieChartComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-pie-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"translation\" class=\"pie-chart chart\">\n        <svg:g\n          ngx-charts-pie-series\n          [colors]=\"colors\"\n          [series]=\"data\"\n          [showLabels]=\"labels\"\n          [labelFormatting]=\"labelFormatting\"\n          [trimLabels]=\"trimLabels\"\n          [maxLabelLength]=\"maxLabelLength\"\n          [activeEntries]=\"activeEntries\"\n          [innerRadius]=\"innerRadius\"\n          [outerRadius]=\"outerRadius\"\n          [explodeSlices]=\"explodeSlices\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (dblclick)=\"dblclick.emit($event)\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{-webkit-animation:fadeIn .75s ease-in;animation:fadeIn .75s ease-in}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{-webkit-animation:drawOut 3s linear;animation:drawOut 3s linear;transition:d .75s}@-webkit-keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"]
            }]
    }], null, { margins: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], labels: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], explodeSlices: [{
            type: core.Input
        }], doughnut: [{
            type: core.Input
        }], arcWidth: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], trimLabels: [{
            type: core.Input
        }], maxLabelLength: [{
            type: core.Input
        }], tooltipText: [{
            type: core.Input
        }], dblclick: [{
            type: core.Output
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return PieChartComponent;
    }(BaseChartComponent));
    PieChartComponent.propDecorators = {
        labels: [{ type: core.Input }],
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        explodeSlices: [{ type: core.Input }],
        doughnut: [{ type: core.Input }],
        arcWidth: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        trimLabels: [{ type: core.Input }],
        maxLabelLength: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        dblclick: [{ type: core.Output }],
        margins: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    function gridSize(dims, len, minWidth) {
        var rows = 1;
        var cols = len;
        var width = dims.width;
        if (width > minWidth) {
            while (width / cols < minWidth) {
                rows += 1;
                cols = Math.ceil(len / rows);
            }
        }
        return [cols, rows];
    }
    function gridLayout(dims, data, minWidth, designatedTotal) {
        var xScale = d3Scale.scaleBand();
        var yScale = d3Scale.scaleBand();
        var width = dims.width;
        var height = dims.height;
        var _a = __read(gridSize(dims, data.length, minWidth), 2), columns = _a[0], rows = _a[1];
        var xDomain = [];
        var yDomain = [];
        for (var i = 0; i < rows; i++) {
            yDomain.push(i);
        }
        for (var i = 0; i < columns; i++) {
            xDomain.push(i);
        }
        xScale.domain(xDomain);
        yScale.domain(yDomain);
        xScale.rangeRound([0, width], 0.1);
        yScale.rangeRound([0, height], 0.1);
        var res = [];
        var total = designatedTotal ? designatedTotal : getTotal(data);
        var cardWidth = xScale.bandwidth();
        var cardHeight = yScale.bandwidth();
        for (var i = 0; i < data.length; i++) {
            res[i] = {};
            res[i].data = {
                name: data[i] ? data[i].name : '',
                value: data[i] ? data[i].value : undefined,
                extra: data[i] ? data[i].extra : undefined,
                label: data[i] ? data[i].label : ''
            };
            res[i].x = xScale(i % columns);
            res[i].y = yScale(Math.floor(i / columns));
            res[i].width = cardWidth;
            res[i].height = cardHeight;
            res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
            res[i].data.total = total;
        }
        return res;
    }
    function getTotal(results) {
        return results.map(function (d) { return (d ? d.value : 0); }).reduce(function (sum, val) { return sum + val; }, 0);
    }

    var PieGridComponent = /** @class */ (function (_super) {
        __extends(PieGridComponent, _super);
        function PieGridComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.tooltipDisabled = false;
            _this.label = 'Total';
            _this.minWidth = 150;
            _this.activeEntries = [];
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.margin = [20, 20, 20, 20];
            return _this;
        }
        PieGridComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin
            });
            this.formatDates();
            this.domain = this.getDomain();
            this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
            this.transform = "translate(" + this.margin[3] + " , " + this.margin[0] + ")";
            this.series = this.getSeries();
            this.setColors();
            this.tooltipText = this.tooltipText || this.defaultTooltipText;
        };
        PieGridComponent.prototype.defaultTooltipText = function (_a) {
            var data = _a.data;
            var label = trimLabel(formatLabel(data.name));
            var val = data.value.toLocaleString();
            return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
        };
        PieGridComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        PieGridComponent.prototype.getSeries = function () {
            var _this = this;
            var total = this.designatedTotal ? this.designatedTotal : this.getTotal();
            return this.data.map(function (d) {
                var baselineLabelHeight = 20;
                var padding = 10;
                var name = d.data.name;
                var label = formatLabel(name);
                var value = d.data.value;
                var radius = d3Array.min([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
                var innerRadius = radius * 0.9;
                var count = 0;
                var colors = function () {
                    count += 1;
                    if (count === 1) {
                        return 'rgba(100,100,100,0.3)';
                    }
                    else {
                        return _this.colorScale.getColor(label);
                    }
                };
                var xPos = d.x + (d.width - padding) / 2;
                var yPos = d.y + (d.height - baselineLabelHeight) / 2;
                return {
                    transform: "translate(" + xPos + ", " + yPos + ")",
                    colors: colors,
                    innerRadius: innerRadius,
                    outerRadius: radius,
                    name: name,
                    label: trimLabel(label),
                    total: value,
                    value: value,
                    percent: d3Format.format('.1%')(d.data.percent),
                    data: [
                        d,
                        {
                            data: {
                                other: true,
                                value: total - value,
                                name: d.data.name
                            }
                        }
                    ]
                };
            });
        };
        PieGridComponent.prototype.getTotal = function () {
            return this.results.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        };
        PieGridComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        PieGridComponent.prototype.setColors = function () {
            this.colorScale = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
        PieGridComponent.prototype.onActivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        PieGridComponent.prototype.onDeactivate = function (item, fromLegend) {
            if (fromLegend === void 0) { fromLegend = false; }
            item = this.results.find(function (d) {
                if (fromLegend) {
                    return d.label === item.name;
                }
                else {
                    return d.name === item.name;
                }
            });
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
PieGridComponent.ɵfac = /*@__PURE__*/ function () { var ɵPieGridComponent_BaseFactory; return function PieGridComponent_Factory(t) { return (ɵPieGridComponent_BaseFactory || (ɵPieGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieGridComponent)))(t || PieGridComponent); }; }();
PieGridComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieGridComponent, selectors: [["ngx-charts-pie-grid"]], contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { tooltipText: "tooltipText", activeEntries: "activeEntries", designatedTotal: "designatedTotal", tooltipDisabled: "tooltipDisabled", label: "label", minWidth: "minWidth" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]], template: function PieGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(5, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.series);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, PieGridSeriesComponent, TooltipDirective, ɵngcc1.NgIf, CountUpDirective]; }, styles: [_c24, ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieGridComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-pie-grid',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"pie-grid chart\">\n        <svg:g *ngFor=\"let series of series\" class=\"pie-grid-item\" [attr.transform]=\"series.transform\">\n          <svg:g\n            ngx-charts-pie-grid-series\n            [colors]=\"series.colors\"\n            [data]=\"series.data\"\n            [innerRadius]=\"series.innerRadius\"\n            [outerRadius]=\"series.outerRadius\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText({ data: series })\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"series.data[0].data\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          />\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label percent-label\"\n            dy=\"-0.5em\"\n            x=\"0\"\n            y=\"5\"\n            ngx-charts-count-up\n            [countTo]=\"series.percent\"\n            [countSuffix]=\"'%'\"\n            text-anchor=\"middle\"\n          ></svg:text>\n          <svg:text *ngIf=\"!animations\" class=\"label percent-label\" dy=\"-0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.percent.toLocaleString() }}\n          </svg:text>\n          <svg:text class=\"label\" dy=\"0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.label }}\n          </svg:text>\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n            ngx-charts-count-up\n            [countTo]=\"series.total\"\n            [countPrefix]=\"label + ': '\"\n          ></svg:text>\n          <svg:text\n            *ngIf=\"!animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n          >\n            {{ label }}: {{ series.total.toLocaleString() }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"]
            }]
    }], null, { tooltipText: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], designatedTotal: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], minWidth: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return PieGridComponent;
    }(BaseChartComponent));
    PieGridComponent.propDecorators = {
        designatedTotal: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        label: [{ type: core.Input }],
        minWidth: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var PieGridSeriesComponent = /** @class */ (function () {
        function PieGridSeriesComponent(element) {
            this.innerRadius = 70;
            this.outerRadius = 80;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.element = element.nativeElement;
        }
        PieGridSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        PieGridSeriesComponent.prototype.update = function () {
            this.layout = d3Shape.pie()
                .value(function (d) { return d.data.value; })
                .sort(null);
            this.arcs = this.getArcs();
        };
        PieGridSeriesComponent.prototype.getArcs = function () {
            var _this = this;
            return this.layout(this.data).map(function (arc, index) {
                var label = arc.data.data.name;
                var other = arc.data.data.other;
                if (index === 0) {
                    arc.startAngle = 0;
                }
                var color = _this.colors(label);
                return {
                    data: arc.data.data,
                    class: 'arc ' + 'arc' + index,
                    fill: color,
                    startAngle: other ? 0 : arc.startAngle,
                    endAngle: arc.endAngle,
                    animate: _this.animations && !other,
                    pointerEvents: !other
                };
            });
        };
        PieGridSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(this.data[0].data);
        };
        PieGridSeriesComponent.prototype.trackBy = function (index, item) {
            return item.data.name;
        };
        PieGridSeriesComponent.prototype.label = function (arc) {
            return arc.data.name;
        };
        PieGridSeriesComponent.prototype.color = function (arc) {
            return this.colors(this.label(arc));
        };
PieGridSeriesComponent.ɵfac = function PieGridSeriesComponent_Factory(t) { return new (t || PieGridSeriesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PieGridSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieGridSeriesComponent, selectors: [["g", "ngx-charts-pie-grid-series", ""]], inputs: { innerRadius: "innerRadius", outerRadius: "outerRadius", animations: "animations", colors: "colors", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c41, decls: 2, vars: 2, consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate"]], template: function PieGridSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, PieArcComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieGridSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-pie-grid-series]',
                template: "\n    <svg:g class=\"pie-grid-arcs\">\n      <svg:g\n        ngx-charts-pie-arc\n        *ngFor=\"let arc of arcs; trackBy: trackBy\"\n        [attr.class]=\"arc.class\"\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [data]=\"arc.data\"\n        [gradient]=\"false\"\n        [pointerEvents]=\"arc.pointerEvents\"\n        [animate]=\"arc.animate\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { innerRadius: [{
            type: core.Input
        }], outerRadius: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], colors: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }] }); })();
        return PieGridSeriesComponent;
    }());
    PieGridSeriesComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    PieGridSeriesComponent.propDecorators = {
        colors: [{ type: core.Input }],
        data: [{ type: core.Input }],
        innerRadius: [{ type: core.Input }],
        outerRadius: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var PieSeriesComponent = /** @class */ (function () {
        function PieSeriesComponent() {
            this.series = [];
            this.innerRadius = 60;
            this.outerRadius = 80;
            this.trimLabels = true;
            this.maxLabelLength = 10;
            this.tooltipDisabled = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
            this.dblclick = new core.EventEmitter();
        }
        PieSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        PieSeriesComponent.prototype.update = function () {
            var pieGenerator = d3Shape.pie()
                .value(function (d) { return d.value; })
                .sort(null);
            var arcData = pieGenerator(this.series);
            this.max = d3Array.max(arcData, function (d) {
                return d.value;
            });
            this.data = this.calculateLabelPositions(arcData);
            this.tooltipText = this.tooltipText || this.defaultTooltipText;
        };
        PieSeriesComponent.prototype.midAngle = function (d) {
            return d.startAngle + (d.endAngle - d.startAngle) / 2;
        };
        PieSeriesComponent.prototype.outerArc = function () {
            var factor = 1.5;
            return d3Shape.arc()
                .innerRadius(this.outerRadius * factor)
                .outerRadius(this.outerRadius * factor);
        };
        PieSeriesComponent.prototype.calculateLabelPositions = function (pieData) {
            var _this = this;
            var factor = 1.5;
            var minDistance = 10;
            var labelPositions = pieData;
            labelPositions.forEach(function (d) {
                d.pos = _this.outerArc().centroid(d);
                d.pos[0] = factor * _this.outerRadius * (_this.midAngle(d) < Math.PI ? 1 : -1);
            });
            for (var i = 0; i < labelPositions.length - 1; i++) {
                var a = labelPositions[i];
                if (!this.labelVisible(a)) {
                    continue;
                }
                for (var j = i + 1; j < labelPositions.length; j++) {
                    var b = labelPositions[j];
                    if (!this.labelVisible(b)) {
                        continue;
                    }
                    // if they're on the same side
                    if (b.pos[0] * a.pos[0] > 0) {
                        // if they're overlapping
                        var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                        if (o > 0) {
                            // push the second up or down
                            b.pos[1] += Math.sign(b.pos[0]) * o;
                        }
                    }
                }
            }
            return labelPositions;
        };
        PieSeriesComponent.prototype.labelVisible = function (myArc) {
            return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
        };
        PieSeriesComponent.prototype.getTooltipTitle = function (a) {
            return this.tooltipTemplate ? undefined : this.tooltipText(a);
        };
        PieSeriesComponent.prototype.labelText = function (myArc) {
            if (this.labelFormatting) {
                return this.labelFormatting(myArc.data.name);
            }
            return this.label(myArc);
        };
        PieSeriesComponent.prototype.label = function (myArc) {
            return formatLabel(myArc.data.name);
        };
        PieSeriesComponent.prototype.defaultTooltipText = function (myArc) {
            var label = this.label(myArc);
            var val = formatLabel(myArc.data.value);
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
        };
        PieSeriesComponent.prototype.color = function (myArc) {
            return this.colors.getColor(this.label(myArc));
        };
        PieSeriesComponent.prototype.trackBy = function (index, item) {
            return item.data.name;
        };
        PieSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        PieSeriesComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name && entry.series === d.series;
            });
            return item !== undefined;
        };
PieSeriesComponent.ɵfac = function PieSeriesComponent_Factory(t) { return new (t || PieSeriesComponent)(); };
PieSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PieSeriesComponent, selectors: [["g", "ngx-charts-pie-series", ""]], inputs: { series: "series", innerRadius: "innerRadius", outerRadius: "outerRadius", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", colors: "colors", dims: "dims", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c42, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", "dblclick"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]], template: function PieSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, PieArcComponent, TooltipDirective, PieLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-pie-series]',
                template: "\n    <svg:g *ngFor=\"let arc of data; trackBy: trackBy\">\n      <svg:g\n        ngx-charts-pie-label\n        *ngIf=\"labelVisible(arc)\"\n        [data]=\"arc\"\n        [radius]=\"outerRadius\"\n        [color]=\"color(arc)\"\n        [label]=\"labelText(arc)\"\n        [labelTrim]=\"trimLabels\"\n        [labelTrimSize]=\"maxLabelLength\"\n        [max]=\"max\"\n        [value]=\"arc.value\"\n        [explodeSlices]=\"explodeSlices\"\n        [animations]=\"animations\"\n      ></svg:g>\n      <svg:g\n        ngx-charts-pie-arc\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [gradient]=\"gradient\"\n        [data]=\"arc.data\"\n        [max]=\"max\"\n        [explodeSlices]=\"explodeSlices\"\n        [isActive]=\"isActive(arc.data)\"\n        [animate]=\"animations\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n        (dblclick)=\"dblclick.emit($event)\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"getTooltipTitle(arc)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"arc.data\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { series: [{
            type: core.Input
        }], innerRadius: [{
            type: core.Input
        }], outerRadius: [{
            type: core.Input
        }], trimLabels: [{
            type: core.Input
        }], maxLabelLength: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], dblclick: [{
            type: core.Output
        }], tooltipText: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], explodeSlices: [{
            type: core.Input
        }], showLabels: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return PieSeriesComponent;
    }());
    PieSeriesComponent.propDecorators = {
        colors: [{ type: core.Input }],
        series: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        innerRadius: [{ type: core.Input }],
        outerRadius: [{ type: core.Input }],
        explodeSlices: [{ type: core.Input }],
        showLabels: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        trimLabels: [{ type: core.Input }],
        maxLabelLength: [{ type: core.Input }],
        tooltipText: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        dblclick: [{ type: core.Output }]
    };

    var PieChartModule = /** @class */ (function () {
        function PieChartModule() {
        }
PieChartModule.ɵfac = function PieChartModule_Factory(t) { return new (t || PieChartModule)(); };
PieChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PieChartModule });
PieChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ],
                exports: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PieChartModule, { declarations: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent], imports: [ChartCommonModule], exports: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent] }); })();
        return PieChartModule;
    }());

    var PolarChartModule = /** @class */ (function () {
        function PolarChartModule() {
        }
PolarChartModule.ɵfac = function PolarChartModule_Factory(t) { return new (t || PolarChartModule)(); };
PolarChartModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PolarChartModule });
PolarChartModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule, PieChartModule, LineChartModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarChartModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, LineChartModule],
                declarations: [PolarChartComponent, PolarSeriesComponent],
                exports: [PolarChartComponent, PolarSeriesComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PolarChartModule, { declarations: [PolarChartComponent, PolarSeriesComponent], imports: [ChartCommonModule, PieChartModule, LineChartModule], exports: [PolarChartComponent, PolarSeriesComponent] }); })();
        return PolarChartModule;
    }());

    function calculateTextWidth(fontFamilyKey, text, defaultWidth) {
        if (defaultWidth === void 0) { defaultWidth = 8; }
        return text.split('').reduce(function (acc, curr) {
            var width = fontFamilyKey[curr] || defaultWidth;
            return acc + width;
        }, 0);
    }

    var VERDANA_FONT_WIDTHS_16_PX = {
        '0': 10,
        '1': 10,
        '2': 10,
        '3': 10,
        '4': 10,
        '5': 10,
        '6': 10,
        '7': 10,
        '8': 10,
        '9': 10,
        A: 11,
        B: 11,
        C: 11,
        D: 12,
        E: 10,
        F: 9,
        G: 12,
        H: 12,
        I: 7,
        J: 7,
        K: 11,
        L: 9,
        M: 13,
        N: 12,
        O: 13,
        P: 10,
        Q: 13,
        R: 11,
        S: 11,
        T: 10,
        U: 12,
        V: 11,
        W: 16,
        X: 11,
        Y: 10,
        Z: 11,
        a: 10,
        b: 10,
        c: 8,
        d: 10,
        e: 10,
        f: 6,
        g: 10,
        h: 10,
        i: 4,
        j: 6,
        k: 9,
        l: 4,
        m: 16,
        n: 10,
        o: 10,
        p: 10,
        q: 10,
        r: 7,
        s: 8,
        t: 6,
        u: 10,
        v: 9,
        w: 13,
        x: 9,
        y: 9,
        z: 8,
        '!': 6,
        '@': 16,
        '#': 13,
        $: 10,
        '%': 17,
        '^': 13,
        '&': 12,
        '*': 10,
        '(': 7,
        ')': 7,
        _: 10,
        '-': 7,
        '+': 13,
        '=': 13,
        ',': 6,
        '.': 6,
        '/': 7,
        "'": 4,
        ':': 7,
        '|': 7,
        '?': 9,
        ';': 7,
        '<': 13,
        '>': 13
    };

    var CardComponent = /** @class */ (function () {
        function CardComponent(element, cd, zone, platformId) {
            this.cd = cd;
            this.zone = zone;
            this.platformId = platformId;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.value = '';
            this.textFontSize = 12;
            this.textTransform = '';
            this.initialized = false;
            this.bandHeight = 10;
            this.textPadding = [10, 20, 5, 20];
            this.labelFontSize = 15;
            this.element = element.nativeElement;
        }
        CardComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        CardComponent.prototype.ngOnInit = function () {
            if (common.isPlatformServer(this.platformId)) {
                this.scaleTextSSR();
            }
        };
        CardComponent.prototype.ngOnDestroy = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                cancelAnimationFrame(this.animationReq);
            }
        };
        CardComponent.prototype.update = function () {
            var _this = this;
            this.zone.run(function () {
                var hasValue = _this.data && typeof _this.data.value !== 'undefined';
                var valueFormatting = _this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
                var labelFormatting = _this.labelFormatting || (function (card) { return escapeLabel(trimLabel(card.label, 55)); });
                _this.transform = "translate(" + _this.x + " , " + _this.y + ")";
                _this.textWidth = Math.max(0, _this.width) - _this.textPadding[1] - _this.textPadding[3];
                _this.cardWidth = Math.max(0, _this.width);
                _this.cardHeight = Math.max(0, _this.height);
                _this.label = _this.label ? _this.label : _this.data.name;
                var cardData = {
                    label: _this.label,
                    data: _this.data,
                    value: _this.data.value
                };
                _this.formattedLabel = labelFormatting(cardData);
                _this.transformBand = "translate(0 , " + (_this.cardHeight - _this.bandHeight) + ")";
                var value = hasValue ? valueFormatting(cardData) : '';
                _this.value = _this.paddedValue(value);
                _this.setPadding();
                _this.bandPath = roundedRect(0, 0, _this.cardWidth, _this.bandHeight, 3, [false, false, true, true]);
                setTimeout(function () {
                    if (common.isPlatformBrowser(_this.platformId)) {
                        _this.scaleText();
                    }
                    _this.value = value;
                    if (hasValue && !_this.initialized) {
                        setTimeout(function () { return _this.startCount(); }, 20);
                    }
                }, 8);
            });
        };
        CardComponent.prototype.paddedValue = function (value) {
            if (this.medianSize && this.medianSize > value.length) {
                value += '\u2007'.repeat(this.medianSize - value.length);
            }
            return value;
        };
        CardComponent.prototype.startCount = function () {
            var _this = this;
            if (!this.initialized && this.animations) {
                cancelAnimationFrame(this.animationReq);
                var val_1 = this.data.value;
                var decs = decimalChecker(val_1);
                var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
                var callback = function (_a) {
                    var value = _a.value, finished = _a.finished;
                    _this.zone.run(function () {
                        value = finished ? val_1 : value;
                        _this.value = valueFormatting_1({ label: _this.label, data: _this.data, value: value });
                        if (!finished) {
                            _this.value = _this.paddedValue(_this.value);
                        }
                        _this.cd.markForCheck();
                    });
                };
                this.animationReq = count(0, val_1, decs, 1, callback);
                this.initialized = true;
            }
        };
        CardComponent.prototype.scaleText = function () {
            var _this = this;
            this.zone.run(function () {
                var _a = _this.textEl.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
                if (width === 0 || height === 0) {
                    return;
                }
                var textPadding = (_this.textPadding[1] = _this.textPadding[3] = _this.cardWidth / 8);
                var availableWidth = _this.cardWidth - 2 * textPadding;
                var availableHeight = _this.cardHeight / 3;
                var resizeScale = Math.min(availableWidth / width, availableHeight / height);
                _this.textFontSize = Math.floor(_this.textFontSize * resizeScale);
                _this.labelFontSize = Math.min(_this.textFontSize, 15);
                _this.setPadding();
                _this.cd.markForCheck();
            });
        };
        CardComponent.prototype.scaleTextSSR = function () {
            var width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, this.value, 10);
            var height = 18;
            var textPadding = (this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8);
            var availableWidth = this.cardWidth - 2 * textPadding;
            var availableHeight = this.cardHeight / 3;
            var resizeScale = Math.min(availableWidth / width, availableHeight / height);
            this.textFontSize = Math.floor(this.textFontSize * resizeScale);
            this.labelFontSize = Math.min(this.textFontSize, 15);
            this.setPadding();
        };
        CardComponent.prototype.setPadding = function () {
            this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
            var padding = this.cardHeight / 2;
            this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
            this.textPadding[2] = padding - this.labelFontSize;
        };
        CardComponent.prototype.onClick = function () {
            this.select.emit(this.data);
        };
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(core.PLATFORM_ID)); };
CardComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["g", "ngx-charts-card", ""]], viewQuery: function CardComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { animations: "animations", color: "color", bandColor: "bandColor", textColor: "textColor", x: "x", y: "y", width: "width", height: "height", label: "label", data: "data", medianSize: "medianSize", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c44, decls: 10, vars: 25, consts: [[1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["textEl", ""], ["stroke", "none", 1, "card-band"]], template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵlistener("click", function CardComponent_Template__svg_g_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelement(1, "rect", 1);
        ɵngcc0.ɵɵtemplate(2, CardComponent__svg_path_2_Template, 1, 3, "path", 2);
        ɵngcc0.ɵɵelementStart(3, "title");
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "foreignObject", 3);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(6, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(7, "text", 5, 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.color);
        ɵngcc0.ɵɵattribute("width", ctx.cardWidth)("height", ctx.cardHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
        ɵngcc0.ɵɵproperty("innerHTML", ctx.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.value, " ");
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-card]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\" (click)=\"onClick()\">\n      <svg:rect class=\"card\" [style.fill]=\"color\" [attr.width]=\"cardWidth\" [attr.height]=\"cardHeight\" rx=\"3\" ry=\"3\" />\n      <svg:path\n        *ngIf=\"bandColor && bandColor !== color\"\n        class=\"card-band\"\n        [attr.fill]=\"bandColor\"\n        [attr.transform]=\"transformBand\"\n        stroke=\"none\"\n        [attr.d]=\"bandPath\"\n      />\n      <title>{{ label }}</title>\n      <svg:foreignObject\n        class=\"trimmed-label\"\n        x=\"5\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"cardHeight - textPadding[2]\"\n        [attr.width]=\"textWidth\"\n        [attr.height]=\"labelFontSize + textPadding[2]\"\n        alignment-baseline=\"hanging\"\n      >\n        <xhtml:p\n          [style.color]=\"textColor\"\n          [style.fontSize.px]=\"labelFontSize\"\n          [style.lineHeight.px]=\"labelFontSize\"\n          [innerHTML]=\"formattedLabel\"\n        >\n        </xhtml:p>\n      </svg:foreignObject>\n      <svg:text\n        #textEl\n        class=\"value-text\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"textPadding[0]\"\n        [style.fill]=\"textColor\"\n        text-anchor=\"start\"\n        alignment-baseline=\"hanging\"\n        [style.font-size.pt]=\"textFontSize\"\n      >\n        {{ value }}\n      </svg:text>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [core.PLATFORM_ID]
            }] }]; }, { animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], color: [{
            type: core.Input
        }], bandColor: [{
            type: core.Input
        }], textColor: [{
            type: core.Input
        }], x: [{
            type: core.Input
        }], y: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], medianSize: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], textEl: [{
            type: core.ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
        return CardComponent;
    }());
    CardComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef },
        { type: core.NgZone },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
    ]; };
    CardComponent.propDecorators = {
        color: [{ type: core.Input }],
        bandColor: [{ type: core.Input }],
        textColor: [{ type: core.Input }],
        x: [{ type: core.Input }],
        y: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        label: [{ type: core.Input }],
        data: [{ type: core.Input }],
        medianSize: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        textEl: [{ type: core.ViewChild, args: ['textEl', { static: false },] }]
    };

    /**
     * Converts a hex to RGB
     *
     * @export
     */
    function hexToRgb(value) {
        // deprecated, use d3.color()
        return d3_color.rgb(value);
    }
    /**
     * Accepts a color (string) and returns a inverted hex color (string)
     * http://stackoverflow.com/questions/9600295/automatically-change-text-color-to-assure-readability
     *
     * @export
     */
    function invertColor(value) {
        var color = d3_color.rgb(value);
        var r = color.r, g = color.g, b = color.b, opacity = color.opacity;
        if (opacity === 0) {
            return color.toString();
        }
        var yiq = (r * 299 + g * 587 + b * 114) / 1000;
        var depth = yiq >= 128 ? -0.8 : 0.8;
        return shadeRGBColor(color, depth);
    }
    /**
     * Given a rgb, it will darken/lighten
     * http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
     *
     * @export
     * @param \{ r, g, b }
     */
    function shadeRGBColor(_a, percent) {
        var r = _a.r, g = _a.g, b = _a.b;
        var t = percent < 0 ? 0 : 255;
        var p = percent < 0 ? percent * -1 : percent;
        r = Math.round((t - r) * p) + r;
        g = Math.round((t - g) * p) + g;
        b = Math.round((t - b) * p) + b;
        return "rgb(" + r + ", " + g + ", " + b + ")";
    }

    var CardSeriesComponent = /** @class */ (function () {
        function CardSeriesComponent() {
            this.innerPadding = 15;
            this.emptyColor = 'rgba(0, 0, 0, 0)';
            this.animations = true;
            this.select = new core.EventEmitter();
        }
        CardSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        CardSeriesComponent.prototype.update = function () {
            if (this.data.length > 2) {
                var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
                var sortedLengths = this.data
                    .map(function (d) {
                    var hasValue = d && d.data && typeof d.data.value !== 'undefined' && d.data.value !== null;
                    return hasValue
                        ? valueFormatting_1({
                            data: d.data,
                            label: d ? d.data.name : '',
                            value: d && d.data ? d.data.value : ''
                        }).length
                        : 0;
                })
                    .sort(function (a, b) { return b - a; });
                var idx = Math.ceil(this.data.length / 2);
                this.medianSize = sortedLengths[idx];
            }
            var cards = this.getCards();
            this.cards = cards.filter(function (d) { return d.data.value !== null; });
            this.emptySlots = cards.filter(function (d) { return d.data.value === null; });
        };
        CardSeriesComponent.prototype.getCards = function () {
            var _this = this;
            var yPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
            var xPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
            return this.data.map(function (d, index) {
                var label = d.data.name;
                if (label && label.constructor.name === 'Date') {
                    label = label.toLocaleDateString();
                }
                else {
                    label = label ? label.toLocaleString() : label;
                }
                var value = d.data.value;
                var valueColor = label ? _this.colors.getColor(label) : _this.emptyColor;
                var color = _this.cardColor || valueColor || '#000';
                return {
                    x: d.x,
                    y: d.y,
                    width: d.width - xPadding,
                    height: d.height - yPadding,
                    color: color,
                    bandColor: _this.bandColor || valueColor,
                    textColor: _this.textColor || invertColor(color),
                    label: label,
                    data: d.data,
                    tooltipText: label + ": " + value
                };
            });
        };
        CardSeriesComponent.prototype.trackBy = function (index, card) {
            return card.label;
        };
        CardSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
CardSeriesComponent.ɵfac = function CardSeriesComponent_Factory(t) { return new (t || CardSeriesComponent)(); };
CardSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CardSeriesComponent, selectors: [["g", "ngx-charts-card-series", ""]], inputs: { innerPadding: "innerPadding", emptyColor: "emptyColor", animations: "animations", data: "data", slots: "slots", dims: "dims", colors: "colors", cardColor: "cardColor", bandColor: "bandColor", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c45, decls: 2, vars: 4, consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select"]], template: function CardSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0);
        ɵngcc0.ɵɵtemplate(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CardComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-card-series]',
                template: "\n    <svg:rect\n      *ngFor=\"let c of emptySlots; trackBy: trackBy\"\n      class=\"card-empty\"\n      [attr.x]=\"c.x\"\n      [attr.y]=\"c.y\"\n      [style.fill]=\"emptyColor\"\n      [attr.width]=\"c.width\"\n      [attr.height]=\"c.height\"\n      rx=\"3\"\n      ry=\"3\"\n    />\n    <svg:g\n      ngx-charts-card\n      *ngFor=\"let c of cards; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [color]=\"c.color\"\n      [bandColor]=\"c.bandColor\"\n      [textColor]=\"c.textColor\"\n      [data]=\"c.data\"\n      [label]=\"c.label\"\n      [medianSize]=\"medianSize\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n    />\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { innerPadding: [{
            type: core.Input
        }], emptyColor: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], slots: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], cardColor: [{
            type: core.Input
        }], bandColor: [{
            type: core.Input
        }], textColor: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }] }); })();
        return CardSeriesComponent;
    }());
    CardSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        slots: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        innerPadding: [{ type: core.Input }],
        cardColor: [{ type: core.Input }],
        bandColor: [{ type: core.Input }],
        emptyColor: [{ type: core.Input }],
        textColor: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var NumberCardComponent = /** @class */ (function (_super) {
        __extends(NumberCardComponent, _super);
        function NumberCardComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.emptyColor = 'rgba(0, 0, 0, 0)';
            _this.innerPadding = 15;
            _this.margin = [10, 10, 10, 10];
            return _this;
        }
        Object.defineProperty(NumberCardComponent.prototype, "clickable", {
            get: function () {
                return !!this.select.observers.length;
            },
            enumerable: false,
            configurable: true
        });
        NumberCardComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin
            });
            this.formatDates();
            this.domain = this.getDomain();
            this.setColors();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
            var size = gridSize(this.dims, this.results.length, 150);
            var N = size[0] * size[1];
            var data = this.results.slice();
            while (data.length < N) {
                data.push({ value: null });
            }
            this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
        };
        NumberCardComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.label; });
        };
        NumberCardComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        NumberCardComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
NumberCardComponent.ɵfac = /*@__PURE__*/ function () { var ɵNumberCardComponent_BaseFactory; return function NumberCardComponent_Factory(t) { return (ɵNumberCardComponent_BaseFactory || (ɵNumberCardComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NumberCardComponent)))(t || NumberCardComponent); }; }();
NumberCardComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NumberCardComponent, selectors: [["ngx-charts-number-card"]], inputs: { cardColor: "cardColor", bandColor: "bandColor", emptyColor: "emptyColor", innerPadding: "innerPadding", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", designatedTotal: "designatedTotal" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 20, consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations", "select"]], template: function NumberCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function NumberCardComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clickable", ctx.clickable);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
    } }, directives: [ChartComponent, CardSeriesComponent], styles: [_c24, "ngx-charts-number-card .cell .trimmed-label{font-size:12px;line-height:1em;overflow:hidden;pointer-events:none;text-align:left}ngx-charts-number-card .cell .trimmed-label p{margin:0;overflow:hidden;padding:0;text-overflow:ellipsis;white-space:nowrap;width:100%}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumberCardComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-number-card',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"number-card chart\" [class.clickable]=\"clickable\">\n        <svg:g\n          ngx-charts-card-series\n          [colors]=\"colors\"\n          [cardColor]=\"cardColor\"\n          [bandColor]=\"bandColor\"\n          [textColor]=\"textColor\"\n          [emptyColor]=\"emptyColor\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [innerPadding]=\"innerPadding\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;line-height:1em;overflow:hidden;pointer-events:none;text-align:left}ngx-charts-number-card .cell .trimmed-label p{margin:0;overflow:hidden;padding:0;text-overflow:ellipsis;white-space:nowrap;width:100%}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"]
            }]
    }], null, { cardColor: [{
            type: core.Input
        }], bandColor: [{
            type: core.Input
        }], emptyColor: [{
            type: core.Input
        }], innerPadding: [{
            type: core.Input
        }], textColor: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], designatedTotal: [{
            type: core.Input
        }] }); })();
        return NumberCardComponent;
    }(BaseChartComponent));
    NumberCardComponent.propDecorators = {
        cardColor: [{ type: core.Input }],
        bandColor: [{ type: core.Input }],
        emptyColor: [{ type: core.Input }],
        innerPadding: [{ type: core.Input }],
        textColor: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        designatedTotal: [{ type: core.Input }]
    };

    var NumberCardModule = /** @class */ (function () {
        function NumberCardModule() {
        }
NumberCardModule.ɵfac = function NumberCardModule_Factory(t) { return new (t || NumberCardModule)(); };
NumberCardModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NumberCardModule });
NumberCardModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumberCardModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [CardComponent, CardSeriesComponent, NumberCardComponent],
                exports: [CardComponent, CardSeriesComponent, NumberCardComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumberCardModule, { declarations: [CardComponent, CardSeriesComponent, NumberCardComponent], imports: [ChartCommonModule], exports: [CardComponent, CardSeriesComponent, NumberCardComponent] }); })();
        return NumberCardModule;
    }());

    var TreeMapCellComponent = /** @class */ (function () {
        function TreeMapCellComponent(element) {
            this.gradient = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.initialized = false;
            this.element = element.nativeElement;
        }
        TreeMapCellComponent.prototype.ngOnChanges = function () {
            this.update();
            this.valueFormatting = this.valueFormatting || (function (value) { return value.toLocaleString(); });
            var labelFormatting = this.labelFormatting || (function (cell) { return escapeLabel(trimLabel(cell.label, 55)); });
            var cellData = {
                data: this.data,
                label: this.label,
                value: this.value
            };
            this.formattedValue = this.valueFormatting(cellData.value);
            this.formattedLabel = labelFormatting(cellData);
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            this.gradientStops = this.getGradientStops();
        };
        TreeMapCellComponent.prototype.update = function () {
            if (this.initialized) {
                this.animateToCurrentForm();
            }
            else {
                if (this.animations) {
                    this.loadAnimation();
                }
                this.initialized = true;
            }
        };
        TreeMapCellComponent.prototype.loadAnimation = function () {
            var node = d3Selection.select(this.element).select('.cell');
            node.attr('opacity', 0).attr('x', this.x).attr('y', this.y);
            this.animateToCurrentForm();
        };
        TreeMapCellComponent.prototype.getTextColor = function () {
            return invertColor(this.fill);
        };
        TreeMapCellComponent.prototype.animateToCurrentForm = function () {
            var node = d3Selection.select(this.element).select('.cell');
            if (this.animations) {
                node
                    .transition()
                    .duration(750)
                    .attr('opacity', 1)
                    .attr('x', this.x)
                    .attr('y', this.y)
                    .attr('width', this.width)
                    .attr('height', this.height);
            }
            else {
                node.attr('opacity', 1).attr('x', this.x).attr('y', this.y).attr('width', this.width).attr('height', this.height);
            }
        };
        TreeMapCellComponent.prototype.onClick = function () {
            this.select.emit(this.data);
        };
        TreeMapCellComponent.prototype.getGradientStops = function () {
            return [
                {
                    offset: 0,
                    color: this.fill,
                    opacity: 0.3
                },
                {
                    offset: 100,
                    color: this.fill,
                    opacity: 1
                }
            ];
        };
TreeMapCellComponent.ɵfac = function TreeMapCellComponent_Factory(t) { return new (t || TreeMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TreeMapCellComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellComponent, selectors: [["g", "ngx-charts-tree-map-cell", ""]], inputs: { gradient: "gradient", animations: "animations", valueFormatting: "valueFormatting", data: "data", fill: "fill", x: "x", y: "y", width: "width", height: "height", label: "label", value: "value", valueType: "valueType", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c46, decls: 4, vars: 9, consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]], template: function TreeMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, TreeMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵelementStart(2, "rect", 1);
        ɵngcc0.ɵɵlistener("click", function TreeMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("cursor", "pointer");
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.width >= 70 && ctx.height >= 35);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent, CountUpDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapCellComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell]',
                template: "\n    <svg:g>\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [style.cursor]=\"'pointer'\"\n        class=\"cell\"\n        (click)=\"onClick()\"\n      />\n      <svg:foreignObject\n        *ngIf=\"width >= 70 && height >= 35\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"treemap-label\"\n        [style.pointer-events]=\"'none'\"\n      >\n        <xhtml:p [style.color]=\"getTextColor()\" [style.height]=\"height + 'px'\" [style.width]=\"width + 'px'\">\n          <xhtml:span class=\"treemap-label\" [innerHTML]=\"formattedLabel\"> </xhtml:span>\n          <xhtml:br />\n          <xhtml:span\n            *ngIf=\"animations\"\n            class=\"treemap-val\"\n            ngx-charts-count-up\n            [countTo]=\"value\"\n            [valueFormatting]=\"valueFormatting\"\n          >\n          </xhtml:span>\n          <xhtml:span *ngIf=\"!animations\" class=\"treemap-val\">\n            {{ formattedValue }}\n          </xhtml:span>\n        </xhtml:p>\n      </svg:foreignObject>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { gradient: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], valueFormatting: [{
            type: core.Input
        }], data: [{
            type: core.Input
        }], fill: [{
            type: core.Input
        }], x: [{
            type: core.Input
        }], y: [{
            type: core.Input
        }], width: [{
            type: core.Input
        }], height: [{
            type: core.Input
        }], label: [{
            type: core.Input
        }], value: [{
            type: core.Input
        }], valueType: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }] }); })();
        return TreeMapCellComponent;
    }());
    TreeMapCellComponent.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    TreeMapCellComponent.propDecorators = {
        data: [{ type: core.Input }],
        fill: [{ type: core.Input }],
        x: [{ type: core.Input }],
        y: [{ type: core.Input }],
        width: [{ type: core.Input }],
        height: [{ type: core.Input }],
        label: [{ type: core.Input }],
        value: [{ type: core.Input }],
        valueType: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var TreeMapCellSeriesComponent = /** @class */ (function () {
        function TreeMapCellSeriesComponent() {
            this.gradient = false;
            this.tooltipDisabled = false;
            this.animations = true;
            this.select = new core.EventEmitter();
        }
        TreeMapCellSeriesComponent.prototype.ngOnChanges = function (changes) {
            this.cells = this.getCells();
        };
        TreeMapCellSeriesComponent.prototype.getCells = function () {
            var _this = this;
            return this.data.children
                .filter(function (d) {
                return d.depth === 1;
            })
                .map(function (d, index) {
                var label = d.id;
                return {
                    data: d.data,
                    x: d.x0,
                    y: d.y0,
                    width: d.x1 - d.x0,
                    height: d.y1 - d.y0,
                    fill: _this.colors.getColor(label),
                    label: label,
                    value: d.value,
                    valueType: d.valueType
                };
            });
        };
        TreeMapCellSeriesComponent.prototype.getTooltipText = function (_a) {
            var label = _a.label, value = _a.value;
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
        };
        TreeMapCellSeriesComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        TreeMapCellSeriesComponent.prototype.trackBy = function (index, item) {
            return item.label;
        };
TreeMapCellSeriesComponent.ɵfac = function TreeMapCellSeriesComponent_Factory(t) { return new (t || TreeMapCellSeriesComponent)(); };
TreeMapCellSeriesComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellSeriesComponent, selectors: [["g", "ngx-charts-tree-map-cell-series", ""]], inputs: { gradient: "gradient", tooltipDisabled: "tooltipDisabled", animations: "animations", data: "data", dims: "dims", colors: "colors", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c47, decls: 1, vars: 2, consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select"]], template: function TreeMapCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, TreeMapCellComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapCellSeriesComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-tree-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [data]=\"c.data\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [label]=\"c.label\"\n      [value]=\"c.value\"\n      [valueType]=\"c.valueType\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"c.data\"\n    ></svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { gradient: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], data: [{
            type: core.Input
        }], dims: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return TreeMapCellSeriesComponent;
    }());
    TreeMapCellSeriesComponent.propDecorators = {
        data: [{ type: core.Input }],
        dims: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }]
    };

    var TreeMapComponent = /** @class */ (function (_super) {
        __extends(TreeMapComponent, _super);
        function TreeMapComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.tooltipDisabled = false;
            _this.gradient = false;
            _this.select = new core.EventEmitter();
            _this.margin = [10, 10, 10, 10];
            return _this;
        }
        TreeMapComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin
            });
            this.domain = this.getDomain();
            this.treemap = d3Hierarchy.treemap().size([this.dims.width, this.dims.height]);
            var rootNode = {
                name: 'root',
                value: 0,
                isRoot: true
            };
            var root = d3Hierarchy.stratify()
                .id(function (d) {
                var label = d.name;
                if (label.constructor.name === 'Date') {
                    label = label.toLocaleDateString();
                }
                else {
                    label = label.toLocaleString();
                }
                return label;
            })
                .parentId(function (d) { return (d.isRoot ? null : 'root'); })(__spread([rootNode], this.results))
                .sum(function (d) { return d.value; });
            this.data = this.treemap(root);
            this.setColors();
            this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        };
        TreeMapComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        TreeMapComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        TreeMapComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
TreeMapComponent.ɵfac = /*@__PURE__*/ function () { var ɵTreeMapComponent_BaseFactory; return function TreeMapComponent_Factory(t) { return (ɵTreeMapComponent_BaseFactory || (ɵTreeMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TreeMapComponent)))(t || TreeMapComponent); }; }();
TreeMapComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TreeMapComponent, selectors: [["ngx-charts-tree-map"]], contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { results: "results", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", gradient: "gradient" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 16, consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations", "select"]], template: function TreeMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function TreeMapComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(13, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
    } }, directives: [ChartComponent, TreeMapCellSeriesComponent], styles: [".tree-map .treemap-val{display:inline-block;font-size:1.3em;padding-top:5px}.tree-map .treemap-label p{display:table-cell;line-height:1.2em;text-align:center;vertical-align:middle}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-tree-map',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"tree-map chart\">\n        <svg:g\n          ngx-charts-tree-map-cell-series\n          [colors]=\"colors\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".tree-map .treemap-val{display:inline-block;font-size:1.3em;padding-top:5px}.tree-map .treemap-label p{display:table-cell;line-height:1.2em;text-align:center;vertical-align:middle}"]
            }]
    }], null, { results: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], labelFormatting: [{
            type: core.Input
        }], gradient: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }] }); })();
        return TreeMapComponent;
    }(BaseChartComponent));
    TreeMapComponent.propDecorators = {
        results: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        labelFormatting: [{ type: core.Input }],
        gradient: [{ type: core.Input }],
        select: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }]
    };

    var TreeMapModule = /** @class */ (function () {
        function TreeMapModule() {
        }
TreeMapModule.ɵfac = function TreeMapModule_Factory(t) { return new (t || TreeMapModule)(); };
TreeMapModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TreeMapModule });
TreeMapModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent],
                exports: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeMapModule, { declarations: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent], imports: [ChartCommonModule], exports: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent] }); })();
        return TreeMapModule;
    }());

    var LinearGaugeComponent = /** @class */ (function (_super) {
        __extends(LinearGaugeComponent, _super);
        function LinearGaugeComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.min = 0;
            _this.max = 100;
            _this.value = 0;
            _this.margin = [10, 20, 10, 20];
            _this.valueResizeScale = 1;
            _this.unitsResizeScale = 1;
            _this.valueTextTransform = '';
            _this.valueTranslate = '';
            _this.unitsTextTransform = '';
            _this.unitsTranslate = '';
            return _this;
        }
        LinearGaugeComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            if (common.isPlatformBrowser(this.platformId)) {
                setTimeout(function () {
                    _this.scaleText('value');
                    _this.scaleText('units');
                });
            }
        };
        LinearGaugeComponent.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            this.hasPreviousValue = this.previousValue !== undefined;
            this.max = Math.max(this.max, this.value);
            this.min = Math.min(this.min, this.value);
            if (this.hasPreviousValue) {
                this.max = Math.max(this.max, this.previousValue);
                this.min = Math.min(this.min, this.previousValue);
            }
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin
            });
            this.valueDomain = this.getValueDomain();
            this.valueScale = this.getValueScale();
            this.displayValue = this.getDisplayValue();
            this.setColors();
            var xOffset = this.margin[3] + this.dims.width / 2;
            var yOffset = this.margin[0] + this.dims.height / 2;
            this.transform = "translate(" + xOffset + ", " + yOffset + ")";
            this.transformLine = "translate(" + (this.margin[3] + this.valueScale(this.previousValue)) + ", " + yOffset + ")";
            this.valueTranslate = "translate(0, -15)";
            this.unitsTranslate = "translate(0, 15)";
            if (common.isPlatformServer(this.platformId)) {
                this.scaleTextSSR('value');
                this.scaleTextSSR('units');
            }
            else {
                setTimeout(function () { return _this.scaleText('value'); }, 50);
                setTimeout(function () { return _this.scaleText('units'); }, 50);
            }
        };
        LinearGaugeComponent.prototype.getValueDomain = function () {
            return [this.min, this.max];
        };
        LinearGaugeComponent.prototype.getValueScale = function () {
            return d3Scale.scaleLinear().range([0, this.dims.width]).domain(this.valueDomain);
        };
        LinearGaugeComponent.prototype.getDisplayValue = function () {
            if (this.valueFormatting) {
                return this.valueFormatting(this.value);
            }
            return this.value.toLocaleString();
        };
        LinearGaugeComponent.prototype.scaleText = function (element, repeat) {
            var _this = this;
            if (repeat === void 0) { repeat = true; }
            var el;
            var resizeScale;
            if (element === 'value') {
                el = this.valueTextEl;
                resizeScale = this.valueResizeScale;
            }
            else {
                el = this.unitsTextEl;
                resizeScale = this.unitsResizeScale;
            }
            var _a = el.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            if (width === 0 || height === 0)
                return;
            var oldScale = resizeScale;
            var availableWidth = this.dims.width;
            var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
            var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
            var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
            resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
            if (resizeScale !== oldScale) {
                if (element === 'value') {
                    this.valueResizeScale = resizeScale;
                    this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
                }
                else {
                    this.unitsResizeScale = resizeScale;
                    this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
                }
                this.cd.markForCheck();
                if (repeat && common.isPlatformBrowser(this.platformId)) {
                    setTimeout(function () {
                        _this.scaleText(element, false);
                    }, 50);
                }
            }
        };
        LinearGaugeComponent.prototype.scaleTextSSR = function (element) {
            var resizeScale = 1;
            var value = element === 'value' ? this.displayValue : this.units;
            var width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, value, 10);
            var height = 25;
            var availableWidth = this.dims.width;
            var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
            var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
            var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
            resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
            if (element === 'value') {
                this.valueResizeScale = resizeScale;
                this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            else {
                this.unitsResizeScale = resizeScale;
                this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            this.cd.markForCheck();
        };
        LinearGaugeComponent.prototype.onClick = function () {
            this.select.emit({
                name: 'Value',
                value: this.value
            });
        };
        LinearGaugeComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', [this.value], this.customColors);
        };
LinearGaugeComponent.ɵfac = /*@__PURE__*/ function () { var ɵLinearGaugeComponent_BaseFactory; return function LinearGaugeComponent_Factory(t) { return (ɵLinearGaugeComponent_BaseFactory || (ɵLinearGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LinearGaugeComponent)))(t || LinearGaugeComponent); }; }();
LinearGaugeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["ngx-charts-linear-gauge"]], viewQuery: function LinearGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c48, 5);
        ɵngcc0.ɵɵviewQuery(_c49, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.unitsTextEl = _t.first);
    } }, inputs: { max: "max", min: "min", value: "value", units: "units", previousValue: "previousValue", valueFormatting: "valueFormatting" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 38, consts: [[3, "view", "showLegend", "animations", "click"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["valueTextEl", ""], ["alignment-baseline", "before-edge", 1, "units"], ["unitsTextEl", ""], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵelement(3, "g", 3);
        ɵngcc0.ɵɵtemplate(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 4);
        ɵngcc0.ɵɵtemplate(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 5);
        ɵngcc0.ɵɵelementStart(6, "g");
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵelementStart(8, "text", 6, 7);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "g");
        ɵngcc0.ɵɵelementStart(12, "text", 8, 9);
        ɵngcc0.ɵɵtext(14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(33, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", ɵngcc0.ɵɵpureFunction0(36, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", ɵngcc0.ɵɵpureFunction0(37, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.valueTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.valueTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.units, " ");
    } }, directives: [ChartComponent, BarComponent, ɵngcc1.NgIf], styles: [_c24, ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-linear-gauge',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\" (click)=\"onClick()\">\n      <svg:g class=\"linear-gauge chart\">\n        <svg:g\n          ngx-charts-bar\n          class=\"background-bar\"\n          [width]=\"dims.width\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-bar\n          [width]=\"valueScale(value)\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [fill]=\"colors.getColor(units)\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"5\"\n          x2=\"0\"\n          y2=\"15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"-5\"\n          x2=\"0\"\n          y2=\"-15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:g [attr.transform]=\"transform\">\n          <svg:g [attr.transform]=\"valueTranslate\">\n            <svg:text\n              #valueTextEl\n              class=\"value\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"valueTextTransform\"\n              alignment-baseline=\"after-edge\"\n            >\n              {{ displayValue }}\n            </svg:text>\n          </svg:g>\n\n          <svg:g [attr.transform]=\"unitsTranslate\">\n            <svg:text\n              #unitsTextEl\n              class=\"units\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"unitsTextTransform\"\n              alignment-baseline=\"before-edge\"\n            >\n              {{ units }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"]
            }]
    }], null, { max: [{
            type: core.Input
        }], min: [{
            type: core.Input
        }], value: [{
            type: core.Input
        }], units: [{
            type: core.Input
        }], previousValue: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], valueTextEl: [{
            type: core.ViewChild,
            args: ['valueTextEl']
        }], unitsTextEl: [{
            type: core.ViewChild,
            args: ['unitsTextEl']
        }] }); })();
        return LinearGaugeComponent;
    }(BaseChartComponent));
    LinearGaugeComponent.propDecorators = {
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        value: [{ type: core.Input }],
        units: [{ type: core.Input }],
        previousValue: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        valueTextEl: [{ type: core.ViewChild, args: ['valueTextEl',] }],
        unitsTextEl: [{ type: core.ViewChild, args: ['unitsTextEl',] }]
    };

    var GaugeComponent = /** @class */ (function (_super) {
        __extends(GaugeComponent, _super);
        function GaugeComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.legend = false;
            _this.legendTitle = 'Legend';
            _this.legendPosition = 'right';
            _this.min = 0;
            _this.max = 100;
            _this.bigSegments = 10;
            _this.smallSegments = 5;
            _this.showAxis = true;
            _this.startAngle = -120;
            _this.angleSpan = 240;
            _this.activeEntries = [];
            _this.tooltipDisabled = false;
            _this.showText = true;
            _this.activate = new core.EventEmitter();
            _this.deactivate = new core.EventEmitter();
            _this.resizeScale = 1;
            _this.rotation = '';
            _this.textTransform = 'scale(1, 1)';
            _this.cornerRadius = 10;
            return _this;
        }
        GaugeComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            setTimeout(function () { return _this.scaleText(); });
        };
        GaugeComponent.prototype.update = function () {
            var _this = this;
            _super.prototype.update.call(this);
            if (!this.showAxis) {
                if (!this.margin) {
                    this.margin = [10, 20, 10, 20];
                }
            }
            else {
                if (!this.margin) {
                    this.margin = [60, 100, 60, 100];
                }
            }
            // make the starting angle positive
            if (this.startAngle < 0) {
                this.startAngle = (this.startAngle % 360) + 360;
            }
            this.angleSpan = Math.min(this.angleSpan, 360);
            this.dims = calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showLegend: this.legend,
                legendPosition: this.legendPosition
            });
            this.domain = this.getDomain();
            this.valueDomain = this.getValueDomain();
            this.valueScale = this.getValueScale();
            this.displayValue = this.getDisplayValue();
            this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
            this.arcs = this.getArcs();
            this.setColors();
            this.legendOptions = this.getLegendOptions();
            var xOffset = this.margin[3] + this.dims.width / 2;
            var yOffset = this.margin[0] + this.dims.height / 2;
            this.transform = "translate(" + xOffset + ", " + yOffset + ")";
            this.rotation = "rotate(" + this.startAngle + ")";
            setTimeout(function () { return _this.scaleText(); }, 50);
        };
        GaugeComponent.prototype.getArcs = function () {
            var e_1, _a;
            var arcs = [];
            var availableRadius = this.outerRadius * 0.7;
            var radiusPerArc = Math.min(availableRadius / this.results.length, 10);
            var arcWidth = radiusPerArc * 0.7;
            this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
            this.cornerRadius = Math.floor(arcWidth / 2);
            var i = 0;
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var d = _c.value;
                    var outerRadius = this.outerRadius - i * radiusPerArc;
                    var innerRadius = outerRadius - arcWidth;
                    var backgroundArc = {
                        endAngle: (this.angleSpan * Math.PI) / 180,
                        innerRadius: innerRadius,
                        outerRadius: outerRadius,
                        data: {
                            value: this.max,
                            name: d.name
                        }
                    };
                    var valueArc = {
                        endAngle: (Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI) / 180,
                        innerRadius: innerRadius,
                        outerRadius: outerRadius,
                        data: {
                            value: d.value,
                            name: d.name
                        }
                    };
                    var arc = {
                        backgroundArc: backgroundArc,
                        valueArc: valueArc
                    };
                    arcs.push(arc);
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return arcs;
        };
        GaugeComponent.prototype.getDomain = function () {
            return this.results.map(function (d) { return d.name; });
        };
        GaugeComponent.prototype.getValueDomain = function () {
            var values = this.results.map(function (d) { return d.value; });
            var dataMin = Math.min.apply(Math, __spread(values));
            var dataMax = Math.max.apply(Math, __spread(values));
            if (this.min !== undefined) {
                this.min = Math.min(this.min, dataMin);
            }
            else {
                this.min = dataMin;
            }
            if (this.max !== undefined) {
                this.max = Math.max(this.max, dataMax);
            }
            else {
                this.max = dataMax;
            }
            return [this.min, this.max];
        };
        GaugeComponent.prototype.getValueScale = function () {
            return d3Scale.scaleLinear().range([0, this.angleSpan]).nice().domain(this.valueDomain);
        };
        GaugeComponent.prototype.getDisplayValue = function () {
            var value = this.results.map(function (d) { return d.value; }).reduce(function (a, b) { return a + b; }, 0);
            if (this.textValue && 0 !== this.textValue.length) {
                return this.textValue.toLocaleString();
            }
            if (this.valueFormatting) {
                return this.valueFormatting(value);
            }
            return value.toLocaleString();
        };
        GaugeComponent.prototype.scaleText = function (repeat) {
            var _this = this;
            if (repeat === void 0) { repeat = true; }
            if (!this.showText) {
                return;
            }
            var width = this.textEl.nativeElement.getBoundingClientRect().width;
            var oldScale = this.resizeScale;
            if (width === 0) {
                this.resizeScale = 1;
            }
            else {
                var availableSpace = this.textRadius;
                this.resizeScale = Math.floor((availableSpace / (width / this.resizeScale)) * 100) / 100;
            }
            if (this.resizeScale !== oldScale) {
                this.textTransform = "scale(" + this.resizeScale + ", " + this.resizeScale + ")";
                this.cd.markForCheck();
                if (repeat) {
                    setTimeout(function () { return _this.scaleText(false); }, 50);
                }
            }
        };
        GaugeComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        GaugeComponent.prototype.getLegendOptions = function () {
            return {
                scaleType: 'ordinal',
                colors: this.colors,
                domain: this.domain,
                title: this.legendTitle,
                position: this.legendPosition
            };
        };
        GaugeComponent.prototype.setColors = function () {
            this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
        };
        GaugeComponent.prototype.onActivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spread([item], this.activeEntries);
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        GaugeComponent.prototype.onDeactivate = function (item) {
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spread(this.activeEntries);
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        GaugeComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name && entry.series === d.series;
            });
            return item !== undefined;
        };
        GaugeComponent.prototype.trackBy = function (index, item) {
            return item.valueArc.data.name;
        };
GaugeComponent.ɵfac = /*@__PURE__*/ function () { var ɵGaugeComponent_BaseFactory; return function GaugeComponent_Factory(t) { return (ɵGaugeComponent_BaseFactory || (ɵGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(GaugeComponent)))(t || GaugeComponent); }; }();
GaugeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GaugeComponent, selectors: [["ngx-charts-gauge"]], contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function GaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, 5);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { margin: "margin", startAngle: "startAngle", angleSpan: "angleSpan", min: "min", max: "max", activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", textValue: "textValue", units: "units", bigSegments: "bigSegments", smallSegments: "smallSegments", results: "results", showAxis: "showAxis", axisTickFormatting: "axisTickFormatting", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", showText: "showText" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations", "select", "activate", "deactivate"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["textEl", ""], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]], template: function GaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showText);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, GaugeArcComponent, GaugeAxisComponent]; }, styles: [_c24, ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{fill:#666;font-size:12px;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeComponent, [{
        type: core.Component,
        args: [{
                selector: 'ngx-charts-gauge',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"gauge chart\">\n        <svg:g *ngFor=\"let arc of arcs; trackBy: trackBy\" [attr.transform]=\"rotation\">\n          <svg:g\n            ngx-charts-gauge-arc\n            [backgroundArc]=\"arc.backgroundArc\"\n            [valueArc]=\"arc.valueArc\"\n            [cornerRadius]=\"cornerRadius\"\n            [colors]=\"colors\"\n            [isActive]=\"isActive(arc.valueArc.data)\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [valueFormatting]=\"valueFormatting\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          ></svg:g>\n        </svg:g>\n\n        <svg:g\n          ngx-charts-gauge-axis\n          *ngIf=\"showAxis\"\n          [bigSegments]=\"bigSegments\"\n          [smallSegments]=\"smallSegments\"\n          [min]=\"min\"\n          [max]=\"max\"\n          [radius]=\"outerRadius\"\n          [angleSpan]=\"angleSpan\"\n          [valueScale]=\"valueScale\"\n          [startAngle]=\"startAngle\"\n          [tickFormatting]=\"axisTickFormatting\"\n        ></svg:g>\n\n        <svg:text\n          #textEl\n          *ngIf=\"showText\"\n          [style.textAnchor]=\"'middle'\"\n          [attr.transform]=\"textTransform\"\n          alignment-baseline=\"central\"\n        >\n          <tspan x=\"0\" dy=\"0\">{{ displayValue }}</tspan>\n          <tspan x=\"0\" dy=\"1.2em\">{{ units }}</tspan>\n        </svg:text>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:none}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{opacity:.2;transition:opacity .1s ease-in-out}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{fill:none;stroke:#ddd;stroke-width:1}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-dasharray:5;stroke-dashoffset:5;stroke-width:1}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill:#000;fill-opacity:.05}.ngx-charts .gridline-path-dotted{fill:none;stroke:#ddd;stroke-dasharray:1,20;stroke-dashoffset:3;stroke-width:1}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{fill:#666;font-size:12px;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"]
            }]
    }], null, { margin: [{
            type: core.Input
        }], startAngle: [{
            type: core.Input
        }], angleSpan: [{
            type: core.Input
        }], min: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], activeEntries: [{
            type: core.Input
        }], legend: [{
            type: core.Input
        }], legendTitle: [{
            type: core.Input
        }], legendPosition: [{
            type: core.Input
        }], textValue: [{
            type: core.Input
        }], units: [{
            type: core.Input
        }], bigSegments: [{
            type: core.Input
        }], smallSegments: [{
            type: core.Input
        }], results: [{
            type: core.Input
        }], showAxis: [{
            type: core.Input
        }], axisTickFormatting: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], showText: [{
            type: core.Input
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], tooltipTemplate: [{
            type: core.ContentChild,
            args: ['tooltipTemplate']
        }], textEl: [{
            type: core.ViewChild,
            args: ['textEl']
        }] }); })();
        return GaugeComponent;
    }(BaseChartComponent));
    GaugeComponent.propDecorators = {
        legend: [{ type: core.Input }],
        legendTitle: [{ type: core.Input }],
        legendPosition: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        textValue: [{ type: core.Input }],
        units: [{ type: core.Input }],
        bigSegments: [{ type: core.Input }],
        smallSegments: [{ type: core.Input }],
        results: [{ type: core.Input }],
        showAxis: [{ type: core.Input }],
        startAngle: [{ type: core.Input }],
        angleSpan: [{ type: core.Input }],
        activeEntries: [{ type: core.Input }],
        axisTickFormatting: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        showText: [{ type: core.Input }],
        margin: [{ type: core.Input }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }],
        tooltipTemplate: [{ type: core.ContentChild, args: ['tooltipTemplate',] }],
        textEl: [{ type: core.ViewChild, args: ['textEl',] }]
    };

    var GaugeArcComponent = /** @class */ (function () {
        function GaugeArcComponent() {
            this.isActive = false;
            this.tooltipDisabled = false;
            this.animations = true;
            this.select = new core.EventEmitter();
            this.activate = new core.EventEmitter();
            this.deactivate = new core.EventEmitter();
        }
        GaugeArcComponent.prototype.tooltipText = function (arc) {
            var label = formatLabel(arc.data.name);
            var val;
            if (this.valueFormatting) {
                val = this.valueFormatting(arc.data.value);
            }
            else {
                val = formatLabel(arc.data.value);
            }
            return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
        };
GaugeArcComponent.ɵfac = function GaugeArcComponent_Factory(t) { return new (t || GaugeArcComponent)(); };
GaugeArcComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GaugeArcComponent, selectors: [["g", "ngx-charts-gauge-arc", ""]], inputs: { isActive: "isActive", tooltipDisabled: "tooltipDisabled", animations: "animations", backgroundArc: "backgroundArc", valueArc: "valueArc", cornerRadius: "cornerRadius", colors: "colors", valueFormatting: "valueFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, attrs: _c51, decls: 2, vars: 23, consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function GaugeArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵlistener("select", function GaugeArcComponent_Template__svg_g_select_1_listener($event) { return ctx.select.emit($event); })("activate", function GaugeArcComponent_Template__svg_g_activate_1_listener($event) { return ctx.activate.emit($event); })("deactivate", function GaugeArcComponent_Template__svg_g_deactivate_1_listener($event) { return ctx.deactivate.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx.tooltipTemplate ? undefined : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
    } }, directives: [PieArcComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeArcComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-gauge-arc]',
                template: "\n    <svg:g\n      ngx-charts-pie-arc\n      class=\"background-arc\"\n      [startAngle]=\"0\"\n      [endAngle]=\"backgroundArc.endAngle\"\n      [innerRadius]=\"backgroundArc.innerRadius\"\n      [outerRadius]=\"backgroundArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [data]=\"backgroundArc.data\"\n      [animate]=\"false\"\n      [pointerEvents]=\"false\"\n    ></svg:g>\n    <svg:g\n      ngx-charts-pie-arc\n      [startAngle]=\"0\"\n      [endAngle]=\"valueArc.endAngle\"\n      [innerRadius]=\"valueArc.innerRadius\"\n      [outerRadius]=\"valueArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [fill]=\"colors.getColor(valueArc.data.name)\"\n      [data]=\"valueArc.data\"\n      [animate]=\"animations\"\n      [isActive]=\"isActive\"\n      (select)=\"select.emit($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(valueArc)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"valueArc.data\"\n    ></svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: core.Input
        }], tooltipDisabled: [{
            type: core.Input
        }], animations: [{
            type: core.Input
        }], select: [{
            type: core.Output
        }], activate: [{
            type: core.Output
        }], deactivate: [{
            type: core.Output
        }], backgroundArc: [{
            type: core.Input
        }], valueArc: [{
            type: core.Input
        }], cornerRadius: [{
            type: core.Input
        }], colors: [{
            type: core.Input
        }], valueFormatting: [{
            type: core.Input
        }], tooltipTemplate: [{
            type: core.Input
        }] }); })();
        return GaugeArcComponent;
    }());
    GaugeArcComponent.propDecorators = {
        backgroundArc: [{ type: core.Input }],
        valueArc: [{ type: core.Input }],
        cornerRadius: [{ type: core.Input }],
        colors: [{ type: core.Input }],
        isActive: [{ type: core.Input }],
        tooltipDisabled: [{ type: core.Input }],
        valueFormatting: [{ type: core.Input }],
        tooltipTemplate: [{ type: core.Input }],
        animations: [{ type: core.Input }],
        select: [{ type: core.Output }],
        activate: [{ type: core.Output }],
        deactivate: [{ type: core.Output }]
    };

    var GaugeAxisComponent = /** @class */ (function () {
        function GaugeAxisComponent() {
            this.rotate = '';
        }
        GaugeAxisComponent.prototype.ngOnChanges = function (changes) {
            this.update();
        };
        GaugeAxisComponent.prototype.update = function () {
            this.rotationAngle = -90 + this.startAngle;
            this.rotate = "rotate(" + this.rotationAngle + ")";
            this.ticks = this.getTicks();
        };
        GaugeAxisComponent.prototype.getTicks = function () {
            var bigTickSegment = this.angleSpan / this.bigSegments;
            var smallTickSegment = bigTickSegment / this.smallSegments;
            var tickLength = 20;
            var ticks = {
                big: [],
                small: []
            };
            var startDistance = this.radius + 10;
            var textDist = startDistance + tickLength + 10;
            for (var i = 0; i <= this.bigSegments; i++) {
                var angleDeg = i * bigTickSegment;
                var angle = (angleDeg * Math.PI) / 180;
                var textAnchor = this.getTextAnchor(angleDeg);
                var skip = false;
                if (i === 0 && this.angleSpan === 360) {
                    skip = true;
                }
                if (!skip) {
                    var text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                    if (this.tickFormatting) {
                        text = this.tickFormatting(text);
                    }
                    ticks.big.push({
                        line: this.getTickPath(startDistance, tickLength, angle),
                        textAnchor: textAnchor,
                        text: text,
                        textTransform: "\n            translate(" + textDist * Math.cos(angle) + ", " + textDist * Math.sin(angle) + ") rotate(" + -this.rotationAngle + ")\n          "
                    });
                }
                if (i === this.bigSegments) {
                    continue;
                }
                for (var j = 1; j <= this.smallSegments; j++) {
                    var smallAngleDeg = angleDeg + j * smallTickSegment;
                    var smallAngle = (smallAngleDeg * Math.PI) / 180;
                    ticks.small.push({
                        line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                    });
                }
            }
            return ticks;
        };
        GaugeAxisComponent.prototype.getTextAnchor = function (angle) {
            // [0, 45] = 'middle';
            // [46, 135] = 'start';
            // [136, 225] = 'middle';
            // [226, 315] = 'end';
            angle = (this.startAngle + angle) % 360;
            var textAnchor = 'middle';
            if (angle > 45 && angle <= 135) {
                textAnchor = 'start';
            }
            else if (angle > 225 && angle <= 315) {
                textAnchor = 'end';
            }
            return textAnchor;
        };
        GaugeAxisComponent.prototype.getTickPath = function (startDistance, tickLength, angle) {
            var y1 = startDistance * Math.sin(angle);
            var y2 = (startDistance + tickLength) * Math.sin(angle);
            var x1 = startDistance * Math.cos(angle);
            var x2 = (startDistance + tickLength) * Math.cos(angle);
            var points = [
                { x: x1, y: y1 },
                { x: x2, y: y2 }
            ];
            var lineGenerator = d3Shape.line()
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; });
            return lineGenerator(points);
        };
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c52, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: core.Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: "\n    <svg:g [attr.transform]=\"rotate\">\n      <svg:g *ngFor=\"let tick of ticks.big\" class=\"gauge-tick gauge-tick-large\">\n        <svg:path [attr.d]=\"tick.line\" />\n      </svg:g>\n      <svg:g *ngFor=\"let tick of ticks.big\" class=\"gauge-tick gauge-tick-large\">\n        <svg:text\n          [style.textAnchor]=\"tick.textAnchor\"\n          [attr.transform]=\"tick.textTransform\"\n          alignment-baseline=\"central\"\n        >\n          {{ tick.text }}\n        </svg:text>\n      </svg:g>\n      <svg:g *ngFor=\"let tick of ticks.small\" class=\"gauge-tick gauge-tick-small\">\n        <svg:path [attr.d]=\"tick.line\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: core.Input
        }], smallSegments: [{
            type: core.Input
        }], min: [{
            type: core.Input
        }], max: [{
            type: core.Input
        }], angleSpan: [{
            type: core.Input
        }], startAngle: [{
            type: core.Input
        }], radius: [{
            type: core.Input
        }], valueScale: [{
            type: core.Input
        }], tickFormatting: [{
            type: core.Input
        }] }); })();
        return GaugeAxisComponent;
    }());
    GaugeAxisComponent.propDecorators = {
        bigSegments: [{ type: core.Input }],
        smallSegments: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        angleSpan: [{ type: core.Input }],
        startAngle: [{ type: core.Input }],
        radius: [{ type: core.Input }],
        valueScale: [{ type: core.Input }],
        tickFormatting: [{ type: core.Input }]
    };

    var GaugeModule = /** @class */ (function () {
        function GaugeModule() {
        }
GaugeModule.ɵfac = function GaugeModule_Factory(t) { return new (t || GaugeModule)(); };
GaugeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GaugeModule });
GaugeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule, PieChartModule, BarChartModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeModule, [{
        type: core.NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, BarChartModule],
                declarations: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent],
                exports: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugeModule, { declarations: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent], imports: [ChartCommonModule, PieChartModule, BarChartModule], exports: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent] }); })();
        return GaugeModule;
    }());

    // The export is needed here to generate a valid polyfills.metadata.json file
    function ngxChartsPolyfills() {
        // IE11 fix
        // Ref: https://github.com/swimlane/ngx-charts/issues/386
        if (typeof SVGElement !== 'undefined' && typeof SVGElement.prototype.contains === 'undefined') {
            SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
        }
    }

    var NgxChartsModule = /** @class */ (function () {
        function NgxChartsModule() {
            ngxChartsPolyfills();
        }
NgxChartsModule.ɵfac = function NgxChartsModule_Factory(t) { return new (t || NgxChartsModule)(); };
NgxChartsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxChartsModule });
NgxChartsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [ChartCommonModule, AreaChartModule, BarChartModule, BubbleChartModule, HeatMapModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxChartsModule, [{
        type: core.NgModule,
        args: [{
                exports: [
                    ChartCommonModule,
                    AreaChartModule,
                    BarChartModule,
                    BubbleChartModule,
                    HeatMapModule,
                    LineChartModule,
                    PolarChartModule,
                    NumberCardModule,
                    PieChartModule,
                    TreeMapModule,
                    GaugeModule
                ]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxChartsModule, { exports: [ChartCommonModule, AreaChartModule, BarChartModule, BubbleChartModule, HeatMapModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule] }); })();
        return NgxChartsModule;
    }());
    NgxChartsModule.ctorParameters = function () { return []; };

    function tickFormat(fieldType, groupByType) {
        return function (label) {
            if (label === 'No Value' || label === 'Other') {
                return label;
            }
            if (fieldType === 'date' && groupByType === 'groupBy') {
                var formatter = d3TimeFormat.timeFormat('MM/DD/YYYY');
                return formatter(label);
            }
            return label.toString();
        };
    }

    /*
     * Public API Surface of ngx-charts
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AdvancedLegendComponent = AdvancedLegendComponent;
    exports.AdvancedPieChartComponent = AdvancedPieChartComponent;
    exports.AreaChartComponent = AreaChartComponent;
    exports.AreaChartModule = AreaChartModule;
    exports.AreaChartNormalizedComponent = AreaChartNormalizedComponent;
    exports.AreaChartStackedComponent = AreaChartStackedComponent;
    exports.AreaComponent = AreaComponent;
    exports.AreaSeriesComponent = AreaSeriesComponent;
    exports.AxesModule = AxesModule;
    exports.AxisLabelComponent = AxisLabelComponent;
    exports.BarChartModule = BarChartModule;
    exports.BarComponent = BarComponent;
    exports.BarHorizontal2DComponent = BarHorizontal2DComponent;
    exports.BarHorizontalComponent = BarHorizontalComponent;
    exports.BarHorizontalNormalizedComponent = BarHorizontalNormalizedComponent;
    exports.BarHorizontalStackedComponent = BarHorizontalStackedComponent;
    exports.BarLabelComponent = BarLabelComponent;
    exports.BarVertical2DComponent = BarVertical2DComponent;
    exports.BarVerticalComponent = BarVerticalComponent;
    exports.BarVerticalNormalizedComponent = BarVerticalNormalizedComponent;
    exports.BarVerticalStackedComponent = BarVerticalStackedComponent;
    exports.BaseChartComponent = BaseChartComponent;
    exports.BubbleChartComponent = BubbleChartComponent;
    exports.BubbleChartModule = BubbleChartModule;
    exports.BubbleSeriesComponent = BubbleSeriesComponent;
    exports.CardComponent = CardComponent;
    exports.CardSeriesComponent = CardSeriesComponent;
    exports.ChartCommonModule = ChartCommonModule;
    exports.ChartComponent = ChartComponent;
    exports.CircleComponent = CircleComponent;
    exports.CircleSeriesComponent = CircleSeriesComponent;
    exports.ColorHelper = ColorHelper;
    exports.CountUpDirective = CountUpDirective;
    exports.GaugeArcComponent = GaugeArcComponent;
    exports.GaugeAxisComponent = GaugeAxisComponent;
    exports.GaugeComponent = GaugeComponent;
    exports.GaugeModule = GaugeModule;
    exports.GridPanelComponent = GridPanelComponent;
    exports.GridPanelSeriesComponent = GridPanelSeriesComponent;
    exports.HeatCellSeriesComponent = HeatCellSeriesComponent;
    exports.HeatMapCellComponent = HeatMapCellComponent;
    exports.HeatMapComponent = HeatMapComponent;
    exports.HeatMapModule = HeatMapModule;
    exports.LegendComponent = LegendComponent;
    exports.LegendEntryComponent = LegendEntryComponent;
    exports.LineChartComponent = LineChartComponent;
    exports.LineChartModule = LineChartModule;
    exports.LineComponent = LineComponent;
    exports.LineSeriesComponent = LineSeriesComponent;
    exports.LinearGaugeComponent = LinearGaugeComponent;
    exports.NgxChartsModule = NgxChartsModule;
    exports.NumberCardComponent = NumberCardComponent;
    exports.NumberCardModule = NumberCardModule;
    exports.PieArcComponent = PieArcComponent;
    exports.PieChartComponent = PieChartComponent;
    exports.PieChartModule = PieChartModule;
    exports.PieGridComponent = PieGridComponent;
    exports.PieGridSeriesComponent = PieGridSeriesComponent;
    exports.PieLabelComponent = PieLabelComponent;
    exports.PieSeriesComponent = PieSeriesComponent;
    exports.PolarChartComponent = PolarChartComponent;
    exports.PolarChartModule = PolarChartModule;
    exports.PolarSeriesComponent = PolarSeriesComponent;
    exports.ScaleLegendComponent = ScaleLegendComponent;
    exports.SeriesHorizontal = SeriesHorizontal;
    exports.SeriesVerticalComponent = SeriesVerticalComponent;
    exports.SvgLinearGradientComponent = SvgLinearGradientComponent;
    exports.SvgRadialGradientComponent = SvgRadialGradientComponent;
    exports.Timeline = Timeline;
    exports.TooltipArea = TooltipArea;
    exports.TooltipContentComponent = TooltipContentComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipService = TooltipService;
    exports.TreeMapCellComponent = TreeMapCellComponent;
    exports.TreeMapCellSeriesComponent = TreeMapCellSeriesComponent;
    exports.TreeMapComponent = TreeMapComponent;
    exports.TreeMapModule = TreeMapModule;
    exports.VisibilityObserver = VisibilityObserver;
    exports.XAxisComponent = XAxisComponent;
    exports.XAxisTicksComponent = XAxisTicksComponent;
    exports.YAxisComponent = YAxisComponent;
    exports.YAxisTicksComponent = YAxisTicksComponent;
    exports.calculateViewDimensions = calculateViewDimensions;
    exports.colorSets = colorSets;
    exports.count = count;
    exports.decimalChecker = decimalChecker;
    exports.escapeLabel = escapeLabel;
    exports.formatLabel = formatLabel;
    exports.getDomain = getDomain;
    exports.getScale = getScale;
    exports.getScaleType = getScaleType;
    exports.getUniqueXDomainValues = getUniqueXDomainValues;
    exports.gridLayout = gridLayout;
    exports.gridSize = gridSize;
    exports.hexToRgb = hexToRgb;
    exports.id = id;
    exports.invertColor = invertColor;
    exports.reduceTicks = reduceTicks;
    exports.shadeRGBColor = shadeRGBColor;
    exports.sortByDomain = sortByDomain;
    exports.sortByTime = sortByTime;
    exports.sortLinear = sortLinear;
    exports.throttle = throttle;
    exports.throttleable = throttleable;
    exports.tickFormat = tickFormat;
    exports.trimLabel = trimLabel;
    exports.ɵa = InjectionRegisteryService;
    exports.ɵb = InjectionService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=swimlane-ngx-charts.umd.js.map