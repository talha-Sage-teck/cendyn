(function () {
  "use strict";

  var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36;

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  (self["webpackChunkshell"] = self["webpackChunkshell"] || []).push([["node_modules_ng-bootstrap_ng-bootstrap_fesm2015_ng-bootstrap_js-_99180"], {
    /***/
    33843: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ModalDismissReasons": function ModalDismissReasons() {
          return (
            /* binding */
            _ModalDismissReasons
          );
        },

        /* harmony export */
        "NgbAccordion": function NgbAccordion() {
          return (
            /* binding */
            _NgbAccordion
          );
        },

        /* harmony export */
        "NgbAccordionConfig": function NgbAccordionConfig() {
          return (
            /* binding */
            _NgbAccordionConfig
          );
        },

        /* harmony export */
        "NgbAccordionModule": function NgbAccordionModule() {
          return (
            /* binding */
            _NgbAccordionModule
          );
        },

        /* harmony export */
        "NgbActiveModal": function NgbActiveModal() {
          return (
            /* binding */
            _NgbActiveModal
          );
        },

        /* harmony export */
        "NgbAlert": function NgbAlert() {
          return (
            /* binding */
            _NgbAlert
          );
        },

        /* harmony export */
        "NgbAlertConfig": function NgbAlertConfig() {
          return (
            /* binding */
            _NgbAlertConfig
          );
        },

        /* harmony export */
        "NgbAlertModule": function NgbAlertModule() {
          return (
            /* binding */
            _NgbAlertModule
          );
        },

        /* harmony export */
        "NgbButtonLabel": function NgbButtonLabel() {
          return (
            /* binding */
            _NgbButtonLabel
          );
        },

        /* harmony export */
        "NgbButtonsModule": function NgbButtonsModule() {
          return (
            /* binding */
            _NgbButtonsModule
          );
        },

        /* harmony export */
        "NgbCalendar": function NgbCalendar() {
          return (
            /* binding */
            _NgbCalendar
          );
        },

        /* harmony export */
        "NgbCalendarBuddhist": function NgbCalendarBuddhist() {
          return (
            /* binding */
            _NgbCalendarBuddhist
          );
        },

        /* harmony export */
        "NgbCalendarGregorian": function NgbCalendarGregorian() {
          return (
            /* binding */
            _NgbCalendarGregorian
          );
        },

        /* harmony export */
        "NgbCalendarHebrew": function NgbCalendarHebrew() {
          return (
            /* binding */
            _NgbCalendarHebrew
          );
        },

        /* harmony export */
        "NgbCalendarIslamicCivil": function NgbCalendarIslamicCivil() {
          return (
            /* binding */
            _NgbCalendarIslamicCivil
          );
        },

        /* harmony export */
        "NgbCalendarIslamicUmalqura": function NgbCalendarIslamicUmalqura() {
          return (
            /* binding */
            _NgbCalendarIslamicUmalqura
          );
        },

        /* harmony export */
        "NgbCalendarPersian": function NgbCalendarPersian() {
          return (
            /* binding */
            _NgbCalendarPersian
          );
        },

        /* harmony export */
        "NgbCarousel": function NgbCarousel() {
          return (
            /* binding */
            _NgbCarousel
          );
        },

        /* harmony export */
        "NgbCarouselConfig": function NgbCarouselConfig() {
          return (
            /* binding */
            _NgbCarouselConfig
          );
        },

        /* harmony export */
        "NgbCarouselModule": function NgbCarouselModule() {
          return (
            /* binding */
            _NgbCarouselModule
          );
        },

        /* harmony export */
        "NgbCheckBox": function NgbCheckBox() {
          return (
            /* binding */
            _NgbCheckBox
          );
        },

        /* harmony export */
        "NgbCollapse": function NgbCollapse() {
          return (
            /* binding */
            _NgbCollapse
          );
        },

        /* harmony export */
        "NgbCollapseConfig": function NgbCollapseConfig() {
          return (
            /* binding */
            _NgbCollapseConfig
          );
        },

        /* harmony export */
        "NgbCollapseModule": function NgbCollapseModule() {
          return (
            /* binding */
            _NgbCollapseModule
          );
        },

        /* harmony export */
        "NgbConfig": function NgbConfig() {
          return (
            /* binding */
            _NgbConfig
          );
        },

        /* harmony export */
        "NgbDate": function NgbDate() {
          return (
            /* binding */
            _NgbDate
          );
        },

        /* harmony export */
        "NgbDateAdapter": function NgbDateAdapter() {
          return (
            /* binding */
            _NgbDateAdapter
          );
        },

        /* harmony export */
        "NgbDateNativeAdapter": function NgbDateNativeAdapter() {
          return (
            /* binding */
            _NgbDateNativeAdapter
          );
        },

        /* harmony export */
        "NgbDateNativeUTCAdapter": function NgbDateNativeUTCAdapter() {
          return (
            /* binding */
            _NgbDateNativeUTCAdapter
          );
        },

        /* harmony export */
        "NgbDateParserFormatter": function NgbDateParserFormatter() {
          return (
            /* binding */
            _NgbDateParserFormatter
          );
        },

        /* harmony export */
        "NgbDatepicker": function NgbDatepicker() {
          return (
            /* binding */
            _NgbDatepicker
          );
        },

        /* harmony export */
        "NgbDatepickerConfig": function NgbDatepickerConfig() {
          return (
            /* binding */
            _NgbDatepickerConfig
          );
        },

        /* harmony export */
        "NgbDatepickerContent": function NgbDatepickerContent() {
          return (
            /* binding */
            _NgbDatepickerContent
          );
        },

        /* harmony export */
        "NgbDatepickerI18n": function NgbDatepickerI18n() {
          return (
            /* binding */
            _NgbDatepickerI18n
          );
        },

        /* harmony export */
        "NgbDatepickerI18nDefault": function NgbDatepickerI18nDefault() {
          return (
            /* binding */
            _NgbDatepickerI18nDefault
          );
        },

        /* harmony export */
        "NgbDatepickerI18nHebrew": function NgbDatepickerI18nHebrew() {
          return (
            /* binding */
            _NgbDatepickerI18nHebrew
          );
        },

        /* harmony export */
        "NgbDatepickerKeyboardService": function NgbDatepickerKeyboardService() {
          return (
            /* binding */
            _NgbDatepickerKeyboardService
          );
        },

        /* harmony export */
        "NgbDatepickerModule": function NgbDatepickerModule() {
          return (
            /* binding */
            _NgbDatepickerModule
          );
        },

        /* harmony export */
        "NgbDatepickerMonth": function NgbDatepickerMonth() {
          return (
            /* binding */
            _NgbDatepickerMonth
          );
        },

        /* harmony export */
        "NgbDropdown": function NgbDropdown() {
          return (
            /* binding */
            _NgbDropdown
          );
        },

        /* harmony export */
        "NgbDropdownAnchor": function NgbDropdownAnchor() {
          return (
            /* binding */
            _NgbDropdownAnchor
          );
        },

        /* harmony export */
        "NgbDropdownConfig": function NgbDropdownConfig() {
          return (
            /* binding */
            _NgbDropdownConfig
          );
        },

        /* harmony export */
        "NgbDropdownItem": function NgbDropdownItem() {
          return (
            /* binding */
            _NgbDropdownItem
          );
        },

        /* harmony export */
        "NgbDropdownMenu": function NgbDropdownMenu() {
          return (
            /* binding */
            _NgbDropdownMenu
          );
        },

        /* harmony export */
        "NgbDropdownModule": function NgbDropdownModule() {
          return (
            /* binding */
            _NgbDropdownModule
          );
        },

        /* harmony export */
        "NgbDropdownToggle": function NgbDropdownToggle() {
          return (
            /* binding */
            _NgbDropdownToggle
          );
        },

        /* harmony export */
        "NgbHighlight": function NgbHighlight() {
          return (
            /* binding */
            _NgbHighlight
          );
        },

        /* harmony export */
        "NgbInputDatepicker": function NgbInputDatepicker() {
          return (
            /* binding */
            _NgbInputDatepicker
          );
        },

        /* harmony export */
        "NgbInputDatepickerConfig": function NgbInputDatepickerConfig() {
          return (
            /* binding */
            _NgbInputDatepickerConfig
          );
        },

        /* harmony export */
        "NgbModal": function NgbModal() {
          return (
            /* binding */
            _NgbModal
          );
        },

        /* harmony export */
        "NgbModalConfig": function NgbModalConfig() {
          return (
            /* binding */
            _NgbModalConfig
          );
        },

        /* harmony export */
        "NgbModalModule": function NgbModalModule() {
          return (
            /* binding */
            _NgbModalModule
          );
        },

        /* harmony export */
        "NgbModalRef": function NgbModalRef() {
          return (
            /* binding */
            _NgbModalRef
          );
        },

        /* harmony export */
        "NgbModule": function NgbModule() {
          return (
            /* binding */
            _NgbModule
          );
        },

        /* harmony export */
        "NgbNav": function NgbNav() {
          return (
            /* binding */
            _NgbNav
          );
        },

        /* harmony export */
        "NgbNavConfig": function NgbNavConfig() {
          return (
            /* binding */
            _NgbNavConfig
          );
        },

        /* harmony export */
        "NgbNavContent": function NgbNavContent() {
          return (
            /* binding */
            _NgbNavContent
          );
        },

        /* harmony export */
        "NgbNavItem": function NgbNavItem() {
          return (
            /* binding */
            _NgbNavItem
          );
        },

        /* harmony export */
        "NgbNavLink": function NgbNavLink() {
          return (
            /* binding */
            _NgbNavLink
          );
        },

        /* harmony export */
        "NgbNavModule": function NgbNavModule() {
          return (
            /* binding */
            _NgbNavModule
          );
        },

        /* harmony export */
        "NgbNavOutlet": function NgbNavOutlet() {
          return (
            /* binding */
            _NgbNavOutlet
          );
        },

        /* harmony export */
        "NgbNavPane": function NgbNavPane() {
          return (
            /* binding */
            _NgbNavPane
          );
        },

        /* harmony export */
        "NgbNavbar": function NgbNavbar() {
          return (
            /* binding */
            _NgbNavbar
          );
        },

        /* harmony export */
        "NgbPagination": function NgbPagination() {
          return (
            /* binding */
            _NgbPagination
          );
        },

        /* harmony export */
        "NgbPaginationConfig": function NgbPaginationConfig() {
          return (
            /* binding */
            _NgbPaginationConfig
          );
        },

        /* harmony export */
        "NgbPaginationEllipsis": function NgbPaginationEllipsis() {
          return (
            /* binding */
            _NgbPaginationEllipsis
          );
        },

        /* harmony export */
        "NgbPaginationFirst": function NgbPaginationFirst() {
          return (
            /* binding */
            _NgbPaginationFirst
          );
        },

        /* harmony export */
        "NgbPaginationLast": function NgbPaginationLast() {
          return (
            /* binding */
            _NgbPaginationLast
          );
        },

        /* harmony export */
        "NgbPaginationModule": function NgbPaginationModule() {
          return (
            /* binding */
            _NgbPaginationModule
          );
        },

        /* harmony export */
        "NgbPaginationNext": function NgbPaginationNext() {
          return (
            /* binding */
            _NgbPaginationNext
          );
        },

        /* harmony export */
        "NgbPaginationNumber": function NgbPaginationNumber() {
          return (
            /* binding */
            _NgbPaginationNumber
          );
        },

        /* harmony export */
        "NgbPaginationPages": function NgbPaginationPages() {
          return (
            /* binding */
            _NgbPaginationPages
          );
        },

        /* harmony export */
        "NgbPaginationPrevious": function NgbPaginationPrevious() {
          return (
            /* binding */
            _NgbPaginationPrevious
          );
        },

        /* harmony export */
        "NgbPanel": function NgbPanel() {
          return (
            /* binding */
            _NgbPanel
          );
        },

        /* harmony export */
        "NgbPanelContent": function NgbPanelContent() {
          return (
            /* binding */
            _NgbPanelContent
          );
        },

        /* harmony export */
        "NgbPanelHeader": function NgbPanelHeader() {
          return (
            /* binding */
            _NgbPanelHeader
          );
        },

        /* harmony export */
        "NgbPanelTitle": function NgbPanelTitle() {
          return (
            /* binding */
            _NgbPanelTitle
          );
        },

        /* harmony export */
        "NgbPanelToggle": function NgbPanelToggle() {
          return (
            /* binding */
            _NgbPanelToggle
          );
        },

        /* harmony export */
        "NgbPopover": function NgbPopover() {
          return (
            /* binding */
            _NgbPopover
          );
        },

        /* harmony export */
        "NgbPopoverConfig": function NgbPopoverConfig() {
          return (
            /* binding */
            _NgbPopoverConfig
          );
        },

        /* harmony export */
        "NgbPopoverModule": function NgbPopoverModule() {
          return (
            /* binding */
            _NgbPopoverModule
          );
        },

        /* harmony export */
        "NgbProgressbar": function NgbProgressbar() {
          return (
            /* binding */
            _NgbProgressbar
          );
        },

        /* harmony export */
        "NgbProgressbarConfig": function NgbProgressbarConfig() {
          return (
            /* binding */
            _NgbProgressbarConfig
          );
        },

        /* harmony export */
        "NgbProgressbarModule": function NgbProgressbarModule() {
          return (
            /* binding */
            _NgbProgressbarModule
          );
        },

        /* harmony export */
        "NgbRadio": function NgbRadio() {
          return (
            /* binding */
            _NgbRadio
          );
        },

        /* harmony export */
        "NgbRadioGroup": function NgbRadioGroup() {
          return (
            /* binding */
            _NgbRadioGroup
          );
        },

        /* harmony export */
        "NgbRating": function NgbRating() {
          return (
            /* binding */
            _NgbRating
          );
        },

        /* harmony export */
        "NgbRatingConfig": function NgbRatingConfig() {
          return (
            /* binding */
            _NgbRatingConfig
          );
        },

        /* harmony export */
        "NgbRatingModule": function NgbRatingModule() {
          return (
            /* binding */
            _NgbRatingModule
          );
        },

        /* harmony export */
        "NgbSlide": function NgbSlide() {
          return (
            /* binding */
            _NgbSlide
          );
        },

        /* harmony export */
        "NgbSlideEventDirection": function NgbSlideEventDirection() {
          return (
            /* binding */
            _NgbSlideEventDirection
          );
        },

        /* harmony export */
        "NgbSlideEventSource": function NgbSlideEventSource() {
          return (
            /* binding */
            _NgbSlideEventSource
          );
        },

        /* harmony export */
        "NgbTimeAdapter": function NgbTimeAdapter() {
          return (
            /* binding */
            _NgbTimeAdapter
          );
        },

        /* harmony export */
        "NgbTimepicker": function NgbTimepicker() {
          return (
            /* binding */
            _NgbTimepicker
          );
        },

        /* harmony export */
        "NgbTimepickerConfig": function NgbTimepickerConfig() {
          return (
            /* binding */
            _NgbTimepickerConfig
          );
        },

        /* harmony export */
        "NgbTimepickerI18n": function NgbTimepickerI18n() {
          return (
            /* binding */
            _NgbTimepickerI18n
          );
        },

        /* harmony export */
        "NgbTimepickerModule": function NgbTimepickerModule() {
          return (
            /* binding */
            _NgbTimepickerModule
          );
        },

        /* harmony export */
        "NgbToast": function NgbToast() {
          return (
            /* binding */
            _NgbToast
          );
        },

        /* harmony export */
        "NgbToastConfig": function NgbToastConfig() {
          return (
            /* binding */
            _NgbToastConfig
          );
        },

        /* harmony export */
        "NgbToastHeader": function NgbToastHeader() {
          return (
            /* binding */
            _NgbToastHeader
          );
        },

        /* harmony export */
        "NgbToastModule": function NgbToastModule() {
          return (
            /* binding */
            _NgbToastModule
          );
        },

        /* harmony export */
        "NgbTooltip": function NgbTooltip() {
          return (
            /* binding */
            _NgbTooltip
          );
        },

        /* harmony export */
        "NgbTooltipConfig": function NgbTooltipConfig() {
          return (
            /* binding */
            _NgbTooltipConfig
          );
        },

        /* harmony export */
        "NgbTooltipModule": function NgbTooltipModule() {
          return (
            /* binding */
            _NgbTooltipModule
          );
        },

        /* harmony export */
        "NgbTypeahead": function NgbTypeahead() {
          return (
            /* binding */
            _NgbTypeahead
          );
        },

        /* harmony export */
        "NgbTypeaheadConfig": function NgbTypeaheadConfig() {
          return (
            /* binding */
            _NgbTypeaheadConfig
          );
        },

        /* harmony export */
        "NgbTypeaheadModule": function NgbTypeaheadModule() {
          return (
            /* binding */
            _NgbTypeaheadModule
          );
        },

        /* harmony export */
        "ɵa": function ɵa() {
          return (
            /* binding */
            NGB_CAROUSEL_DIRECTIVES
          );
        },

        /* harmony export */
        "ɵb": function ɵb() {
          return (
            /* binding */
            NGB_DATEPICKER_CALENDAR_FACTORY
          );
        },

        /* harmony export */
        "ɵba": function ɵba() {
          return (
            /* binding */
            ContentRef
          );
        },

        /* harmony export */
        "ɵc": function ɵc() {
          return (
            /* binding */
            NgbDatepickerDayView
          );
        },

        /* harmony export */
        "ɵd": function ɵd() {
          return (
            /* binding */
            NgbDatepickerNavigation
          );
        },

        /* harmony export */
        "ɵe": function ɵe() {
          return (
            /* binding */
            NgbDatepickerNavigationSelect
          );
        },

        /* harmony export */
        "ɵf": function ɵf() {
          return (
            /* binding */
            NGB_DATEPICKER_18N_FACTORY
          );
        },

        /* harmony export */
        "ɵg": function ɵg() {
          return (
            /* binding */
            NGB_DATEPICKER_DATE_ADAPTER_FACTORY
          );
        },

        /* harmony export */
        "ɵh": function ɵh() {
          return (
            /* binding */
            NgbDateStructAdapter
          );
        },

        /* harmony export */
        "ɵi": function ɵi() {
          return (
            /* binding */
            NGB_DATEPICKER_PARSER_FORMATTER_FACTORY
          );
        },

        /* harmony export */
        "ɵj": function ɵj() {
          return (
            /* binding */
            NgbDateISOParserFormatter
          );
        },

        /* harmony export */
        "ɵk": function ɵk() {
          return (
            /* binding */
            NgbPopoverWindow
          );
        },

        /* harmony export */
        "ɵl": function ɵl() {
          return (
            /* binding */
            NGB_DATEPICKER_TIME_ADAPTER_FACTORY
          );
        },

        /* harmony export */
        "ɵm": function ɵm() {
          return (
            /* binding */
            NgbTimeStructAdapter
          );
        },

        /* harmony export */
        "ɵn": function ɵn() {
          return (
            /* binding */
            NGB_TIMEPICKER_I18N_FACTORY
          );
        },

        /* harmony export */
        "ɵo": function ɵo() {
          return (
            /* binding */
            NgbTimepickerI18nDefault
          );
        },

        /* harmony export */
        "ɵp": function ɵp() {
          return (
            /* binding */
            NgbTooltipWindow
          );
        },

        /* harmony export */
        "ɵq": function ɵq() {
          return (
            /* binding */
            NgbTypeaheadWindow
          );
        },

        /* harmony export */
        "ɵr": function ɵr() {
          return (
            /* binding */
            NgbDatepickerService
          );
        },

        /* harmony export */
        "ɵs": function ɵs() {
          return (
            /* binding */
            NgbModalBackdrop
          );
        },

        /* harmony export */
        "ɵt": function ɵt() {
          return (
            /* binding */
            NgbModalWindow
          );
        },

        /* harmony export */
        "ɵu": function ɵu() {
          return (
            /* binding */
            NgbModalStack
          );
        },

        /* harmony export */
        "ɵv": function ɵv() {
          return (
            /* binding */
            ScrollBar
          );
        },

        /* harmony export */
        "ɵw": function ɵw() {
          return (
            /* binding */
            ARIA_LIVE_DELAY
          );
        },

        /* harmony export */
        "ɵx": function ɵx() {
          return (
            /* binding */
            ARIA_LIVE_DELAY_FACTORY
          );
        },

        /* harmony export */
        "ɵy": function ɵy() {
          return (
            /* binding */
            Live
          );
        },

        /* harmony export */
        "ɵz": function ɵz() {
          return (
            /* binding */
            NgbCalendarHijri
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      92343);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__);
      /* harmony import */


      var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/forms */
      25864);
      /* harmony import */


      var _angular_forms__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_angular_forms__WEBPACK_IMPORTED_MODULE_4__);

      function NgbAccordion_ng_template_0_ng_template_2_Template(rf, ctx) {}

      function NgbAccordion_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbAccordion_ng_template_0_ng_template_2_Template, 0, 0, "ng-template", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var panel_r3 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngbPanelToggle", panel_r3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", panel_r3.title, "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", panel_r3.titleTpl == null ? null : panel_r3.titleTpl.templateRef);
        }
      }

      function NgbAccordion_ng_template_2_ng_template_2_Template(rf, ctx) {}

      function NgbAccordion_ng_template_2_div_3_ng_template_2_Template(rf, ctx) {}

      function NgbAccordion_ng_template_2_div_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbAccordion_ng_template_2_div_3_ng_template_2_Template, 0, 0, "ng-template", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var panel_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("id", panel_r5.id);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-labelledby", panel_r5.id + "-header");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (panel_r5.contentTpl == null ? null : panel_r5.contentTpl.templateRef) || null);
        }
      }

      var _c0 = function _c0(a0, a1) {
        return {
          $implicit: a0,
          opened: a1
        };
      };

      function NgbAccordion_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbAccordion_ng_template_2_ng_template_2_Template, 0, 0, "ng-template", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbAccordion_ng_template_2_div_3_Template, 3, 3, "div", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var panel_r5 = ctx.$implicit;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("card " + (panel_r5.cardClass || ""));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("card-header " + (panel_r5.type ? "bg-" + panel_r5.type : ctx_r2.type ? "bg-" + ctx_r2.type : ""));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate1"]("id", "", panel_r5.id, "-header");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (panel_r5.headerTpl == null ? null : panel_r5.headerTpl.templateRef) || _r0)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](8, _c0, panel_r5, panel_r5.isOpen));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r2.destroyOnHide || panel_r5.isOpen || panel_r5.transitionRunning);
        }
      }

      function NgbAlert_button_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbAlert_button_1_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r1.close();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2, "\xD7");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      var _c3 = ["*"];

      function NgbCarousel_li_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbCarousel_li_1_Template_li_click_0_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

            var slide_r4 = restoredCtx.$implicit;

            var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r5.focus();
            return ctx_r5.select(slide_r4.id, ctx_r5.NgbSlideEventSource.INDICATOR);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var slide_r4 = ctx.$implicit;

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("active", slide_r4.id === ctx_r0.activeId);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-labelledby", "slide-" + slide_r4.id)("aria-controls", "slide-" + slide_r4.id)("aria-selected", slide_r4.id === ctx_r0.activeId);
        }
      }

      function NgbCarousel_div_3_ng_template_3_Template(rf, ctx) {}

      function NgbCarousel_div_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](2, 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbCarousel_div_3_ng_template_3_Template, 0, 0, "ng-template", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var slide_r7 = ctx.$implicit;
          var i_r8 = ctx.index;
          var c_r9 = ctx.count;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", "slide-" + slide_r7.id);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nExp"](i_r8 + 1)(c_r9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nApply"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", slide_r7.tplRef);
        }
      }

      function NgbCarousel_a_4_Template(rf, ctx) {
        if (rf & 1) {
          var _r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbCarousel_a_4_Template_a_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r11.arrowLeft();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbCarousel_a_5_Template(rf, ctx) {
        if (rf & 1) {
          var _r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbCarousel_a_5_Template_a_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

            var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r13.arrowRight();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      var _c10 = ["defaultDayTemplate"];
      var _c11 = ["content"];

      function NgbDatepicker_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 7);
        }

        if (rf & 2) {
          var date_r8 = ctx.date;
          var currentMonth_r9 = ctx.currentMonth;
          var selected_r10 = ctx.selected;
          var disabled_r11 = ctx.disabled;
          var focused_r12 = ctx.focused;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("date", date_r8)("currentMonth", currentMonth_r9)("selected", selected_r10)("disabled", disabled_r11)("focused", focused_r12);
        }
      }

      function NgbDatepicker_ng_template_2_div_0_div_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var month_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r16.i18n.getMonthLabel(month_r14.firstDate), " ");
        }
      }

      function NgbDatepicker_ng_template_2_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbDatepicker_ng_template_2_div_0_div_1_Template, 2, 1, "div", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "ngb-datepicker-month", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var month_r14 = ctx.$implicit;

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r13.navigation === "none" || ctx_r13.displayMonths > 1 && ctx_r13.navigation === "select");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("month", month_r14.firstDate);
        }
      }

      function NgbDatepicker_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepicker_ng_template_2_div_0_Template, 3, 2, "div", 8);
        }

        if (rf & 2) {
          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r3.model.months);
        }
      }

      function NgbDatepicker_ngb_datepicker_navigation_5_Template(rf, ctx) {
        if (rf & 1) {
          var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ngb-datepicker-navigation", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("navigate", function NgbDatepicker_ngb_datepicker_navigation_5_Template_ngb_datepicker_navigation_navigate_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

            var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r18.onNavigateEvent($event);
          })("select", function NgbDatepicker_ngb_datepicker_navigation_5_Template_ngb_datepicker_navigation_select_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

            var ctx_r20 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r20.onNavigateDateSelect($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("date", ctx_r4.model.firstDate)("months", ctx_r4.model.months)("disabled", ctx_r4.model.disabled)("showSelect", ctx_r4.model.navigation === "select")("prevDisabled", ctx_r4.model.prevDisabled)("nextDisabled", ctx_r4.model.nextDisabled)("selectBoxes", ctx_r4.model.selectBoxes);
        }
      }

      function NgbDatepicker_ng_template_8_Template(rf, ctx) {}

      function NgbDatepicker_ng_template_9_Template(rf, ctx) {}

      function NgbDatepickerMonth_div_0_div_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r2.i18n.getWeekLabel());
        }
      }

      function NgbDatepickerMonth_div_0_div_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var weekday_r4 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](weekday_r4);
        }
      }

      function NgbDatepickerMonth_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbDatepickerMonth_div_0_div_1_Template, 2, 1, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbDatepickerMonth_div_0_div_2_Template, 2, 1, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.datepicker.showWeekNumbers);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.viewModel.weekdays);
        }
      }

      function NgbDatepickerMonth_ng_template_1_div_0_div_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var week_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r7.i18n.getWeekNumerals(week_r5.number));
        }
      }

      function NgbDatepickerMonth_ng_template_1_div_0_div_2_ng_template_1_ng_template_0_Template(rf, ctx) {}

      function NgbDatepickerMonth_ng_template_1_div_0_div_2_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepickerMonth_ng_template_1_div_0_div_2_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 14);
        }

        if (rf & 2) {
          var day_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r11.datepicker.dayTemplate)("ngTemplateOutletContext", day_r10.context);
        }
      }

      function NgbDatepickerMonth_ng_template_1_div_0_div_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbDatepickerMonth_ng_template_1_div_0_div_2_Template_div_click_0_listener($event) {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r15);

            var day_r10 = restoredCtx.$implicit;

            var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            ctx_r14.doSelect(day_r10);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbDatepickerMonth_ng_template_1_div_0_div_2_ng_template_1_Template, 1, 2, "ng-template", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var day_r10 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", day_r10.context.disabled)("hidden", day_r10.hidden)("ngb-dp-today", day_r10.context.today);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", day_r10.tabindex);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", day_r10.ariaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !day_r10.hidden);
        }
      }

      function NgbDatepickerMonth_ng_template_1_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbDatepickerMonth_ng_template_1_div_0_div_1_Template, 2, 1, "div", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbDatepickerMonth_ng_template_1_div_0_div_2_Template, 2, 9, "div", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var week_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r6.datepicker.showWeekNumbers);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", week_r5.days);
        }
      }

      function NgbDatepickerMonth_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepickerMonth_ng_template_1_div_0_Template, 3, 2, "div", 7);
        }

        if (rf & 2) {
          var week_r5 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !week_r5.collapsed);
        }
      }

      function NgbDatepickerNavigation_ngb_datepicker_navigation_select_3_Template(rf, ctx) {
        if (rf & 1) {
          var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ngb-datepicker-navigation-select", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("select", function NgbDatepickerNavigation_ngb_datepicker_navigation_select_3_Template_ngb_datepicker_navigation_select_select_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

            var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r2.select.emit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("date", ctx_r0.date)("disabled", ctx_r0.disabled)("months", ctx_r0.selectBoxes.months)("years", ctx_r0.selectBoxes.years);
        }
      }

      function NgbDatepickerNavigation_4_ng_template_0_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 0);
        }
      }

      function NgbDatepickerNavigation_4_ng_template_0_div_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 0);
        }
      }

      function NgbDatepickerNavigation_4_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepickerNavigation_4_ng_template_0_div_0_Template, 1, 0, "div", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbDatepickerNavigation_4_ng_template_0_div_3_Template, 1, 0, "div", 9);
        }

        if (rf & 2) {
          var month_r5 = ctx.$implicit;
          var i_r6 = ctx.index;

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", i_r6 > 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r4.i18n.getMonthLabel(month_r5.firstDate), " ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", i_r6 !== ctx_r4.months.length - 1);
        }
      }

      function NgbDatepickerNavigation_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepickerNavigation_4_ng_template_0_Template, 4, 3, "ng-template", 8);
        }

        if (rf & 2) {
          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r1.months);
        }
      }

      var _c20 = ["ngbDatepickerDayView", ""];
      var _c21 = ["month"];
      var _c22 = ["year"];

      function NgbDatepickerNavigationSelect_option_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "option", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var m_r4 = ctx.$implicit;

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", m_r4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r1.i18n.getMonthFullName(m_r4, ctx_r1.date == null ? null : ctx_r1.date.year));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r1.i18n.getMonthShortName(m_r4, ctx_r1.date == null ? null : ctx_r1.date.year));
        }
      }

      function NgbDatepickerNavigationSelect_option_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "option", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var y_r5 = ctx.$implicit;

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", y_r5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r3.i18n.getYearNumerals(y_r5));
        }
      }

      var _c31 = ["dialog"];
      var _c32 = ["ngbNavOutlet", ""];

      function NgbNavOutlet_ng_template_0_div_0_ng_template_1_Template(rf, ctx) {}

      var _c33 = function _c33(a0) {
        return {
          $implicit: a0
        };
      };

      function NgbNavOutlet_ng_template_0_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbNavOutlet_ng_template_0_div_0_ng_template_1_Template, 0, 0, "ng-template", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var item_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("item", item_r1)("nav", ctx_r2.nav)("role", ctx_r2.paneRole);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (item_r1.contentTpl == null ? null : item_r1.contentTpl.templateRef) || null)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](5, _c33, item_r1.active || ctx_r2.isPanelTransitioning(item_r1)));
        }
      }

      function NgbNavOutlet_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbNavOutlet_ng_template_0_div_0_Template, 2, 7, "div", 1);
        }

        if (rf & 2) {
          var item_r1 = ctx.$implicit;

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", item_r1.isPanelInDom() || ctx_r0.isPanelTransitioning(item_r1));
        }
      }

      function NgbPagination_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbPagination_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbPagination_ng_template_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbPagination_ng_template_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbPagination_ng_template_8_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0, "...");
        }
      }

      function NgbPagination_ng_template_10_span_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1, "(current)");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbPagination_ng_template_10_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPagination_ng_template_10_span_1_Template, 2, 0, "span", 14);
        }

        if (rf & 2) {
          var page_r19 = ctx.$implicit;
          var currentPage_r20 = ctx.currentPage;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", page_r19, " ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", page_r19 === currentPage_r20);
        }
      }

      function NgbPagination_ng_template_12_li_0_a_1_ng_template_1_Template(rf, ctx) {}

      var _c42 = function _c42(a1) {
        return {
          disabled: true,
          currentPage: a1
        };
      };

      function NgbPagination_ng_template_12_li_0_a_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 20);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPagination_ng_template_12_li_0_a_1_ng_template_1_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var page_r22 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r27 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r27.tplEllipsis == null ? null : ctx_r27.tplEllipsis.templateRef) || _r8)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](2, _c42, page_r22));
        }
      }

      function NgbPagination_ng_template_12_li_0_a_2_ng_template_1_Template(rf, ctx) {}

      var _c43 = function _c43(a0, a1, a2) {
        return {
          disabled: a0,
          $implicit: a1,
          currentPage: a2
        };
      };

      function NgbPagination_ng_template_12_li_0_a_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r34 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 21);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPagination_ng_template_12_li_0_a_2_Template_a_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r34);

            var pageNumber_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

            var ctx_r32 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            ctx_r32.selectPage(pageNumber_r26);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPagination_ng_template_12_li_0_a_2_ng_template_1_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var pageNumber_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r35 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var disabled_r24 = ctx_r35.disabled;
          var page_r22 = ctx_r35.$implicit;

          var ctx_r28 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("tabindex", disabled_r24 ? "-1" : null)("aria-disabled", disabled_r24 ? "true" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r28.tplNumber == null ? null : ctx_r28.tplNumber.templateRef) || _r10)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction3"](4, _c43, disabled_r24, pageNumber_r26, page_r22));
        }
      }

      function NgbPagination_ng_template_12_li_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPagination_ng_template_12_li_0_a_1_Template, 2, 4, "a", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_ng_template_12_li_0_a_2_Template, 2, 8, "a", 19);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var pageNumber_r26 = ctx.$implicit;

          var ctx_r37 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var page_r22 = ctx_r37.$implicit;
          var disabled_r24 = ctx_r37.disabled;

          var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("active", pageNumber_r26 === page_r22)("disabled", ctx_r25.isEllipsis(pageNumber_r26) || disabled_r24);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-current", pageNumber_r26 === page_r22 ? "page" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r25.isEllipsis(pageNumber_r26));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r25.isEllipsis(pageNumber_r26));
        }
      }

      function NgbPagination_ng_template_12_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbPagination_ng_template_12_li_0_Template, 3, 7, "li", 16);
        }

        if (rf & 2) {
          var pages_r23 = ctx.pages;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", pages_r23);
        }
      }

      function NgbPagination_li_15_ng_template_2_Template(rf, ctx) {}

      var _c46 = function _c46(a0, a1) {
        return {
          disabled: a0,
          currentPage: a1
        };
      };

      function NgbPagination_li_15_Template(rf, ctx) {
        if (rf & 1) {
          var _r40 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 22);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPagination_li_15_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r40);

            var ctx_r39 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r39.selectPage(1);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_li_15_ng_template_2_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx_r14.previousDisabled());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("tabindex", ctx_r14.previousDisabled() ? "-1" : null)("aria-disabled", ctx_r14.previousDisabled() ? "true" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r14.tplFirst == null ? null : ctx_r14.tplFirst.templateRef) || _r0)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](6, _c46, ctx_r14.previousDisabled(), ctx_r14.page));
        }
      }

      function NgbPagination_li_16_ng_template_2_Template(rf, ctx) {}

      var _c49 = function _c49(a0) {
        return {
          disabled: a0
        };
      };

      function NgbPagination_li_16_Template(rf, ctx) {
        if (rf & 1) {
          var _r43 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 23);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPagination_li_16_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r43);

            var ctx_r42 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r42.selectPage(ctx_r42.page - 1);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_li_16_ng_template_2_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx_r15.previousDisabled());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("tabindex", ctx_r15.previousDisabled() ? "-1" : null)("aria-disabled", ctx_r15.previousDisabled() ? "true" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r15.tplPrevious == null ? null : ctx_r15.tplPrevious.templateRef) || _r2)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](6, _c49, ctx_r15.previousDisabled()));
        }
      }

      function NgbPagination_ng_template_17_Template(rf, ctx) {}

      function NgbPagination_li_18_ng_template_2_Template(rf, ctx) {}

      function NgbPagination_li_18_Template(rf, ctx) {
        if (rf & 1) {
          var _r46 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 24);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPagination_li_18_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r46);

            var ctx_r45 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r45.selectPage(ctx_r45.page + 1);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_li_18_ng_template_2_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx_r17.nextDisabled());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("tabindex", ctx_r17.nextDisabled() ? "-1" : null)("aria-disabled", ctx_r17.nextDisabled() ? "true" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r17.tplNext == null ? null : ctx_r17.tplNext.templateRef) || _r4)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](6, _c46, ctx_r17.nextDisabled(), ctx_r17.page));
        }
      }

      function NgbPagination_li_19_ng_template_2_Template(rf, ctx) {}

      function NgbPagination_li_19_Template(rf, ctx) {
        if (rf & 1) {
          var _r49 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 25);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPagination_li_19_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r49);

            var ctx_r48 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r48.selectPage(ctx_r48.pageCount);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_li_19_ng_template_2_Template, 0, 0, "ng-template", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx_r18.nextDisabled());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("tabindex", ctx_r18.nextDisabled() ? "-1" : null)("aria-disabled", ctx_r18.nextDisabled() ? "true" : null);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx_r18.tplLast == null ? null : ctx_r18.tplLast.templateRef) || _r6)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](6, _c46, ctx_r18.nextDisabled(), ctx_r18.page));
        }
      }

      var _c54 = function _c54(a0, a1, a2) {
        return {
          $implicit: a0,
          pages: a1,
          disabled: a2
        };
      };

      function NgbPopoverWindow_h3_1_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0);
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r2.title);
        }
      }

      function NgbPopoverWindow_h3_1_ng_template_3_Template(rf, ctx) {}

      function NgbPopoverWindow_h3_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "h3", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPopoverWindow_h3_1_ng_template_1_Template, 1, 1, "ng-template", null, 4, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbPopoverWindow_h3_1_ng_template_3_Template, 0, 0, "ng-template", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var _r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](2);

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r0.isTitleTemplate() ? ctx_r0.title : _r1)("ngTemplateOutletContext", ctx_r0.context);
        }
      }

      function NgbProgressbar_span_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](2, "percent");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nExp"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](2, 1, ctx_r0.getValue() / ctx_r0.max));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nApply"](1);
        }
      }

      function NgbRating_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0);
        }

        if (rf & 2) {
          var fill_r3 = ctx.fill;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](fill_r3 === 100 ? "\u2605" : "\u2606");
        }
      }

      function NgbRating_ng_template_2_ng_template_3_Template(rf, ctx) {}

      function NgbRating_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mouseenter", function NgbRating_ng_template_2_Template_span_mouseenter_2_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

            var index_r4 = restoredCtx.index;

            var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r6.enter(index_r4 + 1);
          })("click", function NgbRating_ng_template_2_Template_span_click_2_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

            var index_r4 = restoredCtx.index;

            var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r8.handleClick(index_r4 + 1);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbRating_ng_template_2_ng_template_3_Template, 0, 0, "ng-template", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var index_r4 = ctx.index;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("(", index_r4 < ctx_r2.nextRate ? "*" : " ", ")");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("cursor", ctx_r2.isInteractive() ? "pointer" : "default");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r2.starTemplate || ctx_r2.starTemplateFromContent || _r0)("ngTemplateOutletContext", ctx_r2.contexts[index_r4]);
        }
      }

      function NgbTimepicker_button_3_Template(rf, ctx) {
        if (rf & 1) {
          var _r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_button_3_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r9);

            var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r8.changeHour(ctx_r8.hourStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r0.isSmallSize)("btn-lg", ctx_r0.isLargeSize)("disabled", ctx_r0.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r0.disabled);
        }
      }

      function NgbTimepicker_button_5_Template(rf, ctx) {
        if (rf & 1) {
          var _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_button_5_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r11);

            var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r10.changeHour(-ctx_r10.hourStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r1.isSmallSize)("btn-lg", ctx_r1.isLargeSize)("disabled", ctx_r1.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r1.disabled);
        }
      }

      function NgbTimepicker_button_9_Template(rf, ctx) {
        if (rf & 1) {
          var _r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_button_9_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r13);

            var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r12.changeMinute(ctx_r12.minuteStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r2.isSmallSize)("btn-lg", ctx_r2.isLargeSize)("disabled", ctx_r2.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r2.disabled);
        }
      }

      function NgbTimepicker_button_11_Template(rf, ctx) {
        if (rf & 1) {
          var _r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_button_11_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r15);

            var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r14.changeMinute(-ctx_r14.minuteStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r3.isSmallSize)("btn-lg", ctx_r3.isLargeSize)("disabled", ctx_r3.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r3.disabled);
        }
      }

      function NgbTimepicker_div_12_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1, ":");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }
      }

      function NgbTimepicker_div_13_button_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_div_13_button_1_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

            var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r18.changeSecond(ctx_r18.secondStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 21);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r16.isSmallSize)("btn-lg", ctx_r16.isLargeSize)("disabled", ctx_r16.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r16.disabled);
        }
      }

      function NgbTimepicker_div_13_button_3_Template(rf, ctx) {
        if (rf & 1) {
          var _r21 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_div_13_button_3_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r21);

            var ctx_r20 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r20.changeSecond(-ctx_r20.secondStep);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](3, 22);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r17.isSmallSize)("btn-lg", ctx_r17.isLargeSize)("disabled", ctx_r17.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r17.disabled);
        }
      }

      function NgbTimepicker_div_13_Template(rf, ctx) {
        if (rf & 1) {
          var _r23 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 19);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbTimepicker_div_13_button_1_Template, 4, 7, "button", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "input", 20);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbTimepicker_div_13_Template_input_change_2_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r23);

            var ctx_r22 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r22.updateSecond($event.target.value);
          })("blur", function NgbTimepicker_div_13_Template_input_blur_2_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r23);

            var ctx_r24 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r24.handleBlur();
          })("input", function NgbTimepicker_div_13_Template_input_input_2_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r23);

            var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r25.formatInput($event.target);
          })("keydown.ArrowUp", function NgbTimepicker_div_13_Template_input_keydown_ArrowUp_2_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r23);

            var ctx_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r26.changeSecond(ctx_r26.secondStep);
            return $event.preventDefault();
          })("keydown.ArrowDown", function NgbTimepicker_div_13_Template_input_keydown_ArrowDown_2_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r23);

            var ctx_r27 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            ctx_r27.changeSecond(-ctx_r27.secondStep);
            return $event.preventDefault();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbTimepicker_div_13_button_3_Template, 4, 7, "button", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r5.spinners);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("form-control-sm", ctx_r5.isSmallSize)("form-control-lg", ctx_r5.isLargeSize);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", ctx_r5.formatMinSec(ctx_r5.model == null ? null : ctx_r5.model.second))("readOnly", ctx_r5.readonlyInputs)("disabled", ctx_r5.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r5.spinners);
        }
      }

      function NgbTimepicker_div_14_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 5);
        }
      }

      function NgbTimepicker_div_15_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](1, 27);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r28 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nExp"](ctx_r28.i18n.getAfternoonPeriod());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nApply"](1);
        }
      }

      function NgbTimepicker_div_15_ng_template_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18n"](0, 28);
        }

        if (rf & 2) {
          var ctx_r30 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nExp"](ctx_r30.i18n.getMorningPeriod());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵi18nApply"](0);
        }
      }

      function NgbTimepicker_div_15_Template(rf, ctx) {
        if (rf & 1) {
          var _r32 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 23);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "button", 24);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbTimepicker_div_15_Template_button_click_1_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r32);

            var ctx_r31 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r31.toggleMeridian();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbTimepicker_div_15_ng_container_2_Template, 2, 1, "ng-container", 25);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbTimepicker_div_15_ng_template_3_Template, 1, 1, "ng-template", null, 26, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var _r29 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](4);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn-sm", ctx_r7.isSmallSize)("btn-lg", ctx_r7.isLargeSize)("disabled", ctx_r7.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r7.disabled);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r7.model && ctx_r7.model.hour >= 12)("ngIfElse", _r29);
        }
      }

      function NgbToast_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "strong", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r1.header);
        }
      }

      function NgbToast_ng_template_2_ng_template_1_Template(rf, ctx) {}

      function NgbToast_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbToast_ng_template_2_ng_template_1_Template, 0, 0, "ng-template", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "button", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbToast_ng_template_2_Template_button_click_2_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

            var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r4.hide();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4, "\xD7");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r2.contentHeaderTpl || _r0);
        }
      }

      function NgbHighlight_ng_template_0_span_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var part_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"](ctx_r3.highlightClass);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](part_r1);
        }
      }

      function NgbHighlight_ng_template_0_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0);
        }

        if (rf & 2) {
          var part_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](part_r1);
        }
      }

      function NgbHighlight_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbHighlight_ng_template_0_span_0_Template, 2, 3, "span", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbHighlight_ng_template_0_ng_template_1_Template, 1, 1, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
        }

        if (rf & 2) {
          var isOdd_r2 = ctx.odd;

          var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", isOdd_r2)("ngIfElse", _r4);
        }
      }

      function NgbTypeaheadWindow_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "ngb-highlight", 2);
        }

        if (rf & 2) {
          var result_r3 = ctx.result;
          var term_r4 = ctx.term;
          var formatter_r5 = ctx.formatter;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("result", formatter_r5(result_r3))("term", term_r4);
        }
      }

      function NgbTypeaheadWindow_ng_template_2_ng_template_1_Template(rf, ctx) {}

      var _c87 = function _c87(a0, a1, a2) {
        return {
          result: a0,
          term: a1,
          formatter: a2
        };
      };

      function NgbTypeaheadWindow_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mouseenter", function NgbTypeaheadWindow_ng_template_2_Template_button_mouseenter_0_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var idx_r7 = restoredCtx.index;

            var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r9.markActive(idx_r7);
          })("click", function NgbTypeaheadWindow_ng_template_2_Template_button_click_0_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var result_r6 = restoredCtx.$implicit;

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r11.select(result_r6);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbTypeaheadWindow_ng_template_2_ng_template_1_Template, 0, 0, "ng-template", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var result_r6 = ctx.$implicit;
          var idx_r7 = ctx.index;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("active", idx_r7 === ctx_r2.activeIdx);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r2.id + "-" + idx_r7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r2.resultTemplate || _r0)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction3"](5, _c87, result_r6, ctx_r2.term, ctx_r2.formatter));
        }
      }

      function toInteger(value) {
        return parseInt("".concat(value), 10);
      }

      function toString(value) {
        return value !== undefined && value !== null ? "".concat(value) : '';
      }

      function getValueInRange(value, max) {
        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return Math.max(Math.min(value, max), min);
      }

      function isString(value) {
        return typeof value === 'string';
      }

      function isNumber(value) {
        return !isNaN(toInteger(value));
      }

      function isInteger(value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
      }

      function isDefined(value) {
        return value !== undefined && value !== null;
      }

      function padNumber(value) {
        if (isNumber(value)) {
          return "0".concat(value).slice(-2);
        } else {
          return '';
        }
      }

      function regExpEscape(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      }

      function hasClassName(element, className) {
        return element && element.className && element.className.split && element.className.split(/\s+/).indexOf(className) >= 0;
      }

      if (typeof Element !== 'undefined' && !Element.prototype.closest) {
        // Polyfill for ie10+
        if (!Element.prototype.matches) {
          // IE uses the non-standard name: msMatchesSelector
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }

        Element.prototype.closest = function (s) {
          var el = this;

          if (!document.documentElement.contains(el)) {
            return null;
          }

          do {
            if (el.matches(s)) {
              return el;
            }

            el = el.parentElement || el.parentNode;
          } while (el !== null && el.nodeType === 1);

          return null;
        };
      }

      function closest(element, selector) {
        if (!selector) {
          return null;
        }
        /*
         * In certain browsers (e.g. Edge 44.18362.449.0) HTMLDocument does
         * not support `Element.prototype.closest`. To emulate the correct behaviour
         * we return null when the method is missing.
         *
         * Note that in evergreen browsers `closest(document.documentElement, 'html')`
         * will return the document element whilst in Edge null will be returned. This
         * compromise was deemed good enough.
         */


        if (typeof element.closest === 'undefined') {
          return null;
        }

        return element.closest(selector);
      }
      /**
       * Force a browser reflow
       * @param element element where to apply the reflow
       */


      function reflow(element) {
        return (element || document.body).getBoundingClientRect();
      }
      /**
       * Creates an observable where all callbacks are executed inside a given zone
       *
       * @param zone
       */


      function runInZone(zone) {
        return function (source) {
          return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(function (observer) {
            var onNext = function onNext(value) {
              return zone.run(function () {
                return observer.next(value);
              });
            };

            var onError = function onError(e) {
              return zone.run(function () {
                return observer.error(e);
              });
            };

            var onComplete = function onComplete() {
              return zone.run(function () {
                return observer.complete();
              });
            };

            return source.subscribe(onNext, onError, onComplete);
          });
        };
      }

      function removeAccents(str) {
        return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      }

      var environment = {
        animation: true,
        transitionTimerDelayMs: 5
      };
      /**
       * Global ng-bootstrap config
       *
       * @since 8.0.0
       */

      var _NgbConfig = /*#__PURE__*/function () {
        var NgbConfig = function NgbConfig() {
          _classCallCheck(this, NgbConfig);

          this.animation = environment.animation;
        };

        NgbConfig.ɵfac = function NgbConfig_Factory(t) {
          return new (t || NgbConfig)();
        };

        NgbConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbConfig_Factory() {
            return new NgbConfig();
          },
          token: NgbConfig,
          providedIn: "root"
        });
        return NgbConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A configuration service for the [NgbAccordion](#/components/accordion/api#NgbAccordion) component.
       *
       * You can inject this service, typically in your root component, and customize its properties
       * to provide default values for all accordions used in the application.
       */


      var _NgbAccordionConfig = /*#__PURE__*/function () {
        var NgbAccordionConfig = /*#__PURE__*/function () {
          function NgbAccordionConfig(_ngbConfig) {
            _classCallCheck(this, NgbAccordionConfig);

            this._ngbConfig = _ngbConfig;
            this.closeOthers = false;
          }

          _createClass(NgbAccordionConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbAccordionConfig;
        }();

        NgbAccordionConfig.ɵfac = function NgbAccordionConfig_Factory(t) {
          return new (t || NgbAccordionConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbAccordionConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbAccordionConfig_Factory() {
            return new NgbAccordionConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbAccordionConfig,
          providedIn: "root"
        });
        return NgbAccordionConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      function getTransitionDurationMs(element) {
        var _window$getComputedSt = window.getComputedStyle(element),
            transitionDelay = _window$getComputedSt.transitionDelay,
            transitionDuration = _window$getComputedSt.transitionDuration;

        var transitionDelaySec = parseFloat(transitionDelay);
        var transitionDurationSec = parseFloat(transitionDuration);
        return (transitionDelaySec + transitionDurationSec) * 1000;
      }

      var noopFn = function noopFn() {};

      var ɵ0 = noopFn;
      var transitionTimerDelayMs = environment.transitionTimerDelayMs;
      var runningTransitions = new Map();

      var ngbRunTransition = function ngbRunTransition(zone, element, startFn, options) {
        // Getting initial context from options
        var context = options.context || {}; // Checking if there are already running transitions on the given element.

        var running = runningTransitions.get(element);

        if (running) {
          switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
              return rxjs__WEBPACK_IMPORTED_MODULE_2__.EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.

            case 'stop':
              zone.run(function () {
                return running.transition$.complete();
              });
              context = Object.assign(running.context, context);
              runningTransitions["delete"](element);
          }
        } // Running the start function


        var endFn = startFn(element, options.animation, context) || noopFn; // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
        // If animations are disabled, we have to emit a value and complete the observable
        // In this case we have to call the end function, but can finish immediately by emitting a value,
        // completing the observable and executing end functions synchronously.

        if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
          zone.run(function () {
            return endFn();
          });
          return (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(undefined).pipe(runInZone(zone));
        } // Starting a new transition


        var transition$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
        var finishTransition$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
        var stop$ = transition$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.endWith)(true));
        runningTransitions.set(element, {
          transition$: transition$,
          complete: function complete() {
            finishTransition$.next();
            finishTransition$.complete();
          },
          context: context
        });
        var transitionDurationMs = getTransitionDurationMs(element); // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
        // because 'transitionend' event might not be fired in some browsers, if the transitioning
        // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
        // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
        // 2. We need to filter transition end events, because they might bubble from shorter transitions
        // on inner DOM elements. We're only interested in the transition on the 'element' itself.

        zone.runOutsideAngular(function () {
          var transitionEnd$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(element, 'transitionend').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stop$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (_ref) {
            var target = _ref.target;
            return target === element;
          }));
          var timer$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.timer)(transitionDurationMs + transitionTimerDelayMs).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stop$));
          (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.race)(timer$, transitionEnd$, finishTransition$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stop$)).subscribe(function () {
            runningTransitions["delete"](element);
            zone.run(function () {
              endFn();
              transition$.next();
              transition$.complete();
            });
          });
        });
        return transition$.asObservable();
      };

      var ngbCompleteTransition = function ngbCompleteTransition(element) {
        var _a;

        (_a = runningTransitions.get(element)) === null || _a === void 0 ? void 0 : _a.complete();
      };

      function measureCollapsingElementHeightPx(element) {
        // SSR fix for without injecting the PlatformId
        if (typeof navigator === 'undefined') {
          return '0px';
        }

        var classList = element.classList;
        var hasShownClass = classList.contains('show');

        if (!hasShownClass) {
          classList.add('show');
        }

        element.style.height = '';
        var height = element.getBoundingClientRect().height + 'px';

        if (!hasShownClass) {
          classList.remove('show');
        }

        return height;
      }

      var ngbCollapsingTransition = function ngbCollapsingTransition(element, animation, context) {
        var direction = context.direction,
            maxHeight = context.maxHeight;
        var classList = element.classList;

        function setInitialClasses() {
          classList.add('collapse');

          if (direction === 'show') {
            classList.add('show');
          } else {
            classList.remove('show');
          }
        } // without animations we just need to set initial classes


        if (!animation) {
          setInitialClasses();
          return;
        } // No maxHeight -> running the transition for the first time


        if (!maxHeight) {
          maxHeight = measureCollapsingElementHeightPx(element);
          context.maxHeight = maxHeight; // Fix the height before starting the animation

          element.style.height = direction !== 'show' ? maxHeight : '0px';
          classList.remove('collapse');
          classList.remove('collapsing');
          classList.remove('show');
          reflow(element); // Start the animation

          classList.add('collapsing');
        } // Start or revert the animation


        element.style.height = direction === 'show' ? maxHeight : '0px';
        return function () {
          setInitialClasses();
          classList.remove('collapsing');
          element.style.height = '';
        };
      };

      var nextId = 0;
      /**
       * A directive that wraps an accordion panel header with any HTML markup and a toggling button
       * marked with [`NgbPanelToggle`](#/components/accordion/api#NgbPanelToggle).
       * See the [header customization demo](#/components/accordion/examples#header) for more details.
       *
       * You can also use [`NgbPanelTitle`](#/components/accordion/api#NgbPanelTitle) to customize only the panel title.
       *
       * @since 4.1.0
       */

      var _NgbPanelHeader = /*#__PURE__*/function () {
        var NgbPanelHeader = function NgbPanelHeader(templateRef) {
          _classCallCheck(this, NgbPanelHeader);

          this.templateRef = templateRef;
        };

        NgbPanelHeader.ɵfac = function NgbPanelHeader_Factory(t) {
          return new (t || NgbPanelHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPanelHeader.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPanelHeader,
          selectors: [["ng-template", "ngbPanelHeader", ""]]
        });
        return NgbPanelHeader;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that wraps only the panel title with HTML markup inside.
       *
       * You can also use [`NgbPanelHeader`](#/components/accordion/api#NgbPanelHeader) to customize the full panel header.
       */


      var _NgbPanelTitle = /*#__PURE__*/function () {
        var NgbPanelTitle = function NgbPanelTitle(templateRef) {
          _classCallCheck(this, NgbPanelTitle);

          this.templateRef = templateRef;
        };

        NgbPanelTitle.ɵfac = function NgbPanelTitle_Factory(t) {
          return new (t || NgbPanelTitle)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPanelTitle.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPanelTitle,
          selectors: [["ng-template", "ngbPanelTitle", ""]]
        });
        return NgbPanelTitle;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that wraps the accordion panel content.
       */


      var _NgbPanelContent = /*#__PURE__*/function () {
        var NgbPanelContent = function NgbPanelContent(templateRef) {
          _classCallCheck(this, NgbPanelContent);

          this.templateRef = templateRef;
        };

        NgbPanelContent.ɵfac = function NgbPanelContent_Factory(t) {
          return new (t || NgbPanelContent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPanelContent.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPanelContent,
          selectors: [["ng-template", "ngbPanelContent", ""]]
        });
        return NgbPanelContent;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that wraps an individual accordion panel with title and collapsible content.
       */


      var _NgbPanel = /*#__PURE__*/function () {
        var NgbPanel = /*#__PURE__*/function () {
          function NgbPanel() {
            _classCallCheck(this, NgbPanel);

            /**
             *  If `true`, the panel is disabled an can't be toggled.
             */
            this.disabled = false;
            /**
             *  An optional id for the panel that must be unique on the page.
             *
             *  If not provided, it will be auto-generated in the `ngb-panel-xxx` format.
             */

            this.id = "ngb-panel-".concat(nextId++);
            this.isOpen = false;
            /* A flag to specified that the transition panel classes have been initialized */

            this.initClassDone = false;
            /* A flag to specified if the panel is currently being animated, to ensure its presence in the dom */

            this.transitionRunning = false;
            /**
             * An event emitted when the panel is shown, after the transition. It has no payload.
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the panel is hidden, after the transition. It has no payload.
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          }

          _createClass(NgbPanel, [{
            key: "ngAfterContentChecked",
            value: function ngAfterContentChecked() {
              // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
              // only @ContentChildren allows us to specify the {descendants: false} option.
              // Without {descendants: false} we are hitting bugs described in:
              // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
              this.titleTpl = this.titleTpls.first;
              this.headerTpl = this.headerTpls.first;
              this.contentTpl = this.contentTpls.first;
            }
          }]);

          return NgbPanel;
        }();

        NgbPanel.ɵfac = function NgbPanel_Factory(t) {
          return new (t || NgbPanel)();
        };

        NgbPanel.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPanel,
          selectors: [["ngb-panel"]],
          contentQueries: function NgbPanel_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPanelTitle, 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPanelHeader, 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPanelContent, 4);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.titleTpls = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.headerTpls = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.contentTpls = _t);
            }
          },
          inputs: {
            disabled: "disabled",
            id: "id",
            title: "title",
            type: "type",
            cardClass: "cardClass"
          },
          outputs: {
            shown: "shown",
            hidden: "hidden"
          }
        });
        return NgbPanel;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Accordion is a collection of collapsible panels (bootstrap cards).
       *
       * It can ensure only one panel is opened at a time and allows to customize panel
       * headers.
       */


      var _NgbAccordion = /*#__PURE__*/function () {
        var NgbAccordion = /*#__PURE__*/function () {
          function NgbAccordion(config, _element, _ngZone, _changeDetector) {
            _classCallCheck(this, NgbAccordion);

            this._element = _element;
            this._ngZone = _ngZone;
            this._changeDetector = _changeDetector;
            /**
             * An array or comma separated strings of panel ids that should be opened **initially**.
             *
             * For subsequent changes use methods like `expand()`, `collapse()`, etc. and
             * the `(panelChange)` event.
             */

            this.activeIds = [];
            /**
             * If `true`, panel content will be detached from DOM and not simply hidden when the panel is collapsed.
             */

            this.destroyOnHide = true;
            /**
             * Event emitted right before the panel toggle happens.
             *
             * See [NgbPanelChangeEvent](#/components/accordion/api#NgbPanelChangeEvent) for payload details.
             */

            this.panelChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the expanding animation is finished on the panel. The payload is the panel id.
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the collapsing animation is finished on the panel, and before the panel element is removed.
             * The payload is the panel id.
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.animation = config.animation;
            this.type = config.type;
            this.closeOtherPanels = config.closeOthers;
          }
          /**
           * Checks if a panel with a given id is expanded.
           */


          _createClass(NgbAccordion, [{
            key: "isExpanded",
            value: function isExpanded(panelId) {
              return this.activeIds.indexOf(panelId) > -1;
            }
            /**
             * Expands a panel with a given id.
             *
             * Has no effect if the panel is already expanded or disabled.
             */

          }, {
            key: "expand",
            value: function expand(panelId) {
              this._changeOpenState(this._findPanelById(panelId), true);
            }
            /**
             * Expands all panels, if `[closeOthers]` is `false`.
             *
             * If `[closeOthers]` is `true`, it will expand the first panel, unless there is already a panel opened.
             */

          }, {
            key: "expandAll",
            value: function expandAll() {
              var _this = this;

              if (this.closeOtherPanels) {
                if (this.activeIds.length === 0 && this.panels.length) {
                  this._changeOpenState(this.panels.first, true);
                }
              } else {
                this.panels.forEach(function (panel) {
                  return _this._changeOpenState(panel, true);
                });
              }
            }
            /**
             * Collapses a panel with the given id.
             *
             * Has no effect if the panel is already collapsed or disabled.
             */

          }, {
            key: "collapse",
            value: function collapse(panelId) {
              this._changeOpenState(this._findPanelById(panelId), false);
            }
            /**
             * Collapses all opened panels.
             */

          }, {
            key: "collapseAll",
            value: function collapseAll() {
              var _this2 = this;

              this.panels.forEach(function (panel) {
                _this2._changeOpenState(panel, false);
              });
            }
            /**
             * Toggles a panel with the given id.
             *
             * Has no effect if the panel is disabled.
             */

          }, {
            key: "toggle",
            value: function toggle(panelId) {
              var panel = this._findPanelById(panelId);

              if (panel) {
                this._changeOpenState(panel, !panel.isOpen);
              }
            }
          }, {
            key: "ngAfterContentChecked",
            value: function ngAfterContentChecked() {
              var _this3 = this;

              // active id updates
              if (isString(this.activeIds)) {
                this.activeIds = this.activeIds.split(/\s*,\s*/);
              } // update panels open states


              this.panels.forEach(function (panel) {
                panel.isOpen = !panel.disabled && _this3.activeIds.indexOf(panel.id) > -1;
              }); // closeOthers updates

              if (this.activeIds.length > 1 && this.closeOtherPanels) {
                this._closeOthers(this.activeIds[0], false);

                this._updateActiveIds();
              } // Setup the initial classes here


              this._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                _this3.panels.forEach(function (panel) {
                  var panelElement = _this3._getPanelElement(panel.id);

                  if (panelElement) {
                    if (!panel.initClassDone) {
                      panel.initClassDone = true;
                      ngbRunTransition(_this3._ngZone, panelElement, ngbCollapsingTransition, {
                        animation: false,
                        runningTransition: 'continue',
                        context: {
                          direction: panel.isOpen ? 'show' : 'hide'
                        }
                      });
                    }
                  } else {
                    // Classes must be initialized next time it will be in the dom
                    panel.initClassDone = false;
                  }
                });
              });
            }
          }, {
            key: "_changeOpenState",
            value: function _changeOpenState(panel, nextState) {
              if (panel != null && !panel.disabled && panel.isOpen !== nextState) {
                var defaultPrevented = false;
                this.panelChange.emit({
                  panelId: panel.id,
                  nextState: nextState,
                  preventDefault: function preventDefault() {
                    defaultPrevented = true;
                  }
                });

                if (!defaultPrevented) {
                  panel.isOpen = nextState;
                  panel.transitionRunning = true;

                  if (nextState && this.closeOtherPanels) {
                    this._closeOthers(panel.id);
                  }

                  this._updateActiveIds();

                  this._runTransitions(this.animation);
                }
              }
            }
          }, {
            key: "_closeOthers",
            value: function _closeOthers(panelId) {
              var enableTransition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              this.panels.forEach(function (panel) {
                if (panel.id !== panelId && panel.isOpen) {
                  panel.isOpen = false;
                  panel.transitionRunning = enableTransition;
                }
              });
            }
          }, {
            key: "_findPanelById",
            value: function _findPanelById(panelId) {
              return this.panels.find(function (p) {
                return p.id === panelId;
              }) || null;
            }
          }, {
            key: "_updateActiveIds",
            value: function _updateActiveIds() {
              this.activeIds = this.panels.filter(function (panel) {
                return panel.isOpen && !panel.disabled;
              }).map(function (panel) {
                return panel.id;
              });
            }
          }, {
            key: "_runTransitions",
            value: function _runTransitions(animation) {
              var _this4 = this;

              // detectChanges is performed to ensure that all panels are in the dom (via transitionRunning = true)
              // before starting the animation
              this._changeDetector.detectChanges();

              this.panels.forEach(function (panel) {
                // When panel.transitionRunning is true, the transition needs to be started OR reversed,
                // The direction (show or hide) is choosen by each panel.isOpen state
                if (panel.transitionRunning) {
                  var panelElement = _this4._getPanelElement(panel.id);

                  ngbRunTransition(_this4._ngZone, panelElement, ngbCollapsingTransition, {
                    animation: animation,
                    runningTransition: 'stop',
                    context: {
                      direction: panel.isOpen ? 'show' : 'hide'
                    }
                  }).subscribe(function () {
                    panel.transitionRunning = false;
                    var id = panel.id;

                    if (panel.isOpen) {
                      panel.shown.emit();

                      _this4.shown.emit(id);
                    } else {
                      panel.hidden.emit();

                      _this4.hidden.emit(id);
                    }
                  });
                }
              });
            }
          }, {
            key: "_getPanelElement",
            value: function _getPanelElement(panelId) {
              return this._element.nativeElement.querySelector('#' + panelId);
            }
          }]);

          return NgbAccordion;
        }();

        NgbAccordion.ɵfac = function NgbAccordion_Factory(t) {
          return new (t || NgbAccordion)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbAccordionConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
        };

        NgbAccordion.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbAccordion,
          selectors: [["ngb-accordion"]],
          contentQueries: function NgbAccordion_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPanel, 4);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.panels = _t);
            }
          },
          hostAttrs: ["role", "tablist", 1, "accordion"],
          hostVars: 1,
          hostBindings: function NgbAccordion_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-multiselectable", !ctx.closeOtherPanels);
            }
          },
          inputs: {
            activeIds: "activeIds",
            destroyOnHide: "destroyOnHide",
            animation: "animation",
            type: "type",
            closeOtherPanels: ["closeOthers", "closeOtherPanels"]
          },
          outputs: {
            panelChange: "panelChange",
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbAccordion"],
          decls: 3,
          vars: 1,
          consts: [["ngbPanelHeader", ""], ["t", ""], ["ngFor", "", 3, "ngForOf"], [1, "btn", "btn-link", 3, "ngbPanelToggle"], [3, "ngTemplateOutlet"], ["role", "tab", 3, "id"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "tabpanel", 3, "id", 4, "ngIf"], ["role", "tabpanel", 3, "id"], [1, "card-body"]],
          template: function NgbAccordion_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbAccordion_ng_template_0_Template, 3, 3, "ng-template", 0, 1, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbAccordion_ng_template_2_Template, 4, 11, "ng-template", 2);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.panels);
            }
          },
          directives: function directives() {
            return [_NgbPanelHeader, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _NgbPanelToggle, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf];
          },
          encapsulation: 2
        });
        return NgbAccordion;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to put on a button that toggles panel opening and closing.
       *
       * To be used inside the [`NgbPanelHeader`](#/components/accordion/api#NgbPanelHeader)
       *
       * @since 4.1.0
       */


      var _NgbPanelToggle = /*#__PURE__*/function () {
        var NgbPanelToggle = /*#__PURE__*/function () {
          function NgbPanelToggle(accordion, panel) {
            _classCallCheck(this, NgbPanelToggle);

            this.accordion = accordion;
            this.panel = panel;
          }

          _createClass(NgbPanelToggle, [{
            key: "ngbPanelToggle",
            set: function set(panel) {
              if (panel) {
                this.panel = panel;
              }
            }
          }]);

          return NgbPanelToggle;
        }();

        NgbPanelToggle.ɵfac = function NgbPanelToggle_Factory(t) {
          return new (t || NgbPanelToggle)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbAccordion), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbPanel, 9));
        };

        NgbPanelToggle.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPanelToggle,
          selectors: [["button", "ngbPanelToggle", ""]],
          hostAttrs: ["type", "button"],
          hostVars: 5,
          hostBindings: function NgbPanelToggle_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbPanelToggle_click_HostBindingHandler() {
                return ctx.accordion.toggle(ctx.panel.id);
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("disabled", ctx.panel.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-expanded", ctx.panel.isOpen)("aria-controls", ctx.panel.id);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("collapsed", !ctx.panel.isOpen);
            }
          },
          inputs: {
            ngbPanelToggle: "ngbPanelToggle"
          }
        });
        return NgbPanelToggle;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NGB_ACCORDION_DIRECTIVES = [_NgbAccordion, _NgbPanel, _NgbPanelTitle, _NgbPanelContent, _NgbPanelHeader, _NgbPanelToggle];

      var _NgbAccordionModule = /*#__PURE__*/function () {
        var NgbAccordionModule = function NgbAccordionModule() {
          _classCallCheck(this, NgbAccordionModule);
        };

        NgbAccordionModule.ɵfac = function NgbAccordionModule_Factory(t) {
          return new (t || NgbAccordionModule)();
        };

        NgbAccordionModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbAccordionModule
        });
        NgbAccordionModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbAccordionModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbAccordionModule, {
          declarations: function declarations() {
            return [_NgbAccordion, _NgbPanel, _NgbPanelTitle, _NgbPanelContent, _NgbPanelHeader, _NgbPanelToggle];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbAccordion, _NgbPanel, _NgbPanelTitle, _NgbPanelContent, _NgbPanelHeader, _NgbPanelToggle];
          }
        });
      })();
      /**
       * A configuration service for the [NgbAlert](#/components/alert/api#NgbAlert) component.
       *
       * You can inject this service, typically in your root component, and customize its properties
       * to provide default values for all alerts used in the application.
       */


      var _NgbAlertConfig = /*#__PURE__*/function () {
        var NgbAlertConfig = /*#__PURE__*/function () {
          function NgbAlertConfig(_ngbConfig) {
            _classCallCheck(this, NgbAlertConfig);

            this._ngbConfig = _ngbConfig;
            this.dismissible = true;
            this.type = 'warning';
          }

          _createClass(NgbAlertConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbAlertConfig;
        }();

        NgbAlertConfig.ɵfac = function NgbAlertConfig_Factory(t) {
          return new (t || NgbAlertConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbAlertConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbAlertConfig_Factory() {
            return new NgbAlertConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbAlertConfig,
          providedIn: "root"
        });
        return NgbAlertConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var ngbAlertFadingTransition = function ngbAlertFadingTransition(_ref2) {
        var classList = _ref2.classList;
        classList.remove('show');
      };
      /**
       * Alert is a component to provide contextual feedback messages for user.
       *
       * It supports several alert types and can be dismissed.
       */


      var _NgbAlert = /*#__PURE__*/function () {
        var NgbAlert = /*#__PURE__*/function () {
          function NgbAlert(config, _renderer, _element, _zone) {
            _classCallCheck(this, NgbAlert);

            this._renderer = _renderer;
            this._element = _element;
            this._zone = _zone;
            /**
             * An event emitted when the close button is clicked. It has no payload and only relevant for dismissible alerts.
             *
             * @since 8.0.0
             */

            this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.dismissible = config.dismissible;
            this.type = config.type;
            this.animation = config.animation;
          }
          /**
           * Triggers alert closing programmatically (same as clicking on the close button (×)).
           *
           * The returned observable will emit and be completed once the closing transition has finished.
           * If the animations are turned off this happens synchronously.
           *
           * Alternatively you could listen or subscribe to the `(closed)` output
           *
           * @since 8.0.0
           */


          _createClass(NgbAlert, [{
            key: "close",
            value: function close() {
              var _this5 = this;

              var transition = ngbRunTransition(this._zone, this._element.nativeElement, ngbAlertFadingTransition, {
                animation: this.animation,
                runningTransition: 'continue'
              });
              transition.subscribe(function () {
                return _this5.closed.emit();
              });
              return transition;
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              var typeChange = changes['type'];

              if (typeChange && !typeChange.firstChange) {
                this._renderer.removeClass(this._element.nativeElement, "alert-".concat(typeChange.previousValue));

                this._renderer.addClass(this._element.nativeElement, "alert-".concat(typeChange.currentValue));
              }
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this._renderer.addClass(this._element.nativeElement, "alert-".concat(this.type));
            }
          }]);

          return NgbAlert;
        }();

        NgbAlert.ɵfac = function NgbAlert_Factory(t) {
          return new (t || NgbAlert)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbAlertConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbAlert.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbAlert,
          selectors: [["ngb-alert"]],
          hostAttrs: ["role", "alert", 1, "alert", "show"],
          hostVars: 4,
          hostBindings: function NgbAlert_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.animation)("alert-dismissible", ctx.dismissible);
            }
          },
          inputs: {
            dismissible: "dismissible",
            type: "type",
            animation: "animation"
          },
          outputs: {
            closed: "closed"
          },
          exportAs: ["ngbAlert"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          ngContentSelectors: _c3,
          decls: 2,
          vars: 1,
          consts: function consts() {
            var i18n_1;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_alert_close$$FESM2015_NG_BOOTSTRAP_JS_2 = goog.getMsg("Close");
              i18n_1 = MSG_EXTERNAL_ngb_alert_close$$FESM2015_NG_BOOTSTRAP_JS_2;
            } else {
              i18n_1 = $localize(_templateObject || (_templateObject = _taggedTemplateLiteral([":@@ngb.alert.close\u241Ff4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8\u241F7819314041543176992:Close"])));
            }

            return [["type", "button", "class", "close", "aria-label", i18n_1, 3, "click", 4, "ngIf"], ["type", "button", "aria-label", i18n_1, 1, "close", 3, "click"], ["aria-hidden", "true"]];
          },
          template: function NgbAlert_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbAlert_button_1_Template, 3, 0, "button", 0);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.dismissible);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf],
          styles: ["ngb-alert{display:block}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbAlert;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbAlertModule = /*#__PURE__*/function () {
        var NgbAlertModule = function NgbAlertModule() {
          _classCallCheck(this, NgbAlertModule);
        };

        NgbAlertModule.ɵfac = function NgbAlertModule_Factory(t) {
          return new (t || NgbAlertModule)();
        };

        NgbAlertModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbAlertModule
        });
        NgbAlertModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbAlertModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbAlertModule, {
          declarations: function declarations() {
            return [_NgbAlert];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbAlert];
          }
        });
      })();

      var _NgbButtonLabel = /*#__PURE__*/function () {
        var NgbButtonLabel = function NgbButtonLabel() {
          _classCallCheck(this, NgbButtonLabel);
        };

        NgbButtonLabel.ɵfac = function NgbButtonLabel_Factory(t) {
          return new (t || NgbButtonLabel)();
        };

        NgbButtonLabel.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbButtonLabel,
          selectors: [["", "ngbButtonLabel", ""]],
          hostVars: 8,
          hostBindings: function NgbButtonLabel_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("btn", true)("active", ctx.active)("disabled", ctx.disabled)("focus", ctx.focused);
            }
          }
        });
        return NgbButtonLabel;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Allows to easily create Bootstrap-style checkbox buttons.
       *
       * Integrates with forms, so the value of a checked button is bound to the underlying form control
       * either in a reactive or template-driven way.
       */


      var _NgbCheckBox = /*#__PURE__*/function () {
        var NgbCheckBox = /*#__PURE__*/function () {
          function NgbCheckBox(_label, _cd) {
            _classCallCheck(this, NgbCheckBox);

            this._label = _label;
            this._cd = _cd;
            /**
             * If `true`, the checkbox button will be disabled
             */

            this.disabled = false;
            /**
             * The form control value when the checkbox is checked.
             */

            this.valueChecked = true;
            /**
             * The form control value when the checkbox is unchecked.
             */

            this.valueUnChecked = false;

            this.onChange = function (_) {};

            this.onTouched = function () {};
          }

          _createClass(NgbCheckBox, [{
            key: "focused",
            set: function set(isFocused) {
              this._label.focused = isFocused;

              if (!isFocused) {
                this.onTouched();
              }
            }
          }, {
            key: "onInputChange",
            value: function onInputChange($event) {
              var modelToPropagate = $event.target.checked ? this.valueChecked : this.valueUnChecked;
              this.onChange(modelToPropagate);
              this.onTouched();
              this.writeValue(modelToPropagate);
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this.onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this.onTouched = fn;
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this.disabled = isDisabled;
              this._label.disabled = isDisabled;
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this.checked = value === this.valueChecked;
              this._label.active = this.checked; // label won't be updated, if it is inside the OnPush component when [ngModel] changes

              this._cd.markForCheck();
            }
          }]);

          return NgbCheckBox;
        }();

        NgbCheckBox.ɵfac = function NgbCheckBox_Factory(t) {
          return new (t || NgbCheckBox)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbButtonLabel), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
        };

        NgbCheckBox.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbCheckBox,
          selectors: [["", "ngbButton", "", "type", "checkbox"]],
          hostVars: 2,
          hostBindings: function NgbCheckBox_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbCheckBox_change_HostBindingHandler($event) {
                return ctx.onInputChange($event);
              })("focus", function NgbCheckBox_focus_HostBindingHandler() {
                return ctx.focused = true;
              })("blur", function NgbCheckBox_blur_HostBindingHandler() {
                return ctx.focused = false;
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("checked", ctx.checked)("disabled", ctx.disabled);
            }
          },
          inputs: {
            disabled: "disabled",
            valueChecked: "valueChecked",
            valueUnChecked: "valueUnChecked"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbCheckBox;
            }),
            multi: true
          }])]
        });
        return NgbCheckBox;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var nextId$1 = 0;
      /**
       * Allows to easily create Bootstrap-style radio buttons.
       *
       * Integrates with forms, so the value of a checked button is bound to the underlying form control
       * either in a reactive or template-driven way.
       */

      var _NgbRadioGroup = /*#__PURE__*/function () {
        var NgbRadioGroup = /*#__PURE__*/function () {
          function NgbRadioGroup() {
            _classCallCheck(this, NgbRadioGroup);

            this._radios = new Set();
            this._value = null;
            /**
             * Name of the radio group applied to radio input elements.
             *
             * Will be applied to all radio input elements inside the group,
             * unless [`NgbRadio`](#/components/buttons/api#NgbRadio)'s specify names themselves.
             *
             * If not provided, will be generated in the `ngb-radio-xx` format.
             */

            this.name = "ngb-radio-".concat(nextId$1++);

            this.onChange = function (_) {};

            this.onTouched = function () {};
          }

          _createClass(NgbRadioGroup, [{
            key: "disabled",
            get: function get() {
              return this._disabled;
            },
            set: function set(isDisabled) {
              this.setDisabledState(isDisabled);
            }
          }, {
            key: "onRadioChange",
            value: function onRadioChange(radio) {
              this.writeValue(radio.value);
              this.onChange(radio.value);
            }
          }, {
            key: "onRadioValueUpdate",
            value: function onRadioValueUpdate() {
              this._updateRadiosValue();
            }
          }, {
            key: "register",
            value: function register(radio) {
              this._radios.add(radio);
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this.onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this.onTouched = fn;
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this._disabled = isDisabled;

              this._updateRadiosDisabled();
            }
          }, {
            key: "unregister",
            value: function unregister(radio) {
              this._radios["delete"](radio);
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this._value = value;

              this._updateRadiosValue();
            }
          }, {
            key: "_updateRadiosValue",
            value: function _updateRadiosValue() {
              var _this6 = this;

              this._radios.forEach(function (radio) {
                return radio.updateValue(_this6._value);
              });
            }
          }, {
            key: "_updateRadiosDisabled",
            value: function _updateRadiosDisabled() {
              this._radios.forEach(function (radio) {
                return radio.updateDisabled();
              });
            }
          }]);

          return NgbRadioGroup;
        }();

        NgbRadioGroup.ɵfac = function NgbRadioGroup_Factory(t) {
          return new (t || NgbRadioGroup)();
        };

        NgbRadioGroup.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbRadioGroup,
          selectors: [["", "ngbRadioGroup", ""]],
          hostAttrs: ["role", "radiogroup"],
          inputs: {
            name: "name"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbRadioGroup;
            }),
            multi: true
          }])]
        });
        return NgbRadioGroup;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that marks an input of type "radio" as a part of the
       * [`NgbRadioGroup`](#/components/buttons/api#NgbRadioGroup).
       */


      var _NgbRadio = /*#__PURE__*/function () {
        var NgbRadio = /*#__PURE__*/function () {
          function NgbRadio(_group, _label, _renderer, _element, _cd) {
            _classCallCheck(this, NgbRadio);

            this._group = _group;
            this._label = _label;
            this._renderer = _renderer;
            this._element = _element;
            this._cd = _cd;
            this._value = null;

            this._group.register(this);

            this.updateDisabled();
          }
          /**
           * The form control value when current radio button is checked.
           */


          _createClass(NgbRadio, [{
            key: "value",
            get: function get() {
              return this._value;
            },
            set: function set(value) {
              this._value = value;
              var stringValue = value ? value.toString() : '';

              this._renderer.setProperty(this._element.nativeElement, 'value', stringValue);

              this._group.onRadioValueUpdate();
            }
            /**
             * If `true`, current radio button will be disabled.
             */

          }, {
            key: "disabled",
            get: function get() {
              return this._group.disabled || this._disabled;
            },
            set: function set(isDisabled) {
              this._disabled = isDisabled !== false;
              this.updateDisabled();
            }
          }, {
            key: "focused",
            set: function set(isFocused) {
              if (this._label) {
                this._label.focused = isFocused;
              }

              if (!isFocused) {
                this._group.onTouched();
              }
            }
          }, {
            key: "checked",
            get: function get() {
              return this._checked;
            }
          }, {
            key: "nameAttr",
            get: function get() {
              return this.name || this._group.name;
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._group.unregister(this);
            }
          }, {
            key: "onChange",
            value: function onChange() {
              this._group.onRadioChange(this);
            }
          }, {
            key: "updateValue",
            value: function updateValue(value) {
              // label won't be updated, if it is inside the OnPush component when [ngModel] changes
              if (this.value !== value) {
                this._cd.markForCheck();
              }

              this._checked = this.value === value;
              this._label.active = this._checked;
            }
          }, {
            key: "updateDisabled",
            value: function updateDisabled() {
              this._label.disabled = this.disabled;
            }
          }]);

          return NgbRadio;
        }();

        NgbRadio.ɵfac = function NgbRadio_Factory(t) {
          return new (t || NgbRadio)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbRadioGroup), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbButtonLabel), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
        };

        NgbRadio.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbRadio,
          selectors: [["", "ngbButton", "", "type", "radio"]],
          hostVars: 3,
          hostBindings: function NgbRadio_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbRadio_change_HostBindingHandler() {
                return ctx.onChange();
              })("focus", function NgbRadio_focus_HostBindingHandler() {
                return ctx.focused = true;
              })("blur", function NgbRadio_blur_HostBindingHandler() {
                return ctx.focused = false;
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("checked", ctx.checked)("disabled", ctx.disabled)("name", ctx.nameAttr);
            }
          },
          inputs: {
            value: "value",
            disabled: "disabled",
            name: "name"
          }
        });
        return NgbRadio;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NGB_BUTTON_DIRECTIVES = [_NgbButtonLabel, _NgbCheckBox, _NgbRadioGroup, _NgbRadio];

      var _NgbButtonsModule = /*#__PURE__*/function () {
        var NgbButtonsModule = function NgbButtonsModule() {
          _classCallCheck(this, NgbButtonsModule);
        };

        NgbButtonsModule.ɵfac = function NgbButtonsModule_Factory(t) {
          return new (t || NgbButtonsModule)();
        };

        NgbButtonsModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbButtonsModule
        });
        NgbButtonsModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return NgbButtonsModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbButtonsModule, {
          declarations: [_NgbButtonLabel, _NgbCheckBox, _NgbRadioGroup, _NgbRadio],
          exports: [_NgbButtonLabel, _NgbCheckBox, _NgbRadioGroup, _NgbRadio]
        });
      })();
      /**
       * A configuration service for the [NgbCarousel](#/components/carousel/api#NgbCarousel) component.
       *
       * You can inject this service, typically in your root component, and customize its properties
       * to provide default values for all carousels used in the application.
       */


      var _NgbCarouselConfig = /*#__PURE__*/function () {
        var NgbCarouselConfig = /*#__PURE__*/function () {
          function NgbCarouselConfig(_ngbConfig) {
            _classCallCheck(this, NgbCarouselConfig);

            this._ngbConfig = _ngbConfig;
            this.interval = 5000;
            this.wrap = true;
            this.keyboard = true;
            this.pauseOnHover = true;
            this.pauseOnFocus = true;
            this.showNavigationArrows = true;
            this.showNavigationIndicators = true;
          }

          _createClass(NgbCarouselConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbCarouselConfig;
        }();

        NgbCarouselConfig.ɵfac = function NgbCarouselConfig_Factory(t) {
          return new (t || NgbCarouselConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbCarouselConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbCarouselConfig_Factory() {
            return new NgbCarouselConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbCarouselConfig,
          providedIn: "root"
        });
        return NgbCarouselConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Defines the carousel slide transition direction.
       */


      var _NgbSlideEventDirection = /*#__PURE__*/function () {
        (function (NgbSlideEventDirection) {
          NgbSlideEventDirection["LEFT"] = "left";
          NgbSlideEventDirection["RIGHT"] = "right";
        })(_NgbSlideEventDirection || (_NgbSlideEventDirection = {}));

        return _NgbSlideEventDirection;
      }();

      var isBeingAnimated = function isBeingAnimated(_ref3) {
        var classList = _ref3.classList;
        return classList.contains('carousel-item-left') || classList.contains('carousel-item-right');
      };

      var ɵ0$1 = isBeingAnimated;

      var removeDirectionClasses = function removeDirectionClasses(classList) {
        classList.remove('carousel-item-left');
        classList.remove('carousel-item-right');
      };

      var ɵ1 = removeDirectionClasses;

      var removeClasses = function removeClasses(classList) {
        removeDirectionClasses(classList);
        classList.remove('carousel-item-prev');
        classList.remove('carousel-item-next');
      };

      var ɵ2 = removeClasses;

      var ngbCarouselTransitionIn = function ngbCarouselTransitionIn(element, animation, _ref4) {
        var direction = _ref4.direction;
        var classList = element.classList;

        if (!animation) {
          removeDirectionClasses(classList);
          removeClasses(classList);
          classList.add('active');
          return;
        }

        if (isBeingAnimated(element)) {
          // Revert the transition
          removeDirectionClasses(classList);
        } else {
          // For the 'in' transition, a 'pre-class' is applied to the element to ensure its visibility
          classList.add('carousel-item-' + (direction === _NgbSlideEventDirection.LEFT ? 'next' : 'prev'));
          reflow(element);
          classList.add('carousel-item-' + direction);
        }

        return function () {
          removeClasses(classList);
          classList.add('active');
        };
      };

      var ngbCarouselTransitionOut = function ngbCarouselTransitionOut(element, animation, _ref5) {
        var direction = _ref5.direction;
        var classList = element.classList;

        if (!animation) {
          removeDirectionClasses(classList);
          removeClasses(classList);
          classList.remove('active');
          return;
        } //  direction is left or right, depending on the way the slide goes out.


        if (isBeingAnimated(element)) {
          // Revert the transition
          removeDirectionClasses(classList);
        } else {
          classList.add('carousel-item-' + direction);
        }

        return function () {
          removeClasses(classList);
          classList.remove('active');
        };
      };

      var nextId$2 = 0;
      /**
       * A directive that wraps the individual carousel slide.
       */

      var _NgbSlide = /*#__PURE__*/function () {
        var NgbSlide = function NgbSlide(tplRef) {
          _classCallCheck(this, NgbSlide);

          this.tplRef = tplRef;
          /**
           * Slide id that must be unique for the entire document.
           *
           * If not provided, will be generated in the `ngb-slide-xx` format.
           */

          this.id = "ngb-slide-".concat(nextId$2++);
          /**
           * An event emitted when the slide transition is finished
           *
           * @since 8.0.0
           */

          this.slid = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        };

        NgbSlide.ɵfac = function NgbSlide_Factory(t) {
          return new (t || NgbSlide)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbSlide.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbSlide,
          selectors: [["ng-template", "ngbSlide", ""]],
          inputs: {
            id: "id"
          },
          outputs: {
            slid: "slid"
          }
        });
        return NgbSlide;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Carousel is a component to easily create and control slideshows.
       *
       * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
       */


      var _NgbCarousel = /*#__PURE__*/function () {
        var NgbCarousel = /*#__PURE__*/function () {
          function NgbCarousel(config, _platformId, _ngZone, _cd, _container) {
            _classCallCheck(this, NgbCarousel);

            this._platformId = _platformId;
            this._ngZone = _ngZone;
            this._cd = _cd;
            this._container = _container;
            this.NgbSlideEventSource = _NgbSlideEventSource;
            this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._interval$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(0);
            this._mouseHover$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            this._focused$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            this._pauseOnHover$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            this._pauseOnFocus$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            this._pause$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            this._wrap$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
            /**
             * An event emitted just before the slide transition starts.
             *
             * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
             */

            this.slide = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted right after the slide transition is completed.
             *
             * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
             *
             * @since 8.0.0
             */

            this.slid = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /*
             * Keep the ids of the panels currently transitionning
             * in order to allow only the transition revertion
             */

            this._transitionIds = null;
            this.animation = config.animation;
            this.interval = config.interval;
            this.wrap = config.wrap;
            this.keyboard = config.keyboard;
            this.pauseOnHover = config.pauseOnHover;
            this.pauseOnFocus = config.pauseOnFocus;
            this.showNavigationArrows = config.showNavigationArrows;
            this.showNavigationIndicators = config.showNavigationIndicators;
          }
          /**
           * Time in milliseconds before the next slide is shown.
           */


          _createClass(NgbCarousel, [{
            key: "interval",
            get: function get() {
              return this._interval$.value;
            }
            /**
             * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
             */
            ,
            set: function set(value) {
              this._interval$.next(value);
            }
          }, {
            key: "wrap",
            get: function get() {
              return this._wrap$.value;
            }
            /**
             * If `true`, will pause slide switching when mouse cursor hovers the slide.
             *
             * @since 2.2.0
             */
            ,
            set: function set(value) {
              this._wrap$.next(value);
            }
          }, {
            key: "pauseOnHover",
            get: function get() {
              return this._pauseOnHover$.value;
            }
            /**
             * If `true`, will pause slide switching when the focus is inside the carousel.
             */
            ,
            set: function set(value) {
              this._pauseOnHover$.next(value);
            }
          }, {
            key: "pauseOnFocus",
            get: function get() {
              return this._pauseOnFocus$.value;
            },
            set: function set(value) {
              this._pauseOnFocus$.next(value);
            }
          }, {
            key: "mouseHover",
            get: function get() {
              return this._mouseHover$.value;
            },
            set: function set(value) {
              this._mouseHover$.next(value);
            }
          }, {
            key: "focused",
            get: function get() {
              return this._focused$.value;
            },
            set: function set(value) {
              this._focused$.next(value);
            }
          }, {
            key: "arrowLeft",
            value: function arrowLeft() {
              this.focus();
              this.prev(_NgbSlideEventSource.ARROW_LEFT);
            }
          }, {
            key: "arrowRight",
            value: function arrowRight() {
              this.focus();
              this.next(_NgbSlideEventSource.ARROW_RIGHT);
            }
          }, {
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              var _this7 = this;

              // setInterval() doesn't play well with SSR and protractor,
              // so we should run it in the browser and outside Angular
              if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this._platformId)) {
                this._ngZone.runOutsideAngular(function () {
                  var hasNextSlide$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([_this7.slide.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (slideEvent) {
                    return slideEvent.current;
                  }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(_this7.activeId)), _this7._wrap$, _this7.slides.changes.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(null))]).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (_ref6) {
                    var _ref7 = _slicedToArray(_ref6, 2),
                        currentSlideId = _ref7[0],
                        wrap = _ref7[1];

                    var slideArr = _this7.slides.toArray();

                    var currentSlideIdx = _this7._getSlideIdxById(currentSlideId);

                    return wrap ? slideArr.length > 1 : currentSlideIdx < slideArr.length - 1;
                  }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.distinctUntilChanged)());
                  (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([_this7._pause$, _this7._pauseOnHover$, _this7._mouseHover$, _this7._pauseOnFocus$, _this7._focused$, _this7._interval$, hasNextSlide$]).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (_ref8) {
                    var _ref9 = _slicedToArray(_ref8, 7),
                        pause = _ref9[0],
                        pauseOnHover = _ref9[1],
                        mouseHover = _ref9[2],
                        pauseOnFocus = _ref9[3],
                        focused = _ref9[4],
                        interval = _ref9[5],
                        hasNextSlide = _ref9[6];

                    return pause || pauseOnHover && mouseHover || pauseOnFocus && focused || !hasNextSlide ? 0 : interval;
                  }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.distinctUntilChanged)(), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.switchMap)(function (interval) {
                    return interval > 0 ? (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.timer)(interval, interval) : rxjs__WEBPACK_IMPORTED_MODULE_2__.NEVER;
                  }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this7._destroy$)).subscribe(function () {
                    return _this7._ngZone.run(function () {
                      return _this7.next(_NgbSlideEventSource.TIMER);
                    });
                  });
                });
              }

              this.slides.changes.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._destroy$)).subscribe(function () {
                var _a;

                (_a = _this7._transitionIds) === null || _a === void 0 ? void 0 : _a.forEach(function (id) {
                  return ngbCompleteTransition(_this7._getSlideElement(id));
                });
                _this7._transitionIds = null;

                _this7._cd.markForCheck(); // The following code need to be done asynchronously, after the dom becomes stable,
                // otherwise all changes will be undone.


                _this7._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                  var _iterator = _createForOfIteratorHelper(_this7.slides),
                      _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var id = _step.value.id;

                      var element = _this7._getSlideElement(id);

                      if (id === _this7.activeId) {
                        element.classList.add('active');
                      } else {
                        element.classList.remove('active');
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                });
              });
            }
          }, {
            key: "ngAfterContentChecked",
            value: function ngAfterContentChecked() {
              var activeSlide = this._getSlideById(this.activeId);

              this.activeId = activeSlide ? activeSlide.id : this.slides.length ? this.slides.first.id : '';
            }
          }, {
            key: "ngAfterViewInit",
            value: function ngAfterViewInit() {
              // Initialize the 'active' class (not managed by the template)
              if (this.activeId) {
                var element = this._getSlideElement(this.activeId);

                if (element) {
                  element.classList.add('active');
                }
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._destroy$.next();
            }
            /**
             * Navigates to a slide with the specified identifier.
             */

          }, {
            key: "select",
            value: function select(slideId, source) {
              this._cycleToSelected(slideId, this._getSlideEventDirection(this.activeId, slideId), source);
            }
            /**
             * Navigates to the previous slide.
             */

          }, {
            key: "prev",
            value: function prev(source) {
              this._cycleToSelected(this._getPrevSlide(this.activeId), _NgbSlideEventDirection.RIGHT, source);
            }
            /**
             * Navigates to the next slide.
             */

          }, {
            key: "next",
            value: function next(source) {
              this._cycleToSelected(this._getNextSlide(this.activeId), _NgbSlideEventDirection.LEFT, source);
            }
            /**
             * Pauses cycling through the slides.
             */

          }, {
            key: "pause",
            value: function pause() {
              this._pause$.next(true);
            }
            /**
             * Restarts cycling through the slides from left to right.
             */

          }, {
            key: "cycle",
            value: function cycle() {
              this._pause$.next(false);
            }
            /**
             * Set the focus on the carousel.
             */

          }, {
            key: "focus",
            value: function focus() {
              this._container.nativeElement.focus();
            }
          }, {
            key: "_cycleToSelected",
            value: function _cycleToSelected(slideIdx, direction, source) {
              var _this8 = this;

              var transitionIds = this._transitionIds;

              if (transitionIds && (transitionIds[0] !== slideIdx || transitionIds[1] !== this.activeId)) {
                // Revert prevented
                return;
              }

              var selectedSlide = this._getSlideById(slideIdx);

              if (selectedSlide && selectedSlide.id !== this.activeId) {
                this._transitionIds = [this.activeId, slideIdx];
                this.slide.emit({
                  prev: this.activeId,
                  current: selectedSlide.id,
                  direction: direction,
                  paused: this._pause$.value,
                  source: source
                });
                var options = {
                  animation: this.animation,
                  runningTransition: 'stop',
                  context: {
                    direction: direction
                  }
                };
                var transitions = [];

                var activeSlide = this._getSlideById(this.activeId);

                if (activeSlide) {
                  var activeSlideTransition = ngbRunTransition(this._ngZone, this._getSlideElement(activeSlide.id), ngbCarouselTransitionOut, options);
                  activeSlideTransition.subscribe(function () {
                    activeSlide.slid.emit({
                      isShown: false,
                      direction: direction,
                      source: source
                    });
                  });
                  transitions.push(activeSlideTransition);
                }

                var previousId = this.activeId;
                this.activeId = selectedSlide.id;

                var nextSlide = this._getSlideById(this.activeId);

                var transition = ngbRunTransition(this._ngZone, this._getSlideElement(selectedSlide.id), ngbCarouselTransitionIn, options);
                transition.subscribe(function () {
                  nextSlide === null || nextSlide === void 0 ? void 0 : nextSlide.slid.emit({
                    isShown: true,
                    direction: direction,
                    source: source
                  });
                });
                transitions.push(transition);
                (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.zip).apply(void 0, transitions).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                  _this8._transitionIds = null;

                  _this8.slid.emit({
                    prev: previousId,
                    current: selectedSlide.id,
                    direction: direction,
                    paused: _this8._pause$.value,
                    source: source
                  });
                });
              } // we get here after the interval fires or any external API call like next(), prev() or select()


              this._cd.markForCheck();
            }
          }, {
            key: "_getSlideEventDirection",
            value: function _getSlideEventDirection(currentActiveSlideId, nextActiveSlideId) {
              var currentActiveSlideIdx = this._getSlideIdxById(currentActiveSlideId);

              var nextActiveSlideIdx = this._getSlideIdxById(nextActiveSlideId);

              return currentActiveSlideIdx > nextActiveSlideIdx ? _NgbSlideEventDirection.RIGHT : _NgbSlideEventDirection.LEFT;
            }
          }, {
            key: "_getSlideById",
            value: function _getSlideById(slideId) {
              return this.slides.find(function (slide) {
                return slide.id === slideId;
              }) || null;
            }
          }, {
            key: "_getSlideIdxById",
            value: function _getSlideIdxById(slideId) {
              var slide = this._getSlideById(slideId);

              return slide != null ? this.slides.toArray().indexOf(slide) : -1;
            }
          }, {
            key: "_getNextSlide",
            value: function _getNextSlide(currentSlideId) {
              var slideArr = this.slides.toArray();

              var currentSlideIdx = this._getSlideIdxById(currentSlideId);

              var isLastSlide = currentSlideIdx === slideArr.length - 1;
              return isLastSlide ? this.wrap ? slideArr[0].id : slideArr[slideArr.length - 1].id : slideArr[currentSlideIdx + 1].id;
            }
          }, {
            key: "_getPrevSlide",
            value: function _getPrevSlide(currentSlideId) {
              var slideArr = this.slides.toArray();

              var currentSlideIdx = this._getSlideIdxById(currentSlideId);

              var isFirstSlide = currentSlideIdx === 0;
              return isFirstSlide ? this.wrap ? slideArr[slideArr.length - 1].id : slideArr[0].id : slideArr[currentSlideIdx - 1].id;
            }
          }, {
            key: "_getSlideElement",
            value: function _getSlideElement(slideId) {
              return this._container.nativeElement.querySelector("#slide-".concat(slideId));
            }
          }]);

          return NgbCarousel;
        }();

        NgbCarousel.ɵfac = function NgbCarousel_Factory(t) {
          return new (t || NgbCarousel)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbCarouselConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbCarousel.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbCarousel,
          selectors: [["ngb-carousel"]],
          contentQueries: function NgbCarousel_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbSlide, 4);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.slides = _t);
            }
          },
          hostAttrs: ["tabIndex", "0", 1, "carousel", "slide"],
          hostVars: 3,
          hostBindings: function NgbCarousel_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown.arrowLeft", function NgbCarousel_keydown_arrowLeft_HostBindingHandler() {
                return ctx.keyboard && ctx.arrowLeft();
              })("keydown.arrowRight", function NgbCarousel_keydown_arrowRight_HostBindingHandler() {
                return ctx.keyboard && ctx.arrowRight();
              })("mouseenter", function NgbCarousel_mouseenter_HostBindingHandler() {
                return ctx.mouseHover = true;
              })("mouseleave", function NgbCarousel_mouseleave_HostBindingHandler() {
                return ctx.mouseHover = false;
              })("focusin", function NgbCarousel_focusin_HostBindingHandler() {
                return ctx.focused = true;
              })("focusout", function NgbCarousel_focusout_HostBindingHandler() {
                return ctx.focused = false;
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-activedescendant", "slide-" + ctx.activeId);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("display", "block");
            }
          },
          inputs: {
            animation: "animation",
            interval: "interval",
            wrap: "wrap",
            keyboard: "keyboard",
            pauseOnHover: "pauseOnHover",
            pauseOnFocus: "pauseOnFocus",
            showNavigationArrows: "showNavigationArrows",
            showNavigationIndicators: "showNavigationIndicators",
            activeId: "activeId"
          },
          outputs: {
            slide: "slide",
            slid: "slid"
          },
          exportAs: ["ngbCarousel"],
          decls: 6,
          vars: 6,
          consts: function consts() {
            var i18n_4;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              /**
               * @desc Currently selected slide number read by screen reader
               */
              var MSG_EXTERNAL_ngb_carousel_slide_number$$FESM2015_NG_BOOTSTRAP_JS__5 = goog.getMsg(" Slide {$interpolation} of {$interpolation_1} ", {
                "interpolation": "\uFFFD0\uFFFD",
                "interpolation_1": "\uFFFD1\uFFFD"
              });
              i18n_4 = MSG_EXTERNAL_ngb_carousel_slide_number$$FESM2015_NG_BOOTSTRAP_JS__5;
            } else {
              i18n_4 = $localize(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([":Currently selected slide number read by screen reader@@ngb.carousel.slide-number\u241Fa65b1b49aa7dd8c4f3004da6a8c2241814dae621\u241F783273603869937627: Slide ", ":INTERPOLATION: of ", ":INTERPOLATION_1: "])), "\uFFFD0\uFFFD", "\uFFFD1\uFFFD");
            }

            var i18n_6;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_carousel_previous$$FESM2015_NG_BOOTSTRAP_JS__7 = goog.getMsg("Previous");
              i18n_6 = MSG_EXTERNAL_ngb_carousel_previous$$FESM2015_NG_BOOTSTRAP_JS__7;
            } else {
              i18n_6 = $localize(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([":@@ngb.carousel.previous\u241F680d5c75b7fd8d37961083608b9fcdc4167b4c43\u241F4452427314943113135:Previous"])));
            }

            var i18n_8;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_carousel_next$$FESM2015_NG_BOOTSTRAP_JS__9 = goog.getMsg("Next");
              i18n_8 = MSG_EXTERNAL_ngb_carousel_next$$FESM2015_NG_BOOTSTRAP_JS__9;
            } else {
              i18n_8 = $localize(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([":@@ngb.carousel.next\u241Ff732c304c7433e5a83ffcd862c3dce709a0f4982\u241F3885497195825665706:Next"])));
            }

            return [["role", "tablist", 1, "carousel-indicators"], ["role", "tab", 3, "active", "click", 4, "ngFor", "ngForOf"], [1, "carousel-inner"], ["class", "carousel-item", "role", "tabpanel", 3, "id", 4, "ngFor", "ngForOf"], ["class", "carousel-control-prev", "role", "button", 3, "click", 4, "ngIf"], ["class", "carousel-control-next", "role", "button", 3, "click", 4, "ngIf"], ["role", "tab", 3, "click"], ["role", "tabpanel", 1, "carousel-item", 3, "id"], [1, "sr-only"], i18n_4, [3, "ngTemplateOutlet"], ["role", "button", 1, "carousel-control-prev", 3, "click"], ["aria-hidden", "true", 1, "carousel-control-prev-icon"], i18n_6, ["role", "button", 1, "carousel-control-next", 3, "click"], ["aria-hidden", "true", 1, "carousel-control-next-icon"], i18n_8];
          },
          template: function NgbCarousel_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ol", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbCarousel_li_1_Template, 1, 5, "li", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbCarousel_div_3_Template, 4, 4, "div", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, NgbCarousel_a_4_Template, 4, 0, "a", 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, NgbCarousel_a_5_Template, 4, 0, "a", 5);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("sr-only", !ctx.showNavigationIndicators);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.slides);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.slides);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showNavigationArrows);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showNavigationArrows);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbCarousel;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbSlideEventSource = /*#__PURE__*/function () {
        (function (NgbSlideEventSource) {
          NgbSlideEventSource["TIMER"] = "timer";
          NgbSlideEventSource["ARROW_LEFT"] = "arrowLeft";
          NgbSlideEventSource["ARROW_RIGHT"] = "arrowRight";
          NgbSlideEventSource["INDICATOR"] = "indicator";
        })(_NgbSlideEventSource || (_NgbSlideEventSource = {}));

        return _NgbSlideEventSource;
      }();

      var NGB_CAROUSEL_DIRECTIVES = [_NgbCarousel, _NgbSlide];

      var _NgbCarouselModule = /*#__PURE__*/function () {
        var NgbCarouselModule = function NgbCarouselModule() {
          _classCallCheck(this, NgbCarouselModule);
        };

        NgbCarouselModule.ɵfac = function NgbCarouselModule_Factory(t) {
          return new (t || NgbCarouselModule)();
        };

        NgbCarouselModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbCarouselModule
        });
        NgbCarouselModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbCarouselModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbCarouselModule, {
          declarations: function declarations() {
            return [_NgbCarousel, _NgbSlide];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbCarousel, _NgbSlide];
          }
        });
      })();
      /**
       * A configuration service for the [NgbCollapse](#/components/collapse/api#NgbCollapse) component.
       *
       * You can inject this service, typically in your root component, and customize its properties
       * to provide default values for all collapses used in the application.
       */


      var _NgbCollapseConfig = /*#__PURE__*/function () {
        var NgbCollapseConfig = /*#__PURE__*/function () {
          function NgbCollapseConfig(_ngbConfig) {
            _classCallCheck(this, NgbCollapseConfig);

            this._ngbConfig = _ngbConfig;
          }

          _createClass(NgbCollapseConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbCollapseConfig;
        }();

        NgbCollapseConfig.ɵfac = function NgbCollapseConfig_Factory(t) {
          return new (t || NgbCollapseConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbCollapseConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbCollapseConfig_Factory() {
            return new NgbCollapseConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbCollapseConfig,
          providedIn: "root"
        });
        return NgbCollapseConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to provide a simple way of hiding and showing elements on the page.
       */


      var _NgbCollapse = /*#__PURE__*/function () {
        var NgbCollapse = /*#__PURE__*/function () {
          function NgbCollapse(_element, config, _zone) {
            _classCallCheck(this, NgbCollapse);

            this._element = _element;
            this._zone = _zone;
            /**
             * If `true`, will collapse the element or show it otherwise.
             */

            this.collapsed = false;
            this.ngbCollapseChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the collapse element is shown, after the transition. It has no payload.
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the collapse element is hidden, after the transition. It has no payload.
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.animation = config.animation;
          }

          _createClass(NgbCollapse, [{
            key: "ngOnInit",
            value: function ngOnInit() {
              this._runTransition(this.collapsed, false);
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(_ref10) {
              var collapsed = _ref10.collapsed;

              if (!collapsed.firstChange) {
                this._runTransitionWithEvents(this.collapsed, this.animation);
              }
            }
            /**
             * Triggers collapsing programmatically.
             *
             * If there is a collapsing transition running already, it will be reversed.
             * If the animations are turned off this happens synchronously.
             *
             * @since 8.0.0
             */

          }, {
            key: "toggle",
            value: function toggle() {
              var open = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.collapsed;
              this.collapsed = !open;
              this.ngbCollapseChange.next(this.collapsed);

              this._runTransitionWithEvents(this.collapsed, this.animation);
            }
          }, {
            key: "_runTransition",
            value: function _runTransition(collapsed, animation) {
              return ngbRunTransition(this._zone, this._element.nativeElement, ngbCollapsingTransition, {
                animation: animation,
                runningTransition: 'stop',
                context: {
                  direction: collapsed ? 'hide' : 'show'
                }
              });
            }
          }, {
            key: "_runTransitionWithEvents",
            value: function _runTransitionWithEvents(collapsed, animation) {
              var _this9 = this;

              this._runTransition(collapsed, animation).subscribe(function () {
                if (collapsed) {
                  _this9.hidden.emit();
                } else {
                  _this9.shown.emit();
                }
              });
            }
          }]);

          return NgbCollapse;
        }();

        NgbCollapse.ɵfac = function NgbCollapse_Factory(t) {
          return new (t || NgbCollapse)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbCollapseConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbCollapse.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbCollapse,
          selectors: [["", "ngbCollapse", ""]],
          inputs: {
            collapsed: ["ngbCollapse", "collapsed"],
            animation: "animation"
          },
          outputs: {
            ngbCollapseChange: "ngbCollapseChange",
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbCollapse"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbCollapse;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbCollapseModule = /*#__PURE__*/function () {
        var NgbCollapseModule = function NgbCollapseModule() {
          _classCallCheck(this, NgbCollapseModule);
        };

        NgbCollapseModule.ɵfac = function NgbCollapseModule_Factory(t) {
          return new (t || NgbCollapseModule)();
        };

        NgbCollapseModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbCollapseModule
        });
        NgbCollapseModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return NgbCollapseModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbCollapseModule, {
          declarations: [_NgbCollapse],
          exports: [_NgbCollapse]
        });
      })();
      /**
       * A simple class that represents a date that datepicker also uses internally.
       *
       * It is the implementation of the `NgbDateStruct` interface that adds some convenience methods,
       * like `.equals()`, `.before()`, etc.
       *
       * All datepicker APIs consume `NgbDateStruct`, but return `NgbDate`.
       *
       * In many cases it is simpler to manipulate these objects together with
       * [`NgbCalendar`](#/components/datepicker/api#NgbCalendar) than native JS Dates.
       *
       * See the [date format overview](#/components/datepicker/overview#date-model) for more details.
       *
       * @since 3.0.0
       */


      var _NgbDate = /*#__PURE__*/function () {
        function _NgbDate(year, month, day) {
          _classCallCheck(this, _NgbDate);

          this.year = isInteger(year) ? year : null;
          this.month = isInteger(month) ? month : null;
          this.day = isInteger(day) ? day : null;
        }
        /**
         * A **static method** that creates a new date object from the `NgbDateStruct`,
         *
         * ex. `NgbDate.from({year: 2000, month: 5, day: 1})`.
         *
         * If the `date` is already of `NgbDate` type, the method will return the same object.
         */


        _createClass(_NgbDate, [{
          key: "equals",
          value:
          /**
           * Checks if the current date is equal to another date.
           */
          function equals(other) {
            return other != null && this.year === other.year && this.month === other.month && this.day === other.day;
          }
          /**
           * Checks if the current date is before another date.
           */

        }, {
          key: "before",
          value: function before(other) {
            if (!other) {
              return false;
            }

            if (this.year === other.year) {
              if (this.month === other.month) {
                return this.day === other.day ? false : this.day < other.day;
              } else {
                return this.month < other.month;
              }
            } else {
              return this.year < other.year;
            }
          }
          /**
           * Checks if the current date is after another date.
           */

        }, {
          key: "after",
          value: function after(other) {
            if (!other) {
              return false;
            }

            if (this.year === other.year) {
              if (this.month === other.month) {
                return this.day === other.day ? false : this.day > other.day;
              } else {
                return this.month > other.month;
              }
            } else {
              return this.year > other.year;
            }
          }
        }], [{
          key: "from",
          value: function from(date) {
            if (date instanceof _NgbDate) {
              return date;
            }

            return date ? new _NgbDate(date.year, date.month, date.day) : null;
          }
        }]);

        return _NgbDate;
      }();

      function fromJSDate(jsDate) {
        return new _NgbDate(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());
      }

      function toJSDate(date) {
        var jsDate = new Date(date.year, date.month - 1, date.day, 12); // this is done avoid 30 -> 1930 conversion

        if (!isNaN(jsDate.getTime())) {
          jsDate.setFullYear(date.year);
        }

        return jsDate;
      }

      function NGB_DATEPICKER_CALENDAR_FACTORY() {
        return new _NgbCalendarGregorian();
      }
      /**
       * A service that represents the calendar used by the datepicker.
       *
       * The default implementation uses the Gregorian calendar. You can inject it in your own
       * implementations if necessary to simplify `NgbDate` calculations.
       */


      var _NgbCalendar = /*#__PURE__*/function () {
        var NgbCalendar = function NgbCalendar() {
          _classCallCheck(this, NgbCalendar);
        };

        NgbCalendar.ɵfac = function NgbCalendar_Factory(t) {
          return new (t || NgbCalendar)();
        };

        NgbCalendar.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: NGB_DATEPICKER_CALENDAR_FACTORY,
          token: NgbCalendar,
          providedIn: "root"
        });
        return NgbCalendar;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbCalendarGregorian = /*#__PURE__*/function () {
        var NgbCalendarGregorian = /*#__PURE__*/function (_NgbCalendar2) {
          _inherits(NgbCalendarGregorian, _NgbCalendar2);

          var _super = _createSuper(NgbCalendarGregorian);

          function NgbCalendarGregorian() {
            _classCallCheck(this, NgbCalendarGregorian);

            return _super.apply(this, arguments);
          }

          _createClass(NgbCalendarGregorian, [{
            key: "getDaysPerWeek",
            value: function getDaysPerWeek() {
              return 7;
            }
          }, {
            key: "getMonths",
            value: function getMonths() {
              return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            }
          }, {
            key: "getWeeksPerMonth",
            value: function getWeeksPerMonth() {
              return 6;
            }
          }, {
            key: "getNext",
            value: function getNext(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              var jsDate = toJSDate(date);
              var checkMonth = true;
              var expectedMonth = jsDate.getMonth();

              switch (period) {
                case 'y':
                  jsDate.setFullYear(jsDate.getFullYear() + number);
                  break;

                case 'm':
                  expectedMonth += number;
                  jsDate.setMonth(expectedMonth);
                  expectedMonth = expectedMonth % 12;

                  if (expectedMonth < 0) {
                    expectedMonth = expectedMonth + 12;
                  }

                  break;

                case 'd':
                  jsDate.setDate(jsDate.getDate() + number);
                  checkMonth = false;
                  break;

                default:
                  return date;
              }

              if (checkMonth && jsDate.getMonth() !== expectedMonth) {
                // this means the destination month has less days than the initial month
                // let's go back to the end of the previous month:
                jsDate.setDate(0);
              }

              return fromJSDate(jsDate);
            }
          }, {
            key: "getPrev",
            value: function getPrev(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              return this.getNext(date, period, -number);
            }
          }, {
            key: "getWeekday",
            value: function getWeekday(date) {
              var jsDate = toJSDate(date);
              var day = jsDate.getDay(); // in JS Date Sun=0, in ISO 8601 Sun=7

              return day === 0 ? 7 : day;
            }
          }, {
            key: "getWeekNumber",
            value: function getWeekNumber(week, firstDayOfWeek) {
              // in JS Date Sun=0, in ISO 8601 Sun=7
              if (firstDayOfWeek === 7) {
                firstDayOfWeek = 0;
              }

              var thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;
              var date = week[thursdayIndex];
              var jsDate = toJSDate(date);
              jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday

              var time = jsDate.getTime();
              jsDate.setMonth(0); // Compare with Jan 1

              jsDate.setDate(1);
              return Math.floor(Math.round((time - jsDate.getTime()) / 86400000) / 7) + 1;
            }
          }, {
            key: "getToday",
            value: function getToday() {
              return fromJSDate(new Date());
            }
          }, {
            key: "isValid",
            value: function isValid(date) {
              if (!date || !isInteger(date.year) || !isInteger(date.month) || !isInteger(date.day)) {
                return false;
              } // year 0 doesn't exist in Gregorian calendar


              if (date.year === 0) {
                return false;
              }

              var jsDate = toJSDate(date);
              return !isNaN(jsDate.getTime()) && jsDate.getFullYear() === date.year && jsDate.getMonth() + 1 === date.month && jsDate.getDate() === date.day;
            }
          }]);

          return NgbCalendarGregorian;
        }(_NgbCalendar);

        NgbCalendarGregorian.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarGregorian_BaseFactory;
          return function NgbCalendarGregorian_Factory(t) {
            return (ɵNgbCalendarGregorian_BaseFactory || (ɵNgbCalendarGregorian_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarGregorian)))(t || NgbCalendarGregorian);
          };
        }();

        NgbCalendarGregorian.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarGregorian,
          factory: NgbCalendarGregorian.ɵfac
        });
        return NgbCalendarGregorian;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      function isChangedDate(prev, next) {
        return !dateComparator(prev, next);
      }

      function isChangedMonth(prev, next) {
        return !prev && !next ? false : !prev || !next ? true : prev.year !== next.year || prev.month !== next.month;
      }

      function dateComparator(prev, next) {
        return !prev && !next || !!prev && !!next && prev.equals(next);
      }

      function checkMinBeforeMax(minDate, maxDate) {
        if (maxDate && minDate && maxDate.before(minDate)) {
          throw new Error("'maxDate' ".concat(maxDate, " should be greater than 'minDate' ").concat(minDate));
        }
      }

      function checkDateInRange(date, minDate, maxDate) {
        if (date && minDate && date.before(minDate)) {
          return minDate;
        }

        if (date && maxDate && date.after(maxDate)) {
          return maxDate;
        }

        return date || null;
      }

      function isDateSelectable(date, state) {
        var minDate = state.minDate,
            maxDate = state.maxDate,
            disabled = state.disabled,
            markDisabled = state.markDisabled; // clang-format off

        return !(date === null || date === undefined || disabled || markDisabled && markDisabled(date, {
          year: date.year,
          month: date.month
        }) || minDate && date.before(minDate) || maxDate && date.after(maxDate)); // clang-format on
      }

      function generateSelectBoxMonths(calendar, date, minDate, maxDate) {
        if (!date) {
          return [];
        }

        var months = calendar.getMonths(date.year);

        if (minDate && date.year === minDate.year) {
          var index = months.findIndex(function (month) {
            return month === minDate.month;
          });
          months = months.slice(index);
        }

        if (maxDate && date.year === maxDate.year) {
          var _index = months.findIndex(function (month) {
            return month === maxDate.month;
          });

          months = months.slice(0, _index + 1);
        }

        return months;
      }

      function generateSelectBoxYears(date, minDate, maxDate) {
        if (!date) {
          return [];
        }

        var start = minDate ? Math.max(minDate.year, date.year - 500) : date.year - 10;
        var end = maxDate ? Math.min(maxDate.year, date.year + 500) : date.year + 10;
        var length = end - start + 1;
        var numbers = Array(length);

        for (var i = 0; i < length; i++) {
          numbers[i] = start + i;
        }

        return numbers;
      }

      function nextMonthDisabled(calendar, date, maxDate) {
        var nextDate = Object.assign(calendar.getNext(date, 'm'), {
          day: 1
        });
        return maxDate != null && nextDate.after(maxDate);
      }

      function prevMonthDisabled(calendar, date, minDate) {
        var prevDate = Object.assign(calendar.getPrev(date, 'm'), {
          day: 1
        });
        return minDate != null && (prevDate.year === minDate.year && prevDate.month < minDate.month || prevDate.year < minDate.year && minDate.month === 1);
      }

      function buildMonths(calendar, date, state, i18n, force) {
        var displayMonths = state.displayMonths,
            months = state.months; // move old months to a temporary array

        var monthsToReuse = months.splice(0, months.length); // generate new first dates, nullify or reuse months

        var firstDates = Array.from({
          length: displayMonths
        }, function (_, i) {
          var firstDate = Object.assign(calendar.getNext(date, 'm', i), {
            day: 1
          });
          months[i] = null;

          if (!force) {
            var reusedIndex = monthsToReuse.findIndex(function (month) {
              return month.firstDate.equals(firstDate);
            }); // move reused month back to months

            if (reusedIndex !== -1) {
              months[i] = monthsToReuse.splice(reusedIndex, 1)[0];
            }
          }

          return firstDate;
        }); // rebuild nullified months

        firstDates.forEach(function (firstDate, i) {
          if (months[i] === null) {
            months[i] = buildMonth(calendar, firstDate, state, i18n, monthsToReuse.shift() || {});
          }
        });
        return months;
      }

      function buildMonth(calendar, date, state, i18n) {
        var month = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        var dayTemplateData = state.dayTemplateData,
            minDate = state.minDate,
            maxDate = state.maxDate,
            firstDayOfWeek = state.firstDayOfWeek,
            markDisabled = state.markDisabled,
            outsideDays = state.outsideDays,
            weekdayWidth = state.weekdayWidth,
            weekdaysVisible = state.weekdaysVisible;
        var calendarToday = calendar.getToday();
        month.firstDate = null;
        month.lastDate = null;
        month.number = date.month;
        month.year = date.year;
        month.weeks = month.weeks || [];
        month.weekdays = month.weekdays || [];
        date = getFirstViewDate(calendar, date, firstDayOfWeek); // clearing weekdays, if not visible

        if (!weekdaysVisible) {
          month.weekdays.length = 0;
        } // month has weeks


        for (var week = 0; week < calendar.getWeeksPerMonth(); week++) {
          var weekObject = month.weeks[week];

          if (!weekObject) {
            weekObject = month.weeks[week] = {
              number: 0,
              days: [],
              collapsed: true
            };
          }

          var days = weekObject.days; // week has days

          for (var day = 0; day < calendar.getDaysPerWeek(); day++) {
            if (week === 0 && weekdaysVisible) {
              month.weekdays[day] = i18n.getWeekdayLabel(calendar.getWeekday(date), weekdayWidth);
            }

            var newDate = new _NgbDate(date.year, date.month, date.day);
            var nextDate = calendar.getNext(newDate);
            var ariaLabel = i18n.getDayAriaLabel(newDate); // marking date as disabled

            var disabled = !!(minDate && newDate.before(minDate) || maxDate && newDate.after(maxDate));

            if (!disabled && markDisabled) {
              disabled = markDisabled(newDate, {
                month: month.number,
                year: month.year
              });
            } // today


            var today = newDate.equals(calendarToday); // adding user-provided data to the context

            var contextUserData = dayTemplateData ? dayTemplateData(newDate, {
              month: month.number,
              year: month.year
            }) : undefined; // saving first date of the month

            if (month.firstDate === null && newDate.month === month.number) {
              month.firstDate = newDate;
            } // saving last date of the month


            if (newDate.month === month.number && nextDate.month !== month.number) {
              month.lastDate = newDate;
            }

            var dayObject = days[day];

            if (!dayObject) {
              dayObject = days[day] = {};
            }

            dayObject.date = newDate;
            dayObject.context = Object.assign(dayObject.context || {}, {
              $implicit: newDate,
              date: newDate,
              data: contextUserData,
              currentMonth: month.number,
              currentYear: month.year,
              disabled: disabled,
              focused: false,
              selected: false,
              today: today
            });
            dayObject.tabindex = -1;
            dayObject.ariaLabel = ariaLabel;
            dayObject.hidden = false;
            date = nextDate;
          }

          weekObject.number = calendar.getWeekNumber(days.map(function (day) {
            return day.date;
          }), firstDayOfWeek); // marking week as collapsed

          weekObject.collapsed = outsideDays === 'collapsed' && days[0].date.month !== month.number && days[days.length - 1].date.month !== month.number;
        }

        return month;
      }

      function getFirstViewDate(calendar, date, firstDayOfWeek) {
        var daysPerWeek = calendar.getDaysPerWeek();
        var firstMonthDate = new _NgbDate(date.year, date.month, 1);
        var dayOfWeek = calendar.getWeekday(firstMonthDate) % daysPerWeek;
        return calendar.getPrev(firstMonthDate, 'd', (daysPerWeek + dayOfWeek - firstDayOfWeek) % daysPerWeek);
      }

      function NGB_DATEPICKER_18N_FACTORY(locale) {
        return new _NgbDatepickerI18nDefault(locale);
      }
      /**
       * A service supplying i18n data to the datepicker component.
       *
       * The default implementation of this service uses the Angular locale and registered locale data for
       * weekdays and month names (as explained in the Angular i18n guide).
       *
       * It also provides a way to i18n data that depends on calendar calculations, like aria labels, day, week and year
       * numerals. For other static labels the datepicker uses the default Angular i18n.
       *
       * See the [i18n demo](#/components/datepicker/examples#i18n) and
       * [Hebrew calendar demo](#/components/datepicker/calendars#hebrew) on how to extend this class and define
       * a custom provider for i18n.
       */


      var _NgbDatepickerI18n = /*#__PURE__*/function () {
        var NgbDatepickerI18n = /*#__PURE__*/function () {
          function NgbDatepickerI18n() {
            _classCallCheck(this, NgbDatepickerI18n);
          }

          _createClass(NgbDatepickerI18n, [{
            key: "getWeekdayLabel",
            value:
            /**
             * Returns the weekday label using specified width
             *
             * @since 9.1.0
             */
            function getWeekdayLabel(weekday, width) {
              return this.getWeekdayShortName(weekday);
            }
            /**
             * Returns the text label to display above the day view.
             *
             * @since 9.1.0
             */

          }, {
            key: "getMonthLabel",
            value: function getMonthLabel(date) {
              return "".concat(this.getMonthFullName(date.month, date.year), " ").concat(this.getYearNumerals(date.year));
            }
            /**
             * Returns the textual representation of a day that is rendered in a day cell.
             *
             * @since 3.0.0
             */

          }, {
            key: "getDayNumerals",
            value: function getDayNumerals(date) {
              return "".concat(date.day);
            }
            /**
             * Returns the textual representation of a week number rendered by datepicker.
             *
             * @since 3.0.0
             */

          }, {
            key: "getWeekNumerals",
            value: function getWeekNumerals(weekNumber) {
              return "".concat(weekNumber);
            }
            /**
             * Returns the textual representation of a year that is rendered in the datepicker year select box.
             *
             * @since 3.0.0
             */

          }, {
            key: "getYearNumerals",
            value: function getYearNumerals(year) {
              return "".concat(year);
            }
            /**
             * Returns the week label to display in the heading of the month view.
             *
             * @since 9.1.0
             */

          }, {
            key: "getWeekLabel",
            value: function getWeekLabel() {
              return '';
            }
          }]);

          return NgbDatepickerI18n;
        }();

        NgbDatepickerI18n.ɵfac = function NgbDatepickerI18n_Factory(t) {
          return new (t || NgbDatepickerI18n)();
        };

        NgbDatepickerI18n.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbDatepickerI18n_Factory() {
            return NGB_DATEPICKER_18N_FACTORY((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID));
          },
          token: NgbDatepickerI18n,
          providedIn: "root"
        });
        return NgbDatepickerI18n;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A service providing default implementation for the datepicker i18n.
       * It can be used as a base implementation if necessary.
       *
       * @since 9.1.0
       */


      var _NgbDatepickerI18nDefault = /*#__PURE__*/function () {
        var NgbDatepickerI18nDefault = /*#__PURE__*/function (_NgbDatepickerI18n2) {
          _inherits(NgbDatepickerI18nDefault, _NgbDatepickerI18n2);

          var _super2 = _createSuper(NgbDatepickerI18nDefault);

          function NgbDatepickerI18nDefault(_locale) {
            var _this10;

            _classCallCheck(this, NgbDatepickerI18nDefault);

            _this10 = _super2.call(this);
            _this10._locale = _locale;
            _this10._monthsShort = (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.getLocaleMonthNames)(_locale, _angular_common__WEBPACK_IMPORTED_MODULE_1__.FormStyle.Standalone, _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Abbreviated);
            _this10._monthsFull = (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.getLocaleMonthNames)(_locale, _angular_common__WEBPACK_IMPORTED_MODULE_1__.FormStyle.Standalone, _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Wide);
            return _this10;
          }

          _createClass(NgbDatepickerI18nDefault, [{
            key: "getWeekdayShortName",
            value: function getWeekdayShortName(weekday) {
              return this.getWeekdayLabel(weekday, _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Short);
            }
          }, {
            key: "getWeekdayLabel",
            value: function getWeekdayLabel(weekday, width) {
              var weekdaysStartingOnSunday = (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.getLocaleDayNames)(this._locale, _angular_common__WEBPACK_IMPORTED_MODULE_1__.FormStyle.Standalone, width === undefined ? _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Short : width);
              var weekdays = weekdaysStartingOnSunday.map(function (day, index) {
                return weekdaysStartingOnSunday[(index + 1) % 7];
              });
              return weekdays[weekday - 1] || '';
            }
          }, {
            key: "getMonthShortName",
            value: function getMonthShortName(month) {
              return this._monthsShort[month - 1] || '';
            }
          }, {
            key: "getMonthFullName",
            value: function getMonthFullName(month) {
              return this._monthsFull[month - 1] || '';
            }
          }, {
            key: "getDayAriaLabel",
            value: function getDayAriaLabel(date) {
              var jsDate = new Date(date.year, date.month - 1, date.day);
              return (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.formatDate)(jsDate, 'fullDate', this._locale);
            }
          }]);

          return NgbDatepickerI18nDefault;
        }(_NgbDatepickerI18n);

        NgbDatepickerI18nDefault.ɵfac = function NgbDatepickerI18nDefault_Factory(t) {
          return new (t || NgbDatepickerI18nDefault)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID));
        };

        NgbDatepickerI18nDefault.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDatepickerI18nDefault,
          factory: NgbDatepickerI18nDefault.ɵfac
        });
        return NgbDatepickerI18nDefault;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDatepickerService = /*#__PURE__*/function () {
        var NgbDatepickerService = /*#__PURE__*/function () {
          function NgbDatepickerService(_calendar, _i18n) {
            var _this11 = this;

            _classCallCheck(this, NgbDatepickerService);

            this._calendar = _calendar;
            this._i18n = _i18n;
            this._VALIDATORS = {
              dayTemplateData: function dayTemplateData(_dayTemplateData) {
                if (_this11._state.dayTemplateData !== _dayTemplateData) {
                  return {
                    dayTemplateData: _dayTemplateData
                  };
                }
              },
              displayMonths: function displayMonths(_displayMonths) {
                _displayMonths = toInteger(_displayMonths);

                if (isInteger(_displayMonths) && _displayMonths > 0 && _this11._state.displayMonths !== _displayMonths) {
                  return {
                    displayMonths: _displayMonths
                  };
                }
              },
              disabled: function disabled(_disabled) {
                if (_this11._state.disabled !== _disabled) {
                  return {
                    disabled: _disabled
                  };
                }
              },
              firstDayOfWeek: function firstDayOfWeek(_firstDayOfWeek) {
                _firstDayOfWeek = toInteger(_firstDayOfWeek);

                if (isInteger(_firstDayOfWeek) && _firstDayOfWeek >= 0 && _this11._state.firstDayOfWeek !== _firstDayOfWeek) {
                  return {
                    firstDayOfWeek: _firstDayOfWeek
                  };
                }
              },
              focusVisible: function focusVisible(_focusVisible) {
                if (_this11._state.focusVisible !== _focusVisible && !_this11._state.disabled) {
                  return {
                    focusVisible: _focusVisible
                  };
                }
              },
              markDisabled: function markDisabled(_markDisabled) {
                if (_this11._state.markDisabled !== _markDisabled) {
                  return {
                    markDisabled: _markDisabled
                  };
                }
              },
              maxDate: function maxDate(date) {
                var maxDate = _this11.toValidDate(date, null);

                if (isChangedDate(_this11._state.maxDate, maxDate)) {
                  return {
                    maxDate: maxDate
                  };
                }
              },
              minDate: function minDate(date) {
                var minDate = _this11.toValidDate(date, null);

                if (isChangedDate(_this11._state.minDate, minDate)) {
                  return {
                    minDate: minDate
                  };
                }
              },
              navigation: function navigation(_navigation) {
                if (_this11._state.navigation !== _navigation) {
                  return {
                    navigation: _navigation
                  };
                }
              },
              outsideDays: function outsideDays(_outsideDays) {
                if (_this11._state.outsideDays !== _outsideDays) {
                  return {
                    outsideDays: _outsideDays
                  };
                }
              },
              weekdays: function weekdays(_weekdays) {
                var weekdayWidth = _weekdays === true || _weekdays === false ? _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Short : _weekdays;
                var weekdaysVisible = _weekdays === true || _weekdays === false ? _weekdays : true;

                if (_this11._state.weekdayWidth !== weekdayWidth || _this11._state.weekdaysVisible !== weekdaysVisible) {
                  return {
                    weekdayWidth: weekdayWidth,
                    weekdaysVisible: weekdaysVisible
                  };
                }
              }
            };
            this._model$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._dateSelect$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._state = {
              dayTemplateData: null,
              markDisabled: null,
              maxDate: null,
              minDate: null,
              disabled: false,
              displayMonths: 1,
              firstDate: null,
              firstDayOfWeek: 1,
              lastDate: null,
              focusDate: null,
              focusVisible: false,
              months: [],
              navigation: 'select',
              outsideDays: 'visible',
              prevDisabled: false,
              nextDisabled: false,
              selectedDate: null,
              selectBoxes: {
                years: [],
                months: []
              },
              weekdayWidth: _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Short,
              weekdaysVisible: true
            };
          }

          _createClass(NgbDatepickerService, [{
            key: "model$",
            get: function get() {
              return this._model$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (model) {
                return model.months.length > 0;
              }));
            }
          }, {
            key: "dateSelect$",
            get: function get() {
              return this._dateSelect$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (date) {
                return date !== null;
              }));
            }
          }, {
            key: "set",
            value: function set(options) {
              var _this12 = this;

              var patch = Object.keys(options).map(function (key) {
                return _this12._VALIDATORS[key](options[key]);
              }).reduce(function (obj, part) {
                return Object.assign(Object.assign({}, obj), part);
              }, {});

              if (Object.keys(patch).length > 0) {
                this._nextState(patch);
              }
            }
          }, {
            key: "focus",
            value: function focus(date) {
              var focusedDate = this.toValidDate(date, null);

              if (focusedDate != null && !this._state.disabled && isChangedDate(this._state.focusDate, focusedDate)) {
                this._nextState({
                  focusDate: date
                });
              }
            }
          }, {
            key: "focusSelect",
            value: function focusSelect() {
              if (isDateSelectable(this._state.focusDate, this._state)) {
                this.select(this._state.focusDate, {
                  emitEvent: true
                });
              }
            }
          }, {
            key: "open",
            value: function open(date) {
              var firstDate = this.toValidDate(date, this._calendar.getToday());

              if (firstDate != null && !this._state.disabled && (!this._state.firstDate || isChangedMonth(this._state.firstDate, firstDate))) {
                this._nextState({
                  firstDate: firstDate
                });
              }
            }
          }, {
            key: "select",
            value: function select(date) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var selectedDate = this.toValidDate(date, null);

              if (selectedDate != null && !this._state.disabled) {
                if (isChangedDate(this._state.selectedDate, selectedDate)) {
                  this._nextState({
                    selectedDate: selectedDate
                  });
                }

                if (options.emitEvent && isDateSelectable(selectedDate, this._state)) {
                  this._dateSelect$.next(selectedDate);
                }
              }
            }
          }, {
            key: "toValidDate",
            value: function toValidDate(date, defaultValue) {
              var ngbDate = _NgbDate.from(date);

              if (defaultValue === undefined) {
                defaultValue = this._calendar.getToday();
              }

              return this._calendar.isValid(ngbDate) ? ngbDate : defaultValue;
            }
          }, {
            key: "getMonth",
            value: function getMonth(struct) {
              var _iterator2 = _createForOfIteratorHelper(this._state.months),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var month = _step2.value;

                  if (struct.month === month.number && struct.year === month.year) {
                    return month;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              throw new Error("month ".concat(struct.month, " of year ").concat(struct.year, " not found"));
            }
          }, {
            key: "_nextState",
            value: function _nextState(patch) {
              var newState = this._updateState(patch);

              this._patchContexts(newState);

              this._state = newState;

              this._model$.next(this._state);
            }
          }, {
            key: "_patchContexts",
            value: function _patchContexts(state) {
              var months = state.months,
                  displayMonths = state.displayMonths,
                  selectedDate = state.selectedDate,
                  focusDate = state.focusDate,
                  focusVisible = state.focusVisible,
                  disabled = state.disabled,
                  outsideDays = state.outsideDays;
              state.months.forEach(function (month) {
                month.weeks.forEach(function (week) {
                  week.days.forEach(function (day) {
                    // patch focus flag
                    if (focusDate) {
                      day.context.focused = focusDate.equals(day.date) && focusVisible;
                    } // calculating tabindex


                    day.tabindex = !disabled && focusDate && day.date.equals(focusDate) && focusDate.month === month.number ? 0 : -1; // override context disabled

                    if (disabled === true) {
                      day.context.disabled = true;
                    } // patch selection flag


                    if (selectedDate !== undefined) {
                      day.context.selected = selectedDate !== null && selectedDate.equals(day.date);
                    } // visibility


                    if (month.number !== day.date.month) {
                      day.hidden = outsideDays === 'hidden' || outsideDays === 'collapsed' || displayMonths > 1 && day.date.after(months[0].firstDate) && day.date.before(months[displayMonths - 1].lastDate);
                    }
                  });
                });
              });
            }
          }, {
            key: "_updateState",
            value: function _updateState(patch) {
              // patching fields
              var state = Object.assign({}, this._state, patch);
              var startDate = state.firstDate; // min/max dates changed

              if ('minDate' in patch || 'maxDate' in patch) {
                checkMinBeforeMax(state.minDate, state.maxDate);
                state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);
                state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);
                startDate = state.focusDate;
              } // disabled


              if ('disabled' in patch) {
                state.focusVisible = false;
              } // initial rebuild via 'select()'


              if ('selectedDate' in patch && this._state.months.length === 0) {
                startDate = state.selectedDate;
              } // terminate early if only focus visibility was changed


              if ('focusVisible' in patch) {
                return state;
              } // focus date changed


              if ('focusDate' in patch) {
                state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);
                startDate = state.focusDate; // nothing to rebuild if only focus changed and it is still visible

                if (state.months.length !== 0 && state.focusDate && !state.focusDate.before(state.firstDate) && !state.focusDate.after(state.lastDate)) {
                  return state;
                }
              } // first date changed


              if ('firstDate' in patch) {
                state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);
                startDate = state.firstDate;
              } // rebuilding months


              if (startDate) {
                var forceRebuild = 'dayTemplateData' in patch || 'firstDayOfWeek' in patch || 'markDisabled' in patch || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch || 'outsideDays' in patch || 'weekdaysVisible' in patch;
                var months = buildMonths(this._calendar, startDate, state, this._i18n, forceRebuild); // updating months and boundary dates

                state.months = months;
                state.firstDate = months[0].firstDate;
                state.lastDate = months[months.length - 1].lastDate; // reset selected date if 'markDisabled' returns true

                if ('selectedDate' in patch && !isDateSelectable(state.selectedDate, state)) {
                  state.selectedDate = null;
                } // adjusting focus after months were built


                if ('firstDate' in patch) {
                  if (!state.focusDate || state.focusDate.before(state.firstDate) || state.focusDate.after(state.lastDate)) {
                    state.focusDate = startDate;
                  }
                } // adjusting months/years for the select box navigation


                var yearChanged = !this._state.firstDate || this._state.firstDate.year !== state.firstDate.year;
                var monthChanged = !this._state.firstDate || this._state.firstDate.month !== state.firstDate.month;

                if (state.navigation === 'select') {
                  // years ->  boundaries (min/max were changed)
                  if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.years.length === 0 || yearChanged) {
                    state.selectBoxes.years = generateSelectBoxYears(state.firstDate, state.minDate, state.maxDate);
                  } // months -> when current year or boundaries change


                  if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.months.length === 0 || yearChanged) {
                    state.selectBoxes.months = generateSelectBoxMonths(this._calendar, state.firstDate, state.minDate, state.maxDate);
                  }
                } else {
                  state.selectBoxes = {
                    years: [],
                    months: []
                  };
                } // updating navigation arrows -> boundaries change (min/max) or month/year changes


                if ((state.navigation === 'arrows' || state.navigation === 'select') && (monthChanged || yearChanged || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch)) {
                  state.prevDisabled = state.disabled || prevMonthDisabled(this._calendar, state.firstDate, state.minDate);
                  state.nextDisabled = state.disabled || nextMonthDisabled(this._calendar, state.lastDate, state.maxDate);
                }
              }

              return state;
            }
          }]);

          return NgbDatepickerService;
        }();

        NgbDatepickerService.ɵfac = function NgbDatepickerService_Factory(t) {
          return new (t || NgbDatepickerService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbCalendar), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbDatepickerI18n));
        };

        NgbDatepickerService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDatepickerService,
          factory: NgbDatepickerService.ɵfac
        });
        return NgbDatepickerService;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })(); // clang-format on


      var NavigationEvent = /*#__PURE__*/function () {
        (function (NavigationEvent) {
          NavigationEvent[NavigationEvent["PREV"] = 0] = "PREV";
          NavigationEvent[NavigationEvent["NEXT"] = 1] = "NEXT";
        })(NavigationEvent || (NavigationEvent = {}));

        return NavigationEvent;
      }();
      /**
       * A configuration service for the [`NgbDatepicker`](#/components/datepicker/api#NgbDatepicker) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the datepickers used in the application.
       */


      var _NgbDatepickerConfig = /*#__PURE__*/function () {
        var NgbDatepickerConfig = function NgbDatepickerConfig() {
          _classCallCheck(this, NgbDatepickerConfig);

          this.displayMonths = 1;
          this.firstDayOfWeek = 1;
          this.navigation = 'select';
          this.outsideDays = 'visible';
          this.showWeekdays = true;
          this.showWeekNumbers = false;
          this.weekdays = _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Short;
        };

        NgbDatepickerConfig.ɵfac = function NgbDatepickerConfig_Factory(t) {
          return new (t || NgbDatepickerConfig)();
        };

        NgbDatepickerConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbDatepickerConfig_Factory() {
            return new NgbDatepickerConfig();
          },
          token: NgbDatepickerConfig,
          providedIn: "root"
        });
        return NgbDatepickerConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      function NGB_DATEPICKER_DATE_ADAPTER_FACTORY() {
        return new NgbDateStructAdapter();
      }
      /**
       * An abstract service that does the conversion between the internal datepicker `NgbDateStruct` model and
       * any provided user date model `D`, ex. a string, a native date, etc.
       *
       * The adapter is used **only** for conversion when binding datepicker to a form control,
       * ex. `[(ngModel)]="userDateModel"`. Here `userDateModel` can be of any type.
       *
       * The default datepicker implementation assumes we use `NgbDateStruct` as a user model.
       *
       * See the [date format overview](#/components/datepicker/overview#date-model) for more details
       * and the [custom adapter demo](#/components/datepicker/examples#adapter) for an example.
       */


      var _NgbDateAdapter = /*#__PURE__*/function () {
        var NgbDateAdapter = function NgbDateAdapter() {
          _classCallCheck(this, NgbDateAdapter);
        };

        NgbDateAdapter.ɵfac = function NgbDateAdapter_Factory(t) {
          return new (t || NgbDateAdapter)();
        };

        NgbDateAdapter.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: NGB_DATEPICKER_DATE_ADAPTER_FACTORY,
          token: NgbDateAdapter,
          providedIn: "root"
        });
        return NgbDateAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDateStructAdapter = /*#__PURE__*/function () {
        var NgbDateStructAdapter = /*#__PURE__*/function (_NgbDateAdapter2) {
          _inherits(NgbDateStructAdapter, _NgbDateAdapter2);

          var _super3 = _createSuper(NgbDateStructAdapter);

          function NgbDateStructAdapter() {
            _classCallCheck(this, NgbDateStructAdapter);

            return _super3.apply(this, arguments);
          }

          _createClass(NgbDateStructAdapter, [{
            key: "fromModel",
            value:
            /**
             * Converts a NgbDateStruct value into NgbDateStruct value
             */
            function fromModel(date) {
              return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? {
                year: date.year,
                month: date.month,
                day: date.day
              } : null;
            }
            /**
             * Converts a NgbDateStruct value into NgbDateStruct value
             */

          }, {
            key: "toModel",
            value: function toModel(date) {
              return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? {
                year: date.year,
                month: date.month,
                day: date.day
              } : null;
            }
          }]);

          return NgbDateStructAdapter;
        }(_NgbDateAdapter);

        NgbDateStructAdapter.ɵfac = /*@__PURE__*/function () {
          var ɵNgbDateStructAdapter_BaseFactory;
          return function NgbDateStructAdapter_Factory(t) {
            return (ɵNgbDateStructAdapter_BaseFactory || (ɵNgbDateStructAdapter_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbDateStructAdapter)))(t || NgbDateStructAdapter);
          };
        }();

        NgbDateStructAdapter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDateStructAdapter,
          factory: NgbDateStructAdapter.ɵfac
        });
        return NgbDateStructAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that marks the content template that customizes the way datepicker months are displayed
       *
       * @since 5.3.0
       */


      var _NgbDatepickerContent = /*#__PURE__*/function () {
        var NgbDatepickerContent = function NgbDatepickerContent(templateRef) {
          _classCallCheck(this, NgbDatepickerContent);

          this.templateRef = templateRef;
        };

        NgbDatepickerContent.ɵfac = function NgbDatepickerContent_Factory(t) {
          return new (t || NgbDatepickerContent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbDatepickerContent.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDatepickerContent,
          selectors: [["ng-template", "ngbDatepickerContent", ""]]
        });
        return NgbDatepickerContent;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A highly configurable component that helps you with selecting calendar dates.
       *
       * `NgbDatepicker` is meant to be displayed inline on a page or put inside a popup.
       */


      var _NgbDatepicker = /*#__PURE__*/function () {
        var NgbDatepicker = /*#__PURE__*/function () {
          function NgbDatepicker(_service, _calendar, i18n, config, cd, _elementRef, _ngbDateAdapter, _ngZone) {
            var _this13 = this;

            _classCallCheck(this, NgbDatepicker);

            this._service = _service;
            this._calendar = _calendar;
            this.i18n = i18n;
            this._elementRef = _elementRef;
            this._ngbDateAdapter = _ngbDateAdapter;
            this._ngZone = _ngZone;
            this._controlValue = null;
            this._destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._publicState = {};
            /**
             * An event emitted right before the navigation happens and displayed month changes.
             *
             * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.
             */

            this.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when user selects a date using keyboard or mouse.
             *
             * The payload of the event is currently selected `NgbDate`.
             *
             * @since 5.2.0
             */

            this.dateSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();

            this.onChange = function (_) {};

            this.onTouched = function () {};

            ['dayTemplate', 'dayTemplateData', 'displayMonths', 'firstDayOfWeek', 'footerTemplate', 'markDisabled', 'minDate', 'maxDate', 'navigation', 'outsideDays', 'showWeekdays', 'showWeekNumbers', 'startDate', 'weekdays'].forEach(function (input) {
              return _this13[input] = config[input];
            });

            _service.dateSelect$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._destroyed$)).subscribe(function (date) {
              _this13.dateSelect.emit(date);
            });

            _service.model$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._destroyed$)).subscribe(function (model) {
              var newDate = model.firstDate;
              var oldDate = _this13.model ? _this13.model.firstDate : null; // update public state

              _this13._publicState = {
                maxDate: model.maxDate,
                minDate: model.minDate,
                firstDate: model.firstDate,
                lastDate: model.lastDate,
                focusedDate: model.focusDate,
                months: model.months.map(function (viewModel) {
                  return viewModel.firstDate;
                })
              };
              var navigationPrevented = false; // emitting navigation event if the first month changes

              if (!newDate.equals(oldDate)) {
                _this13.navigate.emit({
                  current: oldDate ? {
                    year: oldDate.year,
                    month: oldDate.month
                  } : null,
                  next: {
                    year: newDate.year,
                    month: newDate.month
                  },
                  preventDefault: function preventDefault() {
                    return navigationPrevented = true;
                  }
                }); // can't prevent the very first navigation


                if (navigationPrevented && oldDate !== null) {
                  _this13._service.open(oldDate);

                  return;
                }
              }

              var newSelectedDate = model.selectedDate;
              var newFocusedDate = model.focusDate;
              var oldFocusedDate = _this13.model ? _this13.model.focusDate : null;
              _this13.model = model; // handling selection change

              if (isChangedDate(newSelectedDate, _this13._controlValue)) {
                _this13._controlValue = newSelectedDate;

                _this13.onTouched();

                _this13.onChange(_this13._ngbDateAdapter.toModel(newSelectedDate));
              } // handling focus change


              if (isChangedDate(newFocusedDate, oldFocusedDate) && oldFocusedDate && model.focusVisible) {
                _this13.focus();
              }

              cd.markForCheck();
            });
          }
          /**
           * If `true`, weekdays will be displayed.
           *
           * @deprecated 9.1.0, please use 'weekdays' instead
           */


          _createClass(NgbDatepicker, [{
            key: "showWeekdays",
            get: function get() {
              return this._showWeekdays;
            }
            /**
             *  Returns the readonly public state of the datepicker
             *
             * @since 5.2.0
             */
            ,
            set: function set(weekdays) {
              this.weekdays = weekdays;
              this._showWeekdays = weekdays;
            }
          }, {
            key: "state",
            get: function get() {
              return this._publicState;
            }
            /**
             *  Returns the calendar service used in the specific datepicker instance.
             *
             *  @since 5.3.0
             */

          }, {
            key: "calendar",
            get: function get() {
              return this._calendar;
            }
            /**
             *  Focuses on given date.
             */

          }, {
            key: "focusDate",
            value: function focusDate(date) {
              this._service.focus(_NgbDate.from(date));
            }
            /**
             *  Selects focused date.
             */

          }, {
            key: "focusSelect",
            value: function focusSelect() {
              this._service.focusSelect();
            }
          }, {
            key: "focus",
            value: function focus() {
              var _this14 = this;

              this._ngZone.onStable.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                var elementToFocus = _this14._elementRef.nativeElement.querySelector('div.ngb-dp-day[tabindex="0"]');

                if (elementToFocus) {
                  elementToFocus.focus();
                }
              });
            }
            /**
             * Navigates to the provided date.
             *
             * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
             * If nothing or invalid date provided calendar will open current month.
             *
             * Use the `[startDate]` input as an alternative.
             */

          }, {
            key: "navigateTo",
            value: function navigateTo(date) {
              this._service.open(_NgbDate.from(date ? date.day ? date : Object.assign(Object.assign({}, date), {
                day: 1
              }) : null));
            }
          }, {
            key: "ngAfterViewInit",
            value: function ngAfterViewInit() {
              var _this15 = this;

              this._ngZone.runOutsideAngular(function () {
                var focusIns$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(_this15._contentEl.nativeElement, 'focusin');
                var focusOuts$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(_this15._contentEl.nativeElement, 'focusout');
                var nativeElement = _this15._elementRef.nativeElement; // we're changing 'focusVisible' only when entering or leaving months view
                // and ignoring all focus events where both 'target' and 'related' target are day cells

                (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.merge)(focusIns$, focusOuts$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (_ref11) {
                  var target = _ref11.target,
                      relatedTarget = _ref11.relatedTarget;
                  return !(hasClassName(target, 'ngb-dp-day') && hasClassName(relatedTarget, 'ngb-dp-day') && nativeElement.contains(target) && nativeElement.contains(relatedTarget));
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this15._destroyed$)).subscribe(function (_ref12) {
                  var type = _ref12.type;
                  return _this15._ngZone.run(function () {
                    return _this15._service.set({
                      focusVisible: type === 'focusin'
                    });
                  });
                });
              });
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._destroyed$.next();
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              var _this16 = this;

              if (this.model === undefined) {
                var inputs = {};
                ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate', 'outsideDays', 'weekdays'].forEach(function (name) {
                  return inputs[name] = _this16[name];
                });

                this._service.set(inputs);

                this.navigateTo(this.startDate);
              }

              if (!this.dayTemplate) {
                this.dayTemplate = this._defaultDayTemplate;
              }
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              var _this17 = this;

              var inputs = {};

              if (changes.showWeekdays) {
                inputs['weekdays'] = this.weekdays;
              }

              ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate', 'outsideDays', 'weekdays'].filter(function (name) {
                return name in changes;
              }).forEach(function (name) {
                return inputs[name] = _this17[name];
              });

              this._service.set(inputs);

              if ('startDate' in changes) {
                var _changes$startDate = changes.startDate,
                    currentValue = _changes$startDate.currentValue,
                    previousValue = _changes$startDate.previousValue;

                if (isChangedMonth(previousValue, currentValue)) {
                  this.navigateTo(this.startDate);
                }
              }
            }
          }, {
            key: "onDateSelect",
            value: function onDateSelect(date) {
              this._service.focus(date);

              this._service.select(date, {
                emitEvent: true
              });
            }
          }, {
            key: "onNavigateDateSelect",
            value: function onNavigateDateSelect(date) {
              this._service.open(date);
            }
          }, {
            key: "onNavigateEvent",
            value: function onNavigateEvent(event) {
              switch (event) {
                case NavigationEvent.PREV:
                  this._service.open(this._calendar.getPrev(this.model.firstDate, 'm', 1));

                  break;

                case NavigationEvent.NEXT:
                  this._service.open(this._calendar.getNext(this.model.firstDate, 'm', 1));

                  break;
              }
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this.onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this.onTouched = fn;
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(disabled) {
              this._service.set({
                disabled: disabled
              });
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this._controlValue = _NgbDate.from(this._ngbDateAdapter.fromModel(value));

              this._service.select(this._controlValue);
            }
          }]);

          return NgbDatepicker;
        }();

        NgbDatepicker.ɵfac = function NgbDatepicker_Factory(t) {
          return new (t || NgbDatepicker)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](NgbDatepickerService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbCalendar), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerI18n), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDateAdapter), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbDatepicker.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbDatepicker,
          selectors: [["ngb-datepicker"]],
          contentQueries: function NgbDatepicker_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbDatepickerContent, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.contentTemplate = _t.first);
            }
          },
          viewQuery: function NgbDatepicker_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c10, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c11, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._defaultDayTemplate = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentEl = _t.first);
            }
          },
          inputs: {
            showWeekdays: "showWeekdays",
            weekdays: "weekdays",
            dayTemplate: "dayTemplate",
            dayTemplateData: "dayTemplateData",
            displayMonths: "displayMonths",
            firstDayOfWeek: "firstDayOfWeek",
            footerTemplate: "footerTemplate",
            markDisabled: "markDisabled",
            maxDate: "maxDate",
            minDate: "minDate",
            navigation: "navigation",
            outsideDays: "outsideDays",
            showWeekNumbers: "showWeekNumbers",
            startDate: "startDate"
          },
          outputs: {
            navigate: "navigate",
            dateSelect: "dateSelect"
          },
          exportAs: ["ngbDatepicker"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbDatepicker;
            }),
            multi: true
          }, NgbDatepickerService]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          decls: 10,
          vars: 5,
          consts: [["defaultDayTemplate", ""], ["defaultContentTemplate", ""], [1, "ngb-dp-header"], [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select", 4, "ngIf"], [1, "ngb-dp-content"], ["content", ""], [3, "ngTemplateOutlet"], ["ngbDatepickerDayView", "", 3, "date", "currentMonth", "selected", "disabled", "focused"], ["class", "ngb-dp-month", 4, "ngFor", "ngForOf"], [1, "ngb-dp-month"], ["class", "ngb-dp-month-name", 4, "ngIf"], [3, "month"], [1, "ngb-dp-month-name"], [3, "date", "months", "disabled", "showSelect", "prevDisabled", "nextDisabled", "selectBoxes", "navigate", "select"]],
          template: function NgbDatepicker_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepicker_ng_template_0_Template, 1, 5, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbDatepicker_ng_template_2_Template, 1, 1, "ng-template", null, 1, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, NgbDatepicker_ngb_datepicker_navigation_5_Template, 1, 7, "ngb-datepicker-navigation", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "div", 4, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](8, NgbDatepicker_ng_template_8_Template, 0, 0, "ng-template", 6);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](9, NgbDatepicker_ng_template_9_Template, 0, 0, "ng-template", 6);
            }

            if (rf & 2) {
              var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.navigation !== "none");

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("ngb-dp-months", !ctx.contentTemplate);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx.contentTemplate == null ? null : ctx.contentTemplate.templateRef) || _r2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx.footerTemplate);
            }
          },
          directives: function directives() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, NgbDatepickerDayView, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _NgbDatepickerMonth, NgbDatepickerNavigation];
          },
          styles: ["ngb-datepicker{border:1px solid #dfdfdf;border-radius:.25rem;display:inline-block}ngb-datepicker-month{pointer-events:auto}ngb-datepicker.dropdown-menu{padding:0}.ngb-dp-body{z-index:1050}.ngb-dp-header{background-color:#f8f9fa;background-color:var(--light);border-bottom:0;border-radius:.25rem .25rem 0 0;padding-top:.25rem}.ngb-dp-months{display:flex}.ngb-dp-month{pointer-events:none}.ngb-dp-month-name{background-color:#f8f9fa;background-color:var(--light);font-size:larger;height:2rem;line-height:2rem;text-align:center}.ngb-dp-month+.ngb-dp-month .ngb-dp-month-name,.ngb-dp-month+.ngb-dp-month .ngb-dp-week{padding-left:1rem}.ngb-dp-month:last-child .ngb-dp-week{padding-right:.25rem}.ngb-dp-month:first-child .ngb-dp-week{padding-left:.25rem}.ngb-dp-month .ngb-dp-week:last-child{padding-bottom:.25rem}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbDatepicker;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var Key = /*#__PURE__*/function () {
        (function (Key) {
          Key[Key["Tab"] = 9] = "Tab";
          Key[Key["Enter"] = 13] = "Enter";
          Key[Key["Escape"] = 27] = "Escape";
          Key[Key["Space"] = 32] = "Space";
          Key[Key["PageUp"] = 33] = "PageUp";
          Key[Key["PageDown"] = 34] = "PageDown";
          Key[Key["End"] = 35] = "End";
          Key[Key["Home"] = 36] = "Home";
          Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
          Key[Key["ArrowUp"] = 38] = "ArrowUp";
          Key[Key["ArrowRight"] = 39] = "ArrowRight";
          Key[Key["ArrowDown"] = 40] = "ArrowDown";
        })(Key || (Key = {}));

        return Key;
      }();
      /**
       * A service that represents the keyboard navigation.
       *
       * Default keyboard shortcuts [are documented in the overview](#/components/datepicker/overview#keyboard-shortcuts)
       *
       * @since 5.2.0
       */


      var _NgbDatepickerKeyboardService = /*#__PURE__*/function () {
        var NgbDatepickerKeyboardService = /*#__PURE__*/function () {
          function NgbDatepickerKeyboardService() {
            _classCallCheck(this, NgbDatepickerKeyboardService);
          }

          _createClass(NgbDatepickerKeyboardService, [{
            key: "processKey",
            value:
            /**
             * Processes a keyboard event.
             */
            function processKey(event, datepicker) {
              var state = datepicker.state,
                  calendar = datepicker.calendar; // tslint:disable-next-line:deprecation

              switch (event.which) {
                case Key.PageUp:
                  datepicker.focusDate(calendar.getPrev(state.focusedDate, event.shiftKey ? 'y' : 'm', 1));
                  break;

                case Key.PageDown:
                  datepicker.focusDate(calendar.getNext(state.focusedDate, event.shiftKey ? 'y' : 'm', 1));
                  break;

                case Key.End:
                  datepicker.focusDate(event.shiftKey ? state.maxDate : state.lastDate);
                  break;

                case Key.Home:
                  datepicker.focusDate(event.shiftKey ? state.minDate : state.firstDate);
                  break;

                case Key.ArrowLeft:
                  datepicker.focusDate(calendar.getPrev(state.focusedDate, 'd', 1));
                  break;

                case Key.ArrowUp:
                  datepicker.focusDate(calendar.getPrev(state.focusedDate, 'd', calendar.getDaysPerWeek()));
                  break;

                case Key.ArrowRight:
                  datepicker.focusDate(calendar.getNext(state.focusedDate, 'd', 1));
                  break;

                case Key.ArrowDown:
                  datepicker.focusDate(calendar.getNext(state.focusedDate, 'd', calendar.getDaysPerWeek()));
                  break;

                case Key.Enter:
                case Key.Space:
                  datepicker.focusSelect();
                  break;

                default:
                  return;
              }

              event.preventDefault();
              event.stopPropagation();
            }
          }]);

          return NgbDatepickerKeyboardService;
        }();

        NgbDatepickerKeyboardService.ɵfac = function NgbDatepickerKeyboardService_Factory(t) {
          return new (t || NgbDatepickerKeyboardService)();
        };

        NgbDatepickerKeyboardService.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbDatepickerKeyboardService_Factory() {
            return new NgbDatepickerKeyboardService();
          },
          token: NgbDatepickerKeyboardService,
          providedIn: "root"
        });
        return NgbDatepickerKeyboardService;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A component that renders one month including all the days, weekdays and week numbers. Can be used inside
       * the `<ng-template ngbDatepickerMonths></ng-template>` when you want to customize months layout.
       *
       * For a usage example, see [custom month layout demo](#/components/datepicker/examples#custommonth)
       *
       * @since 5.3.0
       */


      var _NgbDatepickerMonth = /*#__PURE__*/function () {
        var NgbDatepickerMonth = /*#__PURE__*/function () {
          function NgbDatepickerMonth(i18n, datepicker, _keyboardService, _service) {
            _classCallCheck(this, NgbDatepickerMonth);

            this.i18n = i18n;
            this.datepicker = datepicker;
            this._keyboardService = _keyboardService;
            this._service = _service;
          }
          /**
           * The first date of month to be rendered.
           *
           * This month must one of the months present in the
           * [datepicker state](#/components/datepicker/api#NgbDatepickerState).
           */


          _createClass(NgbDatepickerMonth, [{
            key: "month",
            set: function set(month) {
              this.viewModel = this._service.getMonth(month);
            }
          }, {
            key: "onKeyDown",
            value: function onKeyDown(event) {
              this._keyboardService.processKey(event, this.datepicker);
            }
          }, {
            key: "doSelect",
            value: function doSelect(day) {
              if (!day.context.disabled && !day.hidden) {
                this.datepicker.onDateSelect(day.date);
              }
            }
          }]);

          return NgbDatepickerMonth;
        }();

        NgbDatepickerMonth.ɵfac = function NgbDatepickerMonth_Factory(t) {
          return new (t || NgbDatepickerMonth)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerI18n), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepicker), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerKeyboardService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](NgbDatepickerService));
        };

        NgbDatepickerMonth.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbDatepickerMonth,
          selectors: [["ngb-datepicker-month"]],
          hostAttrs: ["role", "grid"],
          hostBindings: function NgbDatepickerMonth_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown", function NgbDatepickerMonth_keydown_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              });
            }
          },
          inputs: {
            month: "month"
          },
          decls: 2,
          vars: 2,
          consts: [["class", "ngb-dp-week ngb-dp-weekdays", "role", "row", 4, "ngIf"], ["ngFor", "", 3, "ngForOf"], ["role", "row", 1, "ngb-dp-week", "ngb-dp-weekdays"], ["class", "ngb-dp-weekday ngb-dp-showweek small", 4, "ngIf"], ["class", "ngb-dp-weekday small", "role", "columnheader", 4, "ngFor", "ngForOf"], [1, "ngb-dp-weekday", "ngb-dp-showweek", "small"], ["role", "columnheader", 1, "ngb-dp-weekday", "small"], ["class", "ngb-dp-week", "role", "row", 4, "ngIf"], ["role", "row", 1, "ngb-dp-week"], ["class", "ngb-dp-week-number small text-muted", 4, "ngIf"], ["class", "ngb-dp-day", "role", "gridcell", 3, "disabled", "tabindex", "hidden", "ngb-dp-today", "click", 4, "ngFor", "ngForOf"], [1, "ngb-dp-week-number", "small", "text-muted"], ["role", "gridcell", 1, "ngb-dp-day", 3, "tabindex", "click"], [3, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
          template: function NgbDatepickerMonth_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbDatepickerMonth_div_0_Template, 3, 2, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbDatepickerMonth_ng_template_1_Template, 1, 1, "ng-template", 1);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.viewModel.weekdays.length > 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.viewModel.weeks);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          styles: ["ngb-datepicker-month{display:block}.ngb-dp-week-number,.ngb-dp-weekday{font-style:italic;line-height:2rem;text-align:center}.ngb-dp-weekday{color:#5bc0de;color:var(--info)}.ngb-dp-week{border-radius:.25rem;display:flex}.ngb-dp-weekdays{background-color:#f8f9fa;background-color:var(--light);border-bottom:1px solid rgba(0,0,0,.125);border-radius:0}.ngb-dp-day,.ngb-dp-week-number,.ngb-dp-weekday{height:2rem;width:2rem}.ngb-dp-day{cursor:pointer}.ngb-dp-day.disabled,.ngb-dp-day.hidden{cursor:default;pointer-events:none}.ngb-dp-day[tabindex=\"0\"]{z-index:1}"],
          encapsulation: 2
        });
        return NgbDatepickerMonth;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDatepickerNavigation = /*#__PURE__*/function () {
        var NgbDatepickerNavigation = /*#__PURE__*/function () {
          function NgbDatepickerNavigation(i18n) {
            _classCallCheck(this, NgbDatepickerNavigation);

            this.i18n = i18n;
            this.navigation = NavigationEvent;
            this.months = [];
            this.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          }

          _createClass(NgbDatepickerNavigation, [{
            key: "onClickPrev",
            value: function onClickPrev(event) {
              event.currentTarget.focus();
              this.navigate.emit(this.navigation.PREV);
            }
          }, {
            key: "onClickNext",
            value: function onClickNext(event) {
              event.currentTarget.focus();
              this.navigate.emit(this.navigation.NEXT);
            }
          }]);

          return NgbDatepickerNavigation;
        }();

        NgbDatepickerNavigation.ɵfac = function NgbDatepickerNavigation_Factory(t) {
          return new (t || NgbDatepickerNavigation)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerI18n));
        };

        NgbDatepickerNavigation.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbDatepickerNavigation,
          selectors: [["ngb-datepicker-navigation"]],
          inputs: {
            months: "months",
            date: "date",
            disabled: "disabled",
            showSelect: "showSelect",
            prevDisabled: "prevDisabled",
            nextDisabled: "nextDisabled",
            selectBoxes: "selectBoxes"
          },
          outputs: {
            navigate: "navigate",
            select: "select"
          },
          decls: 8,
          vars: 4,
          consts: function consts() {
            var i18n_12;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_previous_month$$FESM2015_NG_BOOTSTRAP_JS_13 = goog.getMsg("Previous month");
              i18n_12 = MSG_EXTERNAL_ngb_datepicker_previous_month$$FESM2015_NG_BOOTSTRAP_JS_13;
            } else {
              i18n_12 = $localize(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([":@@ngb.datepicker.previous-month\u241Fc3b08b07b5ab98e7cdcf18df39355690ab7d3884\u241F8586908745456864217:Previous month"])));
            }

            var i18n_14;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_previous_month$$FESM2015_NG_BOOTSTRAP_JS_15 = goog.getMsg("Previous month");
              i18n_14 = MSG_EXTERNAL_ngb_datepicker_previous_month$$FESM2015_NG_BOOTSTRAP_JS_15;
            } else {
              i18n_14 = $localize(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([":@@ngb.datepicker.previous-month\u241Fc3b08b07b5ab98e7cdcf18df39355690ab7d3884\u241F8586908745456864217:Previous month"])));
            }

            var i18n_16;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_next_month$$FESM2015_NG_BOOTSTRAP_JS_17 = goog.getMsg("Next month");
              i18n_16 = MSG_EXTERNAL_ngb_datepicker_next_month$$FESM2015_NG_BOOTSTRAP_JS_17;
            } else {
              i18n_16 = $localize(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([":@@ngb.datepicker.next-month\u241F4bd046985cfe13040d5ef0cd881edce0968a111a\u241F3628374603023447227:Next month"])));
            }

            var i18n_18;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_next_month$$FESM2015_NG_BOOTSTRAP_JS_19 = goog.getMsg("Next month");
              i18n_18 = MSG_EXTERNAL_ngb_datepicker_next_month$$FESM2015_NG_BOOTSTRAP_JS_19;
            } else {
              i18n_18 = $localize(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([":@@ngb.datepicker.next-month\u241F4bd046985cfe13040d5ef0cd881edce0968a111a\u241F3628374603023447227:Next month"])));
            }

            return [[1, "ngb-dp-arrow"], ["type", "button", "aria-label", i18n_12, "title", i18n_14, 1, "btn", "btn-link", "ngb-dp-arrow-btn", 3, "disabled", "click"], [1, "ngb-dp-navigation-chevron"], ["class", "ngb-dp-navigation-select", 3, "date", "disabled", "months", "years", "select", 4, "ngIf"], [4, "ngIf"], [1, "ngb-dp-arrow", "right"], ["type", "button", "aria-label", i18n_16, "title", i18n_18, 1, "btn", "btn-link", "ngb-dp-arrow-btn", 3, "disabled", "click"], [1, "ngb-dp-navigation-select", 3, "date", "disabled", "months", "years", "select"], ["ngFor", "", 3, "ngForOf"], ["class", "ngb-dp-arrow", 4, "ngIf"], [1, "ngb-dp-month-name"]];
          },
          template: function NgbDatepickerNavigation_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "button", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbDatepickerNavigation_Template_button_click_1_listener($event) {
                return ctx.onClickPrev($event);
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "span", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbDatepickerNavigation_ngb_datepicker_navigation_select_3_Template, 1, 4, "ngb-datepicker-navigation-select", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, NgbDatepickerNavigation_4_Template, 1, 1, undefined, 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "div", 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "button", 6);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbDatepickerNavigation_Template_button_click_6_listener($event) {
                return ctx.onClickNext($event);
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](7, "span", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx.prevDisabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showSelect);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.showSelect);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx.nextDisabled);
            }
          },
          directives: function directives() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, NgbDatepickerNavigationSelect, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf];
          },
          styles: ["ngb-datepicker-navigation{align-items:center;display:flex}.ngb-dp-navigation-chevron{border-style:solid;border-width:.2em .2em 0 0;display:inline-block;height:.75em;margin-left:.25em;margin-right:.15em;transform:rotate(-135deg);width:.75em}.ngb-dp-arrow{display:flex;flex:1 1 auto;height:2rem;margin:0;padding-left:0;padding-right:0;width:2rem}.ngb-dp-arrow.right{justify-content:flex-end}.ngb-dp-arrow.right .ngb-dp-navigation-chevron{margin-left:.15em;margin-right:.25em;transform:rotate(45deg)}.ngb-dp-arrow-btn{background-color:transparent;border:none;margin:0 .5rem;padding:0 .25rem;z-index:1}.ngb-dp-arrow-btn:focus{outline-style:auto;outline-width:1px}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.ngb-dp-arrow-btn:focus{outline-style:solid}}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center}.ngb-dp-navigation-select{display:flex;flex:1 1 9rem}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbDatepickerNavigation;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var isContainedIn = function isContainedIn(element, array) {
        return array ? array.some(function (item) {
          return item.contains(element);
        }) : false;
      };

      var ɵ0$2 = isContainedIn;

      var matchesSelectorIfAny = function matchesSelectorIfAny(element, selector) {
        return !selector || closest(element, selector) != null;
      };

      var ɵ1$1 = matchesSelectorIfAny;

      var ɵ2$1 = function ɵ2$1() {
        var isIOS = function isIOS() {
          return /iPad|iPhone|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2;
        };

        var isAndroid = function isAndroid() {
          return /Android/.test(navigator.userAgent);
        };

        return typeof navigator !== 'undefined' ? !!navigator.userAgent && (isIOS() || isAndroid()) : false;
      }; // we have to add a more significant delay to avoid re-opening when handling (click) on a toggling element
      // TODO: use proper Angular platform detection when NgbAutoClose becomes a service and we can inject PLATFORM_ID


      var isMobile = ɵ2$1(); // setting 'ngbAutoClose' synchronously on mobile results in immediate popup closing
      // when tapping on the triggering element

      var wrapAsyncForMobile = function wrapAsyncForMobile(fn) {
        return isMobile ? function () {
          return setTimeout(function () {
            return fn();
          }, 100);
        } : fn;
      };

      var ɵ3 = wrapAsyncForMobile;

      function ngbAutoClose(zone, document, type, close, closed$, insideElements, ignoreElements, insideSelector) {
        // closing on ESC and outside clicks
        if (type) {
          zone.runOutsideAngular(wrapAsyncForMobile(function () {
            var shouldCloseOnClick = function shouldCloseOnClick(event) {
              var element = event.target;

              if (event.button === 2 || isContainedIn(element, ignoreElements)) {
                return false;
              }

              if (type === 'inside') {
                return isContainedIn(element, insideElements) && matchesSelectorIfAny(element, insideSelector);
              } else if (type === 'outside') {
                return !isContainedIn(element, insideElements);
              } else
                /* if (type === true) */
                {
                  return matchesSelectorIfAny(element, insideSelector) || !isContainedIn(element, insideElements);
                }
            };

            var escapes$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(document, 'keydown').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(closed$), // tslint:disable-next-line:deprecation
            (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (e) {
              return e.which === Key.Escape;
            }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(function (e) {
              return e.preventDefault();
            })); // we have to pre-calculate 'shouldCloseOnClick' on 'mousedown',
            // because on 'mouseup' DOM nodes might be detached

            var mouseDowns$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(document, 'mousedown').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(shouldCloseOnClick), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(closed$));
            var closeableClicks$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(document, 'mouseup').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.withLatestFrom)(mouseDowns$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (_ref13) {
              var _ref14 = _slicedToArray(_ref13, 2),
                  _ = _ref14[0],
                  shouldClose = _ref14[1];

              return shouldClose;
            }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.delay)(0), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(closed$));
            (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.race)([escapes$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (_) {
              return 0;
            }
            /* ESCAPE */
            )), closeableClicks$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (_) {
              return 1;
            }
            /* CLICK */
            ))]).subscribe(function (source) {
              return zone.run(function () {
                return close(source);
              });
            });
          }));
        }
      }

      var FOCUSABLE_ELEMENTS_SELECTOR = ['a[href]', 'button:not([disabled])', 'input:not([disabled]):not([type="hidden"])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable]', '[tabindex]:not([tabindex="-1"])'].join(', ');
      /**
       * Returns first and last focusable elements inside of a given element based on specific CSS selector
       */

      function getFocusableBoundaryElements(element) {
        var list = Array.from(element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)).filter(function (el) {
          return el.tabIndex !== -1;
        });
        return [list[0], list[list.length - 1]];
      }
      /**
       * Function that enforces browser focus to be trapped inside a DOM element.
       *
       * Works only for clicks inside the element and navigation with 'Tab', ignoring clicks outside of the element
       *
       * @param zone Angular zone
       * @param element The element around which focus will be trapped inside
       * @param stopFocusTrap$ The observable stream. When completed the focus trap will clean up listeners
       * and free internal resources
       * @param refocusOnClick Put the focus back to the last focused element whenever a click occurs on element (default to
       * false)
       */


      var ngbFocusTrap = function ngbFocusTrap(zone, element, stopFocusTrap$) {
        var refocusOnClick = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        zone.runOutsideAngular(function () {
          // last focused element
          var lastFocusedElement$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(element, 'focusin').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stopFocusTrap$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (e) {
            return e.target;
          })); // 'tab' / 'shift+tab' stream

          (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(element, 'keydown').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stopFocusTrap$), // tslint:disable:deprecation
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (e) {
            return e.which === Key.Tab;
          }), // tslint:enable:deprecation
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.withLatestFrom)(lastFocusedElement$)).subscribe(function (_ref15) {
            var _ref16 = _slicedToArray(_ref15, 2),
                tabEvent = _ref16[0],
                focusedElement = _ref16[1];

            var _getFocusableBoundary = getFocusableBoundaryElements(element),
                _getFocusableBoundary2 = _slicedToArray(_getFocusableBoundary, 2),
                first = _getFocusableBoundary2[0],
                last = _getFocusableBoundary2[1];

            if ((focusedElement === first || focusedElement === element) && tabEvent.shiftKey) {
              last.focus();
              tabEvent.preventDefault();
            }

            if (focusedElement === last && !tabEvent.shiftKey) {
              first.focus();
              tabEvent.preventDefault();
            }
          }); // inside click

          if (refocusOnClick) {
            (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(element, 'click').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(stopFocusTrap$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.withLatestFrom)(lastFocusedElement$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (arr) {
              return arr[1];
            })).subscribe(function (lastFocusedElement) {
              return lastFocusedElement.focus();
            });
          }
        });
      }; // previous version:
      // https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js


      var Positioning = /*#__PURE__*/function () {
        function Positioning() {
          _classCallCheck(this, Positioning);
        }

        _createClass(Positioning, [{
          key: "getAllStyles",
          value: function getAllStyles(element) {
            return window.getComputedStyle(element);
          }
        }, {
          key: "getStyle",
          value: function getStyle(element, prop) {
            return this.getAllStyles(element)[prop];
          }
        }, {
          key: "isStaticPositioned",
          value: function isStaticPositioned(element) {
            return (this.getStyle(element, 'position') || 'static') === 'static';
          }
        }, {
          key: "offsetParent",
          value: function offsetParent(element) {
            var offsetParentEl = element.offsetParent || document.documentElement;

            while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {
              offsetParentEl = offsetParentEl.offsetParent;
            }

            return offsetParentEl || document.documentElement;
          }
        }, {
          key: "position",
          value: function position(element) {
            var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var elPosition;
            var parentOffset = {
              width: 0,
              height: 0,
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            };

            if (this.getStyle(element, 'position') === 'fixed') {
              elPosition = element.getBoundingClientRect();
              elPosition = {
                top: elPosition.top,
                bottom: elPosition.bottom,
                left: elPosition.left,
                right: elPosition.right,
                height: elPosition.height,
                width: elPosition.width
              };
            } else {
              var offsetParentEl = this.offsetParent(element);
              elPosition = this.offset(element, false);

              if (offsetParentEl !== document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
              }

              parentOffset.top += offsetParentEl.clientTop;
              parentOffset.left += offsetParentEl.clientLeft;
            }

            elPosition.top -= parentOffset.top;
            elPosition.bottom -= parentOffset.top;
            elPosition.left -= parentOffset.left;
            elPosition.right -= parentOffset.left;

            if (round) {
              elPosition.top = Math.round(elPosition.top);
              elPosition.bottom = Math.round(elPosition.bottom);
              elPosition.left = Math.round(elPosition.left);
              elPosition.right = Math.round(elPosition.right);
            }

            return elPosition;
          }
        }, {
          key: "offset",
          value: function offset(element) {
            var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var elBcr = element.getBoundingClientRect();
            var viewportOffset = {
              top: window.pageYOffset - document.documentElement.clientTop,
              left: window.pageXOffset - document.documentElement.clientLeft
            };
            var elOffset = {
              height: elBcr.height || element.offsetHeight,
              width: elBcr.width || element.offsetWidth,
              top: elBcr.top + viewportOffset.top,
              bottom: elBcr.bottom + viewportOffset.top,
              left: elBcr.left + viewportOffset.left,
              right: elBcr.right + viewportOffset.left
            };

            if (round) {
              elOffset.height = Math.round(elOffset.height);
              elOffset.width = Math.round(elOffset.width);
              elOffset.top = Math.round(elOffset.top);
              elOffset.bottom = Math.round(elOffset.bottom);
              elOffset.left = Math.round(elOffset.left);
              elOffset.right = Math.round(elOffset.right);
            }

            return elOffset;
          }
          /*
            Return false if the element to position is outside the viewport
          */

        }, {
          key: "positionElements",
          value: function positionElements(hostElement, targetElement, placement, appendToBody) {
            var _placement$split = placement.split('-'),
                _placement$split2 = _slicedToArray(_placement$split, 2),
                _placement$split2$ = _placement$split2[0],
                placementPrimary = _placement$split2$ === void 0 ? 'top' : _placement$split2$,
                _placement$split2$2 = _placement$split2[1],
                placementSecondary = _placement$split2$2 === void 0 ? 'center' : _placement$split2$2;

            var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);
            var targetElStyles = this.getAllStyles(targetElement);
            var marginTop = parseFloat(targetElStyles.marginTop);
            var marginBottom = parseFloat(targetElStyles.marginBottom);
            var marginLeft = parseFloat(targetElStyles.marginLeft);
            var marginRight = parseFloat(targetElStyles.marginRight);
            var topPosition = 0;
            var leftPosition = 0;

            switch (placementPrimary) {
              case 'top':
                topPosition = hostElPosition.top - (targetElement.offsetHeight + marginTop + marginBottom);
                break;

              case 'bottom':
                topPosition = hostElPosition.top + hostElPosition.height;
                break;

              case 'left':
                leftPosition = hostElPosition.left - (targetElement.offsetWidth + marginLeft + marginRight);
                break;

              case 'right':
                leftPosition = hostElPosition.left + hostElPosition.width;
                break;
            }

            switch (placementSecondary) {
              case 'top':
                topPosition = hostElPosition.top;
                break;

              case 'bottom':
                topPosition = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
                break;

              case 'left':
                leftPosition = hostElPosition.left;
                break;

              case 'right':
                leftPosition = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
                break;

              case 'center':
                if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                  leftPosition = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
                } else {
                  topPosition = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
                }

                break;
            } /// The translate3d/gpu acceleration render a blurry text on chrome, the next line is commented until a browser fix
            // targetElement.style.transform = `translate3d(${Math.round(leftPosition)}px, ${Math.floor(topPosition)}px, 0px)`;


            targetElement.style.transform = "translate(".concat(Math.round(leftPosition), "px, ").concat(Math.round(topPosition), "px)"); // Check if the targetElement is inside the viewport

            var targetElBCR = targetElement.getBoundingClientRect();
            var html = document.documentElement;
            var windowHeight = window.innerHeight || html.clientHeight;
            var windowWidth = window.innerWidth || html.clientWidth;
            return targetElBCR.left >= 0 && targetElBCR.top >= 0 && targetElBCR.right <= windowWidth && targetElBCR.bottom <= windowHeight;
          }
        }]);

        return Positioning;
      }();

      var placementSeparator = /\s+/;
      var positionService = new Positioning();
      /*
       * Accept the placement array and applies the appropriate placement dependent on the viewport.
       * Returns the applied placement.
       * In case of auto placement, placements are selected in order
       *   'top', 'bottom', 'left', 'right',
       *   'top-left', 'top-right',
       *   'bottom-left', 'bottom-right',
       *   'left-top', 'left-bottom',
       *   'right-top', 'right-bottom'.
       * */

      function positionElements(hostElement, targetElement, placement, appendToBody, baseClass) {
        var placementVals = Array.isArray(placement) ? placement : placement.split(placementSeparator);
        var allowedPlacements = ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top', 'left-bottom', 'right-top', 'right-bottom'];
        var classList = targetElement.classList;

        var addClassesToTarget = function addClassesToTarget(targetPlacement) {
          var _targetPlacement$spli = targetPlacement.split('-'),
              _targetPlacement$spli2 = _slicedToArray(_targetPlacement$spli, 2),
              primary = _targetPlacement$spli2[0],
              secondary = _targetPlacement$spli2[1];

          var classes = [];

          if (baseClass) {
            classes.push("".concat(baseClass, "-").concat(primary));

            if (secondary) {
              classes.push("".concat(baseClass, "-").concat(primary, "-").concat(secondary));
            }

            classes.forEach(function (classname) {
              classList.add(classname);
            });
          }

          return classes;
        }; // Remove old placement classes to avoid issues


        if (baseClass) {
          allowedPlacements.forEach(function (placementToRemove) {
            classList.remove("".concat(baseClass, "-").concat(placementToRemove));
          });
        } // replace auto placement with other placements


        var hasAuto = placementVals.findIndex(function (val) {
          return val === 'auto';
        });

        if (hasAuto >= 0) {
          allowedPlacements.forEach(function (obj) {
            if (placementVals.find(function (val) {
              return val.search('^' + obj) !== -1;
            }) == null) {
              placementVals.splice(hasAuto++, 1, obj);
            }
          });
        } // coordinates where to position
        // Required for transform:


        var style = targetElement.style;
        style.position = 'absolute';
        style.top = '0';
        style.left = '0';
        style['will-change'] = 'transform';
        var testPlacement = null;
        var isInViewport = false;

        var _iterator3 = _createForOfIteratorHelper(placementVals),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            testPlacement = _step3.value;
            var addedClasses = addClassesToTarget(testPlacement);

            if (positionService.positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
              isInViewport = true;
              break;
            } // Remove the baseClasses for further calculation


            if (baseClass) {
              addedClasses.forEach(function (classname) {
                classList.remove(classname);
              });
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        if (!isInViewport) {
          // If nothing match, the first placement is the default one
          testPlacement = placementVals[0];
          addClassesToTarget(testPlacement);
          positionService.positionElements(hostElement, targetElement, testPlacement, appendToBody);
        }

        return testPlacement;
      }

      function NGB_DATEPICKER_PARSER_FORMATTER_FACTORY() {
        return new NgbDateISOParserFormatter();
      }
      /**
       * An abstract service for parsing and formatting dates for the
       * [`NgbInputDatepicker`](#/components/datepicker/api#NgbInputDatepicker) directive.
       * Converts between the internal `NgbDateStruct` model presentation and a `string` that is displayed in the
       * input element.
       *
       * When user types something in the input this service attempts to parse it into a `NgbDateStruct` object.
       * And vice versa, when users selects a date in the calendar with the mouse, it must be displayed as a `string`
       * in the input.
       *
       * Default implementation uses the ISO 8601 format, but you can provide another implementation via DI
       * to use an alternative string format or a custom parsing logic.
       *
       * See the [date format overview](#/components/datepicker/overview#date-model) for more details.
       */


      var _NgbDateParserFormatter = /*#__PURE__*/function () {
        var NgbDateParserFormatter = function NgbDateParserFormatter() {
          _classCallCheck(this, NgbDateParserFormatter);
        };

        NgbDateParserFormatter.ɵfac = function NgbDateParserFormatter_Factory(t) {
          return new (t || NgbDateParserFormatter)();
        };

        NgbDateParserFormatter.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: NGB_DATEPICKER_PARSER_FORMATTER_FACTORY,
          token: NgbDateParserFormatter,
          providedIn: "root"
        });
        return NgbDateParserFormatter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDateISOParserFormatter = /*#__PURE__*/function () {
        var NgbDateISOParserFormatter = /*#__PURE__*/function (_NgbDateParserFormatt) {
          _inherits(NgbDateISOParserFormatter, _NgbDateParserFormatt);

          var _super4 = _createSuper(NgbDateISOParserFormatter);

          function NgbDateISOParserFormatter() {
            _classCallCheck(this, NgbDateISOParserFormatter);

            return _super4.apply(this, arguments);
          }

          _createClass(NgbDateISOParserFormatter, [{
            key: "parse",
            value: function parse(value) {
              if (value != null) {
                var dateParts = value.trim().split('-');

                if (dateParts.length === 1 && isNumber(dateParts[0])) {
                  return {
                    year: toInteger(dateParts[0]),
                    month: null,
                    day: null
                  };
                } else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {
                  return {
                    year: toInteger(dateParts[0]),
                    month: toInteger(dateParts[1]),
                    day: null
                  };
                } else if (dateParts.length === 3 && isNumber(dateParts[0]) && isNumber(dateParts[1]) && isNumber(dateParts[2])) {
                  return {
                    year: toInteger(dateParts[0]),
                    month: toInteger(dateParts[1]),
                    day: toInteger(dateParts[2])
                  };
                }
              }

              return null;
            }
          }, {
            key: "format",
            value: function format(date) {
              return date ? "".concat(date.year, "-").concat(isNumber(date.month) ? padNumber(date.month) : '', "-").concat(isNumber(date.day) ? padNumber(date.day) : '') : '';
            }
          }]);

          return NgbDateISOParserFormatter;
        }(_NgbDateParserFormatter);

        NgbDateISOParserFormatter.ɵfac = /*@__PURE__*/function () {
          var ɵNgbDateISOParserFormatter_BaseFactory;
          return function NgbDateISOParserFormatter_Factory(t) {
            return (ɵNgbDateISOParserFormatter_BaseFactory || (ɵNgbDateISOParserFormatter_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbDateISOParserFormatter)))(t || NgbDateISOParserFormatter);
          };
        }();

        NgbDateISOParserFormatter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDateISOParserFormatter,
          factory: NgbDateISOParserFormatter.ɵfac
        });
        return NgbDateISOParserFormatter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A configuration service for the [`NgbDatepickerInput`](#/components/datepicker/api#NgbDatepicker) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the datepicker inputs used in the application.
       *
       * @since 5.2.0
       */


      var _NgbInputDatepickerConfig = /*#__PURE__*/function () {
        var NgbInputDatepickerConfig = /*#__PURE__*/function (_NgbDatepickerConfig2) {
          _inherits(NgbInputDatepickerConfig, _NgbDatepickerConfig2);

          var _super5 = _createSuper(NgbInputDatepickerConfig);

          function NgbInputDatepickerConfig() {
            var _this18;

            _classCallCheck(this, NgbInputDatepickerConfig);

            _this18 = _super5.apply(this, arguments);
            _this18.autoClose = true;
            _this18.placement = ['bottom-left', 'bottom-right', 'top-left', 'top-right'];
            _this18.restoreFocus = true;
            return _this18;
          }

          return NgbInputDatepickerConfig;
        }(_NgbDatepickerConfig);

        NgbInputDatepickerConfig.ɵfac = /*@__PURE__*/function () {
          var ɵNgbInputDatepickerConfig_BaseFactory;
          return function NgbInputDatepickerConfig_Factory(t) {
            return (ɵNgbInputDatepickerConfig_BaseFactory || (ɵNgbInputDatepickerConfig_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbInputDatepickerConfig)))(t || NgbInputDatepickerConfig);
          };
        }();

        NgbInputDatepickerConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbInputDatepickerConfig_Factory() {
            return new NgbInputDatepickerConfig();
          },
          token: NgbInputDatepickerConfig,
          providedIn: "root"
        });
        return NgbInputDatepickerConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that allows to stick a datepicker popup to an input field.
       *
       * Manages interaction with the input field itself, does value formatting and provides forms integration.
       */


      var _NgbInputDatepicker = /*#__PURE__*/function () {
        var NgbInputDatepicker = /*#__PURE__*/function () {
          function NgbInputDatepicker(_parserFormatter, _elRef, _vcRef, _renderer, _cfr, _ngZone, _calendar, _dateAdapter, _document, _changeDetector, config) {
            var _this19 = this;

            _classCallCheck(this, NgbInputDatepicker);

            this._parserFormatter = _parserFormatter;
            this._elRef = _elRef;
            this._vcRef = _vcRef;
            this._renderer = _renderer;
            this._cfr = _cfr;
            this._ngZone = _ngZone;
            this._calendar = _calendar;
            this._dateAdapter = _dateAdapter;
            this._document = _document;
            this._changeDetector = _changeDetector;
            this._cRef = null;
            this._disabled = false;
            this._elWithFocus = null;
            this._model = null;
            /**
             * An event emitted when user selects a date using keyboard or mouse.
             *
             * The payload of the event is currently selected `NgbDate`.
             *
             * @since 1.1.1
             */

            this.dateSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * Event emitted right after the navigation happens and displayed month changes.
             *
             * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.
             */

            this.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event fired after closing datepicker window.
             *
             * @since 4.2.0
             */

            this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();

            this._onChange = function (_) {};

            this._onTouched = function () {};

            this._validatorChange = function () {};

            ['autoClose', 'container', 'positionTarget', 'placement'].forEach(function (input) {
              return _this19[input] = config[input];
            });
            this._zoneSubscription = _ngZone.onStable.subscribe(function () {
              return _this19._updatePopupPosition();
            });
          }
          /**
           * If `true`, weekdays will be displayed.
           *
           * @deprecated 9.1.0, please use 'weekdays' instead
           */


          _createClass(NgbInputDatepicker, [{
            key: "showWeekdays",
            get: function get() {
              return this._showWeekdays;
            },
            set: function set(weekdays) {
              this.weekdays = weekdays;
              this._showWeekdays = weekdays;
            }
          }, {
            key: "disabled",
            get: function get() {
              return this._disabled;
            },
            set: function set(value) {
              this._disabled = value === '' || value && value !== 'false';

              if (this.isOpen()) {
                this._cRef.instance.setDisabledState(this._disabled);
              }
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this._onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this._onTouched = fn;
            }
          }, {
            key: "registerOnValidatorChange",
            value: function registerOnValidatorChange(fn) {
              this._validatorChange = fn;
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this.disabled = isDisabled;
            }
          }, {
            key: "validate",
            value: function validate(c) {
              var value = c.value;

              if (value != null) {
                var ngbDate = this._fromDateStruct(this._dateAdapter.fromModel(value));

                if (!ngbDate) {
                  return {
                    'ngbDate': {
                      invalid: value
                    }
                  };
                }

                if (this.minDate && ngbDate.before(_NgbDate.from(this.minDate))) {
                  return {
                    'ngbDate': {
                      minDate: {
                        minDate: this.minDate,
                        actual: value
                      }
                    }
                  };
                }

                if (this.maxDate && ngbDate.after(_NgbDate.from(this.maxDate))) {
                  return {
                    'ngbDate': {
                      maxDate: {
                        maxDate: this.maxDate,
                        actual: value
                      }
                    }
                  };
                }
              }

              return null;
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this._model = this._fromDateStruct(this._dateAdapter.fromModel(value));

              this._writeModelValue(this._model);
            }
          }, {
            key: "manualDateChange",
            value: function manualDateChange(value) {
              var updateView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var inputValueChanged = value !== this._inputValue;

              if (inputValueChanged) {
                this._inputValue = value;
                this._model = this._fromDateStruct(this._parserFormatter.parse(value));
              }

              if (inputValueChanged || !updateView) {
                this._onChange(this._model ? this._dateAdapter.toModel(this._model) : value === '' ? null : value);
              }

              if (updateView && this._model) {
                this._writeModelValue(this._model);
              }
            }
          }, {
            key: "isOpen",
            value: function isOpen() {
              return !!this._cRef;
            }
            /**
             * Opens the datepicker popup.
             *
             * If the related form control contains a valid date, the corresponding month will be opened.
             */

          }, {
            key: "open",
            value: function open() {
              var _this20 = this;

              if (!this.isOpen()) {
                var cf = this._cfr.resolveComponentFactory(_NgbDatepicker);

                this._cRef = this._vcRef.createComponent(cf);

                this._applyPopupStyling(this._cRef.location.nativeElement);

                this._applyDatepickerInputs(this._cRef.instance);

                this._subscribeForDatepickerOutputs(this._cRef.instance);

                this._cRef.instance.ngOnInit();

                this._cRef.instance.writeValue(this._dateAdapter.toModel(this._model)); // date selection event handling


                this._cRef.instance.registerOnChange(function (selectedDate) {
                  _this20.writeValue(selectedDate);

                  _this20._onChange(selectedDate);

                  _this20._onTouched();
                });

                this._cRef.changeDetectorRef.detectChanges();

                this._cRef.instance.setDisabledState(this.disabled);

                if (this.container === 'body') {
                  this._document.querySelector(this.container).appendChild(this._cRef.location.nativeElement);
                } // focus handling


                this._elWithFocus = this._document.activeElement;
                ngbFocusTrap(this._ngZone, this._cRef.location.nativeElement, this.closed, true);

                this._cRef.instance.focus();

                ngbAutoClose(this._ngZone, this._document, this.autoClose, function () {
                  return _this20.close();
                }, this.closed, [], [this._elRef.nativeElement, this._cRef.location.nativeElement]);
              }
            }
            /**
             * Closes the datepicker popup.
             */

          }, {
            key: "close",
            value: function close() {
              if (this.isOpen()) {
                this._vcRef.remove(this._vcRef.indexOf(this._cRef.hostView));

                this._cRef = null;
                this.closed.emit();

                this._changeDetector.markForCheck(); // restore focus


                var elementToFocus = this._elWithFocus;

                if (isString(this.restoreFocus)) {
                  elementToFocus = this._document.querySelector(this.restoreFocus);
                } else if (this.restoreFocus !== undefined) {
                  elementToFocus = this.restoreFocus;
                } // in IE document.activeElement can contain an object without 'focus()' sometimes


                if (elementToFocus && elementToFocus['focus']) {
                  elementToFocus.focus();
                } else {
                  this._document.body.focus();
                }
              }
            }
            /**
             * Toggles the datepicker popup.
             */

          }, {
            key: "toggle",
            value: function toggle() {
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            }
            /**
             * Navigates to the provided date.
             *
             * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.
             * If nothing or invalid date provided calendar will open current month.
             *
             * Use the `[startDate]` input as an alternative.
             */

          }, {
            key: "navigateTo",
            value: function navigateTo(date) {
              if (this.isOpen()) {
                this._cRef.instance.navigateTo(date);
              }
            }
          }, {
            key: "onBlur",
            value: function onBlur() {
              this._onTouched();
            }
          }, {
            key: "onFocus",
            value: function onFocus() {
              this._elWithFocus = this._elRef.nativeElement;
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              if (changes['minDate'] || changes['maxDate']) {
                this._validatorChange();

                if (this.isOpen()) {
                  if (changes['minDate']) {
                    this._cRef.instance.minDate = this.minDate;
                  }

                  if (changes['maxDate']) {
                    this._cRef.instance.maxDate = this.maxDate;
                  }

                  this._cRef.instance.ngOnChanges(changes);
                }
              }

              if (changes['datepickerClass']) {
                var _changes$datepickerCl = changes['datepickerClass'],
                    currentValue = _changes$datepickerCl.currentValue,
                    previousValue = _changes$datepickerCl.previousValue;

                this._applyPopupClass(currentValue, previousValue);
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.close();

              this._zoneSubscription.unsubscribe();
            }
          }, {
            key: "_applyDatepickerInputs",
            value: function _applyDatepickerInputs(datepickerInstance) {
              var _this21 = this;

              ['dayTemplate', 'dayTemplateData', 'displayMonths', 'firstDayOfWeek', 'footerTemplate', 'markDisabled', 'minDate', 'maxDate', 'navigation', 'outsideDays', 'showNavigation', 'showWeekNumbers', 'weekdays'].forEach(function (optionName) {
                if (_this21[optionName] !== undefined) {
                  datepickerInstance[optionName] = _this21[optionName];
                }
              });
              datepickerInstance.startDate = this.startDate || this._model;
            }
          }, {
            key: "_applyPopupClass",
            value: function _applyPopupClass(newClass, oldClass) {
              var _a;

              var popupEl = (_a = this._cRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement;

              if (popupEl) {
                if (newClass) {
                  this._renderer.addClass(popupEl, newClass);
                }

                if (oldClass) {
                  this._renderer.removeClass(popupEl, oldClass);
                }
              }
            }
          }, {
            key: "_applyPopupStyling",
            value: function _applyPopupStyling(nativeElement) {
              this._renderer.addClass(nativeElement, 'dropdown-menu');

              this._renderer.addClass(nativeElement, 'show');

              if (this.container === 'body') {
                this._renderer.addClass(nativeElement, 'ngb-dp-body');
              }

              this._applyPopupClass(this.datepickerClass);
            }
          }, {
            key: "_subscribeForDatepickerOutputs",
            value: function _subscribeForDatepickerOutputs(datepickerInstance) {
              var _this22 = this;

              datepickerInstance.navigate.subscribe(function (navigateEvent) {
                return _this22.navigate.emit(navigateEvent);
              });
              datepickerInstance.dateSelect.subscribe(function (date) {
                _this22.dateSelect.emit(date);

                if (_this22.autoClose === true || _this22.autoClose === 'inside') {
                  _this22.close();
                }
              });
            }
          }, {
            key: "_writeModelValue",
            value: function _writeModelValue(model) {
              var value = this._parserFormatter.format(model);

              this._inputValue = value;

              this._renderer.setProperty(this._elRef.nativeElement, 'value', value);

              if (this.isOpen()) {
                this._cRef.instance.writeValue(this._dateAdapter.toModel(model));

                this._onTouched();
              }
            }
          }, {
            key: "_fromDateStruct",
            value: function _fromDateStruct(date) {
              var ngbDate = date ? new _NgbDate(date.year, date.month, date.day) : null;
              return this._calendar.isValid(ngbDate) ? ngbDate : null;
            }
          }, {
            key: "_updatePopupPosition",
            value: function _updatePopupPosition() {
              if (!this._cRef) {
                return;
              }

              var hostElement;

              if (isString(this.positionTarget)) {
                hostElement = this._document.querySelector(this.positionTarget);
              } else if (this.positionTarget instanceof HTMLElement) {
                hostElement = this.positionTarget;
              } else {
                hostElement = this._elRef.nativeElement;
              }

              if (this.positionTarget && !hostElement) {
                throw new Error('ngbDatepicker could not find element declared in [positionTarget] to position against.');
              }

              positionElements(hostElement, this._cRef.location.nativeElement, this.placement, this.container === 'body');
            }
          }]);

          return NgbInputDatepicker;
        }();

        NgbInputDatepicker.ɵfac = function NgbInputDatepicker_Factory(t) {
          return new (t || NgbInputDatepicker)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDateParserFormatter), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbCalendar), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDateAdapter), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbInputDatepickerConfig));
        };

        NgbInputDatepicker.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbInputDatepicker,
          selectors: [["input", "ngbDatepicker", ""]],
          hostVars: 1,
          hostBindings: function NgbInputDatepicker_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("input", function NgbInputDatepicker_input_HostBindingHandler($event) {
                return ctx.manualDateChange($event.target.value);
              })("change", function NgbInputDatepicker_change_HostBindingHandler($event) {
                return ctx.manualDateChange($event.target.value, true);
              })("focus", function NgbInputDatepicker_focus_HostBindingHandler() {
                return ctx.onFocus();
              })("blur", function NgbInputDatepicker_blur_HostBindingHandler() {
                return ctx.onBlur();
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("disabled", ctx.disabled);
            }
          },
          inputs: {
            showWeekdays: "showWeekdays",
            weekdays: "weekdays",
            disabled: "disabled",
            autoClose: "autoClose",
            datepickerClass: "datepickerClass",
            dayTemplate: "dayTemplate",
            dayTemplateData: "dayTemplateData",
            displayMonths: "displayMonths",
            firstDayOfWeek: "firstDayOfWeek",
            footerTemplate: "footerTemplate",
            markDisabled: "markDisabled",
            minDate: "minDate",
            maxDate: "maxDate",
            navigation: "navigation",
            outsideDays: "outsideDays",
            placement: "placement",
            restoreFocus: "restoreFocus",
            showWeekNumbers: "showWeekNumbers",
            startDate: "startDate",
            container: "container",
            positionTarget: "positionTarget"
          },
          outputs: {
            dateSelect: "dateSelect",
            navigate: "navigate",
            closed: "closed"
          },
          exportAs: ["ngbDatepicker"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbInputDatepicker;
            }),
            multi: true
          }, {
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALIDATORS,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbInputDatepicker;
            }),
            multi: true
          }, {
            provide: _NgbDatepickerConfig,
            useExisting: _NgbInputDatepickerConfig
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbInputDatepicker;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDatepickerDayView = /*#__PURE__*/function () {
        var NgbDatepickerDayView = /*#__PURE__*/function () {
          function NgbDatepickerDayView(i18n) {
            _classCallCheck(this, NgbDatepickerDayView);

            this.i18n = i18n;
          }

          _createClass(NgbDatepickerDayView, [{
            key: "isMuted",
            value: function isMuted() {
              return !this.selected && (this.date.month !== this.currentMonth || this.disabled);
            }
          }]);

          return NgbDatepickerDayView;
        }();

        NgbDatepickerDayView.ɵfac = function NgbDatepickerDayView_Factory(t) {
          return new (t || NgbDatepickerDayView)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerI18n));
        };

        NgbDatepickerDayView.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbDatepickerDayView,
          selectors: [["", "ngbDatepickerDayView", ""]],
          hostAttrs: [1, "btn-light"],
          hostVars: 10,
          hostBindings: function NgbDatepickerDayView_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("bg-primary", ctx.selected)("text-white", ctx.selected)("text-muted", ctx.isMuted())("outside", ctx.isMuted())("active", ctx.focused);
            }
          },
          inputs: {
            currentMonth: "currentMonth",
            date: "date",
            disabled: "disabled",
            focused: "focused",
            selected: "selected"
          },
          attrs: _c20,
          decls: 1,
          vars: 1,
          template: function NgbDatepickerDayView_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](0);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.i18n.getDayNumerals(ctx.date));
            }
          },
          styles: ["[ngbDatepickerDayView]{background:transparent;border-radius:.25rem;height:2rem;line-height:2rem;text-align:center;width:2rem}[ngbDatepickerDayView].outside{opacity:.5}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbDatepickerDayView;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbDatepickerNavigationSelect = /*#__PURE__*/function () {
        var NgbDatepickerNavigationSelect = /*#__PURE__*/function () {
          function NgbDatepickerNavigationSelect(i18n, _renderer) {
            _classCallCheck(this, NgbDatepickerNavigationSelect);

            this.i18n = i18n;
            this._renderer = _renderer;
            this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this._month = -1;
            this._year = -1;
          }

          _createClass(NgbDatepickerNavigationSelect, [{
            key: "changeMonth",
            value: function changeMonth(month) {
              this.select.emit(new _NgbDate(this.date.year, toInteger(month), 1));
            }
          }, {
            key: "changeYear",
            value: function changeYear(year) {
              this.select.emit(new _NgbDate(toInteger(year), this.date.month, 1));
            }
          }, {
            key: "ngAfterViewChecked",
            value: function ngAfterViewChecked() {
              if (this.date) {
                if (this.date.month !== this._month) {
                  this._month = this.date.month;

                  this._renderer.setProperty(this.monthSelect.nativeElement, 'value', this._month);
                }

                if (this.date.year !== this._year) {
                  this._year = this.date.year;

                  this._renderer.setProperty(this.yearSelect.nativeElement, 'value', this._year);
                }
              }
            }
          }]);

          return NgbDatepickerNavigationSelect;
        }();

        NgbDatepickerNavigationSelect.ɵfac = function NgbDatepickerNavigationSelect_Factory(t) {
          return new (t || NgbDatepickerNavigationSelect)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDatepickerI18n), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2));
        };

        NgbDatepickerNavigationSelect.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbDatepickerNavigationSelect,
          selectors: [["ngb-datepicker-navigation-select"]],
          viewQuery: function NgbDatepickerNavigationSelect_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c21, 7, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c22, 7, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.monthSelect = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.yearSelect = _t.first);
            }
          },
          inputs: {
            date: "date",
            disabled: "disabled",
            months: "months",
            years: "years"
          },
          outputs: {
            select: "select"
          },
          decls: 6,
          vars: 4,
          consts: function consts() {
            var i18n_23;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_select_month$$FESM2015_NG_BOOTSTRAP_JS_24 = goog.getMsg("Select month");
              i18n_23 = MSG_EXTERNAL_ngb_datepicker_select_month$$FESM2015_NG_BOOTSTRAP_JS_24;
            } else {
              i18n_23 = $localize(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([":@@ngb.datepicker.select-month\u241F1dbc84807f35518112f62e5775d1daebd3d8462b\u241F2253869508135064750:Select month"])));
            }

            var i18n_25;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_select_month$$FESM2015_NG_BOOTSTRAP_JS_26 = goog.getMsg("Select month");
              i18n_25 = MSG_EXTERNAL_ngb_datepicker_select_month$$FESM2015_NG_BOOTSTRAP_JS_26;
            } else {
              i18n_25 = $localize(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([":@@ngb.datepicker.select-month\u241F1dbc84807f35518112f62e5775d1daebd3d8462b\u241F2253869508135064750:Select month"])));
            }

            var i18n_27;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_select_year$$FESM2015_NG_BOOTSTRAP_JS_28 = goog.getMsg("Select year");
              i18n_27 = MSG_EXTERNAL_ngb_datepicker_select_year$$FESM2015_NG_BOOTSTRAP_JS_28;
            } else {
              i18n_27 = $localize(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([":@@ngb.datepicker.select-year\u241F8ceb09d002bf0c5d1cac171dfbffe1805d2b3962\u241F8852264961585484321:Select year"])));
            }

            var i18n_29;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_datepicker_select_year$$FESM2015_NG_BOOTSTRAP_JS_30 = goog.getMsg("Select year");
              i18n_29 = MSG_EXTERNAL_ngb_datepicker_select_year$$FESM2015_NG_BOOTSTRAP_JS_30;
            } else {
              i18n_29 = $localize(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([":@@ngb.datepicker.select-year\u241F8ceb09d002bf0c5d1cac171dfbffe1805d2b3962\u241F8852264961585484321:Select year"])));
            }

            return [["aria-label", i18n_23, "title", i18n_25, 1, "custom-select", 3, "disabled", "change"], ["month", ""], [3, "value", 4, "ngFor", "ngForOf"], ["aria-label", i18n_27, "title", i18n_29, 1, "custom-select", 3, "disabled", "change"], ["year", ""], [3, "value"]];
          },
          template: function NgbDatepickerNavigationSelect_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "select", 0, 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbDatepickerNavigationSelect_Template_select_change_0_listener($event) {
                return ctx.changeMonth($event.target.value);
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbDatepickerNavigationSelect_option_2_Template, 2, 3, "option", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "select", 3, 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbDatepickerNavigationSelect_Template_select_change_3_listener($event) {
                return ctx.changeYear($event.target.value);
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, NgbDatepickerNavigationSelect_option_5_Template, 2, 2, "option", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.months);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.years);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NgSelectOption, _angular_forms__WEBPACK_IMPORTED_MODULE_4__["ɵNgSelectMultipleOption"]],
          styles: ["ngb-datepicker-navigation-select>.custom-select{flex:1 1 auto;font-size:.875rem;height:1.85rem;padding:0 .5rem}ngb-datepicker-navigation-select>.custom-select:focus{z-index:1}ngb-datepicker-navigation-select>.custom-select::-ms-value{background-color:transparent!important}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbDatepickerNavigationSelect;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbCalendarHijri = /*#__PURE__*/function () {
        var NgbCalendarHijri = /*#__PURE__*/function (_NgbCalendar3) {
          _inherits(NgbCalendarHijri, _NgbCalendar3);

          var _super6 = _createSuper(NgbCalendarHijri);

          function NgbCalendarHijri() {
            _classCallCheck(this, NgbCalendarHijri);

            return _super6.apply(this, arguments);
          }

          _createClass(NgbCalendarHijri, [{
            key: "getDaysPerWeek",
            value: function getDaysPerWeek() {
              return 7;
            }
          }, {
            key: "getMonths",
            value: function getMonths() {
              return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            }
          }, {
            key: "getWeeksPerMonth",
            value: function getWeeksPerMonth() {
              return 6;
            }
          }, {
            key: "getNext",
            value: function getNext(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              date = new _NgbDate(date.year, date.month, date.day);

              switch (period) {
                case 'y':
                  date = this._setYear(date, date.year + number);
                  date.month = 1;
                  date.day = 1;
                  return date;

                case 'm':
                  date = this._setMonth(date, date.month + number);
                  date.day = 1;
                  return date;

                case 'd':
                  return this._setDay(date, date.day + number);

                default:
                  return date;
              }
            }
          }, {
            key: "getPrev",
            value: function getPrev(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              return this.getNext(date, period, -number);
            }
          }, {
            key: "getWeekday",
            value: function getWeekday(date) {
              var day = this.toGregorian(date).getDay(); // in JS Date Sun=0, in ISO 8601 Sun=7

              return day === 0 ? 7 : day;
            }
          }, {
            key: "getWeekNumber",
            value: function getWeekNumber(week, firstDayOfWeek) {
              // in JS Date Sun=0, in ISO 8601 Sun=7
              if (firstDayOfWeek === 7) {
                firstDayOfWeek = 0;
              }

              var thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;
              var date = week[thursdayIndex];
              var jsDate = this.toGregorian(date);
              jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday

              var time = jsDate.getTime();
              var MuhDate = this.toGregorian(new _NgbDate(date.year, 1, 1)); // Compare with Muharram 1

              return Math.floor(Math.round((time - MuhDate.getTime()) / 86400000) / 7) + 1;
            }
          }, {
            key: "getToday",
            value: function getToday() {
              return this.fromGregorian(new Date());
            }
          }, {
            key: "isValid",
            value: function isValid(date) {
              return date != null && isNumber(date.year) && isNumber(date.month) && isNumber(date.day) && !isNaN(this.toGregorian(date).getTime());
            }
          }, {
            key: "_setDay",
            value: function _setDay(date, day) {
              day = +day;
              var mDays = this.getDaysPerMonth(date.month, date.year);

              if (day <= 0) {
                while (day <= 0) {
                  date = this._setMonth(date, date.month - 1);
                  mDays = this.getDaysPerMonth(date.month, date.year);
                  day += mDays;
                }
              } else if (day > mDays) {
                while (day > mDays) {
                  day -= mDays;
                  date = this._setMonth(date, date.month + 1);
                  mDays = this.getDaysPerMonth(date.month, date.year);
                }
              }

              date.day = day;
              return date;
            }
          }, {
            key: "_setMonth",
            value: function _setMonth(date, month) {
              month = +month;
              date.year = date.year + Math.floor((month - 1) / 12);
              date.month = Math.floor(((month - 1) % 12 + 12) % 12) + 1;
              return date;
            }
          }, {
            key: "_setYear",
            value: function _setYear(date, year) {
              date.year = +year;
              return date;
            }
          }]);

          return NgbCalendarHijri;
        }(_NgbCalendar);

        NgbCalendarHijri.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarHijri_BaseFactory;
          return function NgbCalendarHijri_Factory(t) {
            return (ɵNgbCalendarHijri_BaseFactory || (ɵNgbCalendarHijri_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarHijri)))(t || NgbCalendarHijri);
          };
        }();

        NgbCalendarHijri.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarHijri,
          factory: NgbCalendarHijri.ɵfac
        });
        return NgbCalendarHijri;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Checks if islamic year is a leap year
       */


      function isIslamicLeapYear(hYear) {
        return (14 + 11 * hYear) % 30 < 11;
      }
      /**
       * Checks if gregorian years is a leap year
       */


      function isGregorianLeapYear(gDate) {
        var year = gDate.getFullYear();
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      /**
       * Returns the start of Hijri Month.
       * `hMonth` is 0 for Muharram, 1 for Safar, etc.
       * `hYear` is any Hijri hYear.
       */


      function getIslamicMonthStart(hYear, hMonth) {
        return Math.ceil(29.5 * hMonth) + (hYear - 1) * 354 + Math.floor((3 + 11 * hYear) / 30.0);
      }
      /**
       * Returns the start of Hijri year.
       * `year` is any Hijri year.
       */


      function getIslamicYearStart(year) {
        return (year - 1) * 354 + Math.floor((3 + 11 * year) / 30.0);
      }

      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      /**
       * The civil calendar is one type of Hijri calendars used in islamic countries.
       * Uses a fixed cycle of alternating 29- and 30-day months,
       * with a leap day added to the last month of 11 out of every 30 years.
       * http://cldr.unicode.org/development/development-process/design-proposals/islamic-calendar-types
       * All the calculations here are based on the equations from "Calendrical Calculations" By Edward M. Reingold, Nachum
       * Dershowitz.
       */


      var GREGORIAN_EPOCH = 1721425.5;
      var ISLAMIC_EPOCH = 1948439.5;

      var _NgbCalendarIslamicCivil = /*#__PURE__*/function () {
        var NgbCalendarIslamicCivil = /*#__PURE__*/function (_NgbCalendarHijri) {
          _inherits(NgbCalendarIslamicCivil, _NgbCalendarHijri);

          var _super7 = _createSuper(NgbCalendarIslamicCivil);

          function NgbCalendarIslamicCivil() {
            _classCallCheck(this, NgbCalendarIslamicCivil);

            return _super7.apply(this, arguments);
          }

          _createClass(NgbCalendarIslamicCivil, [{
            key: "fromGregorian",
            value:
            /**
             * Returns the equivalent islamic(civil) date value for a give input Gregorian date.
             * `gDate` is a JS Date to be converted to Hijri.
             */
            function fromGregorian(gDate) {
              var gYear = gDate.getFullYear(),
                  gMonth = gDate.getMonth(),
                  gDay = gDate.getDate();
              var julianDay = GREGORIAN_EPOCH - 1 + 365 * (gYear - 1) + Math.floor((gYear - 1) / 4) + -Math.floor((gYear - 1) / 100) + Math.floor((gYear - 1) / 400) + Math.floor((367 * (gMonth + 1) - 362) / 12 + (gMonth + 1 <= 2 ? 0 : isGregorianLeapYear(gDate) ? -1 : -2) + gDay);
              julianDay = Math.floor(julianDay) + 0.5;
              var days = julianDay - ISLAMIC_EPOCH;
              var hYear = Math.floor((30 * days + 10646) / 10631.0);
              var hMonth = Math.ceil((days - 29 - getIslamicYearStart(hYear)) / 29.5);
              hMonth = Math.min(hMonth, 11);
              var hDay = Math.ceil(days - getIslamicMonthStart(hYear, hMonth)) + 1;
              return new _NgbDate(hYear, hMonth + 1, hDay);
            }
            /**
             * Returns the equivalent JS date value for a give input islamic(civil) date.
             * `hDate` is an islamic(civil) date to be converted to Gregorian.
             */

          }, {
            key: "toGregorian",
            value: function toGregorian(hDate) {
              var hYear = hDate.year;
              var hMonth = hDate.month - 1;
              var hDay = hDate.day;
              var julianDay = hDay + Math.ceil(29.5 * hMonth) + (hYear - 1) * 354 + Math.floor((3 + 11 * hYear) / 30) + ISLAMIC_EPOCH - 1;
              var wjd = Math.floor(julianDay - 0.5) + 0.5,
                  depoch = wjd - GREGORIAN_EPOCH,
                  quadricent = Math.floor(depoch / 146097),
                  dqc = mod(depoch, 146097),
                  cent = Math.floor(dqc / 36524),
                  dcent = mod(dqc, 36524),
                  quad = Math.floor(dcent / 1461),
                  dquad = mod(dcent, 1461),
                  yindex = Math.floor(dquad / 365);
              var year = quadricent * 400 + cent * 100 + quad * 4 + yindex;

              if (!(cent === 4 || yindex === 4)) {
                year++;
              }

              var gYearStart = GREGORIAN_EPOCH + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);
              var yearday = wjd - gYearStart;
              var tjd = GREGORIAN_EPOCH - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor(739 / 12 + (isGregorianLeapYear(new Date(year, 3, 1)) ? -1 : -2) + 1);
              var leapadj = wjd < tjd ? 0 : isGregorianLeapYear(new Date(year, 3, 1)) ? 1 : 2;
              var month = Math.floor(((yearday + leapadj) * 12 + 373) / 367);
              var tjd2 = GREGORIAN_EPOCH - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor((367 * month - 362) / 12 + (month <= 2 ? 0 : isGregorianLeapYear(new Date(year, month - 1, 1)) ? -1 : -2) + 1);
              var day = wjd - tjd2 + 1;
              return new Date(year, month - 1, day);
            }
            /**
             * Returns the number of days in a specific Hijri month.
             * `month` is 1 for Muharram, 2 for Safar, etc.
             * `year` is any Hijri year.
             */

          }, {
            key: "getDaysPerMonth",
            value: function getDaysPerMonth(month, year) {
              year = year + Math.floor(month / 13);
              month = (month - 1) % 12 + 1;
              var length = 29 + month % 2;

              if (month === 12 && isIslamicLeapYear(year)) {
                length++;
              }

              return length;
            }
          }]);

          return NgbCalendarIslamicCivil;
        }(NgbCalendarHijri);

        NgbCalendarIslamicCivil.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarIslamicCivil_BaseFactory;
          return function NgbCalendarIslamicCivil_Factory(t) {
            return (ɵNgbCalendarIslamicCivil_BaseFactory || (ɵNgbCalendarIslamicCivil_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarIslamicCivil)))(t || NgbCalendarIslamicCivil);
          };
        }();

        NgbCalendarIslamicCivil.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarIslamicCivil,
          factory: NgbCalendarIslamicCivil.ɵfac
        });
        return NgbCalendarIslamicCivil;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Umalqura calendar is one type of Hijri calendars used in islamic countries.
       * This Calendar is used by Saudi Arabia for administrative purpose.
       * Unlike tabular calendars, the algorithm involves astronomical calculation, but it's still deterministic.
       * http://cldr.unicode.org/development/development-process/design-proposals/islamic-calendar-types
       */


      var GREGORIAN_FIRST_DATE = new Date(1882, 10, 12);
      var GREGORIAN_LAST_DATE = new Date(2174, 10, 25);
      var HIJRI_BEGIN = 1300;
      var HIJRI_END = 1600;
      var ONE_DAY = 1000 * 60 * 60 * 24;
      var MONTH_LENGTH = [// 1300-1304
      '101010101010', '110101010100', '111011001001', '011011010100', '011011101010', // 1305-1309
      '001101101100', '101010101101', '010101010101', '011010101001', '011110010010', // 1310-1314
      '101110101001', '010111010100', '101011011010', '010101011100', '110100101101', // 1315-1319
      '011010010101', '011101001010', '101101010100', '101101101010', '010110101101', // 1320-1324
      '010010101110', '101001001111', '010100010111', '011010001011', '011010100101', // 1325-1329
      '101011010101', '001011010110', '100101011011', '010010011101', '101001001101', // 1330-1334
      '110100100110', '110110010101', '010110101100', '100110110110', '001010111010', // 1335-1339
      '101001011011', '010100101011', '101010010101', '011011001010', '101011101001', // 1340-1344
      '001011110100', '100101110110', '001010110110', '100101010110', '101011001010', // 1345-1349
      '101110100100', '101111010010', '010111011001', '001011011100', '100101101101', // 1350-1354
      '010101001101', '101010100101', '101101010010', '101110100101', '010110110100', // 1355-1359
      '100110110110', '010101010111', '001010010111', '010101001011', '011010100011', // 1360-1364
      '011101010010', '101101100101', '010101101010', '101010101011', '010100101011', // 1365-1369
      '110010010101', '110101001010', '110110100101', '010111001010', '101011010110', // 1370-1374
      '100101010111', '010010101011', '100101001011', '101010100101', '101101010010', // 1375-1379
      '101101101010', '010101110101', '001001110110', '100010110111', '010001011011', // 1380-1384
      '010101010101', '010110101001', '010110110100', '100111011010', '010011011101', // 1385-1389
      '001001101110', '100100110110', '101010101010', '110101010100', '110110110010', // 1390-1394
      '010111010101', '001011011010', '100101011011', '010010101011', '101001010101', // 1395-1399
      '101101001001', '101101100100', '101101110001', '010110110100', '101010110101', // 1400-1404
      '101001010101', '110100100101', '111010010010', '111011001001', '011011010100', // 1405-1409
      '101011101001', '100101101011', '010010101011', '101010010011', '110101001001', // 1410-1414
      '110110100100', '110110110010', '101010111001', '010010111010', '101001011011', // 1415-1419
      '010100101011', '101010010101', '101100101010', '101101010101', '010101011100', // 1420-1424
      '010010111101', '001000111101', '100100011101', '101010010101', '101101001010', // 1425-1429
      '101101011010', '010101101101', '001010110110', '100100111011', '010010011011', // 1430-1434
      '011001010101', '011010101001', '011101010100', '101101101010', '010101101100', // 1435-1439
      '101010101101', '010101010101', '101100101001', '101110010010', '101110101001', // 1440-1444
      '010111010100', '101011011010', '010101011010', '101010101011', '010110010101', // 1445-1449
      '011101001001', '011101100100', '101110101010', '010110110101', '001010110110', // 1450-1454
      '101001010110', '111001001101', '101100100101', '101101010010', '101101101010', // 1455-1459
      '010110101101', '001010101110', '100100101111', '010010010111', '011001001011', // 1460-1464
      '011010100101', '011010101100', '101011010110', '010101011101', '010010011101', // 1465-1469
      '101001001101', '110100010110', '110110010101', '010110101010', '010110110101', // 1470-1474
      '001011011010', '100101011011', '010010101101', '010110010101', '011011001010', // 1475-1479
      '011011100100', '101011101010', '010011110101', '001010110110', '100101010110', // 1480-1484
      '101010101010', '101101010100', '101111010010', '010111011001', '001011101010', // 1485-1489
      '100101101101', '010010101101', '101010010101', '101101001010', '101110100101', // 1490-1494
      '010110110010', '100110110101', '010011010110', '101010010111', '010101000111', // 1495-1499
      '011010010011', '011101001001', '101101010101', '010101101010', '101001101011', // 1500-1504
      '010100101011', '101010001011', '110101000110', '110110100011', '010111001010', // 1505-1509
      '101011010110', '010011011011', '001001101011', '100101001011', '101010100101', // 1510-1514
      '101101010010', '101101101001', '010101110101', '000101110110', '100010110111', // 1515-1519
      '001001011011', '010100101011', '010101100101', '010110110100', '100111011010', // 1520-1524
      '010011101101', '000101101101', '100010110110', '101010100110', '110101010010', // 1525-1529
      '110110101001', '010111010100', '101011011010', '100101011011', '010010101011', // 1530-1534
      '011001010011', '011100101001', '011101100010', '101110101001', '010110110010', // 1535-1539
      '101010110101', '010101010101', '101100100101', '110110010010', '111011001001', // 1540-1544
      '011011010010', '101011101001', '010101101011', '010010101011', '101001010101', // 1545-1549
      '110100101001', '110101010100', '110110101010', '100110110101', '010010111010', // 1550-1554
      '101000111011', '010010011011', '101001001101', '101010101010', '101011010101', // 1555-1559
      '001011011010', '100101011101', '010001011110', '101000101110', '110010011010', // 1560-1564
      '110101010101', '011010110010', '011010111001', '010010111010', '101001011101', // 1565-1569
      '010100101101', '101010010101', '101101010010', '101110101000', '101110110100', // 1570-1574
      '010110111001', '001011011010', '100101011010', '101101001010', '110110100100', // 1575-1579
      '111011010001', '011011101000', '101101101010', '010101101101', '010100110101', // 1580-1584
      '011010010101', '110101001010', '110110101000', '110111010100', '011011011010', // 1585-1589
      '010101011011', '001010011101', '011000101011', '101100010101', '101101001010', // 1590-1594
      '101110010101', '010110101010', '101010101110', '100100101110', '110010001111', // 1595-1599
      '010100100111', '011010010101', '011010101010', '101011010110', '010101011101', // 1600
      '001010011101'];

      function getDaysDiff(date1, date2) {
        // Ignores the time part in date1 and date2:
        var time1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());
        var time2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());
        var diff = Math.abs(time1 - time2);
        return Math.round(diff / ONE_DAY);
      }

      var _NgbCalendarIslamicUmalqura = /*#__PURE__*/function () {
        var NgbCalendarIslamicUmalqura = /*#__PURE__*/function (_NgbCalendarIslamicCi) {
          _inherits(NgbCalendarIslamicUmalqura, _NgbCalendarIslamicCi);

          var _super8 = _createSuper(NgbCalendarIslamicUmalqura);

          function NgbCalendarIslamicUmalqura() {
            _classCallCheck(this, NgbCalendarIslamicUmalqura);

            return _super8.apply(this, arguments);
          }

          _createClass(NgbCalendarIslamicUmalqura, [{
            key: "fromGregorian",
            value:
            /**
            * Returns the equivalent islamic(Umalqura) date value for a give input Gregorian date.
            * `gdate` is s JS Date to be converted to Hijri.
            */
            function fromGregorian(gDate) {
              var hDay = 1,
                  hMonth = 0,
                  hYear = 1300;
              var daysDiff = getDaysDiff(gDate, GREGORIAN_FIRST_DATE);

              if (gDate.getTime() - GREGORIAN_FIRST_DATE.getTime() >= 0 && gDate.getTime() - GREGORIAN_LAST_DATE.getTime() <= 0) {
                var year = 1300;

                for (var i = 0; i < MONTH_LENGTH.length; i++, year++) {
                  for (var j = 0; j < 12; j++) {
                    var numOfDays = +MONTH_LENGTH[i][j] + 29;

                    if (daysDiff <= numOfDays) {
                      hDay = daysDiff + 1;

                      if (hDay > numOfDays) {
                        hDay = 1;
                        j++;
                      }

                      if (j > 11) {
                        j = 0;
                        year++;
                      }

                      hMonth = j;
                      hYear = year;
                      return new _NgbDate(hYear, hMonth + 1, hDay);
                    }

                    daysDiff = daysDiff - numOfDays;
                  }
                }

                return null;
              } else {
                return _get(_getPrototypeOf(NgbCalendarIslamicUmalqura.prototype), "fromGregorian", this).call(this, gDate);
              }
            }
            /**
            * Converts the current Hijri date to Gregorian.
            */

          }, {
            key: "toGregorian",
            value: function toGregorian(hDate) {
              var hYear = hDate.year;
              var hMonth = hDate.month - 1;
              var hDay = hDate.day;
              var gDate = new Date(GREGORIAN_FIRST_DATE);
              var dayDiff = hDay - 1;

              if (hYear >= HIJRI_BEGIN && hYear <= HIJRI_END) {
                for (var y = 0; y < hYear - HIJRI_BEGIN; y++) {
                  for (var m = 0; m < 12; m++) {
                    dayDiff += +MONTH_LENGTH[y][m] + 29;
                  }
                }

                for (var _m = 0; _m < hMonth; _m++) {
                  dayDiff += +MONTH_LENGTH[hYear - HIJRI_BEGIN][_m] + 29;
                }

                gDate.setDate(GREGORIAN_FIRST_DATE.getDate() + dayDiff);
              } else {
                gDate = _get(_getPrototypeOf(NgbCalendarIslamicUmalqura.prototype), "toGregorian", this).call(this, hDate);
              }

              return gDate;
            }
            /**
            * Returns the number of days in a specific Hijri hMonth.
            * `hMonth` is 1 for Muharram, 2 for Safar, etc.
            * `hYear` is any Hijri hYear.
            */

          }, {
            key: "getDaysPerMonth",
            value: function getDaysPerMonth(hMonth, hYear) {
              if (hYear >= HIJRI_BEGIN && hYear <= HIJRI_END) {
                var pos = hYear - HIJRI_BEGIN;
                return +MONTH_LENGTH[pos][hMonth - 1] + 29;
              }

              return _get(_getPrototypeOf(NgbCalendarIslamicUmalqura.prototype), "getDaysPerMonth", this).call(this, hMonth, hYear);
            }
          }]);

          return NgbCalendarIslamicUmalqura;
        }(_NgbCalendarIslamicCivil);

        NgbCalendarIslamicUmalqura.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarIslamicUmalqura_BaseFactory;
          return function NgbCalendarIslamicUmalqura_Factory(t) {
            return (ɵNgbCalendarIslamicUmalqura_BaseFactory || (ɵNgbCalendarIslamicUmalqura_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarIslamicUmalqura)))(t || NgbCalendarIslamicUmalqura);
          };
        }();

        NgbCalendarIslamicUmalqura.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarIslamicUmalqura,
          factory: NgbCalendarIslamicUmalqura.ɵfac
        });
        return NgbCalendarIslamicUmalqura;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Returns the equivalent JS date value for a give input Jalali date.
       * `jalaliDate` is an Jalali date to be converted to Gregorian.
       */


      function toGregorian(jalaliDate) {
        var jdn = jalaliToJulian(jalaliDate.year, jalaliDate.month, jalaliDate.day);
        var date = julianToGregorian(jdn);
        date.setHours(6, 30, 3, 200);
        return date;
      }
      /**
       * Returns the equivalent jalali date value for a give input Gregorian date.
       * `gdate` is a JS Date to be converted to jalali.
       * utc to local
       */


      function fromGregorian(gdate) {
        var g2d = gregorianToJulian(gdate.getFullYear(), gdate.getMonth() + 1, gdate.getDate());
        return julianToJalali(g2d);
      }

      function setJalaliYear(date, yearValue) {
        date.year = +yearValue;
        return date;
      }

      function setJalaliMonth(date, month) {
        month = +month;
        date.year = date.year + Math.floor((month - 1) / 12);
        date.month = Math.floor(((month - 1) % 12 + 12) % 12) + 1;
        return date;
      }

      function setJalaliDay(date, day) {
        var mDays = getDaysPerMonth(date.month, date.year);

        if (day <= 0) {
          while (day <= 0) {
            date = setJalaliMonth(date, date.month - 1);
            mDays = getDaysPerMonth(date.month, date.year);
            day += mDays;
          }
        } else if (day > mDays) {
          while (day > mDays) {
            day -= mDays;
            date = setJalaliMonth(date, date.month + 1);
            mDays = getDaysPerMonth(date.month, date.year);
          }
        }

        date.day = day;
        return date;
      }

      function mod$1(a, b) {
        return a - b * Math.floor(a / b);
      }

      function div(a, b) {
        return Math.trunc(a / b);
      }
      /*
       This function determines if the Jalali (Persian) year is
       leap (366-day long) or is the common year (365 days), and
       finds the day in March (Gregorian calendar) of the first
       day of the Jalali year (jalaliYear).
       @param jalaliYear Jalali calendar year (-61 to 3177)
       @return
       leap: number of years since the last leap year (0 to 4)
       gYear: Gregorian year of the beginning of Jalali year
       march: the March day of Farvardin the 1st (1st day of jalaliYear)
       @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
       @see: http://www.fourmilab.ch/documents/calendar/
       */


      function jalCal(jalaliYear) {
        // Jalali years starting the 33-year rule.
        var breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];
        var breaksLength = breaks.length;
        var gYear = jalaliYear + 621;
        var leapJ = -14;
        var jp = breaks[0];

        if (jalaliYear < jp || jalaliYear >= breaks[breaksLength - 1]) {
          throw new Error('Invalid Jalali year ' + jalaliYear);
        } // Find the limiting years for the Jalali year jalaliYear.


        var jump;

        for (var i = 1; i < breaksLength; i += 1) {
          var jm = breaks[i];
          jump = jm - jp;

          if (jalaliYear < jm) {
            break;
          }

          leapJ = leapJ + div(jump, 33) * 8 + div(mod$1(jump, 33), 4);
          jp = jm;
        }

        var n = jalaliYear - jp; // Find the number of leap years from AD 621 to the beginning
        // of the current Jalali year in the Persian calendar.

        leapJ = leapJ + div(n, 33) * 8 + div(mod$1(n, 33) + 3, 4);

        if (mod$1(jump, 33) === 4 && jump - n === 4) {
          leapJ += 1;
        } // And the same in the Gregorian calendar (until the year gYear).


        var leapG = div(gYear, 4) - div((div(gYear, 100) + 1) * 3, 4) - 150; // Determine the Gregorian date of Farvardin the 1st.

        var march = 20 + leapJ - leapG; // Find how many years have passed since the last leap year.

        if (jump - n < 6) {
          n = n - jump + div(jump + 4, 33) * 33;
        }

        var leap = mod$1(mod$1(n + 1, 33) - 1, 4);

        if (leap === -1) {
          leap = 4;
        }

        return {
          leap: leap,
          gy: gYear,
          march: march
        };
      }
      /*
       Calculates Gregorian and Julian calendar dates from the Julian Day number
       (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
       calendars) to some millions years ahead of the present.
       @param jdn Julian Day number
       @return
       gYear: Calendar year (years BC numbered 0, -1, -2, ...)
       gMonth: Calendar month (1 to 12)
       gDay: Calendar day of the month M (1 to 28/29/30/31)
       */


      function julianToGregorian(julianDayNumber) {
        var j = 4 * julianDayNumber + 139361631;
        j = j + div(div(4 * julianDayNumber + 183187720, 146097) * 3, 4) * 4 - 3908;
        var i = div(mod$1(j, 1461), 4) * 5 + 308;
        var gDay = div(mod$1(i, 153), 5) + 1;
        var gMonth = mod$1(div(i, 153), 12) + 1;
        var gYear = div(j, 1461) - 100100 + div(8 - gMonth, 6);
        return new Date(gYear, gMonth - 1, gDay);
      }
      /*
       Converts a date of the Jalali calendar to the Julian Day number.
       @param jy Jalali year (1 to 3100)
       @param jm Jalali month (1 to 12)
       @param jd Jalali day (1 to 29/31)
       @return Julian Day number
       */


      function gregorianToJulian(gy, gm, gd) {
        var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod$1(gm + 9, 12) + 2, 5) + gd - 34840408;
        d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
        return d;
      }
      /*
       Converts the Julian Day number to a date in the Jalali calendar.
       @param julianDayNumber Julian Day number
       @return
       jalaliYear: Jalali year (1 to 3100)
       jalaliMonth: Jalali month (1 to 12)
       jalaliDay: Jalali day (1 to 29/31)
       */


      function julianToJalali(julianDayNumber) {
        var gy = julianToGregorian(julianDayNumber).getFullYear() // Calculate Gregorian year (gy).
        ,
            jalaliYear = gy - 621,
            r = jalCal(jalaliYear),
            gregorianDay = gregorianToJulian(gy, 3, r.march),
            jalaliDay,
            jalaliMonth,
            numberOfDays; // Find number of days that passed since 1 Farvardin.

        numberOfDays = julianDayNumber - gregorianDay;

        if (numberOfDays >= 0) {
          if (numberOfDays <= 185) {
            // The first 6 months.
            jalaliMonth = 1 + div(numberOfDays, 31);
            jalaliDay = mod$1(numberOfDays, 31) + 1;
            return new _NgbDate(jalaliYear, jalaliMonth, jalaliDay);
          } else {
            // The remaining months.
            numberOfDays -= 186;
          }
        } else {
          // Previous Jalali year.
          jalaliYear -= 1;
          numberOfDays += 179;

          if (r.leap === 1) {
            numberOfDays += 1;
          }
        }

        jalaliMonth = 7 + div(numberOfDays, 30);
        jalaliDay = mod$1(numberOfDays, 30) + 1;
        return new _NgbDate(jalaliYear, jalaliMonth, jalaliDay);
      }
      /*
       Converts a date of the Jalali calendar to the Julian Day number.
       @param jYear Jalali year (1 to 3100)
       @param jMonth Jalali month (1 to 12)
       @param jDay Jalali day (1 to 29/31)
       @return Julian Day number
       */


      function jalaliToJulian(jYear, jMonth, jDay) {
        var r = jalCal(jYear);
        return gregorianToJulian(r.gy, 3, r.march) + (jMonth - 1) * 31 - div(jMonth, 7) * (jMonth - 7) + jDay - 1;
      }
      /**
       * Returns the number of days in a specific jalali month.
       */


      function getDaysPerMonth(month, year) {
        if (month <= 6) {
          return 31;
        }

        if (month <= 11) {
          return 30;
        }

        if (jalCal(year).leap === 0) {
          return 30;
        }

        return 29;
      }

      var _NgbCalendarPersian = /*#__PURE__*/function () {
        var NgbCalendarPersian = /*#__PURE__*/function (_NgbCalendar4) {
          _inherits(NgbCalendarPersian, _NgbCalendar4);

          var _super9 = _createSuper(NgbCalendarPersian);

          function NgbCalendarPersian() {
            _classCallCheck(this, NgbCalendarPersian);

            return _super9.apply(this, arguments);
          }

          _createClass(NgbCalendarPersian, [{
            key: "getDaysPerWeek",
            value: function getDaysPerWeek() {
              return 7;
            }
          }, {
            key: "getMonths",
            value: function getMonths() {
              return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            }
          }, {
            key: "getWeeksPerMonth",
            value: function getWeeksPerMonth() {
              return 6;
            }
          }, {
            key: "getNext",
            value: function getNext(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              date = new _NgbDate(date.year, date.month, date.day);

              switch (period) {
                case 'y':
                  date = setJalaliYear(date, date.year + number);
                  date.month = 1;
                  date.day = 1;
                  return date;

                case 'm':
                  date = setJalaliMonth(date, date.month + number);
                  date.day = 1;
                  return date;

                case 'd':
                  return setJalaliDay(date, date.day + number);

                default:
                  return date;
              }
            }
          }, {
            key: "getPrev",
            value: function getPrev(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              return this.getNext(date, period, -number);
            }
          }, {
            key: "getWeekday",
            value: function getWeekday(date) {
              var day = toGregorian(date).getDay(); // in JS Date Sun=0, in ISO 8601 Sun=7

              return day === 0 ? 7 : day;
            }
          }, {
            key: "getWeekNumber",
            value: function getWeekNumber(week, firstDayOfWeek) {
              // in JS Date Sun=0, in ISO 8601 Sun=7
              if (firstDayOfWeek === 7) {
                firstDayOfWeek = 0;
              }

              var thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;
              var date = week[thursdayIndex];
              var jsDate = toGregorian(date);
              jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday

              var time = jsDate.getTime();
              var startDate = toGregorian(new _NgbDate(date.year, 1, 1));
              return Math.floor(Math.round((time - startDate.getTime()) / 86400000) / 7) + 1;
            }
          }, {
            key: "getToday",
            value: function getToday() {
              return fromGregorian(new Date());
            }
          }, {
            key: "isValid",
            value: function isValid(date) {
              return date != null && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) && !isNaN(toGregorian(date).getTime());
            }
          }]);

          return NgbCalendarPersian;
        }(_NgbCalendar);

        NgbCalendarPersian.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarPersian_BaseFactory;
          return function NgbCalendarPersian_Factory(t) {
            return (ɵNgbCalendarPersian_BaseFactory || (ɵNgbCalendarPersian_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarPersian)))(t || NgbCalendarPersian);
          };
        }();

        NgbCalendarPersian.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarPersian,
          factory: NgbCalendarPersian.ɵfac
        });
        return NgbCalendarPersian;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var PARTS_PER_HOUR = 1080;
      var PARTS_PER_DAY = 24 * PARTS_PER_HOUR;
      var PARTS_FRACTIONAL_MONTH = 12 * PARTS_PER_HOUR + 793;
      var PARTS_PER_MONTH = 29 * PARTS_PER_DAY + PARTS_FRACTIONAL_MONTH;
      var BAHARAD = 11 * PARTS_PER_HOUR + 204;
      var HEBREW_DAY_ON_JAN_1_1970 = 2092591;
      var GREGORIAN_EPOCH$1 = 1721425.5;

      function isGregorianLeapYear$1(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }

      function numberOfFirstDayInYear(year) {
        var monthsBeforeYear = Math.floor((235 * year - 234) / 19);
        var fractionalMonthsBeforeYear = monthsBeforeYear * PARTS_FRACTIONAL_MONTH + BAHARAD;
        var dayNumber = monthsBeforeYear * 29 + Math.floor(fractionalMonthsBeforeYear / PARTS_PER_DAY);
        var timeOfDay = fractionalMonthsBeforeYear % PARTS_PER_DAY;
        var dayOfWeek = dayNumber % 7; // 0 == Monday

        if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) {
          dayNumber++;
          dayOfWeek = dayNumber % 7;
        }

        if (dayOfWeek === 1 && timeOfDay > 15 * PARTS_PER_HOUR + 204 && !isHebrewLeapYear(year)) {
          dayNumber += 2;
        } else if (dayOfWeek === 0 && timeOfDay > 21 * PARTS_PER_HOUR + 589 && isHebrewLeapYear(year - 1)) {
          dayNumber++;
        }

        return dayNumber;
      }

      function getDaysInGregorianMonth(month, year) {
        var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        if (isGregorianLeapYear$1(year)) {
          days[1]++;
        }

        return days[month - 1];
      }

      function getHebrewMonths(year) {
        return isHebrewLeapYear(year) ? 13 : 12;
      }
      /**
       * Returns the number of days in a specific Hebrew year.
       * `year` is any Hebrew year.
       */


      function getDaysInHebrewYear(year) {
        return numberOfFirstDayInYear(year + 1) - numberOfFirstDayInYear(year);
      }

      function isHebrewLeapYear(year) {
        if (year != null) {
          var b = (year * 12 + 17) % 19;
          return b >= (b < 0 ? -7 : 12);
        }

        return false;
      }
      /**
       * Returns the number of days in a specific Hebrew month.
       * `month` is 1 for Nisan, 2 for Iyar etc. Note: Hebrew leap year contains 13 months.
       * `year` is any Hebrew year.
       */


      function getDaysInHebrewMonth(month, year) {
        var yearLength = numberOfFirstDayInYear(year + 1) - numberOfFirstDayInYear(year);
        var yearType = (yearLength <= 380 ? yearLength : yearLength - 30) - 353;
        var leapYear = isHebrewLeapYear(year);
        var daysInMonth = leapYear ? [30, 29, 29, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29] : [30, 29, 29, 29, 30, 29, 30, 29, 30, 29, 30, 29];

        if (yearType > 0) {
          daysInMonth[2]++; // Kislev gets an extra day in normal or complete years.
        }

        if (yearType > 1) {
          daysInMonth[1]++; // Heshvan gets an extra day in complete years only.
        }

        return daysInMonth[month - 1];
      }

      function getDayNumberInHebrewYear(date) {
        var numberOfDay = 0;

        for (var i = 1; i < date.month; i++) {
          numberOfDay += getDaysInHebrewMonth(i, date.year);
        }

        return numberOfDay + date.day;
      }

      function setHebrewMonth(date, val) {
        var after = val >= 0;

        if (!after) {
          val = -val;
        }

        while (val > 0) {
          if (after) {
            if (val > getHebrewMonths(date.year) - date.month) {
              val -= getHebrewMonths(date.year) - date.month + 1;
              date.year++;
              date.month = 1;
            } else {
              date.month += val;
              val = 0;
            }
          } else {
            if (val >= date.month) {
              date.year--;
              val -= date.month;
              date.month = getHebrewMonths(date.year);
            } else {
              date.month -= val;
              val = 0;
            }
          }
        }

        return date;
      }

      function setHebrewDay(date, val) {
        var after = val >= 0;

        if (!after) {
          val = -val;
        }

        while (val > 0) {
          if (after) {
            if (val > getDaysInHebrewYear(date.year) - getDayNumberInHebrewYear(date)) {
              val -= getDaysInHebrewYear(date.year) - getDayNumberInHebrewYear(date) + 1;
              date.year++;
              date.month = 1;
              date.day = 1;
            } else if (val > getDaysInHebrewMonth(date.month, date.year) - date.day) {
              val -= getDaysInHebrewMonth(date.month, date.year) - date.day + 1;
              date.month++;
              date.day = 1;
            } else {
              date.day += val;
              val = 0;
            }
          } else {
            if (val >= date.day) {
              val -= date.day;
              date.month--;

              if (date.month === 0) {
                date.year--;
                date.month = getHebrewMonths(date.year);
              }

              date.day = getDaysInHebrewMonth(date.month, date.year);
            } else {
              date.day -= val;
              val = 0;
            }
          }
        }

        return date;
      }
      /**
       * Returns the equivalent Hebrew date value for a give input Gregorian date.
       * `gdate` is a JS Date to be converted to Hebrew date.
       */


      function fromGregorian$1(gdate) {
        var date = new Date(gdate);
        var gYear = date.getFullYear(),
            gMonth = date.getMonth(),
            gDay = date.getDate();
        var julianDay = GREGORIAN_EPOCH$1 - 1 + 365 * (gYear - 1) + Math.floor((gYear - 1) / 4) - Math.floor((gYear - 1) / 100) + Math.floor((gYear - 1) / 400) + Math.floor((367 * (gMonth + 1) - 362) / 12 + (gMonth + 1 <= 2 ? 0 : isGregorianLeapYear$1(gYear) ? -1 : -2) + gDay);
        julianDay = Math.floor(julianDay + 0.5);
        var daysSinceHebEpoch = julianDay - 347997;
        var monthsSinceHebEpoch = Math.floor(daysSinceHebEpoch * PARTS_PER_DAY / PARTS_PER_MONTH);
        var hYear = Math.floor((monthsSinceHebEpoch * 19 + 234) / 235) + 1;
        var firstDayOfThisYear = numberOfFirstDayInYear(hYear);
        var dayOfYear = daysSinceHebEpoch - firstDayOfThisYear;

        while (dayOfYear < 1) {
          hYear--;
          firstDayOfThisYear = numberOfFirstDayInYear(hYear);
          dayOfYear = daysSinceHebEpoch - firstDayOfThisYear;
        }

        var hMonth = 1;
        var hDay = dayOfYear;

        while (hDay > getDaysInHebrewMonth(hMonth, hYear)) {
          hDay -= getDaysInHebrewMonth(hMonth, hYear);
          hMonth++;
        }

        return new _NgbDate(hYear, hMonth, hDay);
      }
      /**
       * Returns the equivalent JS date value for a given Hebrew date.
       * `hebrewDate` is an Hebrew date to be converted to Gregorian.
       */


      function toGregorian$1(hebrewDate) {
        var hYear = hebrewDate.year;
        var hMonth = hebrewDate.month;
        var hDay = hebrewDate.day;
        var days = numberOfFirstDayInYear(hYear);

        for (var i = 1; i < hMonth; i++) {
          days += getDaysInHebrewMonth(i, hYear);
        }

        days += hDay;
        var diffDays = days - HEBREW_DAY_ON_JAN_1_1970;
        var after = diffDays >= 0;

        if (!after) {
          diffDays = -diffDays;
        }

        var gYear = 1970;
        var gMonth = 1;
        var gDay = 1;

        while (diffDays > 0) {
          if (after) {
            if (diffDays >= (isGregorianLeapYear$1(gYear) ? 366 : 365)) {
              diffDays -= isGregorianLeapYear$1(gYear) ? 366 : 365;
              gYear++;
            } else if (diffDays >= getDaysInGregorianMonth(gMonth, gYear)) {
              diffDays -= getDaysInGregorianMonth(gMonth, gYear);
              gMonth++;
            } else {
              gDay += diffDays;
              diffDays = 0;
            }
          } else {
            if (diffDays >= (isGregorianLeapYear$1(gYear - 1) ? 366 : 365)) {
              diffDays -= isGregorianLeapYear$1(gYear - 1) ? 366 : 365;
              gYear--;
            } else {
              if (gMonth > 1) {
                gMonth--;
              } else {
                gMonth = 12;
                gYear--;
              }

              if (diffDays >= getDaysInGregorianMonth(gMonth, gYear)) {
                diffDays -= getDaysInGregorianMonth(gMonth, gYear);
              } else {
                gDay = getDaysInGregorianMonth(gMonth, gYear) - diffDays + 1;
                diffDays = 0;
              }
            }
          }
        }

        return new Date(gYear, gMonth - 1, gDay);
      }

      function hebrewNumerals(numerals) {
        if (!numerals) {
          return '';
        }

        var hArray0_9 = ['', "\u05D0", "\u05D1", "\u05D2", "\u05D3", "\u05D4", "\u05D5", "\u05D6", "\u05D7", "\u05D8"];
        var hArray10_19 = ["\u05D9", "\u05D9\u05D0", "\u05D9\u05D1", "\u05D9\u05D2", "\u05D9\u05D3", "\u05D8\u05D5", "\u05D8\u05D6", "\u05D9\u05D6", "\u05D9\u05D7", "\u05D9\u05D8"];
        var hArray20_90 = ['', '', "\u05DB", "\u05DC", "\u05DE", "\u05E0", "\u05E1", "\u05E2", "\u05E4", "\u05E6"];
        var hArray100_900 = ['', "\u05E7", "\u05E8", "\u05E9", "\u05EA", "\u05EA\u05E7", "\u05EA\u05E8", "\u05EA\u05E9", "\u05EA\u05EA", "\u05EA\u05EA\u05E7"];
        var hArray1000_9000 = ['', "\u05D0", "\u05D1", "\u05D1\u05D0", "\u05D1\u05D1", "\u05D4", "\u05D4\u05D0", "\u05D4\u05D1", "\u05D4\u05D1\u05D0", "\u05D4\u05D1\u05D1"];
        var geresh = "\u05F3",
            gershaim = "\u05F4";
        var mem = 0;
        var result = [];
        var step = 0;

        while (numerals > 0) {
          var m = numerals % 10;

          if (step === 0) {
            mem = m;
          } else if (step === 1) {
            if (m !== 1) {
              result.unshift(hArray20_90[m], hArray0_9[mem]);
            } else {
              result.unshift(hArray10_19[mem]);
            }
          } else if (step === 2) {
            result.unshift(hArray100_900[m]);
          } else {
            if (m !== 5) {
              result.unshift(hArray1000_9000[m], geresh, ' ');
            }

            break;
          }

          numerals = Math.floor(numerals / 10);

          if (step === 0 && numerals === 0) {
            result.unshift(hArray0_9[m]);
          }

          step++;
        }

        result = result.join('').split('');

        if (result.length === 1) {
          result.push(geresh);
        } else if (result.length > 1) {
          result.splice(result.length - 1, 0, gershaim);
        }

        return result.join('');
      }
      /**
       * @since 3.2.0
       */


      var _NgbCalendarHebrew = /*#__PURE__*/function () {
        var NgbCalendarHebrew = /*#__PURE__*/function (_NgbCalendar5) {
          _inherits(NgbCalendarHebrew, _NgbCalendar5);

          var _super10 = _createSuper(NgbCalendarHebrew);

          function NgbCalendarHebrew() {
            _classCallCheck(this, NgbCalendarHebrew);

            return _super10.apply(this, arguments);
          }

          _createClass(NgbCalendarHebrew, [{
            key: "getDaysPerWeek",
            value: function getDaysPerWeek() {
              return 7;
            }
          }, {
            key: "getMonths",
            value: function getMonths(year) {
              if (year && isHebrewLeapYear(year)) {
                return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
              } else {
                return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
              }
            }
          }, {
            key: "getWeeksPerMonth",
            value: function getWeeksPerMonth() {
              return 6;
            }
          }, {
            key: "isValid",
            value: function isValid(date) {
              if (date != null) {
                var b = isNumber(date.year) && isNumber(date.month) && isNumber(date.day);
                b = b && date.month > 0 && date.month <= (isHebrewLeapYear(date.year) ? 13 : 12);
                b = b && date.day > 0 && date.day <= getDaysInHebrewMonth(date.month, date.year);
                return b && !isNaN(toGregorian$1(date).getTime());
              }

              return false;
            }
          }, {
            key: "getNext",
            value: function getNext(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              date = new _NgbDate(date.year, date.month, date.day);

              switch (period) {
                case 'y':
                  date.year += number;
                  date.month = 1;
                  date.day = 1;
                  return date;

                case 'm':
                  date = setHebrewMonth(date, number);
                  date.day = 1;
                  return date;

                case 'd':
                  return setHebrewDay(date, number);

                default:
                  return date;
              }
            }
          }, {
            key: "getPrev",
            value: function getPrev(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              return this.getNext(date, period, -number);
            }
          }, {
            key: "getWeekday",
            value: function getWeekday(date) {
              var day = toGregorian$1(date).getDay(); // in JS Date Sun=0, in ISO 8601 Sun=7

              return day === 0 ? 7 : day;
            }
          }, {
            key: "getWeekNumber",
            value: function getWeekNumber(week, firstDayOfWeek) {
              var date = week[week.length - 1];
              return Math.ceil(getDayNumberInHebrewYear(date) / 7);
            }
          }, {
            key: "getToday",
            value: function getToday() {
              return fromGregorian$1(new Date());
            }
            /**
             * @since 3.4.0
             */

          }, {
            key: "toGregorian",
            value: function toGregorian(date) {
              return fromJSDate(toGregorian$1(date));
            }
            /**
             * @since 3.4.0
             */

          }, {
            key: "fromGregorian",
            value: function fromGregorian(date) {
              return fromGregorian$1(toJSDate(date));
            }
          }]);

          return NgbCalendarHebrew;
        }(_NgbCalendar);

        NgbCalendarHebrew.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarHebrew_BaseFactory;
          return function NgbCalendarHebrew_Factory(t) {
            return (ɵNgbCalendarHebrew_BaseFactory || (ɵNgbCalendarHebrew_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarHebrew)))(t || NgbCalendarHebrew);
          };
        }();

        NgbCalendarHebrew.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarHebrew,
          factory: NgbCalendarHebrew.ɵfac
        });
        return NgbCalendarHebrew;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var WEEKDAYS = ['שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת', 'ראשון'];
      var MONTHS = ['תשרי', 'חשון', 'כסלו', 'טבת', 'שבט', 'אדר', 'ניסן', 'אייר', 'סיון', 'תמוז', 'אב', 'אלול'];
      var MONTHS_LEAP = ['תשרי', 'חשון', 'כסלו', 'טבת', 'שבט', 'אדר א׳', 'אדר ב׳', 'ניסן', 'אייר', 'סיון', 'תמוז', 'אב', 'אלול'];
      /**
       * @since 3.2.0
       */

      var _NgbDatepickerI18nHebrew = /*#__PURE__*/function () {
        var NgbDatepickerI18nHebrew = /*#__PURE__*/function (_NgbDatepickerI18n3) {
          _inherits(NgbDatepickerI18nHebrew, _NgbDatepickerI18n3);

          var _super11 = _createSuper(NgbDatepickerI18nHebrew);

          function NgbDatepickerI18nHebrew() {
            _classCallCheck(this, NgbDatepickerI18nHebrew);

            return _super11.apply(this, arguments);
          }

          _createClass(NgbDatepickerI18nHebrew, [{
            key: "getMonthShortName",
            value: function getMonthShortName(month, year) {
              return this.getMonthFullName(month, year);
            }
          }, {
            key: "getMonthFullName",
            value: function getMonthFullName(month, year) {
              return isHebrewLeapYear(year) ? MONTHS_LEAP[month - 1] || '' : MONTHS[month - 1] || '';
            }
          }, {
            key: "getWeekdayShortName",
            value: function getWeekdayShortName(weekday) {
              return WEEKDAYS[weekday - 1] || '';
            }
          }, {
            key: "getDayAriaLabel",
            value: function getDayAriaLabel(date) {
              return "".concat(hebrewNumerals(date.day), " ").concat(this.getMonthFullName(date.month, date.year), " ").concat(hebrewNumerals(date.year));
            }
          }, {
            key: "getDayNumerals",
            value: function getDayNumerals(date) {
              return hebrewNumerals(date.day);
            }
          }, {
            key: "getWeekNumerals",
            value: function getWeekNumerals(weekNumber) {
              return hebrewNumerals(weekNumber);
            }
          }, {
            key: "getYearNumerals",
            value: function getYearNumerals(year) {
              return hebrewNumerals(year);
            }
          }]);

          return NgbDatepickerI18nHebrew;
        }(_NgbDatepickerI18n);

        NgbDatepickerI18nHebrew.ɵfac = /*@__PURE__*/function () {
          var ɵNgbDatepickerI18nHebrew_BaseFactory;
          return function NgbDatepickerI18nHebrew_Factory(t) {
            return (ɵNgbDatepickerI18nHebrew_BaseFactory || (ɵNgbDatepickerI18nHebrew_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbDatepickerI18nHebrew)))(t || NgbDatepickerI18nHebrew);
          };
        }();

        NgbDatepickerI18nHebrew.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDatepickerI18nHebrew,
          factory: NgbDatepickerI18nHebrew.ɵfac
        });
        return NgbDatepickerI18nHebrew;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Returns the equivalent JS date value for a give input Buddhist date.
       * `date` is an Buddhist date to be converted to Gregorian.
       */


      function toGregorian$2(date) {
        return new Date(date.year - 543, date.month - 1, date.day);
      }
      /**
       * Returns the equivalent Buddhist date value for a give input Gregorian date.
       * `gdate` is a JS Date to be converted to Buddhist.
       * utc to local
       */


      function fromGregorian$2(gdate) {
        return new _NgbDate(gdate.getFullYear() + 543, gdate.getMonth() + 1, gdate.getDate());
      }
      /**
       * @since 9.1.0
       */


      var _NgbCalendarBuddhist = /*#__PURE__*/function () {
        var NgbCalendarBuddhist = /*#__PURE__*/function (_NgbCalendarGregorian2) {
          _inherits(NgbCalendarBuddhist, _NgbCalendarGregorian2);

          var _super12 = _createSuper(NgbCalendarBuddhist);

          function NgbCalendarBuddhist() {
            _classCallCheck(this, NgbCalendarBuddhist);

            return _super12.apply(this, arguments);
          }

          _createClass(NgbCalendarBuddhist, [{
            key: "getToday",
            value: function getToday() {
              return fromGregorian$2(new Date());
            }
          }, {
            key: "getNext",
            value: function getNext(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              var jsDate = toGregorian$2(date);
              var checkMonth = true;
              var expectedMonth = jsDate.getMonth();

              switch (period) {
                case 'y':
                  jsDate.setFullYear(jsDate.getFullYear() + number);
                  break;

                case 'm':
                  expectedMonth += number;
                  jsDate.setMonth(expectedMonth);
                  expectedMonth = expectedMonth % 12;

                  if (expectedMonth < 0) {
                    expectedMonth = expectedMonth + 12;
                  }

                  break;

                case 'd':
                  jsDate.setDate(jsDate.getDate() + number);
                  checkMonth = false;
                  break;

                default:
                  return date;
              }

              if (checkMonth && jsDate.getMonth() !== expectedMonth) {
                // this means the destination month has less days than the initial month
                // let's go back to the end of the previous month:
                jsDate.setDate(0);
              }

              return fromGregorian$2(jsDate);
            }
          }, {
            key: "getPrev",
            value: function getPrev(date) {
              var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
              var number = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              return this.getNext(date, period, -number);
            }
          }, {
            key: "getWeekday",
            value: function getWeekday(date) {
              var jsDate = toGregorian$2(date);
              var day = jsDate.getDay(); // in JS Date Sun=0, in ISO 8601 Sun=7

              return day === 0 ? 7 : day;
            }
          }, {
            key: "getWeekNumber",
            value: function getWeekNumber(week, firstDayOfWeek) {
              // in JS Date Sun=0, in ISO 8601 Sun=7
              if (firstDayOfWeek === 7) {
                firstDayOfWeek = 0;
              }

              var thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;
              var date = week[thursdayIndex];
              var jsDate = toGregorian$2(date);
              jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday

              var time = jsDate.getTime();
              jsDate.setMonth(0); // Compare with Jan 1

              jsDate.setDate(1);
              return Math.floor(Math.round((time - jsDate.getTime()) / 86400000) / 7) + 1;
            }
          }, {
            key: "isValid",
            value: function isValid(date) {
              if (!date || !isInteger(date.year) || !isInteger(date.month) || !isInteger(date.day)) {
                return false;
              } // year 0 doesn't exist in Gregorian calendar


              if (date.year === 0) {
                return false;
              }

              var jsDate = toGregorian$2(date);
              return !isNaN(jsDate.getTime()) && jsDate.getFullYear() === date.year - 543 && jsDate.getMonth() + 1 === date.month && jsDate.getDate() === date.day;
            }
          }]);

          return NgbCalendarBuddhist;
        }(_NgbCalendarGregorian);

        NgbCalendarBuddhist.ɵfac = /*@__PURE__*/function () {
          var ɵNgbCalendarBuddhist_BaseFactory;
          return function NgbCalendarBuddhist_Factory(t) {
            return (ɵNgbCalendarBuddhist_BaseFactory || (ɵNgbCalendarBuddhist_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbCalendarBuddhist)))(t || NgbCalendarBuddhist);
          };
        }();

        NgbCalendarBuddhist.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbCalendarBuddhist,
          factory: NgbCalendarBuddhist.ɵfac
        });
        return NgbCalendarBuddhist;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * [`NgbDateAdapter`](#/components/datepicker/api#NgbDateAdapter) implementation that uses
       * native javascript dates as a user date model.
       */


      var _NgbDateNativeAdapter = /*#__PURE__*/function () {
        var NgbDateNativeAdapter = /*#__PURE__*/function (_NgbDateAdapter3) {
          _inherits(NgbDateNativeAdapter, _NgbDateAdapter3);

          var _super13 = _createSuper(NgbDateNativeAdapter);

          function NgbDateNativeAdapter() {
            _classCallCheck(this, NgbDateNativeAdapter);

            return _super13.apply(this, arguments);
          }

          _createClass(NgbDateNativeAdapter, [{
            key: "fromModel",
            value:
            /**
             * Converts a native `Date` to a `NgbDateStruct`.
             */
            function fromModel(date) {
              return date instanceof Date && !isNaN(date.getTime()) ? this._fromNativeDate(date) : null;
            }
            /**
             * Converts a `NgbDateStruct` to a native `Date`.
             */

          }, {
            key: "toModel",
            value: function toModel(date) {
              return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? this._toNativeDate(date) : null;
            }
          }, {
            key: "_fromNativeDate",
            value: function _fromNativeDate(date) {
              return {
                year: date.getFullYear(),
                month: date.getMonth() + 1,
                day: date.getDate()
              };
            }
          }, {
            key: "_toNativeDate",
            value: function _toNativeDate(date) {
              var jsDate = new Date(date.year, date.month - 1, date.day, 12); // avoid 30 -> 1930 conversion

              jsDate.setFullYear(date.year);
              return jsDate;
            }
          }]);

          return NgbDateNativeAdapter;
        }(_NgbDateAdapter);

        NgbDateNativeAdapter.ɵfac = /*@__PURE__*/function () {
          var ɵNgbDateNativeAdapter_BaseFactory;
          return function NgbDateNativeAdapter_Factory(t) {
            return (ɵNgbDateNativeAdapter_BaseFactory || (ɵNgbDateNativeAdapter_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbDateNativeAdapter)))(t || NgbDateNativeAdapter);
          };
        }();

        NgbDateNativeAdapter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDateNativeAdapter,
          factory: NgbDateNativeAdapter.ɵfac
        });
        return NgbDateNativeAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Same as [`NgbDateNativeAdapter`](#/components/datepicker/api#NgbDateNativeAdapter), but with UTC dates.
       *
       * @since 3.2.0
       */


      var _NgbDateNativeUTCAdapter = /*#__PURE__*/function () {
        var NgbDateNativeUTCAdapter = /*#__PURE__*/function (_NgbDateNativeAdapter2) {
          _inherits(NgbDateNativeUTCAdapter, _NgbDateNativeAdapter2);

          var _super14 = _createSuper(NgbDateNativeUTCAdapter);

          function NgbDateNativeUTCAdapter() {
            _classCallCheck(this, NgbDateNativeUTCAdapter);

            return _super14.apply(this, arguments);
          }

          _createClass(NgbDateNativeUTCAdapter, [{
            key: "_fromNativeDate",
            value: function _fromNativeDate(date) {
              return {
                year: date.getUTCFullYear(),
                month: date.getUTCMonth() + 1,
                day: date.getUTCDate()
              };
            }
          }, {
            key: "_toNativeDate",
            value: function _toNativeDate(date) {
              var jsDate = new Date(Date.UTC(date.year, date.month - 1, date.day)); // avoid 30 -> 1930 conversion

              jsDate.setUTCFullYear(date.year);
              return jsDate;
            }
          }]);

          return NgbDateNativeUTCAdapter;
        }(_NgbDateNativeAdapter);

        NgbDateNativeUTCAdapter.ɵfac = /*@__PURE__*/function () {
          var ɵNgbDateNativeUTCAdapter_BaseFactory;
          return function NgbDateNativeUTCAdapter_Factory(t) {
            return (ɵNgbDateNativeUTCAdapter_BaseFactory || (ɵNgbDateNativeUTCAdapter_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbDateNativeUTCAdapter)))(t || NgbDateNativeUTCAdapter);
          };
        }();

        NgbDateNativeUTCAdapter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbDateNativeUTCAdapter,
          factory: NgbDateNativeUTCAdapter.ɵfac
        });
        return NgbDateNativeUTCAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbDatepickerModule = /*#__PURE__*/function () {
        var NgbDatepickerModule = function NgbDatepickerModule() {
          _classCallCheck(this, NgbDatepickerModule);
        };

        NgbDatepickerModule.ɵfac = function NgbDatepickerModule_Factory(t) {
          return new (t || NgbDatepickerModule)();
        };

        NgbDatepickerModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbDatepickerModule
        });
        NgbDatepickerModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.FormsModule]]
        });
        return NgbDatepickerModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbDatepickerModule, {
          declarations: function declarations() {
            return [_NgbDatepicker, _NgbDatepickerContent, _NgbDatepickerMonth, NgbDatepickerNavigation, NgbDatepickerNavigationSelect, NgbDatepickerDayView, _NgbInputDatepicker];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.FormsModule];
          },
          exports: function exports() {
            return [_NgbDatepicker, _NgbDatepickerContent, _NgbInputDatepicker, _NgbDatepickerMonth];
          }
        });
      })();
      /**
       * A configuration service for the [`NgbDropdown`](#/components/dropdown/api#NgbDropdown) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the dropdowns used in the application.
       */


      var _NgbDropdownConfig = /*#__PURE__*/function () {
        var NgbDropdownConfig = function NgbDropdownConfig() {
          _classCallCheck(this, NgbDropdownConfig);

          this.autoClose = true;
          this.placement = ['bottom-left', 'bottom-right', 'top-left', 'top-right'];
        };

        NgbDropdownConfig.ɵfac = function NgbDropdownConfig_Factory(t) {
          return new (t || NgbDropdownConfig)();
        };

        NgbDropdownConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbDropdownConfig_Factory() {
            return new NgbDropdownConfig();
          },
          token: NgbDropdownConfig,
          providedIn: "root"
        });
        return NgbDropdownConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbNavbar = /*#__PURE__*/function () {
        var NgbNavbar = function NgbNavbar() {
          _classCallCheck(this, NgbNavbar);
        };

        NgbNavbar.ɵfac = function NgbNavbar_Factory(t) {
          return new (t || NgbNavbar)();
        };

        NgbNavbar.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNavbar,
          selectors: [["", 8, "navbar"]]
        });
        return NgbNavbar;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive you should put on a dropdown item to enable keyboard navigation.
       * Arrow keys will move focus between items marked with this directive.
       *
       * @since 4.1.0
       */


      var _NgbDropdownItem = /*#__PURE__*/function () {
        var NgbDropdownItem = /*#__PURE__*/function () {
          function NgbDropdownItem(elementRef) {
            _classCallCheck(this, NgbDropdownItem);

            this.elementRef = elementRef;
            this._disabled = false;
          }

          _createClass(NgbDropdownItem, [{
            key: "disabled",
            get: function get() {
              return this._disabled;
            },
            set: function set(value) {
              this._disabled = value === '' || value === true; // accept an empty attribute as true
            }
          }]);

          return NgbDropdownItem;
        }();

        NgbDropdownItem.ɵfac = function NgbDropdownItem_Factory(t) {
          return new (t || NgbDropdownItem)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbDropdownItem.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDropdownItem,
          selectors: [["", "ngbDropdownItem", ""]],
          hostAttrs: [1, "dropdown-item"],
          hostVars: 2,
          hostBindings: function NgbDropdownItem_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx.disabled);
            }
          },
          inputs: {
            disabled: "disabled"
          }
        });
        return NgbDropdownItem;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that wraps dropdown menu content and dropdown items.
       */


      var _NgbDropdownMenu = /*#__PURE__*/function () {
        var NgbDropdownMenu = function NgbDropdownMenu(dropdown, _elementRef) {
          _classCallCheck(this, NgbDropdownMenu);

          this.dropdown = dropdown;
          this.placement = 'bottom';
          this.isOpen = false;
          this.nativeElement = _elementRef.nativeElement;
        };

        NgbDropdownMenu.ɵfac = function NgbDropdownMenu_Factory(t) {
          return new (t || NgbDropdownMenu)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"]((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
            return _NgbDropdown;
          })), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbDropdownMenu.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDropdownMenu,
          selectors: [["", "ngbDropdownMenu", ""]],
          contentQueries: function NgbDropdownMenu_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbDropdownItem, 4);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.menuItems = _t);
            }
          },
          hostVars: 5,
          hostBindings: function NgbDropdownMenu_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown.ArrowUp", function NgbDropdownMenu_keydown_ArrowUp_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.ArrowDown", function NgbDropdownMenu_keydown_ArrowDown_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Home", function NgbDropdownMenu_keydown_Home_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.End", function NgbDropdownMenu_keydown_End_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Enter", function NgbDropdownMenu_keydown_Enter_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Space", function NgbDropdownMenu_keydown_Space_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Tab", function NgbDropdownMenu_keydown_Tab_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Shift.Tab", function NgbDropdownMenu_keydown_Shift_Tab_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("x-placement", ctx.placement);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("dropdown-menu", true)("show", ctx.dropdown.isOpen());
            }
          }
        });
        return NgbDropdownMenu;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to mark an element to which dropdown menu will be anchored.
       *
       * This is a simple version of the `NgbDropdownToggle` directive.
       * It plays the same role, but doesn't listen to click events to toggle dropdown menu thus enabling support
       * for events other than click.
       *
       * @since 1.1.0
       */


      var _NgbDropdownAnchor = /*#__PURE__*/function () {
        var NgbDropdownAnchor = function NgbDropdownAnchor(dropdown, _elementRef) {
          _classCallCheck(this, NgbDropdownAnchor);

          this.dropdown = dropdown;
          this.nativeElement = _elementRef.nativeElement;
        };

        NgbDropdownAnchor.ɵfac = function NgbDropdownAnchor_Factory(t) {
          return new (t || NgbDropdownAnchor)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"]((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
            return _NgbDropdown;
          })), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbDropdownAnchor.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDropdownAnchor,
          selectors: [["", "ngbDropdownAnchor", ""]],
          hostAttrs: [1, "dropdown-toggle"],
          hostVars: 1,
          hostBindings: function NgbDropdownAnchor_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-expanded", ctx.dropdown.isOpen());
            }
          }
        });
        return NgbDropdownAnchor;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to mark an element that will toggle dropdown via the `click` event.
       *
       * You can also use `NgbDropdownAnchor` as an alternative.
       */


      var _NgbDropdownToggle = /*#__PURE__*/function () {
        var NgbDropdownToggle = /*#__PURE__*/function (_NgbDropdownAnchor2) {
          _inherits(NgbDropdownToggle, _NgbDropdownAnchor2);

          var _super15 = _createSuper(NgbDropdownToggle);

          function NgbDropdownToggle(dropdown, elementRef) {
            _classCallCheck(this, NgbDropdownToggle);

            return _super15.call(this, dropdown, elementRef);
          }

          return NgbDropdownToggle;
        }(_NgbDropdownAnchor);

        NgbDropdownToggle.ɵfac = function NgbDropdownToggle_Factory(t) {
          return new (t || NgbDropdownToggle)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"]((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
            return _NgbDropdown;
          })), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbDropdownToggle.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDropdownToggle,
          selectors: [["", "ngbDropdownToggle", ""]],
          hostAttrs: [1, "dropdown-toggle"],
          hostVars: 1,
          hostBindings: function NgbDropdownToggle_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbDropdownToggle_click_HostBindingHandler() {
                return ctx.dropdown.toggle();
              })("keydown.ArrowUp", function NgbDropdownToggle_keydown_ArrowUp_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.ArrowDown", function NgbDropdownToggle_keydown_ArrowDown_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Home", function NgbDropdownToggle_keydown_Home_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.End", function NgbDropdownToggle_keydown_End_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Tab", function NgbDropdownToggle_keydown_Tab_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              })("keydown.Shift.Tab", function NgbDropdownToggle_keydown_Shift_Tab_HostBindingHandler($event) {
                return ctx.dropdown.onKeyDown($event);
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-expanded", ctx.dropdown.isOpen());
            }
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _NgbDropdownAnchor,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbDropdownToggle;
            })
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return NgbDropdownToggle;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that provides contextual overlays for displaying lists of links and more.
       */


      var _NgbDropdown = /*#__PURE__*/function () {
        var NgbDropdown = /*#__PURE__*/function () {
          function NgbDropdown(_changeDetector, config, _document, _ngZone, _elementRef, _renderer, ngbNavbar) {
            var _this23 = this;

            _classCallCheck(this, NgbDropdown);

            this._changeDetector = _changeDetector;
            this._document = _document;
            this._ngZone = _ngZone;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._closed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._bodyContainer = null;
            /**
             * Defines whether or not the dropdown menu is opened initially.
             */

            this._open = false;
            /**
             * An event fired when the dropdown is opened or closed.
             *
             * The event payload is a `boolean`:
             * * `true` - the dropdown was opened
             * * `false` - the dropdown was closed
             */

            this.openChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.placement = config.placement;
            this.container = config.container;
            this.autoClose = config.autoClose;
            this.display = ngbNavbar ? 'static' : 'dynamic';
            this._zoneSubscription = _ngZone.onStable.subscribe(function () {
              _this23._positionMenu();
            });
          }

          _createClass(NgbDropdown, [{
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              var _this24 = this;

              this._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                _this24._applyPlacementClasses();

                if (_this24._open) {
                  _this24._setCloseHandlers();
                }
              });
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              if (changes.container && this._open) {
                this._applyContainer(this.container);
              }

              if (changes.placement && !changes.placement.isFirstChange) {
                this._applyPlacementClasses();
              }

              if (changes.dropdownClass) {
                var _changes$dropdownClas = changes.dropdownClass,
                    currentValue = _changes$dropdownClas.currentValue,
                    previousValue = _changes$dropdownClas.previousValue;

                this._applyCustomDropdownClass(currentValue, previousValue);
              }
            }
            /**
             * Checks if the dropdown menu is open.
             */

          }, {
            key: "isOpen",
            value: function isOpen() {
              return this._open;
            }
            /**
             * Opens the dropdown menu.
             */

          }, {
            key: "open",
            value: function open() {
              if (!this._open) {
                this._open = true;

                this._applyContainer(this.container);

                this.openChange.emit(true);

                this._setCloseHandlers();

                if (this._anchor) {
                  this._anchor.nativeElement.focus();
                }
              }
            }
          }, {
            key: "_setCloseHandlers",
            value: function _setCloseHandlers() {
              var _this25 = this;

              ngbAutoClose(this._ngZone, this._document, this.autoClose, function (source) {
                _this25.close();

                if (source === 0
                /* ESCAPE */
                ) {
                  _this25._anchor.nativeElement.focus();
                }
              }, this._closed$, this._menu ? [this._menu.nativeElement] : [], this._anchor ? [this._anchor.nativeElement] : [], '.dropdown-item,.dropdown-divider');
            }
            /**
             * Closes the dropdown menu.
             */

          }, {
            key: "close",
            value: function close() {
              if (this._open) {
                this._open = false;

                this._resetContainer();

                this._closed$.next();

                this.openChange.emit(false);

                this._changeDetector.markForCheck();
              }
            }
            /**
             * Toggles the dropdown menu.
             */

          }, {
            key: "toggle",
            value: function toggle() {
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._resetContainer();

              this._closed$.next();

              this._zoneSubscription.unsubscribe();
            }
          }, {
            key: "onKeyDown",
            value: function onKeyDown(event) {
              var _this26 = this;

              // tslint:disable-next-line:deprecation
              var key = event.which;

              var itemElements = this._getMenuElements();

              var position = -1;
              var itemElement = null;

              var isEventFromToggle = this._isEventFromToggle(event);

              if (!isEventFromToggle && itemElements.length) {
                itemElements.forEach(function (item, index) {
                  if (item.contains(event.target)) {
                    itemElement = item;
                  }

                  if (item === _this26._document.activeElement) {
                    position = index;
                  }
                });
              } // closing on Enter / Space


              if (key === Key.Space || key === Key.Enter) {
                if (itemElement && (this.autoClose === true || this.autoClose === 'inside')) {
                  // Item is either a button or a link, so click will be triggered by the browser on Enter or Space.
                  // So we have to register a one-time click handler that will fire after any user defined click handlers
                  // to close the dropdown
                  (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(itemElement, 'click').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                    return _this26.close();
                  });
                }

                return;
              }

              if (key === Key.Tab) {
                if (event.target && this.isOpen() && this.autoClose) {
                  if (this._anchor.nativeElement === event.target) {
                    if (this.container === 'body' && !event.shiftKey) {
                      /* This case is special: user is using [Tab] from the anchor/toggle.
                         User expects the next focusable element in the dropdown menu to get focus.
                         But the menu is not a sibling to anchor/toggle, it is at the end of the body.
                         Trick is to synchronously focus the menu element, and let the [keydown.Tab] go
                         so that browser will focus the proper element (first one focusable in the menu) */
                      this._renderer.setAttribute(this._menu.nativeElement, 'tabindex', '0');

                      this._menu.nativeElement.focus();

                      this._renderer.removeAttribute(this._menu.nativeElement, 'tabindex');
                    } else if (event.shiftKey) {
                      this.close();
                    }

                    return;
                  } else if (this.container === 'body') {
                    var focusableElements = this._menu.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);

                    if (event.shiftKey && event.target === focusableElements[0]) {
                      this._anchor.nativeElement.focus();

                      event.preventDefault();
                    } else if (!event.shiftKey && event.target === focusableElements[focusableElements.length - 1]) {
                      this._anchor.nativeElement.focus();

                      this.close();
                    }
                  } else {
                    (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(event.target, 'focusout').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function (_ref17) {
                      var relatedTarget = _ref17.relatedTarget;

                      if (!_this26._elementRef.nativeElement.contains(relatedTarget)) {
                        _this26.close();
                      }
                    });
                  }
                }

                return;
              } // opening / navigating


              if (isEventFromToggle || itemElement) {
                this.open();

                if (itemElements.length) {
                  switch (key) {
                    case Key.ArrowDown:
                      position = Math.min(position + 1, itemElements.length - 1);
                      break;

                    case Key.ArrowUp:
                      if (this._isDropup() && position === -1) {
                        position = itemElements.length - 1;
                        break;
                      }

                      position = Math.max(position - 1, 0);
                      break;

                    case Key.Home:
                      position = 0;
                      break;

                    case Key.End:
                      position = itemElements.length - 1;
                      break;
                  }

                  itemElements[position].focus();
                }

                event.preventDefault();
              }
            }
          }, {
            key: "_isDropup",
            value: function _isDropup() {
              return this._elementRef.nativeElement.classList.contains('dropup');
            }
          }, {
            key: "_isEventFromToggle",
            value: function _isEventFromToggle(event) {
              return this._anchor.nativeElement.contains(event.target);
            }
          }, {
            key: "_getMenuElements",
            value: function _getMenuElements() {
              var menu = this._menu;

              if (menu == null) {
                return [];
              }

              return menu.menuItems.filter(function (item) {
                return !item.disabled;
              }).map(function (item) {
                return item.elementRef.nativeElement;
              });
            }
          }, {
            key: "_positionMenu",
            value: function _positionMenu() {
              var menu = this._menu;

              if (this.isOpen() && menu) {
                this._applyPlacementClasses(this.display === 'dynamic' ? positionElements(this._anchor.nativeElement, this._bodyContainer || this._menu.nativeElement, this.placement, this.container === 'body') : this._getFirstPlacement(this.placement));
              }
            }
          }, {
            key: "_getFirstPlacement",
            value: function _getFirstPlacement(placement) {
              return Array.isArray(placement) ? placement[0] : placement.split(' ')[0];
            }
          }, {
            key: "_resetContainer",
            value: function _resetContainer() {
              var renderer = this._renderer;

              if (this._menu) {
                var dropdownElement = this._elementRef.nativeElement;
                var dropdownMenuElement = this._menu.nativeElement;
                renderer.appendChild(dropdownElement, dropdownMenuElement);
                renderer.removeStyle(dropdownMenuElement, 'position');
                renderer.removeStyle(dropdownMenuElement, 'transform');
              }

              if (this._bodyContainer) {
                renderer.removeChild(this._document.body, this._bodyContainer);
                this._bodyContainer = null;
              }
            }
          }, {
            key: "_applyContainer",
            value: function _applyContainer() {
              var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

              this._resetContainer();

              if (container === 'body') {
                var renderer = this._renderer;
                var dropdownMenuElement = this._menu.nativeElement;
                var bodyContainer = this._bodyContainer = this._bodyContainer || renderer.createElement('div'); // Override some styles to have the positioning working

                renderer.setStyle(bodyContainer, 'position', 'absolute');
                renderer.setStyle(dropdownMenuElement, 'position', 'static');
                renderer.setStyle(bodyContainer, 'z-index', '1050');
                renderer.appendChild(bodyContainer, dropdownMenuElement);
                renderer.appendChild(this._document.body, bodyContainer);
              }

              this._applyCustomDropdownClass(this.dropdownClass);
            }
          }, {
            key: "_applyCustomDropdownClass",
            value: function _applyCustomDropdownClass(newClass, oldClass) {
              var targetElement = this.container === 'body' ? this._bodyContainer : this._elementRef.nativeElement;

              if (targetElement) {
                if (oldClass) {
                  this._renderer.removeClass(targetElement, oldClass);
                }

                if (newClass) {
                  this._renderer.addClass(targetElement, newClass);
                }
              }
            }
          }, {
            key: "_applyPlacementClasses",
            value: function _applyPlacementClasses(placement) {
              var menu = this._menu;

              if (menu) {
                if (!placement) {
                  placement = this._getFirstPlacement(this.placement);
                }

                var renderer = this._renderer;
                var dropdownElement = this._elementRef.nativeElement; // remove the current placement classes

                renderer.removeClass(dropdownElement, 'dropup');
                renderer.removeClass(dropdownElement, 'dropdown');
                menu.placement = this.display === 'static' ? null : placement;
                /*
                * apply the new placement
                * in case of top use up-arrow or down-arrow otherwise
                */

                var dropdownClass = placement.search('^top') !== -1 ? 'dropup' : 'dropdown';
                renderer.addClass(dropdownElement, dropdownClass);
                var bodyContainer = this._bodyContainer;

                if (bodyContainer) {
                  renderer.removeClass(bodyContainer, 'dropup');
                  renderer.removeClass(bodyContainer, 'dropdown');
                  renderer.addClass(bodyContainer, dropdownClass);
                }
              }
            }
          }]);

          return NgbDropdown;
        }();

        NgbDropdown.ɵfac = function NgbDropdown_Factory(t) {
          return new (t || NgbDropdown)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbDropdownConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbNavbar, 8));
        };

        NgbDropdown.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbDropdown,
          selectors: [["", "ngbDropdown", ""]],
          contentQueries: function NgbDropdown_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbDropdownMenu, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbDropdownAnchor, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._menu = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._anchor = _t.first);
            }
          },
          hostVars: 2,
          hostBindings: function NgbDropdown_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("show", ctx.isOpen());
            }
          },
          inputs: {
            _open: ["open", "_open"],
            placement: "placement",
            container: "container",
            autoClose: "autoClose",
            display: "display",
            dropdownClass: "dropdownClass"
          },
          outputs: {
            openChange: "openChange"
          },
          exportAs: ["ngbDropdown"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbDropdown;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NGB_DROPDOWN_DIRECTIVES = [_NgbDropdown, _NgbDropdownAnchor, _NgbDropdownToggle, _NgbDropdownMenu, _NgbDropdownItem, _NgbNavbar];

      var _NgbDropdownModule = /*#__PURE__*/function () {
        var NgbDropdownModule = function NgbDropdownModule() {
          _classCallCheck(this, NgbDropdownModule);
        };

        NgbDropdownModule.ɵfac = function NgbDropdownModule_Factory(t) {
          return new (t || NgbDropdownModule)();
        };

        NgbDropdownModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbDropdownModule
        });
        NgbDropdownModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return NgbDropdownModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbDropdownModule, {
          declarations: [_NgbDropdown, _NgbDropdownAnchor, _NgbDropdownToggle, _NgbDropdownMenu, _NgbDropdownItem, _NgbNavbar],
          exports: [_NgbDropdown, _NgbDropdownAnchor, _NgbDropdownToggle, _NgbDropdownMenu, _NgbDropdownItem, _NgbNavbar]
        });
      })();
      /**
       * A configuration service for the [`NgbModal`](#/components/modal/api#NgbModal) service.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all modals used in the application.
      *
      * @since 3.1.0
      */


      var _NgbModalConfig = /*#__PURE__*/function () {
        var NgbModalConfig = /*#__PURE__*/function () {
          function NgbModalConfig(_ngbConfig) {
            _classCallCheck(this, NgbModalConfig);

            this._ngbConfig = _ngbConfig;
            this.backdrop = true;
            this.keyboard = true;
          }

          _createClass(NgbModalConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbModalConfig;
        }();

        NgbModalConfig.ɵfac = function NgbModalConfig_Factory(t) {
          return new (t || NgbModalConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbModalConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbModalConfig_Factory() {
            return new NgbModalConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbModalConfig,
          providedIn: "root"
        });
        return NgbModalConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var ContentRef = function ContentRef(nodes, viewRef, componentRef) {
        _classCallCheck(this, ContentRef);

        this.nodes = nodes;
        this.viewRef = viewRef;
        this.componentRef = componentRef;
      };

      var PopupService = /*#__PURE__*/function () {
        function PopupService(_type, _injector, _viewContainerRef, _renderer, _ngZone, _componentFactoryResolver, _applicationRef) {
          _classCallCheck(this, PopupService);

          this._type = _type;
          this._injector = _injector;
          this._viewContainerRef = _viewContainerRef;
          this._renderer = _renderer;
          this._ngZone = _ngZone;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._applicationRef = _applicationRef;
          this._windowRef = null;
          this._contentRef = null;
        }

        _createClass(PopupService, [{
          key: "open",
          value: function open(content, context) {
            var _this27 = this;

            var animation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            if (!this._windowRef) {
              this._contentRef = this._getContentRef(content, context);
              this._windowRef = this._viewContainerRef.createComponent(this._componentFactoryResolver.resolveComponentFactory(this._type), this._viewContainerRef.length, this._injector, this._contentRef.nodes);
            }

            var nativeElement = this._windowRef.location.nativeElement;

            var transition$ = this._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.mergeMap)(function () {
              return ngbRunTransition(_this27._ngZone, nativeElement, function (_ref18) {
                var classList = _ref18.classList;
                return classList.add('show');
              }, {
                animation: animation,
                runningTransition: 'continue'
              });
            }));

            return {
              windowRef: this._windowRef,
              transition$: transition$
            };
          }
        }, {
          key: "close",
          value: function close() {
            var _this28 = this;

            var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this._windowRef) {
              return (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(undefined);
            }

            return ngbRunTransition(this._ngZone, this._windowRef.location.nativeElement, function (_ref19) {
              var classList = _ref19.classList;
              return classList.remove('show');
            }, {
              animation: animation,
              runningTransition: 'stop'
            }).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(function () {
              var _a;

              if (_this28._windowRef) {
                // this is required because of the container='body' option
                _this28._viewContainerRef.remove(_this28._viewContainerRef.indexOf(_this28._windowRef.hostView));

                _this28._windowRef = null;
              }

              if ((_a = _this28._contentRef) === null || _a === void 0 ? void 0 : _a.viewRef) {
                _this28._applicationRef.detachView(_this28._contentRef.viewRef);

                _this28._contentRef.viewRef.destroy();

                _this28._contentRef = null;
              }
            }));
          }
        }, {
          key: "_getContentRef",
          value: function _getContentRef(content, context) {
            if (!content) {
              return new ContentRef([]);
            } else if (content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef) {
              var viewRef = content.createEmbeddedView(context);

              this._applicationRef.attachView(viewRef);

              return new ContentRef([viewRef.rootNodes], viewRef);
            } else {
              return new ContentRef([[this._renderer.createText("".concat(content))]]);
            }
          }
        }]);

        return PopupService;
      }();

      var noop = function noop() {};

      var ɵ0$3 = noop;
      /**
       * Utility to handle the scrollbar.
       *
       * It allows to compensate the lack of a vertical scrollbar by adding an
       * equivalent padding on the right of the body, and to remove this compensation.
       */

      var ScrollBar = /*#__PURE__*/function () {
        var ScrollBar = /*#__PURE__*/function () {
          function ScrollBar(_document) {
            _classCallCheck(this, ScrollBar);

            this._document = _document;
          }
          /**
           * To be called right before a potential vertical scrollbar would be removed:
           *
           * - if there was a scrollbar, adds some compensation padding to the body
           * to keep the same layout as when the scrollbar is there
           * - if there was none, there is nothing to do
           *
           * @return a callback used to revert the compensation (noop if there was none,
           * otherwise a function removing the padding)
           */


          _createClass(ScrollBar, [{
            key: "compensate",
            value: function compensate() {
              var width = this._getWidth();

              return !this._isPresent(width) ? noop : this._adjustBody(width);
            }
            /**
             * Adds a padding of the given width on the right of the body.
             *
             * @return a callback used to revert the padding to its previous value
             */

          }, {
            key: "_adjustBody",
            value: function _adjustBody(scrollbarWidth) {
              var body = this._document.body;
              var userSetPaddingStyle = body.style.paddingRight;
              var actualPadding = parseFloat(window.getComputedStyle(body)['padding-right']);
              body.style['padding-right'] = "".concat(actualPadding + scrollbarWidth, "px");
              return function () {
                return body.style['padding-right'] = userSetPaddingStyle;
              };
            }
            /**
             * Tells whether a scrollbar is currently present on the body.
             *
             * @return true if scrollbar is present, false otherwise
             */

          }, {
            key: "_isPresent",
            value: function _isPresent(scrollbarWidth) {
              var rect = this._document.body.getBoundingClientRect();

              var bodyToViewportGap = window.innerWidth - (rect.left + rect.right);
              var uncertainty = 0.1 * scrollbarWidth;
              return bodyToViewportGap >= scrollbarWidth - uncertainty;
            }
            /**
             * Calculates and returns the width of a scrollbar.
             *
             * @return the width of a scrollbar on this page
             */

          }, {
            key: "_getWidth",
            value: function _getWidth() {
              var measurer = this._document.createElement('div');

              measurer.className = 'modal-scrollbar-measure';
              var body = this._document.body;
              body.appendChild(measurer);
              var width = measurer.getBoundingClientRect().width - measurer.clientWidth;
              body.removeChild(measurer);
              return width;
            }
          }]);

          return ScrollBar;
        }();

        ScrollBar.ɵfac = function ScrollBar_Factory(t) {
          return new (t || ScrollBar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
        };

        ScrollBar.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function ScrollBar_Factory() {
            return new ScrollBar((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
          },
          token: ScrollBar,
          providedIn: "root"
        });
        return ScrollBar;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbModalBackdrop = /*#__PURE__*/function () {
        var NgbModalBackdrop = /*#__PURE__*/function () {
          function NgbModalBackdrop(_el, _zone) {
            _classCallCheck(this, NgbModalBackdrop);

            this._el = _el;
            this._zone = _zone;
          }

          _createClass(NgbModalBackdrop, [{
            key: "ngOnInit",
            value: function ngOnInit() {
              var _this29 = this;

              this._zone.onStable.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                ngbRunTransition(_this29._zone, _this29._el.nativeElement, function (element, animation) {
                  if (animation) {
                    reflow(element);
                  }

                  element.classList.add('show');
                }, {
                  animation: _this29.animation,
                  runningTransition: 'continue'
                });
              });
            }
          }, {
            key: "hide",
            value: function hide() {
              return ngbRunTransition(this._zone, this._el.nativeElement, function (_ref20) {
                var classList = _ref20.classList;
                return classList.remove('show');
              }, {
                animation: this.animation,
                runningTransition: 'stop'
              });
            }
          }]);

          return NgbModalBackdrop;
        }();

        NgbModalBackdrop.ɵfac = function NgbModalBackdrop_Factory(t) {
          return new (t || NgbModalBackdrop)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbModalBackdrop.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbModalBackdrop,
          selectors: [["ngb-modal-backdrop"]],
          hostAttrs: [2, "z-index", "1050"],
          hostVars: 6,
          hostBindings: function NgbModalBackdrop_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("modal-backdrop" + (ctx.backdropClass ? " " + ctx.backdropClass : ""));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("show", !ctx.animation)("fade", ctx.animation);
            }
          },
          inputs: {
            animation: "animation",
            backdropClass: "backdropClass"
          },
          decls: 0,
          vars: 0,
          template: function NgbModalBackdrop_Template(rf, ctx) {},
          encapsulation: 2
        });
        return NgbModalBackdrop;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A reference to the currently opened (active) modal.
       *
       * Instances of this class can be injected into your component passed as modal content.
       * So you can `.close()` or `.dismiss()` the modal window from your component.
       */


      var _NgbActiveModal = /*#__PURE__*/function () {
        function _NgbActiveModal() {
          _classCallCheck(this, _NgbActiveModal);
        }

        _createClass(_NgbActiveModal, [{
          key: "close",
          value:
          /**
           * Closes the modal with an optional `result` value.
           *
           * The `NgbModalRef.result` promise will be resolved with the provided value.
           */
          function close(result) {}
          /**
           * Dismisses the modal with an optional `reason` value.
           *
           * The `NgbModalRef.result` promise will be rejected with the provided value.
           */

        }, {
          key: "dismiss",
          value: function dismiss(reason) {}
        }]);

        return _NgbActiveModal;
      }();
      /**
       * A reference to the newly opened modal returned by the `NgbModal.open()` method.
       */


      var _NgbModalRef = /*#__PURE__*/function () {
        function _NgbModalRef(_windowCmptRef, _contentRef, _backdropCmptRef, _beforeDismiss) {
          var _this30 = this;

          _classCallCheck(this, _NgbModalRef);

          this._windowCmptRef = _windowCmptRef;
          this._contentRef = _contentRef;
          this._backdropCmptRef = _backdropCmptRef;
          this._beforeDismiss = _beforeDismiss;
          this._closed = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          this._dismissed = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          this._hidden = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();

          _windowCmptRef.instance.dismissEvent.subscribe(function (reason) {
            _this30.dismiss(reason);
          });

          this.result = new Promise(function (resolve, reject) {
            _this30._resolve = resolve;
            _this30._reject = reject;
          });
          this.result.then(null, function () {});
        }
        /**
         * The instance of a component used for the modal content.
         *
         * When a `TemplateRef` is used as the content or when the modal is closed, will return `undefined`.
         */


        _createClass(_NgbModalRef, [{
          key: "componentInstance",
          get: function get() {
            if (this._contentRef && this._contentRef.componentRef) {
              return this._contentRef.componentRef.instance;
            }
          }
          /**
           * The observable that emits when the modal is closed via the `.close()` method.
           *
           * It will emit the result passed to the `.close()` method.
           *
           * @since 8.0.0
           */

        }, {
          key: "closed",
          get: function get() {
            return this._closed.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._hidden));
          }
          /**
           * The observable that emits when the modal is dismissed via the `.dismiss()` method.
           *
           * It will emit the reason passed to the `.dismissed()` method by the user, or one of the internal
           * reasons like backdrop click or ESC key press.
           *
           * @since 8.0.0
           */

        }, {
          key: "dismissed",
          get: function get() {
            return this._dismissed.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._hidden));
          }
          /**
           * The observable that emits when both modal window and backdrop are closed and animations were finished.
           * At this point modal and backdrop elements will be removed from the DOM tree.
           *
           * This observable will be completed after emitting.
           *
           * @since 8.0.0
           */

        }, {
          key: "hidden",
          get: function get() {
            return this._hidden.asObservable();
          }
          /**
           * The observable that emits when modal is fully visible and animation was finished.
           * Modal DOM element is always available synchronously after calling 'modal.open()' service.
           *
           * This observable will be completed after emitting.
           * It will not emit, if modal is closed before open animation is finished.
           *
           * @since 8.0.0
           */

        }, {
          key: "shown",
          get: function get() {
            return this._windowCmptRef.instance.shown.asObservable();
          }
          /**
           * Closes the modal with an optional `result` value.
           *
           * The `NgbMobalRef.result` promise will be resolved with the provided value.
           */

        }, {
          key: "close",
          value: function close(result) {
            if (this._windowCmptRef) {
              this._closed.next(result);

              this._resolve(result);

              this._removeModalElements();
            }
          }
        }, {
          key: "_dismiss",
          value: function _dismiss(reason) {
            this._dismissed.next(reason);

            this._reject(reason);

            this._removeModalElements();
          }
          /**
           * Dismisses the modal with an optional `reason` value.
           *
           * The `NgbModalRef.result` promise will be rejected with the provided value.
           */

        }, {
          key: "dismiss",
          value: function dismiss(reason) {
            var _this31 = this;

            if (this._windowCmptRef) {
              if (!this._beforeDismiss) {
                this._dismiss(reason);
              } else {
                var dismiss = this._beforeDismiss();

                if (dismiss && dismiss.then) {
                  dismiss.then(function (result) {
                    if (result !== false) {
                      _this31._dismiss(reason);
                    }
                  }, function () {});
                } else if (dismiss !== false) {
                  this._dismiss(reason);
                }
              }
            }
          }
        }, {
          key: "_removeModalElements",
          value: function _removeModalElements() {
            var _this32 = this;

            var windowTransition$ = this._windowCmptRef.instance.hide();

            var backdropTransition$ = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(undefined); // hiding window

            windowTransition$.subscribe(function () {
              var nativeElement = _this32._windowCmptRef.location.nativeElement;
              nativeElement.parentNode.removeChild(nativeElement);

              _this32._windowCmptRef.destroy();

              if (_this32._contentRef && _this32._contentRef.viewRef) {
                _this32._contentRef.viewRef.destroy();
              }

              _this32._windowCmptRef = null;
              _this32._contentRef = null;
            }); // hiding backdrop

            backdropTransition$.subscribe(function () {
              if (_this32._backdropCmptRef) {
                var nativeElement = _this32._backdropCmptRef.location.nativeElement;
                nativeElement.parentNode.removeChild(nativeElement);

                _this32._backdropCmptRef.destroy();

                _this32._backdropCmptRef = null;
              }
            }); // all done

            (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.zip)(windowTransition$, backdropTransition$).subscribe(function () {
              _this32._hidden.next();

              _this32._hidden.complete();
            });
          }
        }]);

        return _NgbModalRef;
      }();

      var _ModalDismissReasons = /*#__PURE__*/function () {
        (function (ModalDismissReasons) {
          ModalDismissReasons[ModalDismissReasons["BACKDROP_CLICK"] = 0] = "BACKDROP_CLICK";
          ModalDismissReasons[ModalDismissReasons["ESC"] = 1] = "ESC";
        })(_ModalDismissReasons || (_ModalDismissReasons = {}));

        return _ModalDismissReasons;
      }();

      var NgbModalWindow = /*#__PURE__*/function () {
        var NgbModalWindow = /*#__PURE__*/function () {
          function NgbModalWindow(_document, _elRef, _zone) {
            _classCallCheck(this, NgbModalWindow);

            this._document = _document;
            this._elRef = _elRef;
            this._zone = _zone;
            this._closed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._elWithFocus = null; // element that is focused prior to modal opening

            this.backdrop = true;
            this.keyboard = true;
            this.dismissEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.shown = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this.hidden = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          }

          _createClass(NgbModalWindow, [{
            key: "dismiss",
            value: function dismiss(reason) {
              this.dismissEvent.emit(reason);
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              var _this33 = this;

              this._elWithFocus = this._document.activeElement;

              this._zone.onStable.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                _this33._show();
              });
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._disableEventHandling();
            }
          }, {
            key: "hide",
            value: function hide() {
              var _this34 = this;

              var nativeElement = this._elRef.nativeElement;
              var context = {
                animation: this.animation,
                runningTransition: 'stop'
              };
              var windowTransition$ = ngbRunTransition(this._zone, nativeElement, function () {
                return nativeElement.classList.remove('show');
              }, context);
              var dialogTransition$ = ngbRunTransition(this._zone, this._dialogEl.nativeElement, function () {}, context);
              var transitions$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.zip)(windowTransition$, dialogTransition$);
              transitions$.subscribe(function () {
                _this34.hidden.next();

                _this34.hidden.complete();
              });

              this._disableEventHandling();

              this._restoreFocus();

              return transitions$;
            }
          }, {
            key: "_show",
            value: function _show() {
              var _this35 = this;

              var context = {
                animation: this.animation,
                runningTransition: 'continue'
              };
              var windowTransition$ = ngbRunTransition(this._zone, this._elRef.nativeElement, function (element, animation) {
                if (animation) {
                  reflow(element);
                }

                element.classList.add('show');
              }, context);
              var dialogTransition$ = ngbRunTransition(this._zone, this._dialogEl.nativeElement, function () {}, context);
              (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.zip)(windowTransition$, dialogTransition$).subscribe(function () {
                _this35.shown.next();

                _this35.shown.complete();
              });

              this._enableEventHandling();

              this._setFocus();
            }
          }, {
            key: "_enableEventHandling",
            value: function _enableEventHandling() {
              var _this36 = this;

              var nativeElement = this._elRef.nativeElement;

              this._zone.runOutsideAngular(function () {
                (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(nativeElement, 'keydown').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this36._closed$), // tslint:disable-next-line:deprecation
                (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (e) {
                  return e.which === Key.Escape;
                })).subscribe(function (event) {
                  if (_this36.keyboard) {
                    requestAnimationFrame(function () {
                      if (!event.defaultPrevented) {
                        _this36._zone.run(function () {
                          return _this36.dismiss(_ModalDismissReasons.ESC);
                        });
                      }
                    });
                  } else if (_this36.backdrop === 'static') {
                    _this36._bumpBackdrop();
                  }
                }); // We're listening to 'mousedown' and 'mouseup' to prevent modal from closing when pressing the mouse
                // inside the modal dialog and releasing it outside

                var preventClose = false;
                (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(_this36._dialogEl.nativeElement, 'mousedown').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this36._closed$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(function () {
                  return preventClose = false;
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.switchMap)(function () {
                  return (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(nativeElement, 'mouseup').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this36._closed$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1));
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (_ref21) {
                  var target = _ref21.target;
                  return nativeElement === target;
                })).subscribe(function () {
                  preventClose = true;
                }); // We're listening to 'click' to dismiss modal on modal window click, except when:
                // 1. clicking on modal dialog itself
                // 2. closing was prevented by mousedown/up handlers
                // 3. clicking on scrollbar when the viewport is too small and modal doesn't fit (click is not triggered at all)

                (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(nativeElement, 'click').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(_this36._closed$)).subscribe(function (_ref22) {
                  var target = _ref22.target;

                  if (nativeElement === target) {
                    if (_this36.backdrop === 'static') {
                      _this36._bumpBackdrop();
                    } else if (_this36.backdrop === true && !preventClose) {
                      _this36._zone.run(function () {
                        return _this36.dismiss(_ModalDismissReasons.BACKDROP_CLICK);
                      });
                    }
                  }

                  preventClose = false;
                });
              });
            }
          }, {
            key: "_disableEventHandling",
            value: function _disableEventHandling() {
              this._closed$.next();
            }
          }, {
            key: "_setFocus",
            value: function _setFocus() {
              var nativeElement = this._elRef.nativeElement;

              if (!nativeElement.contains(document.activeElement)) {
                var autoFocusable = nativeElement.querySelector("[ngbAutofocus]");
                var firstFocusable = getFocusableBoundaryElements(nativeElement)[0];
                var elementToFocus = autoFocusable || firstFocusable || nativeElement;
                elementToFocus.focus();
              }
            }
          }, {
            key: "_restoreFocus",
            value: function _restoreFocus() {
              var _this37 = this;

              var body = this._document.body;
              var elWithFocus = this._elWithFocus;
              var elementToFocus;

              if (elWithFocus && elWithFocus['focus'] && body.contains(elWithFocus)) {
                elementToFocus = elWithFocus;
              } else {
                elementToFocus = body;
              }

              this._zone.runOutsideAngular(function () {
                setTimeout(function () {
                  return elementToFocus.focus();
                });
                _this37._elWithFocus = null;
              });
            }
          }, {
            key: "_bumpBackdrop",
            value: function _bumpBackdrop() {
              if (this.backdrop === 'static') {
                ngbRunTransition(this._zone, this._elRef.nativeElement, function (_ref23) {
                  var classList = _ref23.classList;
                  classList.add('modal-static');
                  return function () {
                    return classList.remove('modal-static');
                  };
                }, {
                  animation: this.animation,
                  runningTransition: 'continue'
                });
              }
            }
          }]);

          return NgbModalWindow;
        }();

        NgbModalWindow.ɵfac = function NgbModalWindow_Factory(t) {
          return new (t || NgbModalWindow)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbModalWindow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbModalWindow,
          selectors: [["ngb-modal-window"]],
          viewQuery: function NgbModalWindow_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c31, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._dialogEl = _t.first);
            }
          },
          hostAttrs: ["role", "dialog", "tabindex", "-1"],
          hostVars: 7,
          hostBindings: function NgbModalWindow_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-modal", true)("aria-labelledby", ctx.ariaLabelledBy)("aria-describedby", ctx.ariaDescribedBy);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("modal d-block" + (ctx.windowClass ? " " + ctx.windowClass : ""));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.animation);
            }
          },
          inputs: {
            backdrop: "backdrop",
            keyboard: "keyboard",
            animation: "animation",
            ariaLabelledBy: "ariaLabelledBy",
            ariaDescribedBy: "ariaDescribedBy",
            centered: "centered",
            scrollable: "scrollable",
            size: "size",
            windowClass: "windowClass",
            modalDialogClass: "modalDialogClass"
          },
          outputs: {
            dismissEvent: "dismiss"
          },
          ngContentSelectors: _c3,
          decls: 4,
          vars: 2,
          consts: [["role", "document"], ["dialog", ""], [1, "modal-content"]],
          template: function NgbModalWindow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0, 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("modal-dialog" + (ctx.size ? " modal-" + ctx.size : "") + (ctx.centered ? " modal-dialog-centered" : "") + (ctx.scrollable ? " modal-dialog-scrollable" : "") + (ctx.modalDialogClass ? " " + ctx.modalDialogClass : ""));
            }
          },
          styles: ["ngb-modal-window .component-host-scrollable{display:flex;flex-direction:column;overflow:hidden}"],
          encapsulation: 2
        });
        return NgbModalWindow;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbModalStack = /*#__PURE__*/function () {
        var NgbModalStack = /*#__PURE__*/function () {
          function NgbModalStack(_applicationRef, _injector, _document, _scrollBar, _rendererFactory, _ngZone) {
            var _this38 = this;

            _classCallCheck(this, NgbModalStack);

            this._applicationRef = _applicationRef;
            this._injector = _injector;
            this._document = _document;
            this._scrollBar = _scrollBar;
            this._rendererFactory = _rendererFactory;
            this._ngZone = _ngZone;
            this._activeWindowCmptHasChanged = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._ariaHiddenValues = new Map();
            this._backdropAttributes = ['animation', 'backdropClass'];
            this._modalRefs = [];
            this._windowAttributes = ['animation', 'ariaLabelledBy', 'ariaDescribedBy', 'backdrop', 'centered', 'keyboard', 'scrollable', 'size', 'windowClass', 'modalDialogClass'];
            this._windowCmpts = [];
            this._activeInstances = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(); // Trap focus on active WindowCmpt

            this._activeWindowCmptHasChanged.subscribe(function () {
              if (_this38._windowCmpts.length) {
                var activeWindowCmpt = _this38._windowCmpts[_this38._windowCmpts.length - 1];
                ngbFocusTrap(_this38._ngZone, activeWindowCmpt.location.nativeElement, _this38._activeWindowCmptHasChanged);

                _this38._revertAriaHidden();

                _this38._setAriaHidden(activeWindowCmpt.location.nativeElement);
              }
            });
          }

          _createClass(NgbModalStack, [{
            key: "open",
            value: function open(moduleCFR, contentInjector, content, options) {
              var _this39 = this;

              var containerEl = options.container instanceof HTMLElement ? options.container : isDefined(options.container) ? this._document.querySelector(options.container) : this._document.body;

              var renderer = this._rendererFactory.createRenderer(null, null);

              var revertPaddingForScrollBar = this._scrollBar.compensate();

              var removeBodyClass = function removeBodyClass() {
                if (!_this39._modalRefs.length) {
                  renderer.removeClass(_this39._document.body, 'modal-open');

                  _this39._revertAriaHidden();
                }
              };

              if (!containerEl) {
                throw new Error("The specified modal container \"".concat(options.container || 'body', "\" was not found in the DOM."));
              }

              var activeModal = new _NgbActiveModal();

              var contentRef = this._getContentRef(moduleCFR, options.injector || contentInjector, content, activeModal, options);

              var backdropCmptRef = options.backdrop !== false ? this._attachBackdrop(moduleCFR, containerEl) : undefined;

              var windowCmptRef = this._attachWindowComponent(moduleCFR, containerEl, contentRef);

              var ngbModalRef = new _NgbModalRef(windowCmptRef, contentRef, backdropCmptRef, options.beforeDismiss);

              this._registerModalRef(ngbModalRef);

              this._registerWindowCmpt(windowCmptRef);

              ngbModalRef.result.then(revertPaddingForScrollBar, revertPaddingForScrollBar);
              ngbModalRef.result.then(removeBodyClass, removeBodyClass);

              activeModal.close = function (result) {
                ngbModalRef.close(result);
              };

              activeModal.dismiss = function (reason) {
                ngbModalRef.dismiss(reason);
              };

              this._applyWindowOptions(windowCmptRef.instance, options);

              if (this._modalRefs.length === 1) {
                renderer.addClass(this._document.body, 'modal-open');
              }

              if (backdropCmptRef && backdropCmptRef.instance) {
                this._applyBackdropOptions(backdropCmptRef.instance, options);

                backdropCmptRef.changeDetectorRef.detectChanges();
              }

              windowCmptRef.changeDetectorRef.detectChanges();
              return ngbModalRef;
            }
          }, {
            key: "activeInstances",
            get: function get() {
              return this._activeInstances;
            }
          }, {
            key: "dismissAll",
            value: function dismissAll(reason) {
              this._modalRefs.forEach(function (ngbModalRef) {
                return ngbModalRef.dismiss(reason);
              });
            }
          }, {
            key: "hasOpenModals",
            value: function hasOpenModals() {
              return this._modalRefs.length > 0;
            }
          }, {
            key: "_attachBackdrop",
            value: function _attachBackdrop(moduleCFR, containerEl) {
              var backdropFactory = moduleCFR.resolveComponentFactory(NgbModalBackdrop);
              var backdropCmptRef = backdropFactory.create(this._injector);

              this._applicationRef.attachView(backdropCmptRef.hostView);

              containerEl.appendChild(backdropCmptRef.location.nativeElement);
              return backdropCmptRef;
            }
          }, {
            key: "_attachWindowComponent",
            value: function _attachWindowComponent(moduleCFR, containerEl, contentRef) {
              var windowFactory = moduleCFR.resolveComponentFactory(NgbModalWindow);
              var windowCmptRef = windowFactory.create(this._injector, contentRef.nodes);

              this._applicationRef.attachView(windowCmptRef.hostView);

              containerEl.appendChild(windowCmptRef.location.nativeElement);
              return windowCmptRef;
            }
          }, {
            key: "_applyWindowOptions",
            value: function _applyWindowOptions(windowInstance, options) {
              this._windowAttributes.forEach(function (optionName) {
                if (isDefined(options[optionName])) {
                  windowInstance[optionName] = options[optionName];
                }
              });
            }
          }, {
            key: "_applyBackdropOptions",
            value: function _applyBackdropOptions(backdropInstance, options) {
              this._backdropAttributes.forEach(function (optionName) {
                if (isDefined(options[optionName])) {
                  backdropInstance[optionName] = options[optionName];
                }
              });
            }
          }, {
            key: "_getContentRef",
            value: function _getContentRef(moduleCFR, contentInjector, content, activeModal, options) {
              if (!content) {
                return new ContentRef([]);
              } else if (content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef) {
                return this._createFromTemplateRef(content, activeModal);
              } else if (isString(content)) {
                return this._createFromString(content);
              } else {
                return this._createFromComponent(moduleCFR, contentInjector, content, activeModal, options);
              }
            }
          }, {
            key: "_createFromTemplateRef",
            value: function _createFromTemplateRef(content, activeModal) {
              var context = {
                $implicit: activeModal,
                close: function close(result) {
                  activeModal.close(result);
                },
                dismiss: function dismiss(reason) {
                  activeModal.dismiss(reason);
                }
              };
              var viewRef = content.createEmbeddedView(context);

              this._applicationRef.attachView(viewRef);

              return new ContentRef([viewRef.rootNodes], viewRef);
            }
          }, {
            key: "_createFromString",
            value: function _createFromString(content) {
              var component = this._document.createTextNode("".concat(content));

              return new ContentRef([[component]]);
            }
          }, {
            key: "_createFromComponent",
            value: function _createFromComponent(moduleCFR, contentInjector, content, context, options) {
              var contentCmptFactory = moduleCFR.resolveComponentFactory(content);

              var modalContentInjector = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
                providers: [{
                  provide: _NgbActiveModal,
                  useValue: context
                }],
                parent: contentInjector
              });

              var componentRef = contentCmptFactory.create(modalContentInjector);
              var componentNativeEl = componentRef.location.nativeElement;

              if (options.scrollable) {
                componentNativeEl.classList.add('component-host-scrollable');
              }

              this._applicationRef.attachView(componentRef.hostView); // FIXME: we should here get rid of the component nativeElement
              // and use `[Array.from(componentNativeEl.childNodes)]` instead and remove the above CSS class.


              return new ContentRef([[componentNativeEl]], componentRef.hostView, componentRef);
            }
          }, {
            key: "_setAriaHidden",
            value: function _setAriaHidden(element) {
              var _this40 = this;

              var parent = element.parentElement;

              if (parent && element !== this._document.body) {
                Array.from(parent.children).forEach(function (sibling) {
                  if (sibling !== element && sibling.nodeName !== 'SCRIPT') {
                    _this40._ariaHiddenValues.set(sibling, sibling.getAttribute('aria-hidden'));

                    sibling.setAttribute('aria-hidden', 'true');
                  }
                });

                this._setAriaHidden(parent);
              }
            }
          }, {
            key: "_revertAriaHidden",
            value: function _revertAriaHidden() {
              this._ariaHiddenValues.forEach(function (value, element) {
                if (value) {
                  element.setAttribute('aria-hidden', value);
                } else {
                  element.removeAttribute('aria-hidden');
                }
              });

              this._ariaHiddenValues.clear();
            }
          }, {
            key: "_registerModalRef",
            value: function _registerModalRef(ngbModalRef) {
              var _this41 = this;

              var unregisterModalRef = function unregisterModalRef() {
                var index = _this41._modalRefs.indexOf(ngbModalRef);

                if (index > -1) {
                  _this41._modalRefs.splice(index, 1);

                  _this41._activeInstances.emit(_this41._modalRefs);
                }
              };

              this._modalRefs.push(ngbModalRef);

              this._activeInstances.emit(this._modalRefs);

              ngbModalRef.result.then(unregisterModalRef, unregisterModalRef);
            }
          }, {
            key: "_registerWindowCmpt",
            value: function _registerWindowCmpt(ngbWindowCmpt) {
              var _this42 = this;

              this._windowCmpts.push(ngbWindowCmpt);

              this._activeWindowCmptHasChanged.next();

              ngbWindowCmpt.onDestroy(function () {
                var index = _this42._windowCmpts.indexOf(ngbWindowCmpt);

                if (index > -1) {
                  _this42._windowCmpts.splice(index, 1);

                  _this42._activeWindowCmptHasChanged.next();
                }
              });
            }
          }]);

          return NgbModalStack;
        }();

        NgbModalStack.ɵfac = function NgbModalStack_Factory(t) {
          return new (t || NgbModalStack)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](ScrollBar), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbModalStack.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbModalStack_Factory() {
            return new NgbModalStack((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.INJECTOR), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(ScrollBar), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
          },
          token: NgbModalStack,
          providedIn: "root"
        });
        return NgbModalStack;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A service for opening modal windows.
       *
       * Creating a modal is straightforward: create a component or a template and pass it as an argument to
       * the `.open()` method.
       */


      var _NgbModal = /*#__PURE__*/function () {
        var NgbModal = /*#__PURE__*/function () {
          function NgbModal(_moduleCFR, _injector, _modalStack, _config) {
            _classCallCheck(this, NgbModal);

            this._moduleCFR = _moduleCFR;
            this._injector = _injector;
            this._modalStack = _modalStack;
            this._config = _config;
          }
          /**
           * Opens a new modal window with the specified content and supplied options.
           *
           * Content can be provided as a `TemplateRef` or a component type. If you pass a component type as content,
           * then instances of those components can be injected with an instance of the `NgbActiveModal` class. You can then
           * use `NgbActiveModal` methods to close / dismiss modals from "inside" of your component.
           *
           * Also see the [`NgbModalOptions`](#/components/modal/api#NgbModalOptions) for the list of supported options.
           */


          _createClass(NgbModal, [{
            key: "open",
            value: function open(content) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var combinedOptions = Object.assign(Object.assign(Object.assign({}, this._config), {
                animation: this._config.animation
              }), options);
              return this._modalStack.open(this._moduleCFR, this._injector, content, combinedOptions);
            }
            /**
             * Returns an observable that holds the active modal instances.
             */

          }, {
            key: "activeInstances",
            get: function get() {
              return this._modalStack.activeInstances;
            }
            /**
             * Dismisses all currently displayed modal windows with the supplied reason.
             *
             * @since 3.1.0
             */

          }, {
            key: "dismissAll",
            value: function dismissAll(reason) {
              this._modalStack.dismissAll(reason);
            }
            /**
             * Indicates if there are currently any open modal windows in the application.
             *
             * @since 3.3.0
             */

          }, {
            key: "hasOpenModals",
            value: function hasOpenModals() {
              return this._modalStack.hasOpenModals();
            }
          }]);

          return NgbModal;
        }();

        NgbModal.ɵfac = function NgbModal_Factory(t) {
          return new (t || NgbModal)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](NgbModalStack), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbModalConfig));
        };

        NgbModal.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbModal_Factory() {
            return new NgbModal((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.INJECTOR), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(NgbModalStack), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbModalConfig));
          },
          token: NgbModal,
          providedIn: "root"
        });
        return NgbModal;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbModalModule = /*#__PURE__*/function () {
        var NgbModalModule = function NgbModalModule() {
          _classCallCheck(this, NgbModalModule);
        };

        NgbModalModule.ɵfac = function NgbModalModule_Factory(t) {
          return new (t || NgbModalModule)();
        };

        NgbModalModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbModalModule
        });
        NgbModalModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          providers: [_NgbModal]
        });
        return NgbModalModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbModalModule, {
          declarations: [NgbModalBackdrop, NgbModalWindow]
        });
      })();
      /**
       * A configuration service for the [`NgbNav`](#/components/nav/api#NgbNav) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the navs used in the application.
       *
       * @since 5.2.0
       */


      var _NgbNavConfig = /*#__PURE__*/function () {
        var NgbNavConfig = /*#__PURE__*/function () {
          function NgbNavConfig(_ngbConfig) {
            _classCallCheck(this, NgbNavConfig);

            this._ngbConfig = _ngbConfig;
            this.destroyOnHide = true;
            this.orientation = 'horizontal';
            this.roles = 'tablist';
            this.keyboard = false;
          }

          _createClass(NgbNavConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbNavConfig;
        }();

        NgbNavConfig.ɵfac = function NgbNavConfig_Factory(t) {
          return new (t || NgbNavConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbNavConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbNavConfig_Factory() {
            return new NgbNavConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbNavConfig,
          providedIn: "root"
        });
        return NgbNavConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var isValidNavId = function isValidNavId(id) {
        return isDefined(id) && id !== '';
      };

      var ɵ0$4 = isValidNavId;
      var navCounter = 0;
      /**
       * This directive must be used to wrap content to be displayed in the nav.
       *
       * @since 5.2.0
       */

      var _NgbNavContent = /*#__PURE__*/function () {
        var NgbNavContent = function NgbNavContent(templateRef) {
          _classCallCheck(this, NgbNavContent);

          this.templateRef = templateRef;
        };

        NgbNavContent.ɵfac = function NgbNavContent_Factory(t) {
          return new (t || NgbNavContent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbNavContent.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNavContent,
          selectors: [["ng-template", "ngbNavContent", ""]]
        });
        return NgbNavContent;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * The directive used to group nav link and related nav content. As well as set nav identifier and some options.
       *
       * @since 5.2.0
       */


      var _NgbNavItem = /*#__PURE__*/function () {
        var NgbNavItem = /*#__PURE__*/function () {
          function NgbNavItem(nav, elementRef) {
            _classCallCheck(this, NgbNavItem);

            this.elementRef = elementRef;
            /**
             * If `true`, the current nav item is disabled and can't be toggled by user.
             *
             * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
             */

            this.disabled = false;
            /**
             * An event emitted when the fade in transition is finished on the related nav content
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the fade out transition is finished on the related nav content
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(); // TODO: cf https://github.com/angular/angular/issues/30106

            this._nav = nav;
          }

          _createClass(NgbNavItem, [{
            key: "ngAfterContentChecked",
            value: function ngAfterContentChecked() {
              // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
              // only @ContentChildren allows us to specify the {descendants: false} option.
              // Without {descendants: false} we are hitting bugs described in:
              // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
              this.contentTpl = this.contentTpls.first;
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              if (!isDefined(this.domId)) {
                this.domId = "ngb-nav-".concat(navCounter++);
              }
            }
          }, {
            key: "active",
            get: function get() {
              return this._nav.activeId === this.id;
            }
          }, {
            key: "id",
            get: function get() {
              return isValidNavId(this._id) ? this._id : this.domId;
            }
          }, {
            key: "panelDomId",
            get: function get() {
              return "".concat(this.domId, "-panel");
            }
          }, {
            key: "isPanelInDom",
            value: function isPanelInDom() {
              return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;
            }
          }]);

          return NgbNavItem;
        }();

        NgbNavItem.ɵfac = function NgbNavItem_Factory(t) {
          return new (t || NgbNavItem)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"]((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
            return _NgbNav;
          })), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbNavItem.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNavItem,
          selectors: [["", "ngbNavItem", ""]],
          contentQueries: function NgbNavItem_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbNavContent, 4);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.contentTpls = _t);
            }
          },
          hostVars: 2,
          hostBindings: function NgbNavItem_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("nav-item", true);
            }
          },
          inputs: {
            disabled: "disabled",
            domId: "domId",
            destroyOnHide: "destroyOnHide",
            _id: ["ngbNavItem", "_id"]
          },
          outputs: {
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbNavItem"]
        });
        return NgbNavItem;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A nav directive that helps with implementing tabbed navigation components.
       *
       * @since 5.2.0
       */


      var _NgbNav = /*#__PURE__*/function () {
        var NgbNav = /*#__PURE__*/function () {
          function NgbNav(role, config, _cd, _document) {
            _classCallCheck(this, NgbNav);

            this.role = role;
            this._cd = _cd;
            this._document = _document;
            /**
             * The event emitted after the active nav changes
             * The payload of the event is the newly active nav id
             *
             * If you want to prevent nav change, you should use `(navChange)` event
             */

            this.activeIdChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the fade in transition is finished for one of the items.
             *
             * Payload of the event is the nav id that was just shown.
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the fade out transition is finished for one of the items.
             *
             * Payload of the event is the nav id that was just hidden.
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this.navItemChange$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            /**
             * The nav change event emitted right before the nav change happens on user click.
             *
             * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
             *
             * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
             */

            this.navChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.animation = config.animation;
            this.destroyOnHide = config.destroyOnHide;
            this.orientation = config.orientation;
            this.roles = config.roles;
            this.keyboard = config.keyboard;
          }

          _createClass(NgbNav, [{
            key: "click",
            value: function click(item) {
              if (!item.disabled) {
                this._updateActiveId(item.id);
              }
            }
          }, {
            key: "onKeyDown",
            value: function onKeyDown(event) {
              var _this43 = this;

              if (this.roles !== 'tablist' || !this.keyboard) {
                return;
              } // tslint:disable-next-line: deprecation


              var key = event.which;
              var enabledLinks = this.links.filter(function (link) {
                return !link.navItem.disabled;
              });
              var length = enabledLinks.length;
              var position = -1;
              enabledLinks.forEach(function (link, index) {
                if (link.elRef.nativeElement === _this43._document.activeElement) {
                  position = index;
                }
              });

              if (length) {
                switch (key) {
                  case Key.ArrowLeft:
                    if (this.orientation === 'vertical') {
                      return;
                    }

                    position = (position - 1 + length) % length;
                    break;

                  case Key.ArrowRight:
                    if (this.orientation === 'vertical') {
                      return;
                    }

                    position = (position + 1) % length;
                    break;

                  case Key.ArrowDown:
                    if (this.orientation === 'horizontal') {
                      return;
                    }

                    position = (position + 1) % length;
                    break;

                  case Key.ArrowUp:
                    if (this.orientation === 'horizontal') {
                      return;
                    }

                    position = (position - 1 + length) % length;
                    break;

                  case Key.Home:
                    position = 0;
                    break;

                  case Key.End:
                    position = length - 1;
                    break;
                }

                if (this.keyboard === 'changeWithArrows') {
                  this.select(enabledLinks[position].navItem.id);
                }

                enabledLinks[position].elRef.nativeElement.focus();
                event.preventDefault();
              }
            }
            /**
             * Selects the nav with the given id and shows its associated pane.
             * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
             */

          }, {
            key: "select",
            value: function select(id) {
              this._updateActiveId(id, false);
            }
          }, {
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              var _this44 = this;

              if (!isDefined(this.activeId)) {
                var _nextId = this.items.first ? this.items.first.id : null;

                if (isValidNavId(_nextId)) {
                  this._updateActiveId(_nextId, false);

                  this._cd.detectChanges();
                }
              }

              this.items.changes.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(function () {
                return _this44._notifyItemChanged(_this44.activeId);
              });
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(_ref24) {
              var activeId = _ref24.activeId;

              if (activeId && !activeId.firstChange) {
                this._notifyItemChanged(activeId.currentValue);
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.destroy$.next();
            }
          }, {
            key: "_updateActiveId",
            value: function _updateActiveId(nextId) {
              var emitNavChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

              if (this.activeId !== nextId) {
                var defaultPrevented = false;

                if (emitNavChange) {
                  this.navChange.emit({
                    activeId: this.activeId,
                    nextId: nextId,
                    preventDefault: function preventDefault() {
                      defaultPrevented = true;
                    }
                  });
                }

                if (!defaultPrevented) {
                  this.activeId = nextId;
                  this.activeIdChange.emit(nextId);

                  this._notifyItemChanged(nextId);
                }
              }
            }
          }, {
            key: "_notifyItemChanged",
            value: function _notifyItemChanged(nextItemId) {
              this.navItemChange$.next(this._getItemById(nextItemId));
            }
          }, {
            key: "_getItemById",
            value: function _getItemById(itemId) {
              return this.items && this.items.find(function (item) {
                return item.id === itemId;
              }) || null;
            }
          }]);

          return NgbNav;
        }();

        NgbNav.ɵfac = function NgbNav_Factory(t) {
          return new (t || NgbNav)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinjectAttribute"]('role'), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbNavConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
        };

        NgbNav.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNav,
          selectors: [["", "ngbNav", ""]],
          contentQueries: function NgbNav_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbNavItem, 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbNavLink, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.items = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.links = _t);
            }
          },
          hostVars: 6,
          hostBindings: function NgbNav_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown.arrowLeft", function NgbNav_keydown_arrowLeft_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              })("keydown.arrowRight", function NgbNav_keydown_arrowRight_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              })("keydown.arrowDown", function NgbNav_keydown_arrowDown_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              })("keydown.arrowUp", function NgbNav_keydown_arrowUp_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              })("keydown.Home", function NgbNav_keydown_Home_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              })("keydown.End", function NgbNav_keydown_End_HostBindingHandler($event) {
                return ctx.onKeyDown($event);
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-orientation", ctx.orientation === "vertical" && ctx.roles === "tablist" ? "vertical" : undefined)("role", ctx.role ? ctx.role : ctx.roles ? "tablist" : undefined);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("nav", true)("flex-column", ctx.orientation === "vertical");
            }
          },
          inputs: {
            animation: "animation",
            destroyOnHide: "destroyOnHide",
            orientation: "orientation",
            roles: "roles",
            keyboard: "keyboard",
            activeId: "activeId"
          },
          outputs: {
            activeIdChange: "activeIdChange",
            shown: "shown",
            hidden: "hidden",
            navChange: "navChange"
          },
          exportAs: ["ngbNav"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbNav;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to put on the nav link.
       *
       * @since 5.2.0
       */


      var _NgbNavLink = /*#__PURE__*/function () {
        var NgbNavLink = /*#__PURE__*/function () {
          function NgbNavLink(role, navItem, nav, elRef) {
            _classCallCheck(this, NgbNavLink);

            this.role = role;
            this.navItem = navItem;
            this.nav = nav;
            this.elRef = elRef;
          }

          _createClass(NgbNavLink, [{
            key: "hasNavItemClass",
            value: function hasNavItemClass() {
              // with alternative markup we have to add `.nav-item` class, because `ngbNavItem` is on the ng-container
              return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE;
            }
          }]);

          return NgbNavLink;
        }();

        NgbNavLink.ɵfac = function NgbNavLink_Factory(t) {
          return new (t || NgbNavLink)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinjectAttribute"]('role'), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbNavItem), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbNav), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbNavLink.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNavLink,
          selectors: [["a", "ngbNavLink", ""]],
          hostAttrs: ["href", ""],
          hostVars: 14,
          hostBindings: function NgbNavLink_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgbNavLink_click_HostBindingHandler($event) {
                ctx.nav.click(ctx.navItem);
                return $event.preventDefault();
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("id", ctx.navItem.domId);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("role", ctx.role ? ctx.role : ctx.nav.roles ? "tab" : undefined)("tabindex", ctx.navItem.disabled ? -1 : undefined)("aria-controls", ctx.navItem.isPanelInDom() ? ctx.navItem.panelDomId : null)("aria-selected", ctx.navItem.active)("aria-disabled", ctx.navItem.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("nav-link", true)("nav-item", ctx.hasNavItemClass())("active", ctx.navItem.active)("disabled", ctx.navItem.disabled);
            }
          }
        });
        return NgbNavLink;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var ngbNavFadeOutTransition = function ngbNavFadeOutTransition(_ref25) {
        var classList = _ref25.classList;
        classList.remove('show');
        return function () {
          return classList.remove('active');
        };
      };

      var ngbNavFadeInTransition = function ngbNavFadeInTransition(element, animation) {
        if (animation) {
          reflow(element);
        }

        element.classList.add('show');
      };

      var _NgbNavPane = /*#__PURE__*/function () {
        var NgbNavPane = function NgbNavPane(elRef) {
          _classCallCheck(this, NgbNavPane);

          this.elRef = elRef;
        };

        NgbNavPane.ɵfac = function NgbNavPane_Factory(t) {
          return new (t || NgbNavPane)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbNavPane.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbNavPane,
          selectors: [["", "ngbNavPane", ""]],
          hostAttrs: [1, "tab-pane"],
          hostVars: 5,
          hostBindings: function NgbNavPane_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("id", ctx.item.panelDomId);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("role", ctx.role ? ctx.role : ctx.nav.roles ? "tabpanel" : undefined)("aria-labelledby", ctx.item.domId);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.nav.animation);
            }
          },
          inputs: {
            item: "item",
            nav: "nav",
            role: "role"
          }
        });
        return NgbNavPane;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * The outlet where currently active nav content will be displayed.
       *
       * @since 5.2.0
       */


      var _NgbNavOutlet = /*#__PURE__*/function () {
        var NgbNavOutlet = /*#__PURE__*/function () {
          function NgbNavOutlet(_cd, _ngZone) {
            _classCallCheck(this, NgbNavOutlet);

            this._cd = _cd;
            this._ngZone = _ngZone;
            this._activePane = null;
          }

          _createClass(NgbNavOutlet, [{
            key: "isPanelTransitioning",
            value: function isPanelTransitioning(item) {
              var _a;

              return ((_a = this._activePane) === null || _a === void 0 ? void 0 : _a.item) === item;
            }
          }, {
            key: "ngAfterViewInit",
            value: function ngAfterViewInit() {
              var _this45 = this;

              var _a; // initial display


              this._updateActivePane(); // this will be emitted for all 3 types of nav changes: .select(), [activeId] or (click)


              this.nav.navItemChange$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.nav.destroy$), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(((_a = this._activePane) === null || _a === void 0 ? void 0 : _a.item) || null), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.distinctUntilChanged)(), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.skip)(1)).subscribe(function (nextItem) {
                var options = {
                  animation: _this45.nav.animation,
                  runningTransition: 'stop'
                }; // next panel we're switching to will only appear in DOM after the change detection is done
                // and `this._panes` will be updated

                _this45._cd.detectChanges(); // fading out


                if (_this45._activePane) {
                  ngbRunTransition(_this45._ngZone, _this45._activePane.elRef.nativeElement, ngbNavFadeOutTransition, options).subscribe(function () {
                    var _a;

                    var activeItem = (_a = _this45._activePane) === null || _a === void 0 ? void 0 : _a.item;
                    _this45._activePane = _this45._getPaneForItem(nextItem); // mark for check when transition finishes as outlet or parent containers might be OnPush
                    // without this the panes that have "faded out" will stay in DOM

                    _this45._cd.markForCheck(); // fading in


                    if (_this45._activePane) {
                      // we have to add the '.active' class before running the transition,
                      // because it should be in place before `ngbRunTransition` does `reflow()`
                      _this45._activePane.elRef.nativeElement.classList.add('active');

                      ngbRunTransition(_this45._ngZone, _this45._activePane.elRef.nativeElement, ngbNavFadeInTransition, options).subscribe(function () {
                        if (nextItem) {
                          nextItem.shown.emit();

                          _this45.nav.shown.emit(nextItem.id);
                        }
                      });
                    }

                    if (activeItem) {
                      activeItem.hidden.emit();

                      _this45.nav.hidden.emit(activeItem.id);
                    }
                  });
                } else {
                  _this45._updateActivePane();
                }
              });
            }
          }, {
            key: "_updateActivePane",
            value: function _updateActivePane() {
              var _a, _b;

              this._activePane = this._getActivePane();
              (_a = this._activePane) === null || _a === void 0 ? void 0 : _a.elRef.nativeElement.classList.add('show');
              (_b = this._activePane) === null || _b === void 0 ? void 0 : _b.elRef.nativeElement.classList.add('active');
            }
          }, {
            key: "_getPaneForItem",
            value: function _getPaneForItem(item) {
              return this._panes && this._panes.find(function (pane) {
                return pane.item === item;
              }) || null;
            }
          }, {
            key: "_getActivePane",
            value: function _getActivePane() {
              return this._panes && this._panes.find(function (pane) {
                return pane.item.active;
              }) || null;
            }
          }]);

          return NgbNavOutlet;
        }();

        NgbNavOutlet.ɵfac = function NgbNavOutlet_Factory(t) {
          return new (t || NgbNavOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        NgbNavOutlet.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbNavOutlet,
          selectors: [["", "ngbNavOutlet", ""]],
          viewQuery: function NgbNavOutlet_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_NgbNavPane, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._panes = _t);
            }
          },
          hostVars: 2,
          hostBindings: function NgbNavOutlet_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("tab-content", true);
            }
          },
          inputs: {
            paneRole: "paneRole",
            nav: ["ngbNavOutlet", "nav"]
          },
          attrs: _c32,
          decls: 1,
          vars: 1,
          consts: [["ngFor", "", 3, "ngForOf"], ["ngbNavPane", "", 3, "item", "nav", "role", 4, "ngIf"], ["ngbNavPane", "", 3, "item", "nav", "role"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
          template: function NgbNavOutlet_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbNavOutlet_ng_template_0_Template, 1, 1, "ng-template", 0);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.nav.items);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _NgbNavPane, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbNavOutlet;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NGB_NAV_DIRECTIVES = [_NgbNavContent, _NgbNav, _NgbNavItem, _NgbNavLink, _NgbNavOutlet, _NgbNavPane];

      var _NgbNavModule = /*#__PURE__*/function () {
        var NgbNavModule = function NgbNavModule() {
          _classCallCheck(this, NgbNavModule);
        };

        NgbNavModule.ɵfac = function NgbNavModule_Factory(t) {
          return new (t || NgbNavModule)();
        };

        NgbNavModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbNavModule
        });
        NgbNavModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbNavModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbNavModule, {
          declarations: function declarations() {
            return [_NgbNavContent, _NgbNav, _NgbNavItem, _NgbNavLink, _NgbNavOutlet, _NgbNavPane];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbNavContent, _NgbNav, _NgbNavItem, _NgbNavLink, _NgbNavOutlet, _NgbNavPane];
          }
        });
      })();
      /**
       * A configuration service for the [`NgbPagination`](#/components/pagination/api#NgbPagination) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the paginations used in the application.
       */


      var _NgbPaginationConfig = /*#__PURE__*/function () {
        var NgbPaginationConfig = function NgbPaginationConfig() {
          _classCallCheck(this, NgbPaginationConfig);

          this.disabled = false;
          this.boundaryLinks = false;
          this.directionLinks = true;
          this.ellipses = true;
          this.maxSize = 0;
          this.pageSize = 10;
          this.rotate = false;
        };

        NgbPaginationConfig.ɵfac = function NgbPaginationConfig_Factory(t) {
          return new (t || NgbPaginationConfig)();
        };

        NgbPaginationConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbPaginationConfig_Factory() {
            return new NgbPaginationConfig();
          },
          token: NgbPaginationConfig,
          providedIn: "root"
        });
        return NgbPaginationConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'ellipsis' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationEllipsis = /*#__PURE__*/function () {
        var NgbPaginationEllipsis = function NgbPaginationEllipsis(templateRef) {
          _classCallCheck(this, NgbPaginationEllipsis);

          this.templateRef = templateRef;
        };

        NgbPaginationEllipsis.ɵfac = function NgbPaginationEllipsis_Factory(t) {
          return new (t || NgbPaginationEllipsis)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationEllipsis.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationEllipsis,
          selectors: [["ng-template", "ngbPaginationEllipsis", ""]]
        });
        return NgbPaginationEllipsis;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'first' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationFirst = /*#__PURE__*/function () {
        var NgbPaginationFirst = function NgbPaginationFirst(templateRef) {
          _classCallCheck(this, NgbPaginationFirst);

          this.templateRef = templateRef;
        };

        NgbPaginationFirst.ɵfac = function NgbPaginationFirst_Factory(t) {
          return new (t || NgbPaginationFirst)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationFirst.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationFirst,
          selectors: [["ng-template", "ngbPaginationFirst", ""]]
        });
        return NgbPaginationFirst;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'last' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationLast = /*#__PURE__*/function () {
        var NgbPaginationLast = function NgbPaginationLast(templateRef) {
          _classCallCheck(this, NgbPaginationLast);

          this.templateRef = templateRef;
        };

        NgbPaginationLast.ɵfac = function NgbPaginationLast_Factory(t) {
          return new (t || NgbPaginationLast)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationLast.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationLast,
          selectors: [["ng-template", "ngbPaginationLast", ""]]
        });
        return NgbPaginationLast;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'next' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationNext = /*#__PURE__*/function () {
        var NgbPaginationNext = function NgbPaginationNext(templateRef) {
          _classCallCheck(this, NgbPaginationNext);

          this.templateRef = templateRef;
        };

        NgbPaginationNext.ɵfac = function NgbPaginationNext_Factory(t) {
          return new (t || NgbPaginationNext)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationNext.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationNext,
          selectors: [["ng-template", "ngbPaginationNext", ""]]
        });
        return NgbPaginationNext;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the page 'number' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationNumber = /*#__PURE__*/function () {
        var NgbPaginationNumber = function NgbPaginationNumber(templateRef) {
          _classCallCheck(this, NgbPaginationNumber);

          this.templateRef = templateRef;
        };

        NgbPaginationNumber.ɵfac = function NgbPaginationNumber_Factory(t) {
          return new (t || NgbPaginationNumber)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationNumber.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationNumber,
          selectors: [["ng-template", "ngbPaginationNumber", ""]]
        });
        return NgbPaginationNumber;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'previous' link template
       *
       * @since 4.1.0
       */


      var _NgbPaginationPrevious = /*#__PURE__*/function () {
        var NgbPaginationPrevious = function NgbPaginationPrevious(templateRef) {
          _classCallCheck(this, NgbPaginationPrevious);

          this.templateRef = templateRef;
        };

        NgbPaginationPrevious.ɵfac = function NgbPaginationPrevious_Factory(t) {
          return new (t || NgbPaginationPrevious)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationPrevious.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationPrevious,
          selectors: [["ng-template", "ngbPaginationPrevious", ""]]
        });
        return NgbPaginationPrevious;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive to match the 'pages' whole content
       *
       * @since 9.1.0
       */


      var _NgbPaginationPages = /*#__PURE__*/function () {
        var NgbPaginationPages = function NgbPaginationPages(templateRef) {
          _classCallCheck(this, NgbPaginationPages);

          this.templateRef = templateRef;
        };

        NgbPaginationPages.ɵfac = function NgbPaginationPages_Factory(t) {
          return new (t || NgbPaginationPages)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        NgbPaginationPages.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPaginationPages,
          selectors: [["ng-template", "ngbPaginationPages", ""]]
        });
        return NgbPaginationPages;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A component that displays page numbers and allows to customize them in several ways.
       */


      var _NgbPagination = /*#__PURE__*/function () {
        var NgbPagination = /*#__PURE__*/function () {
          function NgbPagination(config) {
            _classCallCheck(this, NgbPagination);

            this.pageCount = 0;
            this.pages = [];
            /**
             *  The current page.
             *
             *  Page numbers start with `1`.
             */

            this.page = 1;
            /**
             *  An event fired when the page is changed. Will fire only if collection size is set and all values are valid.
             *
             *  Event payload is the number of the newly selected page.
             *
             *  Page numbers start with `1`.
             */

            this.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(true);
            this.disabled = config.disabled;
            this.boundaryLinks = config.boundaryLinks;
            this.directionLinks = config.directionLinks;
            this.ellipses = config.ellipses;
            this.maxSize = config.maxSize;
            this.pageSize = config.pageSize;
            this.rotate = config.rotate;
            this.size = config.size;
          }

          _createClass(NgbPagination, [{
            key: "hasPrevious",
            value: function hasPrevious() {
              return this.page > 1;
            }
          }, {
            key: "hasNext",
            value: function hasNext() {
              return this.page < this.pageCount;
            }
          }, {
            key: "nextDisabled",
            value: function nextDisabled() {
              return !this.hasNext() || this.disabled;
            }
          }, {
            key: "previousDisabled",
            value: function previousDisabled() {
              return !this.hasPrevious() || this.disabled;
            }
          }, {
            key: "selectPage",
            value: function selectPage(pageNumber) {
              this._updatePages(pageNumber);
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              this._updatePages(this.page);
            }
          }, {
            key: "isEllipsis",
            value: function isEllipsis(pageNumber) {
              return pageNumber === -1;
            }
            /**
             * Appends ellipses and first/last page number to the displayed pages
             */

          }, {
            key: "_applyEllipses",
            value: function _applyEllipses(start, end) {
              if (this.ellipses) {
                if (start > 0) {
                  // The first page will always be included. If the displayed range
                  // starts after the third page, then add ellipsis. But if the range
                  // starts on the third page, then add the second page instead of
                  // an ellipsis, because the ellipsis would only hide a single page.
                  if (start > 2) {
                    this.pages.unshift(-1);
                  } else if (start === 2) {
                    this.pages.unshift(2);
                  }

                  this.pages.unshift(1);
                }

                if (end < this.pageCount) {
                  // The last page will always be included. If the displayed range
                  // ends before the third-last page, then add ellipsis. But if the range
                  // ends on third-last page, then add the second-last page instead of
                  // an ellipsis, because the ellipsis would only hide a single page.
                  if (end < this.pageCount - 2) {
                    this.pages.push(-1);
                  } else if (end === this.pageCount - 2) {
                    this.pages.push(this.pageCount - 1);
                  }

                  this.pages.push(this.pageCount);
                }
              }
            }
            /**
             * Rotates page numbers based on maxSize items visible.
             * Currently selected page stays in the middle:
             *
             * Ex. for selected page = 6:
             * [5,*6*,7] for maxSize = 3
             * [4,5,*6*,7] for maxSize = 4
             */

          }, {
            key: "_applyRotation",
            value: function _applyRotation() {
              var start = 0;
              var end = this.pageCount;
              var leftOffset = Math.floor(this.maxSize / 2);
              var rightOffset = this.maxSize % 2 === 0 ? leftOffset - 1 : leftOffset;

              if (this.page <= leftOffset) {
                // very beginning, no rotation -> [0..maxSize]
                end = this.maxSize;
              } else if (this.pageCount - this.page < leftOffset) {
                // very end, no rotation -> [len-maxSize..len]
                start = this.pageCount - this.maxSize;
              } else {
                // rotate
                start = this.page - leftOffset - 1;
                end = this.page + rightOffset;
              }

              return [start, end];
            }
            /**
             * Paginates page numbers based on maxSize items per page.
             */

          }, {
            key: "_applyPagination",
            value: function _applyPagination() {
              var page = Math.ceil(this.page / this.maxSize) - 1;
              var start = page * this.maxSize;
              var end = start + this.maxSize;
              return [start, end];
            }
          }, {
            key: "_setPageInRange",
            value: function _setPageInRange(newPageNo) {
              var prevPageNo = this.page;
              this.page = getValueInRange(newPageNo, this.pageCount, 1);

              if (this.page !== prevPageNo && isNumber(this.collectionSize)) {
                this.pageChange.emit(this.page);
              }
            }
          }, {
            key: "_updatePages",
            value: function _updatePages(newPage) {
              this.pageCount = Math.ceil(this.collectionSize / this.pageSize);

              if (!isNumber(this.pageCount)) {
                this.pageCount = 0;
              } // fill-in model needed to render pages


              this.pages.length = 0;

              for (var i = 1; i <= this.pageCount; i++) {
                this.pages.push(i);
              } // set page within 1..max range


              this._setPageInRange(newPage); // apply maxSize if necessary


              if (this.maxSize > 0 && this.pageCount > this.maxSize) {
                var start = 0;
                var end = this.pageCount; // either paginating or rotating page numbers

                if (this.rotate) {
                  var _this$_applyRotation = this._applyRotation();

                  var _this$_applyRotation2 = _slicedToArray(_this$_applyRotation, 2);

                  start = _this$_applyRotation2[0];
                  end = _this$_applyRotation2[1];
                } else {
                  var _this$_applyPaginatio = this._applyPagination();

                  var _this$_applyPaginatio2 = _slicedToArray(_this$_applyPaginatio, 2);

                  start = _this$_applyPaginatio2[0];
                  end = _this$_applyPaginatio2[1];
                }

                this.pages = this.pages.slice(start, end); // adding ellipses

                this._applyEllipses(start, end);
              }
            }
          }]);

          return NgbPagination;
        }();

        NgbPagination.ɵfac = function NgbPagination_Factory(t) {
          return new (t || NgbPagination)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbPaginationConfig));
        };

        NgbPagination.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbPagination,
          selectors: [["ngb-pagination"]],
          contentQueries: function NgbPagination_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationEllipsis, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationFirst, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationLast, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationNext, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationNumber, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationPrevious, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbPaginationPages, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplEllipsis = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplFirst = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplLast = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplNext = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplNumber = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplPrevious = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.tplPages = _t.first);
            }
          },
          hostAttrs: ["role", "navigation"],
          inputs: {
            page: "page",
            disabled: "disabled",
            boundaryLinks: "boundaryLinks",
            directionLinks: "directionLinks",
            ellipses: "ellipses",
            maxSize: "maxSize",
            pageSize: "pageSize",
            rotate: "rotate",
            size: "size",
            collectionSize: "collectionSize"
          },
          outputs: {
            pageChange: "pageChange"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          decls: 20,
          vars: 12,
          consts: function consts() {
            var i18n_34;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_first$$FESM2015_NG_BOOTSTRAP_JS__35 = goog.getMsg("\xAB\xAB");
              i18n_34 = MSG_EXTERNAL_ngb_pagination_first$$FESM2015_NG_BOOTSTRAP_JS__35;
            } else {
              i18n_34 = $localize(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([":@@ngb.pagination.first\u241F656506dfd46380956a655f919f1498d018f75ca0\u241F6867721956102594380:\xAB\xAB"])));
            }

            var i18n_36;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_previous$$FESM2015_NG_BOOTSTRAP_JS__37 = goog.getMsg("\xAB");
              i18n_36 = MSG_EXTERNAL_ngb_pagination_previous$$FESM2015_NG_BOOTSTRAP_JS__37;
            } else {
              i18n_36 = $localize(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([":@@ngb.pagination.previous\u241F6e52b6ee77a4848d899dd21b591c6fd499e3aef3\u241F6479320895410098858:\xAB"])));
            }

            var i18n_38;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_next$$FESM2015_NG_BOOTSTRAP_JS__39 = goog.getMsg("\xBB");
              i18n_38 = MSG_EXTERNAL_ngb_pagination_next$$FESM2015_NG_BOOTSTRAP_JS__39;
            } else {
              i18n_38 = $localize(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([":@@ngb.pagination.next\u241Fba9cbb4ff311464308a3627e4f1c3345d9fe6d7d\u241F5458177150283468089:\xBB"])));
            }

            var i18n_40;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_last$$FESM2015_NG_BOOTSTRAP_JS__41 = goog.getMsg("\xBB\xBB");
              i18n_40 = MSG_EXTERNAL_ngb_pagination_last$$FESM2015_NG_BOOTSTRAP_JS__41;
            } else {
              i18n_40 = $localize(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([":@@ngb.pagination.last\u241F49f27a460bc97e7e00be5b37098bfa79884fc7d9\u241F5277020320267646988:\xBB\xBB"])));
            }

            var i18n_44;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_first_aria$$FESM2015_NG_BOOTSTRAP_JS__45 = goog.getMsg("First");
              i18n_44 = MSG_EXTERNAL_ngb_pagination_first_aria$$FESM2015_NG_BOOTSTRAP_JS__45;
            } else {
              i18n_44 = $localize(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([":@@ngb.pagination.first-aria\u241Ff2f852318759c6396b5d3d17031d53817d7b38cc\u241F2241508602425256033:First"])));
            }

            var i18n_47;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_previous_aria$$FESM2015_NG_BOOTSTRAP_JS__48 = goog.getMsg("Previous");
              i18n_47 = MSG_EXTERNAL_ngb_pagination_previous_aria$$FESM2015_NG_BOOTSTRAP_JS__48;
            } else {
              i18n_47 = $localize(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([":@@ngb.pagination.previous-aria\u241F680d5c75b7fd8d37961083608b9fcdc4167b4c43\u241F4452427314943113135:Previous"])));
            }

            var i18n_50;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_next_aria$$FESM2015_NG_BOOTSTRAP_JS__51 = goog.getMsg("Next");
              i18n_50 = MSG_EXTERNAL_ngb_pagination_next_aria$$FESM2015_NG_BOOTSTRAP_JS__51;
            } else {
              i18n_50 = $localize(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([":@@ngb.pagination.next-aria\u241Ff732c304c7433e5a83ffcd862c3dce709a0f4982\u241F3885497195825665706:Next"])));
            }

            var i18n_52;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_pagination_last_aria$$FESM2015_NG_BOOTSTRAP_JS__53 = goog.getMsg("Last");
              i18n_52 = MSG_EXTERNAL_ngb_pagination_last_aria$$FESM2015_NG_BOOTSTRAP_JS__53;
            } else {
              i18n_52 = $localize(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([":@@ngb.pagination.last-aria\u241F5c729788ba138508aca1bec050b610f7bf81db3e\u241F4882268002141858767:Last"])));
            }

            return [["first", ""], ["previous", ""], ["next", ""], ["last", ""], ["ellipsis", ""], ["defaultNumber", ""], ["defaultPages", ""], ["class", "page-item", 3, "disabled", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true"], i18n_34, i18n_36, i18n_38, i18n_40, ["class", "sr-only", 4, "ngIf"], [1, "sr-only"], ["class", "page-item", 3, "active", "disabled", 4, "ngFor", "ngForOf"], [1, "page-item"], ["class", "page-link", "tabindex", "-1", "aria-disabled", "true", 4, "ngIf"], ["class", "page-link", "href", "", 3, "click", 4, "ngIf"], ["tabindex", "-1", "aria-disabled", "true", 1, "page-link"], ["href", "", 1, "page-link", 3, "click"], ["aria-label", i18n_44, "href", "", 1, "page-link", 3, "click"], ["aria-label", i18n_47, "href", "", 1, "page-link", 3, "click"], ["aria-label", i18n_50, "href", "", 1, "page-link", 3, "click"], ["aria-label", i18n_52, "href", "", 1, "page-link", 3, "click"]];
          },
          template: function NgbPagination_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbPagination_ng_template_0_Template, 2, 0, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbPagination_ng_template_2_Template, 2, 0, "ng-template", null, 1, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, NgbPagination_ng_template_4_Template, 2, 0, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, NgbPagination_ng_template_6_Template, 2, 0, "ng-template", null, 3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](8, NgbPagination_ng_template_8_Template, 1, 0, "ng-template", null, 4, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](10, NgbPagination_ng_template_10_Template, 2, 2, "ng-template", null, 5, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](12, NgbPagination_ng_template_12_Template, 1, 1, "ng-template", null, 6, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](14, "ul");

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](15, NgbPagination_li_15_Template, 3, 9, "li", 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](16, NgbPagination_li_16_Template, 3, 8, "li", 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](17, NgbPagination_ng_template_17_Template, 0, 0, "ng-template", 8);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](18, NgbPagination_li_18_Template, 3, 9, "li", 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](19, NgbPagination_li_19_Template, 3, 9, "li", 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              var _r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](13);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](14);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("pagination" + (ctx.size ? " pagination-" + ctx.size : ""));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.boundaryLinks);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.directionLinks);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", (ctx.tplPages == null ? null : ctx.tplPages.templateRef) || _r12)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction3"](8, _c54, ctx.page, ctx.pages, ctx.disabled));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.directionLinks);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.boundaryLinks);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbPagination;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var DIRECTIVES = [_NgbPagination, _NgbPaginationEllipsis, _NgbPaginationFirst, _NgbPaginationLast, _NgbPaginationNext, _NgbPaginationNumber, _NgbPaginationPrevious, _NgbPaginationPages];

      var _NgbPaginationModule = /*#__PURE__*/function () {
        var NgbPaginationModule = function NgbPaginationModule() {
          _classCallCheck(this, NgbPaginationModule);
        };

        NgbPaginationModule.ɵfac = function NgbPaginationModule_Factory(t) {
          return new (t || NgbPaginationModule)();
        };

        NgbPaginationModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbPaginationModule
        });
        NgbPaginationModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbPaginationModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbPaginationModule, {
          declarations: function declarations() {
            return [_NgbPagination, _NgbPaginationEllipsis, _NgbPaginationFirst, _NgbPaginationLast, _NgbPaginationNext, _NgbPaginationNumber, _NgbPaginationPrevious, _NgbPaginationPages];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbPagination, _NgbPaginationEllipsis, _NgbPaginationFirst, _NgbPaginationLast, _NgbPaginationNext, _NgbPaginationNumber, _NgbPaginationPrevious, _NgbPaginationPages];
          }
        });
      })();

      var Trigger = /*#__PURE__*/function () {
        function Trigger(open, close) {
          _classCallCheck(this, Trigger);

          this.open = open;
          this.close = close;

          if (!close) {
            this.close = open;
          }
        }

        _createClass(Trigger, [{
          key: "isManual",
          value: function isManual() {
            return this.open === 'manual' || this.close === 'manual';
          }
        }]);

        return Trigger;
      }();

      var DEFAULT_ALIASES = {
        'hover': ['mouseenter', 'mouseleave'],
        'focus': ['focusin', 'focusout']
      };

      function parseTriggers(triggers) {
        var aliases = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ALIASES;
        var trimmedTriggers = (triggers || '').trim();

        if (trimmedTriggers.length === 0) {
          return [];
        }

        var parsedTriggers = trimmedTriggers.split(/\s+/).map(function (trigger) {
          return trigger.split(':');
        }).map(function (triggerPair) {
          var alias = aliases[triggerPair[0]] || triggerPair;
          return new Trigger(alias[0], alias[1]);
        });
        var manualTriggers = parsedTriggers.filter(function (triggerPair) {
          return triggerPair.isManual();
        });

        if (manualTriggers.length > 1) {
          throw 'Triggers parse error: only one manual trigger is allowed';
        }

        if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
          throw 'Triggers parse error: manual trigger can\'t be mixed with other triggers';
        }

        return parsedTriggers;
      }

      function observeTriggers(renderer, nativeElement, triggers, isOpenedFn) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {
          var listeners = [];

          var openFn = function openFn() {
            return subscriber.next(true);
          };

          var closeFn = function closeFn() {
            return subscriber.next(false);
          };

          var toggleFn = function toggleFn() {
            return subscriber.next(!isOpenedFn());
          };

          triggers.forEach(function (trigger) {
            if (trigger.open === trigger.close) {
              listeners.push(renderer.listen(nativeElement, trigger.open, toggleFn));
            } else {
              listeners.push(renderer.listen(nativeElement, trigger.open, openFn), renderer.listen(nativeElement, trigger.close, closeFn));
            }
          });
          return function () {
            listeners.forEach(function (unsubscribeFn) {
              return unsubscribeFn();
            });
          };
        });
      }

      var delayOrNoop = function delayOrNoop(time) {
        return time > 0 ? (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.delay)(time) : function (a) {
          return a;
        };
      };

      var ɵ0$5 = delayOrNoop;

      function triggerDelay(openDelay, closeDelay, isOpenedFn) {
        return function (input$) {
          var pending = null;
          var filteredInput$ = input$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (open) {
            return {
              open: open
            };
          }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (event) {
            var currentlyOpen = isOpenedFn();

            if (currentlyOpen !== event.open && (!pending || pending.open === currentlyOpen)) {
              pending = event;
              return true;
            }

            if (pending && pending.open !== event.open) {
              pending = null;
            }

            return false;
          }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.share)());
          var delayedOpen$ = filteredInput$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (event) {
            return event.open;
          }), delayOrNoop(openDelay));
          var delayedClose$ = filteredInput$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (event) {
            return !event.open;
          }), delayOrNoop(closeDelay));
          return (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.merge)(delayedOpen$, delayedClose$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (event) {
            if (event === pending) {
              pending = null;
              return event.open !== isOpenedFn();
            }

            return false;
          }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (event) {
            return event.open;
          }));
        };
      }

      function listenToTriggers(renderer, nativeElement, triggers, isOpenedFn, openFn, closeFn) {
        var openDelay = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var closeDelay = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var parsedTriggers = parseTriggers(triggers);

        if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
          return function () {};
        }

        var subscription = observeTriggers(renderer, nativeElement, parsedTriggers, isOpenedFn).pipe(triggerDelay(openDelay, closeDelay, isOpenedFn)).subscribe(function (open) {
          return open ? openFn() : closeFn();
        });
        return function () {
          return subscription.unsubscribe();
        };
      }
      /**
       * A configuration service for the [`NgbPopover`](#/components/popover/api#NgbPopover) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the popovers used in the application.
       */


      var _NgbPopoverConfig = /*#__PURE__*/function () {
        var NgbPopoverConfig = /*#__PURE__*/function () {
          function NgbPopoverConfig(_ngbConfig) {
            _classCallCheck(this, NgbPopoverConfig);

            this._ngbConfig = _ngbConfig;
            this.autoClose = true;
            this.placement = 'auto';
            this.triggers = 'click';
            this.disablePopover = false;
            this.openDelay = 0;
            this.closeDelay = 0;
          }

          _createClass(NgbPopoverConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbPopoverConfig;
        }();

        NgbPopoverConfig.ɵfac = function NgbPopoverConfig_Factory(t) {
          return new (t || NgbPopoverConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbPopoverConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbPopoverConfig_Factory() {
            return new NgbPopoverConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbPopoverConfig,
          providedIn: "root"
        });
        return NgbPopoverConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var nextId$3 = 0;

      var NgbPopoverWindow = /*#__PURE__*/function () {
        var NgbPopoverWindow = /*#__PURE__*/function () {
          function NgbPopoverWindow() {
            _classCallCheck(this, NgbPopoverWindow);
          }

          _createClass(NgbPopoverWindow, [{
            key: "isTitleTemplate",
            value: function isTitleTemplate() {
              return this.title instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef;
            }
          }]);

          return NgbPopoverWindow;
        }();

        NgbPopoverWindow.ɵfac = function NgbPopoverWindow_Factory(t) {
          return new (t || NgbPopoverWindow)();
        };

        NgbPopoverWindow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbPopoverWindow,
          selectors: [["ngb-popover-window"]],
          hostAttrs: ["role", "tooltip"],
          hostVars: 5,
          hostBindings: function NgbPopoverWindow_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("id", ctx.id);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("popover" + (ctx.popoverClass ? " " + ctx.popoverClass : ""));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.animation);
            }
          },
          inputs: {
            animation: "animation",
            title: "title",
            id: "id",
            popoverClass: "popoverClass",
            context: "context"
          },
          ngContentSelectors: _c3,
          decls: 4,
          vars: 1,
          consts: [[1, "arrow"], ["class", "popover-header", 4, "ngIf"], [1, "popover-body"], [1, "popover-header"], ["simpleTitle", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
          template: function NgbPopoverWindow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbPopoverWindow_h3_1_Template, 4, 2, "h3", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.title);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          styles: ["ngb-popover-window.bs-popover-bottom>.arrow,ngb-popover-window.bs-popover-top>.arrow{left:50%;margin-left:-.5rem}ngb-popover-window.bs-popover-bottom-left>.arrow,ngb-popover-window.bs-popover-top-left>.arrow{left:2em}ngb-popover-window.bs-popover-bottom-right>.arrow,ngb-popover-window.bs-popover-top-right>.arrow{left:auto;right:2em}ngb-popover-window.bs-popover-left>.arrow,ngb-popover-window.bs-popover-right>.arrow{margin-top:-.5rem;top:50%}ngb-popover-window.bs-popover-left-top>.arrow,ngb-popover-window.bs-popover-right-top>.arrow{top:.7em}ngb-popover-window.bs-popover-left-bottom>.arrow,ngb-popover-window.bs-popover-right-bottom>.arrow{bottom:.7em;top:auto}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbPopoverWindow;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A lightweight and extensible directive for fancy popover creation.
       */


      var _NgbPopover = /*#__PURE__*/function () {
        var NgbPopover = /*#__PURE__*/function () {
          function NgbPopover(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, _ngZone, _document, _changeDetector, applicationRef) {
            var _this46 = this;

            _classCallCheck(this, NgbPopover);

            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._ngZone = _ngZone;
            this._document = _document;
            this._changeDetector = _changeDetector;
            /**
             * An event emitted when the popover opening animation has finished. Contains no payload.
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the popover closing animation has finished. Contains no payload.
             *
             * At this point popover is not in the DOM anymore.
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this._ngbPopoverWindowId = "ngb-popover-".concat(nextId$3++);
            this._windowRef = null;
            this.animation = config.animation;
            this.autoClose = config.autoClose;
            this.placement = config.placement;
            this.triggers = config.triggers;
            this.container = config.container;
            this.disablePopover = config.disablePopover;
            this.popoverClass = config.popoverClass;
            this.openDelay = config.openDelay;
            this.closeDelay = config.closeDelay;
            this._popupService = new PopupService(NgbPopoverWindow, injector, viewContainerRef, _renderer, this._ngZone, componentFactoryResolver, applicationRef);
            this._zoneSubscription = _ngZone.onStable.subscribe(function () {
              if (_this46._windowRef) {
                positionElements(_this46._elementRef.nativeElement, _this46._windowRef.location.nativeElement, _this46.placement, _this46.container === 'body', 'bs-popover');
              }
            });
          }

          _createClass(NgbPopover, [{
            key: "_isDisabled",
            value: function _isDisabled() {
              if (this.disablePopover) {
                return true;
              }

              if (!this.ngbPopover && !this.popoverTitle) {
                return true;
              }

              return false;
            }
            /**
             * Opens the popover.
             *
             * This is considered to be a "manual" triggering.
             * The `context` is an optional value to be injected into the popover template when it is created.
             */

          }, {
            key: "open",
            value: function open(context) {
              var _this47 = this;

              if (!this._windowRef && !this._isDisabled()) {
                // this type assertion is safe because otherwise _isDisabled would return true
                var _this$_popupService$o = this._popupService.open(this.ngbPopover, context, this.animation),
                    windowRef = _this$_popupService$o.windowRef,
                    transition$ = _this$_popupService$o.transition$;

                this._windowRef = windowRef;
                this._windowRef.instance.animation = this.animation;
                this._windowRef.instance.title = this.popoverTitle;
                this._windowRef.instance.context = context;
                this._windowRef.instance.popoverClass = this.popoverClass;
                this._windowRef.instance.id = this._ngbPopoverWindowId;

                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbPopoverWindowId);

                if (this.container === 'body') {
                  this._document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);
                } // We need to detect changes, because we don't know where .open() might be called from.
                // Ex. opening popover from one of lifecycle hooks that run after the CD
                // (say from ngAfterViewInit) will result in 'ExpressionHasChanged' exception


                this._windowRef.changeDetectorRef.detectChanges(); // We need to mark for check, because popover won't work inside the OnPush component.
                // Ex. when we use expression like `{{ popover.isOpen() : 'opened' : 'closed' }}`
                // inside the template of an OnPush component and we change the popover from
                // open -> closed, the expression in question won't be updated unless we explicitly
                // mark the parent component to be checked.


                this._windowRef.changeDetectorRef.markForCheck();

                ngbAutoClose(this._ngZone, this._document, this.autoClose, function () {
                  return _this47.close();
                }, this.hidden, [this._windowRef.location.nativeElement]);
                transition$.subscribe(function () {
                  return _this47.shown.emit();
                });
              }
            }
            /**
             * Closes the popover.
             *
             * This is considered to be a "manual" triggering of the popover.
             */

          }, {
            key: "close",
            value: function close() {
              var _this48 = this;

              if (this._windowRef) {
                this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');

                this._popupService.close(this.animation).subscribe(function () {
                  _this48._windowRef = null;

                  _this48.hidden.emit();

                  _this48._changeDetector.markForCheck();
                });
              }
            }
            /**
             * Toggles the popover.
             *
             * This is considered to be a "manual" triggering of the popover.
             */

          }, {
            key: "toggle",
            value: function toggle() {
              if (this._windowRef) {
                this.close();
              } else {
                this.open();
              }
            }
            /**
             * Returns `true`, if the popover is currently shown.
             */

          }, {
            key: "isOpen",
            value: function isOpen() {
              return this._windowRef != null;
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay);
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(_ref26) {
              var ngbPopover = _ref26.ngbPopover,
                  popoverTitle = _ref26.popoverTitle,
                  disablePopover = _ref26.disablePopover,
                  popoverClass = _ref26.popoverClass;

              if (popoverClass && this.isOpen()) {
                this._windowRef.instance.popoverClass = popoverClass.currentValue;
              } // close popover if title and content become empty, or disablePopover set to true


              if ((ngbPopover || popoverTitle || disablePopover) && this._isDisabled()) {
                this.close();
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.close(); // This check is needed as it might happen that ngOnDestroy is called before ngOnInit
              // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199

              if (this._unregisterListenersFn) {
                this._unregisterListenersFn();
              }

              this._zoneSubscription.unsubscribe();
            }
          }]);

          return NgbPopover;
        }();

        NgbPopover.ɵfac = function NgbPopover_Factory(t) {
          return new (t || NgbPopover)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbPopoverConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef));
        };

        NgbPopover.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbPopover,
          selectors: [["", "ngbPopover", ""]],
          inputs: {
            animation: "animation",
            autoClose: "autoClose",
            placement: "placement",
            triggers: "triggers",
            container: "container",
            disablePopover: "disablePopover",
            popoverClass: "popoverClass",
            openDelay: "openDelay",
            closeDelay: "closeDelay",
            ngbPopover: "ngbPopover",
            popoverTitle: "popoverTitle"
          },
          outputs: {
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbPopover"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbPopover;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbPopoverModule = /*#__PURE__*/function () {
        var NgbPopoverModule = function NgbPopoverModule() {
          _classCallCheck(this, NgbPopoverModule);
        };

        NgbPopoverModule.ɵfac = function NgbPopoverModule_Factory(t) {
          return new (t || NgbPopoverModule)();
        };

        NgbPopoverModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbPopoverModule
        });
        NgbPopoverModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbPopoverModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbPopoverModule, {
          declarations: function declarations() {
            return [_NgbPopover, NgbPopoverWindow];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbPopover];
          }
        });
      })();
      /**
       * A configuration service for the [`NgbProgressbar`](#/components/progressbar/api#NgbProgressbar) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the progress bars used in the application.
       */


      var _NgbProgressbarConfig = /*#__PURE__*/function () {
        var NgbProgressbarConfig = function NgbProgressbarConfig() {
          _classCallCheck(this, NgbProgressbarConfig);

          this.max = 100;
          this.animated = false;
          this.striped = false;
          this.showValue = false;
        };

        NgbProgressbarConfig.ɵfac = function NgbProgressbarConfig_Factory(t) {
          return new (t || NgbProgressbarConfig)();
        };

        NgbProgressbarConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbProgressbarConfig_Factory() {
            return new NgbProgressbarConfig();
          },
          token: NgbProgressbarConfig,
          providedIn: "root"
        });
        return NgbProgressbarConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that provides feedback on the progress of a workflow or an action.
       */


      var _NgbProgressbar = /*#__PURE__*/function () {
        var NgbProgressbar = /*#__PURE__*/function () {
          function NgbProgressbar(config) {
            _classCallCheck(this, NgbProgressbar);

            /**
             * The current value for the progress bar.
             *
             * Should be in the `[0, max]` range.
             */
            this.value = 0;
            this.max = config.max;
            this.animated = config.animated;
            this.striped = config.striped;
            this.textType = config.textType;
            this.type = config.type;
            this.showValue = config.showValue;
            this.height = config.height;
          }
          /**
           * The maximal value to be displayed in the progress bar.
           *
           * Should be a positive number. Will default to 100 otherwise.
           */


          _createClass(NgbProgressbar, [{
            key: "max",
            get: function get() {
              return this._max;
            },
            set: function set(max) {
              this._max = !isNumber(max) || max <= 0 ? 100 : max;
            }
          }, {
            key: "getValue",
            value: function getValue() {
              return getValueInRange(this.value, this.max);
            }
          }, {
            key: "getPercentValue",
            value: function getPercentValue() {
              return 100 * this.getValue() / this.max;
            }
          }]);

          return NgbProgressbar;
        }();

        NgbProgressbar.ɵfac = function NgbProgressbar_Factory(t) {
          return new (t || NgbProgressbar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbProgressbarConfig));
        };

        NgbProgressbar.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbProgressbar,
          selectors: [["ngb-progressbar"]],
          hostAttrs: [1, "progress"],
          hostVars: 2,
          hostBindings: function NgbProgressbar_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("height", ctx.height);
            }
          },
          inputs: {
            value: "value",
            max: "max",
            animated: "animated",
            striped: "striped",
            textType: "textType",
            type: "type",
            showValue: "showValue",
            height: "height"
          },
          ngContentSelectors: _c3,
          decls: 3,
          vars: 11,
          consts: function consts() {
            var i18n_55;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_progressbar_value$$FESM2015_NG_BOOTSTRAP_JS__56 = goog.getMsg("{$interpolation}", {
                "interpolation": "\uFFFD0\uFFFD"
              });
              i18n_55 = MSG_EXTERNAL_ngb_progressbar_value$$FESM2015_NG_BOOTSTRAP_JS__56;
            } else {
              i18n_55 = $localize(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([":@@ngb.progressbar.value\u241Ff8e9a947b9db4252c0e9905765338712f2fd032f\u241F3720830768741091151:", ":INTERPOLATION:"])), "\uFFFD0\uFFFD");
            }

            return [["role", "progressbar", "aria-valuemin", "0"], [4, "ngIf"], i18n_55];
          },
          template: function NgbProgressbar_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, NgbProgressbar_span_1_Template, 3, 3, "span", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate4"]("progress-bar", ctx.type ? " bg-" + ctx.type : "", "", ctx.textType ? " text-" + ctx.textType : "", "\n    ", ctx.animated ? " progress-bar-animated" : "", "", ctx.striped ? " progress-bar-striped" : "", "");

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("width", ctx.getPercentValue(), "%");

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-valuenow", ctx.getValue())("aria-valuemax", ctx.max);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showValue);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf],
          pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.PercentPipe],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbProgressbar;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbProgressbarModule = /*#__PURE__*/function () {
        var NgbProgressbarModule = function NgbProgressbarModule() {
          _classCallCheck(this, NgbProgressbarModule);
        };

        NgbProgressbarModule.ɵfac = function NgbProgressbarModule_Factory(t) {
          return new (t || NgbProgressbarModule)();
        };

        NgbProgressbarModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbProgressbarModule
        });
        NgbProgressbarModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbProgressbarModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbProgressbarModule, {
          declarations: function declarations() {
            return [_NgbProgressbar];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbProgressbar];
          }
        });
      })();
      /**
       * A configuration service for the [`NgbRating`](#/components/rating/api#NgbRating) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the ratings used in the application.
       */


      var _NgbRatingConfig = /*#__PURE__*/function () {
        var NgbRatingConfig = function NgbRatingConfig() {
          _classCallCheck(this, NgbRatingConfig);

          this.max = 10;
          this.readonly = false;
          this.resettable = false;
        };

        NgbRatingConfig.ɵfac = function NgbRatingConfig_Factory(t) {
          return new (t || NgbRatingConfig)();
        };

        NgbRatingConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbRatingConfig_Factory() {
            return new NgbRatingConfig();
          },
          token: NgbRatingConfig,
          providedIn: "root"
        });
        return NgbRatingConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A directive that helps visualising and interacting with a star rating bar.
       */


      var _NgbRating = /*#__PURE__*/function () {
        var NgbRating = /*#__PURE__*/function () {
          function NgbRating(config, _changeDetectorRef) {
            _classCallCheck(this, NgbRating);

            this._changeDetectorRef = _changeDetectorRef;
            this.contexts = [];
            this.disabled = false;
            /**
             * An event emitted when the user is hovering over a given rating.
             *
             * Event payload equals to the rating being hovered over.
             */

            this.hover = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the user stops hovering over a given rating.
             *
             * Event payload equals to the rating of the last item being hovered over.
             */

            this.leave = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the user selects a new rating.
             *
             * Event payload equals to the newly selected rating.
             */

            this.rateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(true);

            this.onChange = function (_) {};

            this.onTouched = function () {};

            this.max = config.max;
            this.readonly = config.readonly;
          }

          _createClass(NgbRating, [{
            key: "ariaValueText",
            value: function ariaValueText() {
              return "".concat(this.nextRate, " out of ").concat(this.max);
            }
          }, {
            key: "isInteractive",
            value: function isInteractive() {
              return !this.readonly && !this.disabled;
            }
          }, {
            key: "enter",
            value: function enter(value) {
              if (this.isInteractive()) {
                this._updateState(value);
              }

              this.hover.emit(value);
            }
          }, {
            key: "handleBlur",
            value: function handleBlur() {
              this.onTouched();
            }
          }, {
            key: "handleClick",
            value: function handleClick(value) {
              if (this.isInteractive()) {
                this.update(this.resettable && this.rate === value ? 0 : value);
              }
            }
          }, {
            key: "handleKeyDown",
            value: function handleKeyDown(event) {
              // tslint:disable-next-line:deprecation
              switch (event.which) {
                case Key.ArrowDown:
                case Key.ArrowLeft:
                  this.update(this.rate - 1);
                  break;

                case Key.ArrowUp:
                case Key.ArrowRight:
                  this.update(this.rate + 1);
                  break;

                case Key.Home:
                  this.update(0);
                  break;

                case Key.End:
                  this.update(this.max);
                  break;

                default:
                  return;
              } // note 'return' in default case


              event.preventDefault();
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              if (changes['rate']) {
                this.update(this.rate);
              }
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this.contexts = Array.from({
                length: this.max
              }, function (v, k) {
                return {
                  fill: 0,
                  index: k
                };
              });

              this._updateState(this.rate);
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this.onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this.onTouched = fn;
            }
          }, {
            key: "reset",
            value: function reset() {
              this.leave.emit(this.nextRate);

              this._updateState(this.rate);
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this.disabled = isDisabled;
            }
          }, {
            key: "update",
            value: function update(value) {
              var internalChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var newRate = getValueInRange(value, this.max, 0);

              if (this.isInteractive() && this.rate !== newRate) {
                this.rate = newRate;
                this.rateChange.emit(this.rate);
              }

              if (internalChange) {
                this.onChange(this.rate);
                this.onTouched();
              }

              this._updateState(this.rate);
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this.update(value, false);

              this._changeDetectorRef.markForCheck();
            }
          }, {
            key: "_updateState",
            value: function _updateState(nextValue) {
              this.nextRate = nextValue;
              this.contexts.forEach(function (context, index) {
                return context.fill = Math.round(getValueInRange(nextValue - index, 1, 0) * 100);
              });
            }
          }]);

          return NgbRating;
        }();

        NgbRating.ɵfac = function NgbRating_Factory(t) {
          return new (t || NgbRating)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbRatingConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
        };

        NgbRating.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbRating,
          selectors: [["ngb-rating"]],
          contentQueries: function NgbRating_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.starTemplateFromContent = _t.first);
            }
          },
          hostAttrs: ["role", "slider", "aria-valuemin", "0", 1, "d-inline-flex"],
          hostVars: 5,
          hostBindings: function NgbRating_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("blur", function NgbRating_blur_HostBindingHandler() {
                return ctx.handleBlur();
              })("keydown", function NgbRating_keydown_HostBindingHandler($event) {
                return ctx.handleKeyDown($event);
              })("mouseleave", function NgbRating_mouseleave_HostBindingHandler() {
                return ctx.reset();
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("tabindex", ctx.disabled ? -1 : 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-valuemax", ctx.max)("aria-valuenow", ctx.nextRate)("aria-valuetext", ctx.ariaValueText())("aria-disabled", ctx.readonly ? true : null);
            }
          },
          inputs: {
            max: "max",
            readonly: "readonly",
            rate: "rate",
            resettable: "resettable",
            starTemplate: "starTemplate"
          },
          outputs: {
            hover: "hover",
            leave: "leave",
            rateChange: "rateChange"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbRating;
            }),
            multi: true
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          decls: 3,
          vars: 1,
          consts: [["t", ""], ["ngFor", "", 3, "ngForOf"], [1, "sr-only"], [3, "mouseenter", "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
          template: function NgbRating_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbRating_ng_template_0_Template, 1, 1, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbRating_ng_template_2_Template, 4, 5, "ng-template", 1);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.contexts);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbRating;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbRatingModule = /*#__PURE__*/function () {
        var NgbRatingModule = function NgbRatingModule() {
          _classCallCheck(this, NgbRatingModule);
        };

        NgbRatingModule.ɵfac = function NgbRatingModule_Factory(t) {
          return new (t || NgbRatingModule)();
        };

        NgbRatingModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbRatingModule
        });
        NgbRatingModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbRatingModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbRatingModule, {
          declarations: function declarations() {
            return [_NgbRating];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbRating];
          }
        });
      })();

      var NgbTime = /*#__PURE__*/function () {
        function NgbTime(hour, minute, second) {
          _classCallCheck(this, NgbTime);

          this.hour = toInteger(hour);
          this.minute = toInteger(minute);
          this.second = toInteger(second);
        }

        _createClass(NgbTime, [{
          key: "changeHour",
          value: function changeHour() {
            var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            this.updateHour((isNaN(this.hour) ? 0 : this.hour) + step);
          }
        }, {
          key: "updateHour",
          value: function updateHour(hour) {
            if (isNumber(hour)) {
              this.hour = (hour < 0 ? 24 + hour : hour) % 24;
            } else {
              this.hour = NaN;
            }
          }
        }, {
          key: "changeMinute",
          value: function changeMinute() {
            var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            this.updateMinute((isNaN(this.minute) ? 0 : this.minute) + step);
          }
        }, {
          key: "updateMinute",
          value: function updateMinute(minute) {
            if (isNumber(minute)) {
              this.minute = minute % 60 < 0 ? 60 + minute % 60 : minute % 60;
              this.changeHour(Math.floor(minute / 60));
            } else {
              this.minute = NaN;
            }
          }
        }, {
          key: "changeSecond",
          value: function changeSecond() {
            var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            this.updateSecond((isNaN(this.second) ? 0 : this.second) + step);
          }
        }, {
          key: "updateSecond",
          value: function updateSecond(second) {
            if (isNumber(second)) {
              this.second = second < 0 ? 60 + second % 60 : second % 60;
              this.changeMinute(Math.floor(second / 60));
            } else {
              this.second = NaN;
            }
          }
        }, {
          key: "isValid",
          value: function isValid() {
            var checkSecs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return isNumber(this.hour) && isNumber(this.minute) && (checkSecs ? isNumber(this.second) : true);
          }
        }, {
          key: "toString",
          value: function toString() {
            return "".concat(this.hour || 0, ":").concat(this.minute || 0, ":").concat(this.second || 0);
          }
        }]);

        return NgbTime;
      }();
      /**
       * A configuration service for the [`NgbTimepicker`](#/components/timepicker/api#NgbTimepicker) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the timepickers used in the application.
       */


      var _NgbTimepickerConfig = /*#__PURE__*/function () {
        var NgbTimepickerConfig = function NgbTimepickerConfig() {
          _classCallCheck(this, NgbTimepickerConfig);

          this.meridian = false;
          this.spinners = true;
          this.seconds = false;
          this.hourStep = 1;
          this.minuteStep = 1;
          this.secondStep = 1;
          this.disabled = false;
          this.readonlyInputs = false;
          this.size = 'medium';
        };

        NgbTimepickerConfig.ɵfac = function NgbTimepickerConfig_Factory(t) {
          return new (t || NgbTimepickerConfig)();
        };

        NgbTimepickerConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbTimepickerConfig_Factory() {
            return new NgbTimepickerConfig();
          },
          token: NgbTimepickerConfig,
          providedIn: "root"
        });
        return NgbTimepickerConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      function NGB_DATEPICKER_TIME_ADAPTER_FACTORY() {
        return new NgbTimeStructAdapter();
      }
      /**
       * An abstract service that does the conversion between the internal timepicker `NgbTimeStruct` model and
       * any provided user time model `T`, ex. a string, a native date, etc.
       *
       * The adapter is used **only** for conversion when binding timepicker to a form control,
       * ex. `[(ngModel)]="userTimeModel"`. Here `userTimeModel` can be of any type.
       *
       * The default timepicker implementation assumes we use `NgbTimeStruct` as a user model.
       *
       * See the [custom time adapter demo](#/components/timepicker/examples#adapter) for an example.
       *
       * @since 2.2.0
       */


      var _NgbTimeAdapter = /*#__PURE__*/function () {
        var NgbTimeAdapter = function NgbTimeAdapter() {
          _classCallCheck(this, NgbTimeAdapter);
        };

        NgbTimeAdapter.ɵfac = function NgbTimeAdapter_Factory(t) {
          return new (t || NgbTimeAdapter)();
        };

        NgbTimeAdapter.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: NGB_DATEPICKER_TIME_ADAPTER_FACTORY,
          token: NgbTimeAdapter,
          providedIn: "root"
        });
        return NgbTimeAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbTimeStructAdapter = /*#__PURE__*/function () {
        var NgbTimeStructAdapter = /*#__PURE__*/function (_NgbTimeAdapter2) {
          _inherits(NgbTimeStructAdapter, _NgbTimeAdapter2);

          var _super16 = _createSuper(NgbTimeStructAdapter);

          function NgbTimeStructAdapter() {
            _classCallCheck(this, NgbTimeStructAdapter);

            return _super16.apply(this, arguments);
          }

          _createClass(NgbTimeStructAdapter, [{
            key: "fromModel",
            value:
            /**
             * Converts a NgbTimeStruct value into NgbTimeStruct value
             */
            function fromModel(time) {
              return time && isInteger(time.hour) && isInteger(time.minute) ? {
                hour: time.hour,
                minute: time.minute,
                second: isInteger(time.second) ? time.second : null
              } : null;
            }
            /**
             * Converts a NgbTimeStruct value into NgbTimeStruct value
             */

          }, {
            key: "toModel",
            value: function toModel(time) {
              return time && isInteger(time.hour) && isInteger(time.minute) ? {
                hour: time.hour,
                minute: time.minute,
                second: isInteger(time.second) ? time.second : null
              } : null;
            }
          }]);

          return NgbTimeStructAdapter;
        }(_NgbTimeAdapter);

        NgbTimeStructAdapter.ɵfac = /*@__PURE__*/function () {
          var ɵNgbTimeStructAdapter_BaseFactory;
          return function NgbTimeStructAdapter_Factory(t) {
            return (ɵNgbTimeStructAdapter_BaseFactory || (ɵNgbTimeStructAdapter_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](NgbTimeStructAdapter)))(t || NgbTimeStructAdapter);
          };
        }();

        NgbTimeStructAdapter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbTimeStructAdapter,
          factory: NgbTimeStructAdapter.ɵfac
        });
        return NgbTimeStructAdapter;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      function NGB_TIMEPICKER_I18N_FACTORY(locale) {
        return new NgbTimepickerI18nDefault(locale);
      }
      /**
       * Type of the service supplying day periods (for example, 'AM' and 'PM') to NgbTimepicker component.
       * The default implementation of this service honors the Angular locale, and uses the registered locale data,
       * as explained in the Angular i18n guide.
       */


      var _NgbTimepickerI18n = /*#__PURE__*/function () {
        var NgbTimepickerI18n = function NgbTimepickerI18n() {
          _classCallCheck(this, NgbTimepickerI18n);
        };

        NgbTimepickerI18n.ɵfac = function NgbTimepickerI18n_Factory(t) {
          return new (t || NgbTimepickerI18n)();
        };

        NgbTimepickerI18n.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbTimepickerI18n_Factory() {
            return NGB_TIMEPICKER_I18N_FACTORY((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID));
          },
          token: NgbTimepickerI18n,
          providedIn: "root"
        });
        return NgbTimepickerI18n;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbTimepickerI18nDefault = /*#__PURE__*/function () {
        var NgbTimepickerI18nDefault = /*#__PURE__*/function (_NgbTimepickerI18n2) {
          _inherits(NgbTimepickerI18nDefault, _NgbTimepickerI18n2);

          var _super17 = _createSuper(NgbTimepickerI18nDefault);

          function NgbTimepickerI18nDefault(locale) {
            var _this49;

            _classCallCheck(this, NgbTimepickerI18nDefault);

            _this49 = _super17.call(this);
            _this49._periods = (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.getLocaleDayPeriods)(locale, _angular_common__WEBPACK_IMPORTED_MODULE_1__.FormStyle.Standalone, _angular_common__WEBPACK_IMPORTED_MODULE_1__.TranslationWidth.Narrow);
            return _this49;
          }

          _createClass(NgbTimepickerI18nDefault, [{
            key: "getMorningPeriod",
            value: function getMorningPeriod() {
              return this._periods[0];
            }
          }, {
            key: "getAfternoonPeriod",
            value: function getAfternoonPeriod() {
              return this._periods[1];
            }
          }]);

          return NgbTimepickerI18nDefault;
        }(_NgbTimepickerI18n);

        NgbTimepickerI18nDefault.ɵfac = function NgbTimepickerI18nDefault_Factory(t) {
          return new (t || NgbTimepickerI18nDefault)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID));
        };

        NgbTimepickerI18nDefault.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: NgbTimepickerI18nDefault,
          factory: NgbTimepickerI18nDefault.ɵfac
        });
        return NgbTimepickerI18nDefault;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var FILTER_REGEX = /[^0-9]/g;
      /**
       * A directive that helps with wth picking hours, minutes and seconds.
       */

      var _NgbTimepicker = /*#__PURE__*/function () {
        var NgbTimepicker = /*#__PURE__*/function () {
          function NgbTimepicker(_config, _ngbTimeAdapter, _cd, i18n) {
            _classCallCheck(this, NgbTimepicker);

            this._config = _config;
            this._ngbTimeAdapter = _ngbTimeAdapter;
            this._cd = _cd;
            this.i18n = i18n;

            this.onChange = function (_) {};

            this.onTouched = function () {};

            this.meridian = _config.meridian;
            this.spinners = _config.spinners;
            this.seconds = _config.seconds;
            this.hourStep = _config.hourStep;
            this.minuteStep = _config.minuteStep;
            this.secondStep = _config.secondStep;
            this.disabled = _config.disabled;
            this.readonlyInputs = _config.readonlyInputs;
            this.size = _config.size;
          }
          /**
           * The number of hours to add/subtract when clicking hour spinners.
           */


          _createClass(NgbTimepicker, [{
            key: "hourStep",
            get: function get() {
              return this._hourStep;
            }
            /**
             * The number of minutes to add/subtract when clicking minute spinners.
             */
            ,
            set: function set(step) {
              this._hourStep = isInteger(step) ? step : this._config.hourStep;
            }
          }, {
            key: "minuteStep",
            get: function get() {
              return this._minuteStep;
            }
            /**
             * The number of seconds to add/subtract when clicking second spinners.
             */
            ,
            set: function set(step) {
              this._minuteStep = isInteger(step) ? step : this._config.minuteStep;
            }
          }, {
            key: "secondStep",
            get: function get() {
              return this._secondStep;
            },
            set: function set(step) {
              this._secondStep = isInteger(step) ? step : this._config.secondStep;
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              var structValue = this._ngbTimeAdapter.fromModel(value);

              this.model = structValue ? new NgbTime(structValue.hour, structValue.minute, structValue.second) : new NgbTime();

              if (!this.seconds && (!structValue || !isNumber(structValue.second))) {
                this.model.second = 0;
              }

              this._cd.markForCheck();
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this.onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this.onTouched = fn;
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this.disabled = isDisabled;
            }
          }, {
            key: "changeHour",
            value: function changeHour(step) {
              this.model.changeHour(step);
              this.propagateModelChange();
            }
          }, {
            key: "changeMinute",
            value: function changeMinute(step) {
              this.model.changeMinute(step);
              this.propagateModelChange();
            }
          }, {
            key: "changeSecond",
            value: function changeSecond(step) {
              this.model.changeSecond(step);
              this.propagateModelChange();
            }
          }, {
            key: "updateHour",
            value: function updateHour(newVal) {
              var isPM = this.model.hour >= 12;
              var enteredHour = toInteger(newVal);

              if (this.meridian && (isPM && enteredHour < 12 || !isPM && enteredHour === 12)) {
                this.model.updateHour(enteredHour + 12);
              } else {
                this.model.updateHour(enteredHour);
              }

              this.propagateModelChange();
            }
          }, {
            key: "updateMinute",
            value: function updateMinute(newVal) {
              this.model.updateMinute(toInteger(newVal));
              this.propagateModelChange();
            }
          }, {
            key: "updateSecond",
            value: function updateSecond(newVal) {
              this.model.updateSecond(toInteger(newVal));
              this.propagateModelChange();
            }
          }, {
            key: "toggleMeridian",
            value: function toggleMeridian() {
              if (this.meridian) {
                this.changeHour(12);
              }
            }
          }, {
            key: "formatInput",
            value: function formatInput(input) {
              input.value = input.value.replace(FILTER_REGEX, '');
            }
          }, {
            key: "formatHour",
            value: function formatHour(value) {
              if (isNumber(value)) {
                if (this.meridian) {
                  return padNumber(value % 12 === 0 ? 12 : value % 12);
                } else {
                  return padNumber(value % 24);
                }
              } else {
                return padNumber(NaN);
              }
            }
          }, {
            key: "formatMinSec",
            value: function formatMinSec(value) {
              return padNumber(isNumber(value) ? value : NaN);
            }
          }, {
            key: "handleBlur",
            value: function handleBlur() {
              this.onTouched();
            }
          }, {
            key: "isSmallSize",
            get: function get() {
              return this.size === 'small';
            }
          }, {
            key: "isLargeSize",
            get: function get() {
              return this.size === 'large';
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              if (changes['seconds'] && !this.seconds && this.model && !isNumber(this.model.second)) {
                this.model.second = 0;
                this.propagateModelChange(false);
              }
            }
          }, {
            key: "propagateModelChange",
            value: function propagateModelChange() {
              var touched = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              if (touched) {
                this.onTouched();
              }

              if (this.model.isValid(this.seconds)) {
                this.onChange(this._ngbTimeAdapter.toModel({
                  hour: this.model.hour,
                  minute: this.model.minute,
                  second: this.model.second
                }));
              } else {
                this.onChange(this._ngbTimeAdapter.toModel(null));
              }
            }
          }]);

          return NgbTimepicker;
        }();

        NgbTimepicker.ɵfac = function NgbTimepicker_Factory(t) {
          return new (t || NgbTimepicker)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbTimepickerConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbTimeAdapter), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbTimepickerI18n));
        };

        NgbTimepicker.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbTimepicker,
          selectors: [["ngb-timepicker"]],
          inputs: {
            meridian: "meridian",
            spinners: "spinners",
            seconds: "seconds",
            hourStep: "hourStep",
            minuteStep: "minuteStep",
            secondStep: "secondStep",
            readonlyInputs: "readonlyInputs",
            size: "size"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbTimepicker;
            }),
            multi: true
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          decls: 16,
          vars: 25,
          consts: function consts() {
            var i18n_57;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_HH$$FESM2015_NG_BOOTSTRAP_JS_58 = goog.getMsg("HH");
              i18n_57 = MSG_EXTERNAL_ngb_timepicker_HH$$FESM2015_NG_BOOTSTRAP_JS_58;
            } else {
              i18n_57 = $localize(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([":@@ngb.timepicker.HH\u241Fce676ab1d6d98f85c836381cf100a4a91ef95a1f\u241F4043638465245303811:HH"])));
            }

            var i18n_59;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_hours$$FESM2015_NG_BOOTSTRAP_JS_60 = goog.getMsg("Hours");
              i18n_59 = MSG_EXTERNAL_ngb_timepicker_hours$$FESM2015_NG_BOOTSTRAP_JS_60;
            } else {
              i18n_59 = $localize(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([":@@ngb.timepicker.hours\u241F3bbce5fef7e1151da052a4e529453edb340e3912\u241F8070396816726827304:Hours"])));
            }

            var i18n_61;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_MM$$FESM2015_NG_BOOTSTRAP_JS_62 = goog.getMsg("MM");
              i18n_61 = MSG_EXTERNAL_ngb_timepicker_MM$$FESM2015_NG_BOOTSTRAP_JS_62;
            } else {
              i18n_61 = $localize(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([":@@ngb.timepicker.MM\u241F72c8edf6a50068a05bde70991e36b1e881f4ca54\u241F1647282246509919852:MM"])));
            }

            var i18n_63;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_minutes$$FESM2015_NG_BOOTSTRAP_JS_64 = goog.getMsg("Minutes");
              i18n_63 = MSG_EXTERNAL_ngb_timepicker_minutes$$FESM2015_NG_BOOTSTRAP_JS_64;
            } else {
              i18n_63 = $localize(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([":@@ngb.timepicker.minutes\u241F41e62daa962947c0d23ded0981975d1bddf0bf38\u241F5531237363767747080:Minutes"])));
            }

            var i18n_65;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_increment_hours$$FESM2015_NG_BOOTSTRAP_JS__66 = goog.getMsg("Increment hours");
              i18n_65 = MSG_EXTERNAL_ngb_timepicker_increment_hours$$FESM2015_NG_BOOTSTRAP_JS__66;
            } else {
              i18n_65 = $localize(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([":@@ngb.timepicker.increment-hours\u241Fcb74bc1d625a6c1742f0d7d47306cf495780c218\u241F5939278348542933629:Increment hours"])));
            }

            var i18n_67;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_decrement_hours$$FESM2015_NG_BOOTSTRAP_JS__68 = goog.getMsg("Decrement hours");
              i18n_67 = MSG_EXTERNAL_ngb_timepicker_decrement_hours$$FESM2015_NG_BOOTSTRAP_JS__68;
            } else {
              i18n_67 = $localize(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([":@@ngb.timepicker.decrement-hours\u241F147c7a19429da7d999e247d22e33fee370b1691b\u241F3651829882940481818:Decrement hours"])));
            }

            var i18n_69;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_increment_minutes$$FESM2015_NG_BOOTSTRAP_JS__70 = goog.getMsg("Increment minutes");
              i18n_69 = MSG_EXTERNAL_ngb_timepicker_increment_minutes$$FESM2015_NG_BOOTSTRAP_JS__70;
            } else {
              i18n_69 = $localize(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([":@@ngb.timepicker.increment-minutes\u241Ff5a4a3bc05e053f6732475d0e74875ec01c3a348\u241F180147720391025024:Increment minutes"])));
            }

            var i18n_71;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_decrement_minutes$$FESM2015_NG_BOOTSTRAP_JS__72 = goog.getMsg("Decrement minutes");
              i18n_71 = MSG_EXTERNAL_ngb_timepicker_decrement_minutes$$FESM2015_NG_BOOTSTRAP_JS__72;
            } else {
              i18n_71 = $localize(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([":@@ngb.timepicker.decrement-minutes\u241Fc1a6899e529c096da5b660385d4e77fe1f7ad271\u241F7447789825403243588:Decrement minutes"])));
            }

            var i18n_73;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_SS$$FESM2015_NG_BOOTSTRAP_JS__74 = goog.getMsg("SS");
              i18n_73 = MSG_EXTERNAL_ngb_timepicker_SS$$FESM2015_NG_BOOTSTRAP_JS__74;
            } else {
              i18n_73 = $localize(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([":@@ngb.timepicker.SS\u241Febe38d36a40a2383c5fefa9b4608ffbda08bd4a3\u241F3628127143071124194:SS"])));
            }

            var i18n_75;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_seconds$$FESM2015_NG_BOOTSTRAP_JS__76 = goog.getMsg("Seconds");
              i18n_75 = MSG_EXTERNAL_ngb_timepicker_seconds$$FESM2015_NG_BOOTSTRAP_JS__76;
            } else {
              i18n_75 = $localize(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([":@@ngb.timepicker.seconds\u241F4f2ed9e71a7c981db3e50ae2fedb28aff2ec4e6c\u241F8874012390997067175:Seconds"])));
            }

            var i18n_77;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_increment_seconds$$FESM2015_NG_BOOTSTRAP_JS___78 = goog.getMsg("Increment seconds");
              i18n_77 = MSG_EXTERNAL_ngb_timepicker_increment_seconds$$FESM2015_NG_BOOTSTRAP_JS___78;
            } else {
              i18n_77 = $localize(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([":@@ngb.timepicker.increment-seconds\u241F912322ecee7d659d04dcf494a70e22e49d334b26\u241F5364772110539092174:Increment seconds"])));
            }

            var i18n_79;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_decrement_seconds$$FESM2015_NG_BOOTSTRAP_JS___80 = goog.getMsg("Decrement seconds");
              i18n_79 = MSG_EXTERNAL_ngb_timepicker_decrement_seconds$$FESM2015_NG_BOOTSTRAP_JS___80;
            } else {
              i18n_79 = $localize(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([":@@ngb.timepicker.decrement-seconds\u241F5db47ac104294243a70eb9124fbea9d0004ddf69\u241F753633511487974857:Decrement seconds"])));
            }

            var i18n_81;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_PM$$FESM2015_NG_BOOTSTRAP_JS___82 = goog.getMsg("{$interpolation}", {
                "interpolation": "\uFFFD0\uFFFD"
              });
              i18n_81 = MSG_EXTERNAL_ngb_timepicker_PM$$FESM2015_NG_BOOTSTRAP_JS___82;
            } else {
              i18n_81 = $localize(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([":@@ngb.timepicker.PM\u241F8d6e691e10306c1b34c6b26805151aaea320ef7f\u241F3564199131264287502:", ":INTERPOLATION:"])), "\uFFFD0\uFFFD");
            }

            var i18n_83;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_timepicker_AM$$FESM2015_NG_BOOTSTRAP_JS___84 = goog.getMsg("{$interpolation}", {
                "interpolation": "\uFFFD0\uFFFD"
              });
              i18n_83 = MSG_EXTERNAL_ngb_timepicker_AM$$FESM2015_NG_BOOTSTRAP_JS___84;
            } else {
              i18n_83 = $localize(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([":@@ngb.timepicker.AM\u241F69a1f176a93998876952adac57c3bc3863b6105e\u241F4592818992509942761:", ":INTERPOLATION:"])), "\uFFFD0\uFFFD");
            }

            return [[3, "disabled"], [1, "ngb-tp"], [1, "ngb-tp-input-container", "ngb-tp-hour"], ["tabindex", "-1", "type", "button", "class", "btn btn-link", 3, "btn-sm", "btn-lg", "disabled", "click", 4, "ngIf"], ["type", "text", "maxlength", "2", "inputmode", "numeric", "placeholder", i18n_57, "aria-label", i18n_59, 1, "ngb-tp-input", "form-control", 3, "value", "readOnly", "disabled", "change", "blur", "input", "keydown.ArrowUp", "keydown.ArrowDown"], [1, "ngb-tp-spacer"], [1, "ngb-tp-input-container", "ngb-tp-minute"], ["type", "text", "maxlength", "2", "inputmode", "numeric", "placeholder", i18n_61, "aria-label", i18n_63, 1, "ngb-tp-input", "form-control", 3, "value", "readOnly", "disabled", "change", "blur", "input", "keydown.ArrowUp", "keydown.ArrowDown"], ["class", "ngb-tp-spacer", 4, "ngIf"], ["class", "ngb-tp-input-container ngb-tp-second", 4, "ngIf"], ["class", "ngb-tp-meridian", 4, "ngIf"], ["tabindex", "-1", "type", "button", 1, "btn", "btn-link", 3, "disabled", "click"], [1, "chevron", "ngb-tp-chevron"], [1, "sr-only"], i18n_65, [1, "chevron", "ngb-tp-chevron", "bottom"], i18n_67, i18n_69, i18n_71, [1, "ngb-tp-input-container", "ngb-tp-second"], ["type", "text", "maxlength", "2", "inputmode", "numeric", "placeholder", i18n_73, "aria-label", i18n_75, 1, "ngb-tp-input", "form-control", 3, "value", "readOnly", "disabled", "change", "blur", "input", "keydown.ArrowUp", "keydown.ArrowDown"], i18n_77, i18n_79, [1, "ngb-tp-meridian"], ["type", "button", 1, "btn", "btn-outline-primary", 3, "disabled", "click"], [4, "ngIf", "ngIfElse"], ["am", ""], i18n_81, i18n_83];
          },
          template: function NgbTimepicker_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "fieldset", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, NgbTimepicker_button_3_Template, 4, 7, "button", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "input", 4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbTimepicker_Template_input_change_4_listener($event) {
                return ctx.updateHour($event.target.value);
              })("blur", function NgbTimepicker_Template_input_blur_4_listener() {
                return ctx.handleBlur();
              })("input", function NgbTimepicker_Template_input_input_4_listener($event) {
                return ctx.formatInput($event.target);
              })("keydown.ArrowUp", function NgbTimepicker_Template_input_keydown_ArrowUp_4_listener($event) {
                ctx.changeHour(ctx.hourStep);
                return $event.preventDefault();
              })("keydown.ArrowDown", function NgbTimepicker_Template_input_keydown_ArrowDown_4_listener($event) {
                ctx.changeHour(-ctx.hourStep);
                return $event.preventDefault();
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, NgbTimepicker_button_5_Template, 4, 7, "button", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "div", 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](7, ":");

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](8, "div", 6);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](9, NgbTimepicker_button_9_Template, 4, 7, "button", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](10, "input", 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function NgbTimepicker_Template_input_change_10_listener($event) {
                return ctx.updateMinute($event.target.value);
              })("blur", function NgbTimepicker_Template_input_blur_10_listener() {
                return ctx.handleBlur();
              })("input", function NgbTimepicker_Template_input_input_10_listener($event) {
                return ctx.formatInput($event.target);
              })("keydown.ArrowUp", function NgbTimepicker_Template_input_keydown_ArrowUp_10_listener($event) {
                ctx.changeMinute(ctx.minuteStep);
                return $event.preventDefault();
              })("keydown.ArrowDown", function NgbTimepicker_Template_input_keydown_ArrowDown_10_listener($event) {
                ctx.changeMinute(-ctx.minuteStep);
                return $event.preventDefault();
              });

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](11, NgbTimepicker_button_11_Template, 4, 7, "button", 3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](12, NgbTimepicker_div_12_Template, 2, 0, "div", 8);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](13, NgbTimepicker_div_13_Template, 4, 9, "div", 9);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](14, NgbTimepicker_div_14_Template, 1, 0, "div", 8);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](15, NgbTimepicker_div_15_Template, 5, 9, "div", 10);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.spinners);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("form-control-sm", ctx.isSmallSize)("form-control-lg", ctx.isLargeSize);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", ctx.formatHour(ctx.model == null ? null : ctx.model.hour))("readOnly", ctx.readonlyInputs)("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.spinners);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.spinners);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("form-control-sm", ctx.isSmallSize)("form-control-lg", ctx.isLargeSize);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", ctx.formatMinSec(ctx.model == null ? null : ctx.model.minute))("readOnly", ctx.readonlyInputs)("disabled", ctx.disabled);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.spinners);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.seconds);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.seconds);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.meridian);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.meridian);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf],
          styles: ["ngb-timepicker{font-size:1rem}.ngb-tp{align-items:center;display:flex}.ngb-tp-input-container{width:4em}.ngb-tp-chevron:before{border-style:solid;border-width:.29em .29em 0 0;content:\"\";display:inline-block;height:.69em;left:.05em;position:relative;top:.15em;transform:rotate(-45deg);vertical-align:middle;width:.69em}.ngb-tp-chevron.bottom:before{top:-.3em;transform:rotate(135deg)}.ngb-tp-input{text-align:center}.ngb-tp-hour,.ngb-tp-meridian,.ngb-tp-minute,.ngb-tp-second{align-items:center;display:flex;flex-direction:column;justify-content:space-around}.ngb-tp-spacer{text-align:center;width:1em}"],
          encapsulation: 2
        });
        return NgbTimepicker;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbTimepickerModule = /*#__PURE__*/function () {
        var NgbTimepickerModule = function NgbTimepickerModule() {
          _classCallCheck(this, NgbTimepickerModule);
        };

        NgbTimepickerModule.ɵfac = function NgbTimepickerModule_Factory(t) {
          return new (t || NgbTimepickerModule)();
        };

        NgbTimepickerModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbTimepickerModule
        });
        NgbTimepickerModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbTimepickerModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbTimepickerModule, {
          declarations: function declarations() {
            return [_NgbTimepicker];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbTimepicker];
          }
        });
      })();
      /**
       * Configuration service for the NgbToast component. You can inject this service, typically in your root component,
       * and customize the values of its properties in order to provide default values for all the toasts used in the
       * application.
       *
       * @since 5.0.0
       */


      var _NgbToastConfig = /*#__PURE__*/function () {
        var NgbToastConfig = /*#__PURE__*/function () {
          function NgbToastConfig(_ngbConfig) {
            _classCallCheck(this, NgbToastConfig);

            this._ngbConfig = _ngbConfig;
            this.autohide = true;
            this.delay = 500;
            this.ariaLive = 'polite';
          }

          _createClass(NgbToastConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbToastConfig;
        }();

        NgbToastConfig.ɵfac = function NgbToastConfig_Factory(t) {
          return new (t || NgbToastConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbToastConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbToastConfig_Factory() {
            return new NgbToastConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbToastConfig,
          providedIn: "root"
        });
        return NgbToastConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var ngbToastFadeInTransition = function ngbToastFadeInTransition(element, animation) {
        var classList = element.classList;

        if (!animation) {
          classList.add('show');
          return;
        }

        classList.remove('hide');
        reflow(element);
        classList.add('showing');
        return function () {
          classList.remove('showing');
          classList.add('show');
        };
      };

      var ngbToastFadeOutTransition = function ngbToastFadeOutTransition(_ref27) {
        var classList = _ref27.classList;
        classList.remove('show');
        return function () {
          classList.add('hide');
        };
      };
      /**
       * This directive allows the usage of HTML markup or other directives
       * inside of the toast's header.
       *
       * @since 5.0.0
       */


      var _NgbToastHeader = /*#__PURE__*/function () {
        var NgbToastHeader = function NgbToastHeader() {
          _classCallCheck(this, NgbToastHeader);
        };

        NgbToastHeader.ɵfac = function NgbToastHeader_Factory(t) {
          return new (t || NgbToastHeader)();
        };

        NgbToastHeader.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbToastHeader,
          selectors: [["", "ngbToastHeader", ""]]
        });
        return NgbToastHeader;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Toasts provide feedback messages as notifications to the user.
       * Goal is to mimic the push notifications available both on mobile and desktop operating systems.
       *
       * @since 5.0.0
       */


      var _NgbToast = /*#__PURE__*/function () {
        var NgbToast = /*#__PURE__*/function () {
          function NgbToast(ariaLive, config, _zone, _element) {
            _classCallCheck(this, NgbToast);

            this.ariaLive = ariaLive;
            this._zone = _zone;
            this._element = _element;
            /**
             * A template like `<ng-template ngbToastHeader></ng-template>` can be
             * used in the projected content to allow markup usage.
             */

            this.contentHeaderTpl = null;
            /**
             * An event fired after the animation triggered by calling `.show()` method has finished.
             *
             * @since 8.0.0
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event fired after the animation triggered by calling `.hide()` method has finished.
             *
             * It can only occur in 2 different scenarios:
             * - `autohide` timeout fires
             * - user clicks on a closing cross
             *
             * Additionally this output is purely informative. The toast won't be removed from DOM automatically, it's up
             * to the user to take care of that.
             *
             * @since 8.0.0
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();

            if (this.ariaLive == null) {
              this.ariaLive = config.ariaLive;
            }

            this.delay = config.delay;
            this.autohide = config.autohide;
            this.animation = config.animation;
          }

          _createClass(NgbToast, [{
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              var _this50 = this;

              this._zone.onStable.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(function () {
                _this50._init();

                _this50.show();
              });
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              if ('autohide' in changes) {
                this._clearTimeout();

                this._init();
              }
            }
            /**
             * Triggers toast closing programmatically.
             *
             * The returned observable will emit and be completed once the closing transition has finished.
             * If the animations are turned off this happens synchronously.
             *
             * Alternatively you could listen or subscribe to the `(hidden)` output
             *
             * @since 8.0.0
             */

          }, {
            key: "hide",
            value: function hide() {
              var _this51 = this;

              this._clearTimeout();

              var transition = ngbRunTransition(this._zone, this._element.nativeElement, ngbToastFadeOutTransition, {
                animation: this.animation,
                runningTransition: 'stop'
              });
              transition.subscribe(function () {
                _this51.hidden.emit();
              });
              return transition;
            }
            /**
             * Triggers toast opening programmatically.
             *
             * The returned observable will emit and be completed once the opening transition has finished.
             * If the animations are turned off this happens synchronously.
             *
             * Alternatively you could listen or subscribe to the `(shown)` output
             *
             * @since 8.0.0
             */

          }, {
            key: "show",
            value: function show() {
              var _this52 = this;

              var transition = ngbRunTransition(this._zone, this._element.nativeElement, ngbToastFadeInTransition, {
                animation: this.animation,
                runningTransition: 'continue'
              });
              transition.subscribe(function () {
                _this52.shown.emit();
              });
              return transition;
            }
          }, {
            key: "_init",
            value: function _init() {
              var _this53 = this;

              if (this.autohide && !this._timeoutID) {
                this._timeoutID = setTimeout(function () {
                  return _this53.hide();
                }, this.delay);
              }
            }
          }, {
            key: "_clearTimeout",
            value: function _clearTimeout() {
              if (this._timeoutID) {
                clearTimeout(this._timeoutID);
                this._timeoutID = null;
              }
            }
          }]);

          return NgbToast;
        }();

        NgbToast.ɵfac = function NgbToast_Factory(t) {
          return new (t || NgbToast)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinjectAttribute"]('aria-live'), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbToastConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NgbToast.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbToast,
          selectors: [["ngb-toast"]],
          contentQueries: function NgbToast_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _NgbToastHeader, 7, _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.contentHeaderTpl = _t.first);
            }
          },
          hostAttrs: ["role", "alert", "aria-atomic", "true", 1, "toast"],
          hostVars: 3,
          hostBindings: function NgbToast_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-live", ctx.ariaLive);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.animation);
            }
          },
          inputs: {
            delay: "delay",
            autohide: "autohide",
            animation: "animation",
            header: "header"
          },
          outputs: {
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbToast"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          ngContentSelectors: _c3,
          decls: 5,
          vars: 1,
          consts: function consts() {
            var i18n_85;

            if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
              var MSG_EXTERNAL_ngb_toast_close_aria$$FESM2015_NG_BOOTSTRAP_JS__86 = goog.getMsg("Close");
              i18n_85 = MSG_EXTERNAL_ngb_toast_close_aria$$FESM2015_NG_BOOTSTRAP_JS__86;
            } else {
              i18n_85 = $localize(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([":@@ngb.toast.close-aria\u241Ff4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8\u241F7819314041543176992:Close"])));
            }

            return [["headerTpl", ""], [3, "ngIf"], [1, "toast-body"], [1, "mr-auto"], [1, "toast-header"], [3, "ngTemplateOutlet"], ["type", "button", "aria-label", i18n_85, 1, "close", 3, "click"], ["aria-hidden", "true"]];
          },
          template: function NgbToast_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbToast_ng_template_0_Template, 2, 1, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbToast_ng_template_2_Template, 5, 1, "ng-template", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "div", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](4);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.contentHeaderTpl || ctx.header);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          styles: [".ngb-toasts{margin:.5em;position:fixed;right:0;top:0;z-index:1200}ngb-toast{display:block}ngb-toast .toast-header .close{margin-bottom:.25rem;margin-left:auto}"],
          encapsulation: 2
        });
        return NgbToast;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbToastModule = /*#__PURE__*/function () {
        var NgbToastModule = function NgbToastModule() {
          _classCallCheck(this, NgbToastModule);
        };

        NgbToastModule.ɵfac = function NgbToastModule_Factory(t) {
          return new (t || NgbToastModule)();
        };

        NgbToastModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbToastModule
        });
        NgbToastModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbToastModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbToastModule, {
          declarations: function declarations() {
            return [_NgbToast, _NgbToastHeader];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbToast, _NgbToastHeader];
          }
        });
      })();
      /**
       * A configuration service for the [`NgbTooltip`](#/components/tooltip/api#NgbTooltip) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the tooltips used in the application.
       */


      var _NgbTooltipConfig = /*#__PURE__*/function () {
        var NgbTooltipConfig = /*#__PURE__*/function () {
          function NgbTooltipConfig(_ngbConfig) {
            _classCallCheck(this, NgbTooltipConfig);

            this._ngbConfig = _ngbConfig;
            this.autoClose = true;
            this.placement = 'auto';
            this.triggers = 'hover focus';
            this.disableTooltip = false;
            this.openDelay = 0;
            this.closeDelay = 0;
          }

          _createClass(NgbTooltipConfig, [{
            key: "animation",
            get: function get() {
              return this._animation === undefined ? this._ngbConfig.animation : this._animation;
            },
            set: function set(animation) {
              this._animation = animation;
            }
          }]);

          return NgbTooltipConfig;
        }();

        NgbTooltipConfig.ɵfac = function NgbTooltipConfig_Factory(t) {
          return new (t || NgbTooltipConfig)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_NgbConfig));
        };

        NgbTooltipConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbTooltipConfig_Factory() {
            return new NgbTooltipConfig((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_NgbConfig));
          },
          token: NgbTooltipConfig,
          providedIn: "root"
        });
        return NgbTooltipConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var nextId$4 = 0;

      var NgbTooltipWindow = /*#__PURE__*/function () {
        var NgbTooltipWindow = function NgbTooltipWindow() {
          _classCallCheck(this, NgbTooltipWindow);
        };

        NgbTooltipWindow.ɵfac = function NgbTooltipWindow_Factory(t) {
          return new (t || NgbTooltipWindow)();
        };

        NgbTooltipWindow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbTooltipWindow,
          selectors: [["ngb-tooltip-window"]],
          hostAttrs: ["role", "tooltip"],
          hostVars: 5,
          hostBindings: function NgbTooltipWindow_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("id", ctx.id);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("tooltip" + (ctx.tooltipClass ? " " + ctx.tooltipClass : ""));

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("fade", ctx.animation);
            }
          },
          inputs: {
            animation: "animation",
            id: "id",
            tooltipClass: "tooltipClass"
          },
          ngContentSelectors: _c3,
          decls: 3,
          vars: 0,
          consts: [[1, "arrow"], [1, "tooltip-inner"]],
          template: function NgbTooltipWindow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            }
          },
          styles: ["ngb-tooltip-window{pointer-events:none}ngb-tooltip-window .tooltip-inner{pointer-events:auto}ngb-tooltip-window.bs-tooltip-bottom .arrow,ngb-tooltip-window.bs-tooltip-top .arrow{left:calc(50% - .4rem)}ngb-tooltip-window.bs-tooltip-bottom-left .arrow,ngb-tooltip-window.bs-tooltip-top-left .arrow{left:1em}ngb-tooltip-window.bs-tooltip-bottom-right .arrow,ngb-tooltip-window.bs-tooltip-top-right .arrow{left:auto;right:.8rem}ngb-tooltip-window.bs-tooltip-left .arrow,ngb-tooltip-window.bs-tooltip-right .arrow{top:calc(50% - .4rem)}ngb-tooltip-window.bs-tooltip-left-top .arrow,ngb-tooltip-window.bs-tooltip-right-top .arrow{top:.4rem}ngb-tooltip-window.bs-tooltip-left-bottom .arrow,ngb-tooltip-window.bs-tooltip-right-bottom .arrow{bottom:.4rem;top:auto}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbTooltipWindow;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A lightweight and extensible directive for fancy tooltip creation.
       */


      var _NgbTooltip = /*#__PURE__*/function () {
        var NgbTooltip = /*#__PURE__*/function () {
          function NgbTooltip(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, _ngZone, _document, _changeDetector, applicationRef) {
            var _this54 = this;

            _classCallCheck(this, NgbTooltip);

            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._ngZone = _ngZone;
            this._document = _document;
            this._changeDetector = _changeDetector;
            /**
             * An event emitted when the tooltip opening animation has finished. Contains no payload.
             */

            this.shown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            /**
             * An event emitted when the tooltip closing animation has finished. Contains no payload.
             */

            this.hidden = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this._ngbTooltipWindowId = "ngb-tooltip-".concat(nextId$4++);
            this._windowRef = null;
            this.animation = config.animation;
            this.autoClose = config.autoClose;
            this.placement = config.placement;
            this.triggers = config.triggers;
            this.container = config.container;
            this.disableTooltip = config.disableTooltip;
            this.tooltipClass = config.tooltipClass;
            this.openDelay = config.openDelay;
            this.closeDelay = config.closeDelay;
            this._popupService = new PopupService(NgbTooltipWindow, injector, viewContainerRef, _renderer, this._ngZone, componentFactoryResolver, applicationRef);
            this._zoneSubscription = _ngZone.onStable.subscribe(function () {
              if (_this54._windowRef) {
                positionElements(_this54._elementRef.nativeElement, _this54._windowRef.location.nativeElement, _this54.placement, _this54.container === 'body', 'bs-tooltip');
              }
            });
          }
          /**
           * The string content or a `TemplateRef` for the content to be displayed in the tooltip.
           *
           * If the content if falsy, the tooltip won't open.
           */


          _createClass(NgbTooltip, [{
            key: "ngbTooltip",
            get: function get() {
              return this._ngbTooltip;
            }
            /**
             * Opens the tooltip.
             *
             * This is considered to be a "manual" triggering.
             * The `context` is an optional value to be injected into the tooltip template when it is created.
             */
            ,
            set: function set(value) {
              this._ngbTooltip = value;

              if (!value && this._windowRef) {
                this.close();
              }
            }
          }, {
            key: "open",
            value: function open(context) {
              var _this55 = this;

              if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) {
                var _this$_popupService$o2 = this._popupService.open(this._ngbTooltip, context, this.animation),
                    windowRef = _this$_popupService$o2.windowRef,
                    transition$ = _this$_popupService$o2.transition$;

                this._windowRef = windowRef;
                this._windowRef.instance.animation = this.animation;
                this._windowRef.instance.tooltipClass = this.tooltipClass;
                this._windowRef.instance.id = this._ngbTooltipWindowId;

                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbTooltipWindowId);

                if (this.container === 'body') {
                  this._document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);
                } // We need to detect changes, because we don't know where .open() might be called from.
                // Ex. opening tooltip from one of lifecycle hooks that run after the CD
                // (say from ngAfterViewInit) will result in 'ExpressionHasChanged' exception


                this._windowRef.changeDetectorRef.detectChanges(); // We need to mark for check, because tooltip won't work inside the OnPush component.
                // Ex. when we use expression like `{{ tooltip.isOpen() : 'opened' : 'closed' }}`
                // inside the template of an OnPush component and we change the tooltip from
                // open -> closed, the expression in question won't be updated unless we explicitly
                // mark the parent component to be checked.


                this._windowRef.changeDetectorRef.markForCheck();

                ngbAutoClose(this._ngZone, this._document, this.autoClose, function () {
                  return _this55.close();
                }, this.hidden, [this._windowRef.location.nativeElement]);
                transition$.subscribe(function () {
                  return _this55.shown.emit();
                });
              }
            }
            /**
             * Closes the tooltip.
             *
             * This is considered to be a "manual" triggering of the tooltip.
             */

          }, {
            key: "close",
            value: function close() {
              var _this56 = this;

              if (this._windowRef != null) {
                this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');

                this._popupService.close(this.animation).subscribe(function () {
                  _this56._windowRef = null;

                  _this56.hidden.emit();

                  _this56._changeDetector.markForCheck();
                });
              }
            }
            /**
             * Toggles the tooltip.
             *
             * This is considered to be a "manual" triggering of the tooltip.
             */

          }, {
            key: "toggle",
            value: function toggle() {
              if (this._windowRef) {
                this.close();
              } else {
                this.open();
              }
            }
            /**
             * Returns `true`, if the popover is currently shown.
             */

          }, {
            key: "isOpen",
            value: function isOpen() {
              return this._windowRef != null;
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay);
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(_ref28) {
              var tooltipClass = _ref28.tooltipClass;

              if (tooltipClass && this.isOpen()) {
                this._windowRef.instance.tooltipClass = tooltipClass.currentValue;
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.close(); // This check is needed as it might happen that ngOnDestroy is called before ngOnInit
              // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199

              if (this._unregisterListenersFn) {
                this._unregisterListenersFn();
              }

              this._zoneSubscription.unsubscribe();
            }
          }]);

          return NgbTooltip;
        }();

        NgbTooltip.ɵfac = function NgbTooltip_Factory(t) {
          return new (t || NgbTooltip)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbTooltipConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef));
        };

        NgbTooltip.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbTooltip,
          selectors: [["", "ngbTooltip", ""]],
          inputs: {
            animation: "animation",
            autoClose: "autoClose",
            placement: "placement",
            triggers: "triggers",
            container: "container",
            disableTooltip: "disableTooltip",
            tooltipClass: "tooltipClass",
            openDelay: "openDelay",
            closeDelay: "closeDelay",
            ngbTooltip: "ngbTooltip"
          },
          outputs: {
            shown: "shown",
            hidden: "hidden"
          },
          exportAs: ["ngbTooltip"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbTooltip;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbTooltipModule = /*#__PURE__*/function () {
        var NgbTooltipModule = function NgbTooltipModule() {
          _classCallCheck(this, NgbTooltipModule);
        };

        NgbTooltipModule.ɵfac = function NgbTooltipModule_Factory(t) {
          return new (t || NgbTooltipModule)();
        };

        NgbTooltipModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbTooltipModule
        });
        NgbTooltipModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return NgbTooltipModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbTooltipModule, {
          declarations: [_NgbTooltip, NgbTooltipWindow],
          exports: [_NgbTooltip]
        });
      })();
      /**
       * A component that helps with text highlighting.
       *
       * If splits the `result` text into parts that contain the searched `term` and generates the HTML markup to simplify
       * highlighting:
       *
       * Ex. `result="Alaska"` and `term="as"` will produce `Al<span class="ngb-highlight">as</span>ka`.
       */


      var _NgbHighlight = /*#__PURE__*/function () {
        var NgbHighlight = /*#__PURE__*/function () {
          function NgbHighlight() {
            _classCallCheck(this, NgbHighlight);

            /**
             * The CSS class for `<span>` elements wrapping the `term` inside the `result`.
             */
            this.highlightClass = 'ngb-highlight';
            /**
             * Boolean option to determine if the highlighting should be sensitive to accents or not.
             *
             * This feature is only available for browsers that implement the `String.normalize` function
             * (typically not Internet Explorer).
             * If you want to use this feature in a browser that does not implement `String.normalize`,
             * you will have to include a polyfill in your application (`unorm` for example).
             *
             * @since 9.1.0
             */

            this.accentSensitive = true;
          }

          _createClass(NgbHighlight, [{
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              var _this57 = this;

              if (!this.accentSensitive && !String.prototype.normalize) {
                console.warn('The `accentSensitive` input in `ngb-highlight` cannot be set to `false` in a browser ' + 'that does not implement the `String.normalize` function. ' + 'You will have to include a polyfill in your application to use this feature in the current browser.');
                this.accentSensitive = true;
              }

              var result = toString(this.result);
              var terms = Array.isArray(this.term) ? this.term : [this.term];

              var prepareTerm = function prepareTerm(term) {
                return _this57.accentSensitive ? term : removeAccents(term);
              };

              var escapedTerms = terms.map(function (term) {
                return regExpEscape(prepareTerm(toString(term)));
              }).filter(function (term) {
                return term;
              });
              var toSplit = this.accentSensitive ? result : removeAccents(result);
              var parts = escapedTerms.length ? toSplit.split(new RegExp("(".concat(escapedTerms.join('|'), ")"), 'gmi')) : [result];

              if (this.accentSensitive) {
                this.parts = parts;
              } else {
                var offset = 0;
                this.parts = parts.map(function (part) {
                  return result.substring(offset, offset += part.length);
                });
              }
            }
          }]);

          return NgbHighlight;
        }();

        NgbHighlight.ɵfac = function NgbHighlight_Factory(t) {
          return new (t || NgbHighlight)();
        };

        NgbHighlight.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbHighlight,
          selectors: [["ngb-highlight"]],
          inputs: {
            highlightClass: "highlightClass",
            accentSensitive: "accentSensitive",
            result: "result",
            term: "term"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
          decls: 1,
          vars: 1,
          consts: [["ngFor", "", 3, "ngForOf"], [3, "class", 4, "ngIf", "ngIfElse"], ["even", ""]],
          template: function NgbHighlight_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbHighlight_ng_template_0_Template, 3, 2, "ng-template", 0);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.parts);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf],
          styles: [".ngb-highlight{font-weight:700}"],
          encapsulation: 2,
          changeDetection: 0
        });
        return NgbHighlight;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var NgbTypeaheadWindow = /*#__PURE__*/function () {
        var NgbTypeaheadWindow = /*#__PURE__*/function () {
          function NgbTypeaheadWindow() {
            _classCallCheck(this, NgbTypeaheadWindow);

            this.activeIdx = 0;
            /**
             * Flag indicating if the first row should be active initially
             */

            this.focusFirst = true;
            /**
             * A function used to format a given result before display. This function should return a formatted string without any
             * HTML markup
             */

            this.formatter = toString;
            /**
             * Event raised when user selects a particular result row
             */

            this.selectEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.activeChangeEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          }

          _createClass(NgbTypeaheadWindow, [{
            key: "hasActive",
            value: function hasActive() {
              return this.activeIdx > -1 && this.activeIdx < this.results.length;
            }
          }, {
            key: "getActive",
            value: function getActive() {
              return this.results[this.activeIdx];
            }
          }, {
            key: "markActive",
            value: function markActive(activeIdx) {
              this.activeIdx = activeIdx;

              this._activeChanged();
            }
          }, {
            key: "next",
            value: function next() {
              if (this.activeIdx === this.results.length - 1) {
                this.activeIdx = this.focusFirst ? (this.activeIdx + 1) % this.results.length : -1;
              } else {
                this.activeIdx++;
              }

              this._activeChanged();
            }
          }, {
            key: "prev",
            value: function prev() {
              if (this.activeIdx < 0) {
                this.activeIdx = this.results.length - 1;
              } else if (this.activeIdx === 0) {
                this.activeIdx = this.focusFirst ? this.results.length - 1 : -1;
              } else {
                this.activeIdx--;
              }

              this._activeChanged();
            }
          }, {
            key: "resetActive",
            value: function resetActive() {
              this.activeIdx = this.focusFirst ? 0 : -1;

              this._activeChanged();
            }
          }, {
            key: "select",
            value: function select(item) {
              this.selectEvent.emit(item);
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this.resetActive();
            }
          }, {
            key: "_activeChanged",
            value: function _activeChanged() {
              this.activeChangeEvent.emit(this.activeIdx >= 0 ? this.id + '-' + this.activeIdx : undefined);
            }
          }]);

          return NgbTypeaheadWindow;
        }();

        NgbTypeaheadWindow.ɵfac = function NgbTypeaheadWindow_Factory(t) {
          return new (t || NgbTypeaheadWindow)();
        };

        NgbTypeaheadWindow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: NgbTypeaheadWindow,
          selectors: [["ngb-typeahead-window"]],
          hostAttrs: ["role", "listbox"],
          hostVars: 3,
          hostBindings: function NgbTypeaheadWindow_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mousedown", function NgbTypeaheadWindow_mousedown_HostBindingHandler($event) {
                return $event.preventDefault();
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("id", ctx.id);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"]("dropdown-menu show" + (ctx.popupClass ? " " + ctx.popupClass : ""));
            }
          },
          inputs: {
            focusFirst: "focusFirst",
            formatter: "formatter",
            id: "id",
            results: "results",
            term: "term",
            resultTemplate: "resultTemplate",
            popupClass: "popupClass"
          },
          outputs: {
            selectEvent: "select",
            activeChangeEvent: "activeChange"
          },
          exportAs: ["ngbTypeaheadWindow"],
          decls: 3,
          vars: 1,
          consts: [["rt", ""], ["ngFor", "", 3, "ngForOf"], [3, "result", "term"], ["type", "button", "role", "option", 1, "dropdown-item", 3, "id", "mouseenter", "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
          template: function NgbTypeaheadWindow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, NgbTypeaheadWindow_ng_template_0_Template, 1, 2, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, NgbTypeaheadWindow_ng_template_2_Template, 2, 9, "ng-template", 1);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.results);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _NgbHighlight, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet],
          encapsulation: 2
        });
        return NgbTypeaheadWindow;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var ARIA_LIVE_DELAY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('live announcer delay', {
        providedIn: 'root',
        factory: ARIA_LIVE_DELAY_FACTORY
      });

      function ARIA_LIVE_DELAY_FACTORY() {
        return 100;
      }

      function getLiveElement(document) {
        var lazyCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var element = document.body.querySelector('#ngb-live');

        if (element == null && lazyCreate) {
          element = document.createElement('div');
          element.setAttribute('id', 'ngb-live');
          element.setAttribute('aria-live', 'polite');
          element.setAttribute('aria-atomic', 'true');
          element.classList.add('sr-only');
          document.body.appendChild(element);
        }

        return element;
      }

      var Live = /*#__PURE__*/function () {
        var Live = /*#__PURE__*/function () {
          function Live(_document, _delay) {
            _classCallCheck(this, Live);

            this._document = _document;
            this._delay = _delay;
          }

          _createClass(Live, [{
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              var element = getLiveElement(this._document);

              if (element) {
                // if exists, it will always be attached to the <body>
                element.parentElement.removeChild(element);
              }
            }
          }, {
            key: "say",
            value: function say(message) {
              var element = getLiveElement(this._document, true);
              var delay = this._delay;

              if (element != null) {
                element.textContent = '';

                var setText = function setText() {
                  return element.textContent = message;
                };

                if (delay === null) {
                  setText();
                } else {
                  setTimeout(setText, delay);
                }
              }
            }
          }]);

          return Live;
        }();

        Live.ɵfac = function Live_Factory(t) {
          return new (t || Live)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](ARIA_LIVE_DELAY));
        };

        Live.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function Live_Factory() {
            return new Live((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(ARIA_LIVE_DELAY));
          },
          token: Live,
          providedIn: "root"
        });
        return Live;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * A configuration service for the [`NgbTypeahead`](#/components/typeahead/api#NgbTypeahead) component.
       *
       * You can inject this service, typically in your root component, and customize the values of its properties in
       * order to provide default values for all the typeaheads used in the application.
       */


      var _NgbTypeaheadConfig = /*#__PURE__*/function () {
        var NgbTypeaheadConfig = function NgbTypeaheadConfig() {
          _classCallCheck(this, NgbTypeaheadConfig);

          this.editable = true;
          this.focusFirst = true;
          this.showHint = false;
          this.placement = ['bottom-left', 'bottom-right', 'top-left', 'top-right'];
        };

        NgbTypeaheadConfig.ɵfac = function NgbTypeaheadConfig_Factory(t) {
          return new (t || NgbTypeaheadConfig)();
        };

        NgbTypeaheadConfig.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function NgbTypeaheadConfig_Factory() {
            return new NgbTypeaheadConfig();
          },
          token: NgbTypeaheadConfig,
          providedIn: "root"
        });
        return NgbTypeaheadConfig;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var nextWindowId = 0;
      /**
       * A directive providing a simple way of creating powerful typeaheads from any text input.
       */

      var _NgbTypeahead = /*#__PURE__*/function () {
        var NgbTypeahead = /*#__PURE__*/function () {
          function NgbTypeahead(_elementRef, viewContainerRef, _renderer, injector, componentFactoryResolver, config, ngZone, _live, _document, _ngZone, _changeDetector, applicationRef) {
            var _this58 = this;

            _classCallCheck(this, NgbTypeahead);

            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._live = _live;
            this._document = _document;
            this._ngZone = _ngZone;
            this._changeDetector = _changeDetector;
            this._subscription = null;
            this._closed$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
            this._inputValueBackup = null;
            this._windowRef = null;
            /**
             * The value for the `autocomplete` attribute for the `<input>` element.
             *
             * Defaults to `"off"` to disable the native browser autocomplete, but you can override it if necessary.
             *
             * @since 2.1.0
             */

            this.autocomplete = 'off';
            /**
             * The preferred placement of the typeahead.
             *
             * Possible values are `"top"`, `"top-left"`, `"top-right"`, `"bottom"`, `"bottom-left"`,
             * `"bottom-right"`, `"left"`, `"left-top"`, `"left-bottom"`, `"right"`, `"right-top"`,
             * `"right-bottom"`
             *
             * Accepts an array of strings or a string with space separated possible values.
             *
             * The default order of preference is `"bottom-left bottom-right top-left top-right"`
             *
             * Please see the [positioning overview](#/positioning) for more details.
             */

            this.placement = 'bottom-left';
            /**
             * An event emitted right before an item is selected from the result list.
             *
             * Event payload is of type [`NgbTypeaheadSelectItemEvent`](#/components/typeahead/api#NgbTypeaheadSelectItemEvent).
             */

            this.selectItem = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this.activeDescendant = null;
            this.popupId = "ngb-typeahead-".concat(nextWindowId++);

            this._onTouched = function () {};

            this._onChange = function (_) {};

            this.container = config.container;
            this.editable = config.editable;
            this.focusFirst = config.focusFirst;
            this.showHint = config.showHint;
            this.placement = config.placement;
            this._valueChanges = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(_elementRef.nativeElement, 'input').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function ($event) {
              return $event.target.value;
            }));
            this._resubscribeTypeahead = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
            this._popupService = new PopupService(NgbTypeaheadWindow, injector, viewContainerRef, _renderer, this._ngZone, componentFactoryResolver, applicationRef);
            this._zoneSubscription = ngZone.onStable.subscribe(function () {
              if (_this58.isPopupOpen()) {
                positionElements(_this58._elementRef.nativeElement, _this58._windowRef.location.nativeElement, _this58.placement, _this58.container === 'body');
              }
            });
          }

          _createClass(NgbTypeahead, [{
            key: "ngOnInit",
            value: function ngOnInit() {
              this._subscribeToUserInput();
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges(_ref29) {
              var ngbTypeahead = _ref29.ngbTypeahead;

              if (ngbTypeahead && !ngbTypeahead.firstChange) {
                this._unsubscribeFromUserInput();

                this._subscribeToUserInput();
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._closePopup();

              this._unsubscribeFromUserInput();

              this._zoneSubscription.unsubscribe();
            }
          }, {
            key: "registerOnChange",
            value: function registerOnChange(fn) {
              this._onChange = fn;
            }
          }, {
            key: "registerOnTouched",
            value: function registerOnTouched(fn) {
              this._onTouched = fn;
            }
          }, {
            key: "writeValue",
            value: function writeValue(value) {
              this._writeInputValue(this._formatItemForInput(value));

              if (this.showHint) {
                this._inputValueBackup = value;
              }
            }
          }, {
            key: "setDisabledState",
            value: function setDisabledState(isDisabled) {
              this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
            }
            /**
             * Dismisses typeahead popup window
             */

          }, {
            key: "dismissPopup",
            value: function dismissPopup() {
              if (this.isPopupOpen()) {
                this._resubscribeTypeahead.next(null);

                this._closePopup();

                if (this.showHint && this._inputValueBackup !== null) {
                  this._writeInputValue(this._inputValueBackup);
                }

                this._changeDetector.markForCheck();
              }
            }
            /**
             * Returns true if the typeahead popup window is displayed
             */

          }, {
            key: "isPopupOpen",
            value: function isPopupOpen() {
              return this._windowRef != null;
            }
          }, {
            key: "handleBlur",
            value: function handleBlur() {
              this._resubscribeTypeahead.next(null);

              this._onTouched();
            }
          }, {
            key: "handleKeyDown",
            value: function handleKeyDown(event) {
              if (!this.isPopupOpen()) {
                return;
              } // tslint:disable-next-line:deprecation


              switch (event.which) {
                case Key.ArrowDown:
                  event.preventDefault();

                  this._windowRef.instance.next();

                  this._showHint();

                  break;

                case Key.ArrowUp:
                  event.preventDefault();

                  this._windowRef.instance.prev();

                  this._showHint();

                  break;

                case Key.Enter:
                case Key.Tab:
                  var result = this._windowRef.instance.getActive();

                  if (isDefined(result)) {
                    event.preventDefault();
                    event.stopPropagation();

                    this._selectResult(result);
                  }

                  this._closePopup();

                  break;
              }
            }
          }, {
            key: "_openPopup",
            value: function _openPopup() {
              var _this59 = this;

              if (!this.isPopupOpen()) {
                this._inputValueBackup = this._elementRef.nativeElement.value;

                var _this$_popupService$o3 = this._popupService.open(),
                    windowRef = _this$_popupService$o3.windowRef;

                this._windowRef = windowRef;
                this._windowRef.instance.id = this.popupId;

                this._windowRef.instance.selectEvent.subscribe(function (result) {
                  return _this59._selectResultClosePopup(result);
                });

                this._windowRef.instance.activeChangeEvent.subscribe(function (activeId) {
                  return _this59.activeDescendant = activeId;
                });

                this._windowRef.instance.popupClass = this.popupClass;

                if (this.container === 'body') {
                  this._document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);
                }

                this._changeDetector.markForCheck();

                ngbAutoClose(this._ngZone, this._document, 'outside', function () {
                  return _this59.dismissPopup();
                }, this._closed$, [this._elementRef.nativeElement, this._windowRef.location.nativeElement]);
              }
            }
          }, {
            key: "_closePopup",
            value: function _closePopup() {
              var _this60 = this;

              this._popupService.close().subscribe(function () {
                _this60._closed$.next();

                _this60._windowRef = null;
                _this60.activeDescendant = null;
              });
            }
          }, {
            key: "_selectResult",
            value: function _selectResult(result) {
              var defaultPrevented = false;
              this.selectItem.emit({
                item: result,
                preventDefault: function preventDefault() {
                  defaultPrevented = true;
                }
              });

              this._resubscribeTypeahead.next(null);

              if (!defaultPrevented) {
                this.writeValue(result);

                this._onChange(result);
              }
            }
          }, {
            key: "_selectResultClosePopup",
            value: function _selectResultClosePopup(result) {
              this._selectResult(result);

              this._closePopup();
            }
          }, {
            key: "_showHint",
            value: function _showHint() {
              var _a;

              if (this.showHint && ((_a = this._windowRef) === null || _a === void 0 ? void 0 : _a.instance.hasActive()) && this._inputValueBackup != null) {
                var userInputLowerCase = this._inputValueBackup.toLowerCase();

                var formattedVal = this._formatItemForInput(this._windowRef.instance.getActive());

                if (userInputLowerCase === formattedVal.substr(0, this._inputValueBackup.length).toLowerCase()) {
                  this._writeInputValue(this._inputValueBackup + formattedVal.substr(this._inputValueBackup.length));

                  this._elementRef.nativeElement['setSelectionRange'].apply(this._elementRef.nativeElement, [this._inputValueBackup.length, formattedVal.length]);
                } else {
                  this._writeInputValue(formattedVal);
                }
              }
            }
          }, {
            key: "_formatItemForInput",
            value: function _formatItemForInput(item) {
              return item != null && this.inputFormatter ? this.inputFormatter(item) : toString(item);
            }
          }, {
            key: "_writeInputValue",
            value: function _writeInputValue(value) {
              this._renderer.setProperty(this._elementRef.nativeElement, 'value', toString(value));
            }
          }, {
            key: "_subscribeToUserInput",
            value: function _subscribeToUserInput() {
              var _this61 = this;

              var results$ = this._valueChanges.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(function (value) {
                _this61._inputValueBackup = _this61.showHint ? value : null;

                _this61._onChange(_this61.editable ? value : undefined);
              }), this.ngbTypeahead ? this.ngbTypeahead : function () {
                return (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.of)([]);
              });

              this._subscription = this._resubscribeTypeahead.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.switchMap)(function () {
                return results$;
              })).subscribe(function (results) {
                if (!results || results.length === 0) {
                  _this61._closePopup();
                } else {
                  _this61._openPopup();

                  _this61._windowRef.instance.focusFirst = _this61.focusFirst;
                  _this61._windowRef.instance.results = results;
                  _this61._windowRef.instance.term = _this61._elementRef.nativeElement.value;

                  if (_this61.resultFormatter) {
                    _this61._windowRef.instance.formatter = _this61.resultFormatter;
                  }

                  if (_this61.resultTemplate) {
                    _this61._windowRef.instance.resultTemplate = _this61.resultTemplate;
                  }

                  _this61._windowRef.instance.resetActive(); // The observable stream we are subscribing to might have async steps
                  // and if a component containing typeahead is using the OnPush strategy
                  // the change detection turn wouldn't be invoked automatically.


                  _this61._windowRef.changeDetectorRef.detectChanges();

                  _this61._showHint();
                } // live announcer


                var count = results ? results.length : 0;

                _this61._live.say(count === 0 ? 'No results available' : "".concat(count, " result").concat(count === 1 ? '' : 's', " available"));
              });
            }
          }, {
            key: "_unsubscribeFromUserInput",
            value: function _unsubscribeFromUserInput() {
              if (this._subscription) {
                this._subscription.unsubscribe();
              }

              this._subscription = null;
            }
          }]);

          return NgbTypeahead;
        }();

        NgbTypeahead.ɵfac = function NgbTypeahead_Factory(t) {
          return new (t || NgbTypeahead)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_NgbTypeaheadConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](Live), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef));
        };

        NgbTypeahead.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NgbTypeahead,
          selectors: [["input", "ngbTypeahead", ""]],
          hostAttrs: ["autocapitalize", "off", "autocorrect", "off", "role", "combobox", "aria-multiline", "false"],
          hostVars: 7,
          hostBindings: function NgbTypeahead_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("blur", function NgbTypeahead_blur_HostBindingHandler() {
                return ctx.handleBlur();
              })("keydown", function NgbTypeahead_keydown_HostBindingHandler($event) {
                return ctx.handleKeyDown($event);
              });
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("autocomplete", ctx.autocomplete);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-autocomplete", ctx.showHint ? "both" : "list")("aria-activedescendant", ctx.activeDescendant)("aria-owns", ctx.isPopupOpen() ? ctx.popupId : null)("aria-expanded", ctx.isPopupOpen());

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("open", ctx.isPopupOpen());
            }
          },
          inputs: {
            autocomplete: "autocomplete",
            placement: "placement",
            container: "container",
            editable: "editable",
            focusFirst: "focusFirst",
            showHint: "showHint",
            inputFormatter: "inputFormatter",
            ngbTypeahead: "ngbTypeahead",
            resultFormatter: "resultFormatter",
            resultTemplate: "resultTemplate",
            popupClass: "popupClass"
          },
          outputs: {
            selectItem: "selectItem"
          },
          exportAs: ["ngbTypeahead"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NG_VALUE_ACCESSOR,
            useExisting: (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return NgbTypeahead;
            }),
            multi: true
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return NgbTypeahead;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _NgbTypeaheadModule = /*#__PURE__*/function () {
        var NgbTypeaheadModule = function NgbTypeaheadModule() {
          _classCallCheck(this, NgbTypeaheadModule);
        };

        NgbTypeaheadModule.ɵfac = function NgbTypeaheadModule_Factory(t) {
          return new (t || NgbTypeaheadModule)();
        };

        NgbTypeaheadModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbTypeaheadModule
        });
        NgbTypeaheadModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
        });
        return NgbTypeaheadModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbTypeaheadModule, {
          declarations: function declarations() {
            return [_NgbTypeahead, _NgbHighlight, NgbTypeaheadWindow];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [_NgbTypeahead, _NgbHighlight];
          }
        });
      })();

      var NGB_MODULES = [_NgbAccordionModule, _NgbAlertModule, _NgbButtonsModule, _NgbCarouselModule, _NgbCollapseModule, _NgbDatepickerModule, _NgbDropdownModule, _NgbModalModule, _NgbNavModule, _NgbPaginationModule, _NgbPopoverModule, _NgbProgressbarModule, _NgbRatingModule, _NgbTimepickerModule, _NgbToastModule, _NgbTooltipModule, _NgbTypeaheadModule];

      var _NgbModule = /*#__PURE__*/function () {
        var NgbModule = function NgbModule() {
          _classCallCheck(this, NgbModule);
        };

        NgbModule.ɵfac = function NgbModule_Factory(t) {
          return new (t || NgbModule)();
        };

        NgbModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: NgbModule
        });
        NgbModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [NGB_MODULES, _NgbAccordionModule, _NgbAlertModule, _NgbButtonsModule, _NgbCarouselModule, _NgbCollapseModule, _NgbDatepickerModule, _NgbDropdownModule, _NgbModalModule, _NgbNavModule, _NgbPaginationModule, _NgbPopoverModule, _NgbProgressbarModule, _NgbRatingModule, _NgbTimepickerModule, _NgbToastModule, _NgbTooltipModule, _NgbTypeaheadModule]
        });
        return NgbModule;
      }();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_NgbModule, {
          imports: [_NgbAccordionModule, _NgbAlertModule, _NgbButtonsModule, _NgbCarouselModule, _NgbCollapseModule, _NgbDatepickerModule, _NgbDropdownModule, _NgbModalModule, _NgbNavModule, _NgbPaginationModule, _NgbPopoverModule, _NgbProgressbarModule, _NgbRatingModule, _NgbTimepickerModule, _NgbToastModule, _NgbTooltipModule, _NgbTypeaheadModule],
          exports: [_NgbAccordionModule, _NgbAlertModule, _NgbButtonsModule, _NgbCarouselModule, _NgbCollapseModule, _NgbDatepickerModule, _NgbDropdownModule, _NgbModalModule, _NgbNavModule, _NgbPaginationModule, _NgbPopoverModule, _NgbProgressbarModule, _NgbRatingModule, _NgbTimepickerModule, _NgbToastModule, _NgbTooltipModule, _NgbTypeaheadModule]
        });
      })();
      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    }
  }]);
})();
//# sourceMappingURL=node_modules_ng-bootstrap_ng-bootstrap_fesm2015_ng-bootstrap_js-_99180-es5.841eb6e26e7515a4a2f0.js.map