{"version":3,"mappings":"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","names":["DIR_DOCUMENT","InjectionToken","providedIn","factory","inject","DOCUMENT","Directionality","_","constructor","_document","this","value","change","EventEmitter","htmlDir","documentElement","dir","body","ngOnDestroy","complete","ɵfac","t","ɵngcc0","ɵprov","ɵɵdefineInjectable","ɵɵinject","token","BidiModule","ɵmod","type","ɵinj","fallbackValue","arguments","isNaN","parseFloat","Number","Array","isArray","elementOrRef","ElementRef","nativeElement","U","connect","$","_data","super","isObservable","of","disconnect","DataSource","T","applyChanges","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","forEachOperation","record","adjustedPreviousIndex","currentIndex","view","operation","previousIndex","insertContext","createEmbeddedView","templateRef","context","index","remove","get","move","detach","W","viewCacheSize","_viewCache","_insertView","_detachAndCacheView","_moveView","destroy","viewArgsFactory","cachedView","_insertViewFromCache","viewArgs","$implicit","detachedView","_maybeCacheView","length","push","indexOf","pop","insert","_VIEW_REPEATER_STRATEGY","hasV8BreakIterator","w","Intl","v8BreakIterator","_a","supportsPassiveEvents","rtlScrollAxisType","scrollBehaviorSupported","shadowDomIsSupported","m","Platform","_platformId","isBrowser","isPlatformBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","window","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","PLATFORM_ID","PlatformModule","options","addEventListener","Object","defineProperty","capture","Element","style","scrollToFunction","prototype","scrollTo","toString","scrollContainer","createElement","containerStyle","width","overflow","visibility","pointerEvents","position","content","contentStyle","height","appendChild","scrollLeft","parentNode","removeChild","element","head","createShadowRoot","attachShadow","rootNode","getRootNode","ShadowRoot","_c0","_c1","VIRTUAL_SCROLL_STRATEGY","D","itemSize","minBufferPx","maxBufferPx","_scrolledIndexChange","Subject","scrolledIndexChange","pipe","distinctUntilChanged","_viewport","_itemSize","_minBufferPx","_maxBufferPx","attach","viewport","_updateTotalContentSize","_updateRenderedRange","updateItemAndBufferSize","onContentScrolled","onDataLengthChanged","onContentRendered","onRenderedOffsetChanged","scrollToIndex","behavior","scrollToOffset","setTotalContentSize","getDataLength","renderedRange","getRenderedRange","newRange","start","end","viewportSize","getViewportSize","dataLength","scrollOffset","measureScrollOffset","firstVisibleIndex","maxVisibleItems","Math","ceil","newVisibleIndex","max","min","floor","startBuffer","expandStart","endBuffer","expandEnd","setRenderedRange","setRenderedContentOffset","next","fixedSizeDir","_scrollStrategy","h","CdkFixedSizeVirtualScroll","FixedSizeVirtualScrollStrategy","coerceNumberProperty","ngOnChanges","ɵdir","selectors","inputs","features","provide","useFactory","_fixedSizeVirtualScrollStrategyFactory","deps","forwardRef","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","scrollContainers","Map","register","scrollable","has","set","elementScrolled","subscribe","deregister","scrollableReference","unsubscribe","scrolled","auditTimeInMs","Observable","observer","_addGlobalListener","subscription","auditTime","_removeGlobalListener","forEach","container","ancestorScrolled","elementOrElementRef","ancestors","getAncestorScrollContainers","filter","target","scrollingContainers","_subscription","_scrollableContainsElement","_getWindow","defaultView","coerceElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","fromEvent","ɵngcc1","NgZone","CdkScrollable","elementRef","scrollDispatcher","ngZone","_destroyed","_elementScrolled","takeUntil","ngOnInit","el","isRtl","left","right","bottom","top","scrollHeight","clientHeight","getRtlScrollAxisType","scrollWidth","clientWidth","_applyScrollToOptions","supportsScrollBehavior","scrollTop","from","LEFT","RIGHT","ɵngcc2","ViewportRuler","_change","_changeListener","event","_updateViewportSize","removeEventListener","_viewportSize","output","getViewportRect","scrollPosition","getViewportScrollPosition","documentRect","getBoundingClientRect","scrollY","scrollX","throttleTime","innerWidth","innerHeight","SCROLL_SCHEDULER","requestAnimationFrame","animationFrameScheduler","asapScheduler","CdkVirtualScrollViewport","_changeDetectorRef","viewportRuler","_detachedSubject","_renderedRangeSubject","_orientation","Promise","resolve","then","run","renderedRangeStream","_totalContentSize","_totalContentWidth","_totalContentHeight","_renderedRange","_dataLength","_renderedContentOffset","_renderedContentOffsetNeedsRewrite","_isChangeDetectionPending","_runAfterChangeDetection","_viewportChanges","Subscription","checkViewportSize","orientation","_calculateSpacerSize","_measureViewportSize","startWith","_markChangeDetectionNeeded","forOf","_forOf","dataStream","data","newLength","_doChangeDetection","size","range","r1","r2","getOffsetToRenderedContentStart","offset","to","isHorizontal","axis","transform","_renderedContentTransform","measureRenderedContentSize","contentEl","_contentWrapper","offsetWidth","offsetHeight","measureRangeSize","viewportEl","runAfter","markForCheck","runAfterChangeDetection","fn","_step2","ɵcmp","viewQuery","rf","ctx","_t","first","hostAttrs","hostVars","hostBindings","outputs","useExisting","ngContentSelectors","decls","vars","consts","template","styles","encapsulation","changeDetection","CdkScrollableModule","ScrollingModule","imports","ctx_r0","justify","headerText","data_r2","ctx_r1","dataAccessor","name","base","args","_sticky","_hasStickyChanged","v","prevValue","coerceBooleanProperty","hasStickyChanged","resetStickyChanged","_class","o","CDK_TABLE","TEXT_COLUMN_OPTIONS","CdkCellDef","CdkHeaderCellDef","CdkFooterCellDef","_CdkColumnDefBase","mixinHasStickyInput","CdkColumnDef","_table","_stickyEnd","_name","_setNameInput","_updateColumnCssClassName","_columnCssClassName","cssClassFriendlyName","replace","contentQueries","dirIndex","cell","headerCell","footerCell","sticky","stickyEnd","X","columnDef","classList","className","_step3","add","CdkHeaderCell","BaseCdkCell","CdkFooterCell","CdkCell","tasks","endTasks","_COALESCED_STYLE_SCHEDULER","_CoalescedStyleScheduler","_currentSchedule","schedule","task","_createScheduleIfNeeded","scheduleEnd","_Schedule","_getScheduleObservable","_step4","_step5","isStable","onStable","take","CDK_ROW_TEMPLATE","BaseRowDef","_differs","_columnsDiffer","columns","currentValue","find","create","diff","getColumnsDiff","extractCellTemplate","column","CdkHeaderRowDef","CdkFooterRowDef","_CdkHeaderRowDefBase","_CdkFooterRowDefBase","CdkRowDef","when","CdkCellOutlet","_viewContainer","mostRecentCellOutlet","CdkHeaderRow","directives","CdkFooterRow","CdkRow","CdkNoDataRow","STICKY_DIRECTIONS","ye","_isNativeHtmlTable","_stickCellCss","direction","_coalescedStyleScheduler","_positionListener","_isBrowser","_needsPositionStickyOnElement","_cachedCellWidths","_borderCellCss","clearStickyPositioning","rows","stickyDirections","elementsToClear","row","_step6","nodeType","ELEMENT_NODE","i","children","_scheduleStyleChanges","_step7","_removeStickyStyle","updateStickyColumns","stickyStartStates","stickyEndStates","recalculateCellWidths","some","state","firstRow","numCells","cellWidths","_getCellWidths","startPositions","_getStickyStartColumnPositions","endPositions","_getStickyEndColumnPositions","lastStickyStart","lastIndexOf","firstStickyEnd","_step8","_iterator8","_addStickyStyle","stickyColumnsUpdated","sizes","slice","map","stickyEndColumnsUpdated","reverse","stickRows","rowsToStick","stickyStates","states","stickyOffsets","stickyCellHeights","elementsToStick","rowIndex","stickyOffset","borderedRowIndex","_b","_step9","isBorderedRowIndex","_iterator9","stickyHeaderRowsUpdated","elements","stickyFooterRowsUpdated","updateStickyFooterContainer","tableElement","tfoot","querySelector","_step10","zIndex","_getCalculatedZIndex","dirValue","isBorderElement","cssText","zIndexIncrements","_step11","firstRowCells","widths","positions","nextPosition","STICKY_POSITIONING_LISTENER","DataRowOutlet","viewContainer","HeaderRowOutlet","FooterRowOutlet","NoDataRowOutlet","CDK_TABLE_TEMPLATE","CdkTable","_elementRef","role","_dir","_viewRepeater","_stickyPositioningListener","_viewportRuler","_onDestroy","_columnDefsByName","_customColumnDefs","Set","_customRowDefs","_customHeaderRowDefs","_customFooterRowDefs","_headerRowDefChanged","_footerRowDefChanged","_stickyColumnStylesNeedReset","_forceRecalculateCellWidths","_cachedRenderRowsMap","stickyCssClass","needsPositionStickyOnElement","_isShowingNoDataRow","_multiTemplateDataRows","_fixedLayout","viewChange","BehaviorSubject","MAX_VALUE","setAttribute","nodeName","trackBy","_trackByFn","_dataSource","dataSource","_switchDataSource","_rowOutlet","_forceRenderDataRows","updateStickyColumnStyles","_setupStickyStyler","_applyNativeTableSections","_dataDiffer","_i","dataRow","dataIndex","ngAfterContentChecked","_cacheRowDefs","_cacheColumnDefs","rowDefsChanged","columnsChanged","_renderUpdatedColumns","_forceRenderHeaderRows","_forceRenderFooterRows","_rowDefs","_renderChangeSubscription","_observeRenderChanges","_checkStickyStates","clear","_noDataRowOutlet","_headerRowOutlet","_footerRowOutlet","isDataSource","renderRows","_renderRows","_getAllRenderRows","_adjustedPreviousIndex","_getEmbeddedViewArgs","item","_renderCellTemplateForItem","rowDef","prevIndex","renderRow","_renderRow","_updateRowIndexContext","forEachIdentityChange","_updateNoDataRow","addColumnDef","removeColumnDef","addRowDef","removeRowDef","addHeaderRowDef","headerRowDef","removeHeaderRowDef","addFooterRowDef","footerRowDef","removeFooterRowDef","setNoDataRow","noDataRow","_customNoDataRow","updateStickyHeaderRowStyles","headerRows","_getRenderedRows","thead","display","_headerRowDefs","def","_stickyStyler","updateStickyFooterRowStyles","footerRows","_footerRowDefs","dataRows","headerRow","_addStickyColumnStyles","footerRow","values","prevCachedRenderRows","renderRowsForData","_getRenderRowsForData","WeakMap","j","cache","rowDefs","_getRowDefs","cachedRenderRows","shift","mergeArrayAndSet","_getOwnDefs","_contentColumnDefs","_contentHeaderRowDefs","_contentFooterRowDefs","_contentRowDefs","defaultRowDefs","_defaultRowDef","columnsDiffReducer","acc","dataColumnsChanged","reduce","headerColumnsChanged","footerColumnsChanged","columnDefs","columnName","rowOutlet","renderedRows","viewRef","rootNodes","multiTemplateDataRows","outlet","_getCellTemplates","cellTemplate","_step12","renderIndex","count","last","even","odd","columnId","documentFragment","createDocumentFragment","_i4","tag","outlets","section","_step13","stickyCheckReducer","d","StickyStyler","items","_noDataRow","shouldShow","ɵngcc3","fixedLayout","exportAs","useClass","_DisposeViewRepeaterStrategy","useValue","array","concat","CdkTextColumn","_options","_syncColumnDefName","_createDefaultHeaderText","defaultDataAccessor","defaultHeaderTextTransform","toUpperCase","CdkTextColumn_th_1_Template","CdkTextColumn_td_2_Template","CdkTableModule"],"sources":["webpack:///node_modules/@angular/cdk/fesm2015/bidi.js","webpack:///node_modules/@angular/cdk/fesm2015/coercion.js","webpack:///node_modules/@angular/cdk/fesm2015/collections.js","webpack:///node_modules/@angular/cdk/fesm2015/platform.js","webpack:///node_modules/@angular/cdk/fesm2015/scrolling.js","webpack:///node_modules/@angular/cdk/fesm2015/table.js"],"sourcesContent":["import { InjectionToken, inject, EventEmitter, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, Inject, Directive, Output, Input, NgModule } from '@angular/core';\r\nimport { DOCUMENT } from '@angular/common';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token used to inject the document into Directionality.\r\n * This is used so that the value can be faked in tests.\r\n *\r\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\r\n * tests in Safari to fail.\r\n *\r\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\r\n * themselves use things like `querySelector` in test code.\r\n *\r\n * This token is defined in a separate file from Directionality as a workaround for\r\n * https://github.com/angular/angular/issues/22559\r\n *\r\n * @docs-private\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\r\n    providedIn: 'root',\r\n    factory: DIR_DOCUMENT_FACTORY,\r\n});\r\n/** @docs-private */\r\nfunction DIR_DOCUMENT_FACTORY() {\r\n    return inject(DOCUMENT);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\r\n * Exposes the current direction and a stream of direction changes.\r\n */\r\nclass Directionality {\r\n    constructor(_document) {\r\n        /** The current 'ltr' or 'rtl' value. */\r\n        this.value = 'ltr';\r\n        /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\r\n        this.change = new EventEmitter();\r\n        if (_document) {\r\n            // TODO: handle 'auto' value -\r\n            // We still need to account for dir=\"auto\".\r\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\r\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\r\n            const bodyDir = _document.body ? _document.body.dir : null;\r\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\r\n            const value = bodyDir || htmlDir;\r\n            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.change.complete();\r\n    }\r\n}\r\nDirectionality.ɵfac = function Directionality_Factory(t) { return new (t || Directionality)(ɵngcc0.ɵɵinject(DIR_DOCUMENT, 8)); };\r\nDirectionality.ɵprov = ɵɵdefineInjectable({ factory: function Directionality_Factory() { return new Directionality(ɵɵinject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\r\nDirectionality.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Directionality, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DIR_DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Directive to listen for changes of direction of part of the DOM.\r\n *\r\n * Provides itself as Directionality such that descendant directives only need to ever inject\r\n * Directionality to get the closest direction.\r\n */\r\nclass Dir {\r\n    constructor() {\r\n        /** Normalized direction that accounts for invalid/unsupported values. */\r\n        this._dir = 'ltr';\r\n        /** Whether the `value` has been set to its initial value. */\r\n        this._isInitialized = false;\r\n        /** Event emitted when the direction changes. */\r\n        this.change = new EventEmitter();\r\n    }\r\n    /** @docs-private */\r\n    get dir() { return this._dir; }\r\n    set dir(value) {\r\n        const old = this._dir;\r\n        const normalizedValue = value ? value.toLowerCase() : value;\r\n        this._rawDir = value;\r\n        this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\r\n        if (old !== this._dir && this._isInitialized) {\r\n            this.change.emit(this._dir);\r\n        }\r\n    }\r\n    /** Current layout direction of the element. */\r\n    get value() { return this.dir; }\r\n    /** Initialize once default value has been set. */\r\n    ngAfterContentInit() {\r\n        this._isInitialized = true;\r\n    }\r\n    ngOnDestroy() {\r\n        this.change.complete();\r\n    }\r\n}\r\nDir.ɵfac = function Dir_Factory(t) { return new (t || Dir)(); };\r\nDir.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"dir\", ctx._rawDir);\r\n    } }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: Directionality, useExisting: Dir }])] });\r\nDir.propDecorators = {\r\n    change: [{ type: Output, args: ['dirChange',] }],\r\n    dir: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Dir, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[dir]',\r\n                providers: [{ provide: Directionality, useExisting: Dir }],\r\n                host: { '[attr.dir]': '_rawDir' },\r\n                exportAs: 'dir'\r\n            }]\r\n    }], function () { return []; }, { change: [{\r\n            type: Output,\r\n            args: ['dirChange']\r\n        }], dir: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass BidiModule {\r\n}\r\nBidiModule.ɵfac = function BidiModule_Factory(t) { return new (t || BidiModule)(); };\r\nBidiModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BidiModule });\r\nBidiModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BidiModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: [Dir],\r\n                declarations: [Dir]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BidiModule, { declarations: [Dir], exports: [Dir] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { BidiModule, DIR_DOCUMENT, Dir, Directionality, DIR_DOCUMENT_FACTORY as ɵangular_material_src_cdk_bidi_bidi_a };\r\n\r\n","import { ElementRef } from '@angular/core';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nfunction _isNumberValue(value) {\r\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction coerceArray(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Coerces a value to a CSS pixel value. */\r\nfunction coerceCssPixelValue(value) {\r\n    if (value == null) {\r\n        return '';\r\n    }\r\n    return typeof value === 'string' ? value : `${value}px`;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Coerces an ElementRef or an Element into an element.\r\n * Useful for APIs that can accept either a ref or the native element itself.\r\n */\r\nfunction coerceElement(elementOrRef) {\r\n    return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Coerces a value to an array of trimmed non-empty strings.\r\n * Any input that is not an array, `null` or `undefined` will be turned into a string\r\n * via `toString()` and subsequently split with the given separator.\r\n * `null` and `undefined` will result in an empty array.\r\n * This results in the following outcomes:\r\n * - `null` -&gt; `[]`\r\n * - `[null]` -&gt; `[\"null\"]`\r\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\r\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\r\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\r\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\r\n *\r\n * Useful for defining CSS classes or table columns.\r\n * @param value the value to coerce into an array of strings\r\n * @param separator split-separator if value isn't an array\r\n */\r\nfunction coerceStringArray(value, separator = /\\s+/) {\r\n    const result = [];\r\n    if (value != null) {\r\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\r\n        for (const sourceValue of sourceValues) {\r\n            const trimmedString = `${sourceValue}`.trim();\r\n            if (trimmedString) {\r\n                result.push(trimmedString);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nexport { _isNumberValue, coerceArray, coerceBooleanProperty, coerceCssPixelValue, coerceElement, coerceNumberProperty, coerceStringArray };\r\n\n","import { isObservable, of, Subject } from 'rxjs';\r\nimport { ɵɵdefineInjectable, Injectable, InjectionToken } from '@angular/core';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nclass DataSource {\r\n}\r\n/** Checks whether an object is a data source. */\r\nfunction isDataSource(value) {\r\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\r\n    // be checked as an `instanceof DataSource` since people could create their own sources\r\n    // that match the interface, but don't extend DataSource.\r\n    return value && typeof value.connect === 'function';\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** DataSource wrapper for a native array. */\r\nclass ArrayDataSource extends DataSource {\r\n    constructor(_data) {\r\n        super();\r\n        this._data = _data;\r\n    }\r\n    connect() {\r\n        return isObservable(this._data) ? this._data : of(this._data);\r\n    }\r\n    disconnect() { }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A repeater that destroys views when they are removed from a\r\n * {@link ViewContainerRef}. When new items are inserted into the container,\r\n * the repeater will always construct a new embedded view for each item.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\r\nclass _DisposeViewRepeaterStrategy {\r\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\r\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\r\n            let view;\r\n            let operation;\r\n            if (record.previousIndex == null) {\r\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\r\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\r\n                operation = 1 /* INSERTED */;\r\n            }\r\n            else if (currentIndex == null) {\r\n                viewContainerRef.remove(adjustedPreviousIndex);\r\n                operation = 3 /* REMOVED */;\r\n            }\r\n            else {\r\n                view = viewContainerRef.get(adjustedPreviousIndex);\r\n                viewContainerRef.move(view, currentIndex);\r\n                operation = 2 /* MOVED */;\r\n            }\r\n            if (itemViewChanged) {\r\n                itemViewChanged({\r\n                    context: view === null || view === void 0 ? void 0 : view.context,\r\n                    operation,\r\n                    record,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    detach() {\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A repeater that caches views when they are removed from a\r\n * {@link ViewContainerRef}. When new items are inserted into the container,\r\n * the repeater will reuse one of the cached views instead of creating a new\r\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\r\n * inserts.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\r\nclass _RecycleViewRepeaterStrategy {\r\n    constructor() {\r\n        /**\r\n         * The size of the cache used to store unused views.\r\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\r\n         */\r\n        this.viewCacheSize = 20;\r\n        /**\r\n         * View cache that stores embedded view instances that have been previously stamped out,\r\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\r\n         * creating brand new ones.\r\n         *\r\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\r\n         */\r\n        this._viewCache = [];\r\n    }\r\n    /** Apply changes to the DOM. */\r\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\r\n        // Rearrange the views to put them in the right location.\r\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\r\n            let view;\r\n            let operation;\r\n            if (record.previousIndex == null) { // Item added.\r\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\r\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\r\n            }\r\n            else if (currentIndex == null) { // Item removed.\r\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\r\n                operation = 3 /* REMOVED */;\r\n            }\r\n            else { // Item moved.\r\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = 2 /* MOVED */;\r\n            }\r\n            if (itemViewChanged) {\r\n                itemViewChanged({\r\n                    context: view === null || view === void 0 ? void 0 : view.context,\r\n                    operation,\r\n                    record,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    detach() {\r\n        for (const view of this._viewCache) {\r\n            view.destroy();\r\n        }\r\n        this._viewCache = [];\r\n    }\r\n    /**\r\n     * Inserts a view for a new item, either from the cache or by creating a new\r\n     * one. Returns `undefined` if the item was inserted into a cached view.\r\n     */\r\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\r\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\r\n        if (cachedView) {\r\n            cachedView.context.$implicit = value;\r\n            return undefined;\r\n        }\r\n        const viewArgs = viewArgsFactory();\r\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\r\n    }\r\n    /** Detaches the view at the given index and inserts into the view cache. */\r\n    _detachAndCacheView(index, viewContainerRef) {\r\n        const detachedView = viewContainerRef.detach(index);\r\n        this._maybeCacheView(detachedView, viewContainerRef);\r\n    }\r\n    /** Moves view at the previous index to the current index. */\r\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\r\n        const view = viewContainerRef.get(adjustedPreviousIndex);\r\n        viewContainerRef.move(view, currentIndex);\r\n        view.context.$implicit = value;\r\n        return view;\r\n    }\r\n    /**\r\n     * Cache the given detached view. If the cache is full, the view will be\r\n     * destroyed.\r\n     */\r\n    _maybeCacheView(view, viewContainerRef) {\r\n        if (this._viewCache.length < this.viewCacheSize) {\r\n            this._viewCache.push(view);\r\n        }\r\n        else {\r\n            const index = viewContainerRef.indexOf(view);\r\n            // The host component could remove views from the container outside of\r\n            // the view repeater. It's unlikely this will occur, but just in case,\r\n            // destroy the view on its own, otherwise destroy it through the\r\n            // container to ensure that all the references are removed.\r\n            if (index === -1) {\r\n                view.destroy();\r\n            }\r\n            else {\r\n                viewContainerRef.remove(index);\r\n            }\r\n        }\r\n    }\r\n    /** Inserts a recycled view from the cache at the given index. */\r\n    _insertViewFromCache(index, viewContainerRef) {\r\n        const cachedView = this._viewCache.pop();\r\n        if (cachedView) {\r\n            viewContainerRef.insert(cachedView, index);\r\n        }\r\n        return cachedView || null;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Class to be used to power selecting one or more options from a list.\r\n */\r\nclass SelectionModel {\r\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\r\n        this._multiple = _multiple;\r\n        this._emitChanges = _emitChanges;\r\n        /** Currently-selected values. */\r\n        this._selection = new Set();\r\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\r\n        this._deselectedToEmit = [];\r\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\r\n        this._selectedToEmit = [];\r\n        /** Event emitted when the value has changed. */\r\n        this.changed = new Subject();\r\n        if (initiallySelectedValues && initiallySelectedValues.length) {\r\n            if (_multiple) {\r\n                initiallySelectedValues.forEach(value => this._markSelected(value));\r\n            }\r\n            else {\r\n                this._markSelected(initiallySelectedValues[0]);\r\n            }\r\n            // Clear the array in order to avoid firing the change event for preselected values.\r\n            this._selectedToEmit.length = 0;\r\n        }\r\n    }\r\n    /** Selected values. */\r\n    get selected() {\r\n        if (!this._selected) {\r\n            this._selected = Array.from(this._selection.values());\r\n        }\r\n        return this._selected;\r\n    }\r\n    /**\r\n     * Selects a value or an array of values.\r\n     */\r\n    select(...values) {\r\n        this._verifyValueAssignment(values);\r\n        values.forEach(value => this._markSelected(value));\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Deselects a value or an array of values.\r\n     */\r\n    deselect(...values) {\r\n        this._verifyValueAssignment(values);\r\n        values.forEach(value => this._unmarkSelected(value));\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Toggles a value between selected and deselected.\r\n     */\r\n    toggle(value) {\r\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\r\n    }\r\n    /**\r\n     * Clears all of the selected values.\r\n     */\r\n    clear() {\r\n        this._unmarkAll();\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Determines whether a value is selected.\r\n     */\r\n    isSelected(value) {\r\n        return this._selection.has(value);\r\n    }\r\n    /**\r\n     * Determines whether the model does not have a value.\r\n     */\r\n    isEmpty() {\r\n        return this._selection.size === 0;\r\n    }\r\n    /**\r\n     * Determines whether the model has a value.\r\n     */\r\n    hasValue() {\r\n        return !this.isEmpty();\r\n    }\r\n    /**\r\n     * Sorts the selected values based on a predicate function.\r\n     */\r\n    sort(predicate) {\r\n        if (this._multiple && this.selected) {\r\n            this._selected.sort(predicate);\r\n        }\r\n    }\r\n    /**\r\n     * Gets whether multiple values can be selected.\r\n     */\r\n    isMultipleSelection() {\r\n        return this._multiple;\r\n    }\r\n    /** Emits a change event and clears the records of selected and deselected values. */\r\n    _emitChangeEvent() {\r\n        // Clear the selected values so they can be re-cached.\r\n        this._selected = null;\r\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\r\n            this.changed.next({\r\n                source: this,\r\n                added: this._selectedToEmit,\r\n                removed: this._deselectedToEmit\r\n            });\r\n            this._deselectedToEmit = [];\r\n            this._selectedToEmit = [];\r\n        }\r\n    }\r\n    /** Selects a value. */\r\n    _markSelected(value) {\r\n        if (!this.isSelected(value)) {\r\n            if (!this._multiple) {\r\n                this._unmarkAll();\r\n            }\r\n            this._selection.add(value);\r\n            if (this._emitChanges) {\r\n                this._selectedToEmit.push(value);\r\n            }\r\n        }\r\n    }\r\n    /** Deselects a value. */\r\n    _unmarkSelected(value) {\r\n        if (this.isSelected(value)) {\r\n            this._selection.delete(value);\r\n            if (this._emitChanges) {\r\n                this._deselectedToEmit.push(value);\r\n            }\r\n        }\r\n    }\r\n    /** Clears out the selected values. */\r\n    _unmarkAll() {\r\n        if (!this.isEmpty()) {\r\n            this._selection.forEach(value => this._unmarkSelected(value));\r\n        }\r\n    }\r\n    /**\r\n     * Verifies the value assignment and throws an error if the specified value array is\r\n     * including multiple values while the selection model is not supporting multiple values.\r\n     */\r\n    _verifyValueAssignment(values) {\r\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getMultipleValuesInSingleSelectionError();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns an error that reports that multiple values are passed into a selection model\r\n * with a single value.\r\n * @docs-private\r\n */\r\nfunction getMultipleValuesInSingleSelectionError() {\r\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Class to coordinate unique selection based on name.\r\n * Intended to be consumed as an Angular service.\r\n * This service is needed because native radio change events are only fired on the item currently\r\n * being selected, and we still need to uncheck the previous selection.\r\n *\r\n * This service does not *store* any IDs and names because they may change at any time, so it is\r\n * less error-prone if they are simply passed through when the events occur.\r\n */\r\nclass UniqueSelectionDispatcher {\r\n    constructor() {\r\n        this._listeners = [];\r\n    }\r\n    /**\r\n     * Notify other items that selection for the given name has been set.\r\n     * @param id ID of the item.\r\n     * @param name Name of the item.\r\n     */\r\n    notify(id, name) {\r\n        for (let listener of this._listeners) {\r\n            listener(id, name);\r\n        }\r\n    }\r\n    /**\r\n     * Listen for future changes to item selection.\r\n     * @return Function used to deregister listener\r\n     */\r\n    listen(listener) {\r\n        this._listeners.push(listener);\r\n        return () => {\r\n            this._listeners = this._listeners.filter((registered) => {\r\n                return listener !== registered;\r\n            });\r\n        };\r\n    }\r\n    ngOnDestroy() {\r\n        this._listeners = [];\r\n    }\r\n}\r\nUniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\r\nUniqueSelectionDispatcher.ɵprov = ɵɵdefineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UniqueSelectionDispatcher, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return []; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\r\n * @docs-private\r\n */\r\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, getMultipleValuesInSingleSelectionError, isDataSource };\r\n\r\n","import { ɵɵdefineInjectable, ɵɵinject, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\r\nimport { isPlatformBrowser } from '@angular/common';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// Whether the current platform supports the V8 Break Iterator. The V8 check\r\n// is necessary to detect all Blink based browsers.\r\nimport * as ɵngcc0 from '@angular/core';\r\nlet hasV8BreakIterator;\r\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\r\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\r\n// the consumer is providing a polyfilled `Map`. See:\r\n// https://github.com/Microsoft/ChakraCore/issues/3189\r\n// https://github.com/angular/components/issues/15687\r\ntry {\r\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\r\n}\r\ncatch (_a) {\r\n    hasV8BreakIterator = false;\r\n}\r\n/**\r\n * Service to detect the current platform by comparing the userAgent strings and\r\n * checking browser-specific global properties.\r\n */\r\nclass Platform {\r\n    constructor(_platformId) {\r\n        this._platformId = _platformId;\r\n        // We want to use the Angular platform check because if the Document is shimmed\r\n        // without the navigator, the following checks will fail. This is preferred because\r\n        // sometimes the Document may be shimmed without the user's knowledge or intention\r\n        /** Whether the Angular application is being rendered in the browser. */\r\n        this.isBrowser = this._platformId ?\r\n            isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\r\n        /** Whether the current browser is Microsoft Edge. */\r\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\r\n        /** Whether the current rendering engine is Microsoft Trident. */\r\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\r\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\r\n        /** Whether the current rendering engine is Blink. */\r\n        this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\r\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\r\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\r\n        // ensure that Webkit runs standalone and is not used as another engine's base.\r\n        /** Whether the current rendering engine is WebKit. */\r\n        this.WEBKIT = this.isBrowser &&\r\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\r\n        /** Whether the current platform is Apple iOS. */\r\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\r\n            !('MSStream' in window);\r\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\r\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\r\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\r\n        // instead of having an unstable check for Gecko.\r\n        /** Whether the current browser is Firefox. */\r\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\r\n        /** Whether the current platform is Android. */\r\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\r\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\r\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\r\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\r\n        // Safari browser should also use Webkit as its layout engine.\r\n        /** Whether the current browser is Safari. */\r\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\r\n    }\r\n}\r\nPlatform.ɵfac = function Platform_Factory(t) { return new (t || Platform)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };\r\nPlatform.ɵprov = ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(ɵɵinject(PLATFORM_ID)); }, token: Platform, providedIn: \"root\" });\r\nPlatform.ctorParameters = () => [\r\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Platform, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: Object, decorators: [{\r\n                type: Inject,\r\n                args: [PLATFORM_ID]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass PlatformModule {\r\n}\r\nPlatformModule.ɵfac = function PlatformModule_Factory(t) { return new (t || PlatformModule)(); };\r\nPlatformModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PlatformModule });\r\nPlatformModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlatformModule, [{\r\n        type: NgModule,\r\n        args: [{}]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result Set of input types support by the current browser. */\r\nlet supportedInputTypes;\r\n/** Types of `<input>` that *might* be supported. */\r\nconst candidateInputTypes = [\r\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\r\n    // first changing it to something else:\r\n    // The specified value \"\" does not conform to the required format.\r\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\r\n    'color',\r\n    'button',\r\n    'checkbox',\r\n    'date',\r\n    'datetime-local',\r\n    'email',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'month',\r\n    'number',\r\n    'password',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'search',\r\n    'submit',\r\n    'tel',\r\n    'text',\r\n    'time',\r\n    'url',\r\n    'week',\r\n];\r\n/** @returns The input types supported by this browser. */\r\nfunction getSupportedInputTypes() {\r\n    // Result is cached.\r\n    if (supportedInputTypes) {\r\n        return supportedInputTypes;\r\n    }\r\n    // We can't check if an input type is not supported until we're on the browser, so say that\r\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\r\n    // just a helper function and can't inject it.\r\n    if (typeof document !== 'object' || !document) {\r\n        supportedInputTypes = new Set(candidateInputTypes);\r\n        return supportedInputTypes;\r\n    }\r\n    let featureTestInput = document.createElement('input');\r\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\r\n        featureTestInput.setAttribute('type', value);\r\n        return featureTestInput.type === value;\r\n    }));\r\n    return supportedInputTypes;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result of whether the user's browser supports passive event listeners. */\r\nlet supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\r\nfunction supportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                get: () => supportsPassiveEvents = true\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\r\nfunction normalizePassiveListenerOptions(options) {\r\n    return supportsPassiveEventListeners() ? options : !!options.capture;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\r\nlet rtlScrollAxisType;\r\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\r\nlet scrollBehaviorSupported;\r\n/** Check whether the browser supports scroll behaviors. */\r\nfunction supportsScrollBehavior() {\r\n    if (scrollBehaviorSupported == null) {\r\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\r\n        // some projects stub out the global `document` during SSR which can throw us off.\r\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\r\n            scrollBehaviorSupported = false;\r\n            return scrollBehaviorSupported;\r\n        }\r\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\r\n        if ('scrollBehavior' in document.documentElement.style) {\r\n            scrollBehaviorSupported = true;\r\n        }\r\n        else {\r\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\r\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\r\n            const scrollToFunction = Element.prototype.scrollTo;\r\n            if (scrollToFunction) {\r\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\r\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\r\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\r\n                // polyfilled functions as supporting scroll behavior.\r\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\r\n            }\r\n            else {\r\n                scrollBehaviorSupported = false;\r\n            }\r\n        }\r\n    }\r\n    return scrollBehaviorSupported;\r\n}\r\n/**\r\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\r\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\r\n */\r\nfunction getRtlScrollAxisType() {\r\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\r\n    if (typeof document !== 'object' || !document) {\r\n        return 0 /* NORMAL */;\r\n    }\r\n    if (rtlScrollAxisType == null) {\r\n        // Create a 1px wide scrolling container and a 2px wide content element.\r\n        const scrollContainer = document.createElement('div');\r\n        const containerStyle = scrollContainer.style;\r\n        scrollContainer.dir = 'rtl';\r\n        containerStyle.width = '1px';\r\n        containerStyle.overflow = 'auto';\r\n        containerStyle.visibility = 'hidden';\r\n        containerStyle.pointerEvents = 'none';\r\n        containerStyle.position = 'absolute';\r\n        const content = document.createElement('div');\r\n        const contentStyle = content.style;\r\n        contentStyle.width = '2px';\r\n        contentStyle.height = '1px';\r\n        scrollContainer.appendChild(content);\r\n        document.body.appendChild(scrollContainer);\r\n        rtlScrollAxisType = 0 /* NORMAL */;\r\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\r\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\r\n        // dealing with one of the other two types of browsers.\r\n        if (scrollContainer.scrollLeft === 0) {\r\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\r\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\r\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\r\n            // return 0 when we read it again.\r\n            scrollContainer.scrollLeft = 1;\r\n            rtlScrollAxisType =\r\n                scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\r\n        }\r\n        scrollContainer.parentNode.removeChild(scrollContainer);\r\n    }\r\n    return rtlScrollAxisType;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nlet shadowDomIsSupported;\r\n/** Checks whether the user's browser support Shadow DOM. */\r\nfunction _supportsShadowDom() {\r\n    if (shadowDomIsSupported == null) {\r\n        const head = typeof document !== 'undefined' ? document.head : null;\r\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\r\n    }\r\n    return shadowDomIsSupported;\r\n}\r\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\r\nfunction _getShadowRoot(element) {\r\n    if (_supportsShadowDom()) {\r\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\r\n        // Note that this should be caught by `_supportsShadowDom`, but some\r\n        // teams have been able to hit this code path on unsupported browsers.\r\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\r\n            return rootNode;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { Platform, PlatformModule, _getShadowRoot, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };\r\n\r\n","import { coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { InjectionToken, Directive, forwardRef, Input, ɵɵdefineInjectable, ɵɵinject, NgZone, Injectable, Optional, Inject, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Output, ViewChild, ViewContainerRef, TemplateRef, IterableDiffers, SkipSelf, NgModule } from '@angular/core';\r\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\r\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\r\nimport { Platform, getRtlScrollAxisType, supportsScrollBehavior, PlatformModule } from '@angular/cdk/platform';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\r\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** The injection token used to specify the virtual scrolling strategy. */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/platform';\r\nimport * as ɵngcc2 from '@angular/cdk/bidi';\r\nimport * as ɵngcc3 from '@angular/cdk/collections';\r\n\r\nconst _c0 = [\"contentWrapper\"];\r\nconst _c1 = [\"*\"];\r\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Virtual scrolling strategy for lists with items of known fixed size. */\r\nclass FixedSizeVirtualScrollStrategy {\r\n    /**\r\n     * @param itemSize The size of the items in the virtually scrolling list.\r\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     */\r\n    constructor(itemSize, minBufferPx, maxBufferPx) {\r\n        this._scrolledIndexChange = new Subject();\r\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\r\n        /** The attached viewport. */\r\n        this._viewport = null;\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n    }\r\n    /**\r\n     * Attaches this scroll strategy to a viewport.\r\n     * @param viewport The viewport to attach this strategy to.\r\n     */\r\n    attach(viewport) {\r\n        this._viewport = viewport;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** Detaches this scroll strategy from the currently attached viewport. */\r\n    detach() {\r\n        this._scrolledIndexChange.complete();\r\n        this._viewport = null;\r\n    }\r\n    /**\r\n     * Update the item size and buffer size.\r\n     * @param itemSize The size of the items in the virtually scrolling list.\r\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     */\r\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\r\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\r\n        }\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onContentScrolled() {\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onDataLengthChanged() {\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onContentRendered() { }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onRenderedOffsetChanged() { }\r\n    /**\r\n     * Scroll to the offset for the given index.\r\n     * @param index The index of the element to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling.\r\n     */\r\n    scrollToIndex(index, behavior) {\r\n        if (this._viewport) {\r\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\r\n        }\r\n    }\r\n    /** Update the viewport's total content size. */\r\n    _updateTotalContentSize() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\r\n    }\r\n    /** Update the viewport's rendered range. */\r\n    _updateRenderedRange() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        const renderedRange = this._viewport.getRenderedRange();\r\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\r\n        const viewportSize = this._viewport.getViewportSize();\r\n        const dataLength = this._viewport.getDataLength();\r\n        let scrollOffset = this._viewport.measureScrollOffset();\r\n        // Prevent NaN as result when dividing by zero.\r\n        let firstVisibleIndex = (this._itemSize > 0) ? scrollOffset / this._itemSize : 0;\r\n        // If user scrolls to the bottom of the list and data changes to a smaller list\r\n        if (newRange.end > dataLength) {\r\n            // We have to recalculate the first visible index based on new data length and viewport size.\r\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\r\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\r\n            // If first visible index changed we must update scroll offset to handle start/end buffers\r\n            // Current range must also be adjusted to cover the new position (bottom of new list).\r\n            if (firstVisibleIndex != newVisibleIndex) {\r\n                firstVisibleIndex = newVisibleIndex;\r\n                scrollOffset = newVisibleIndex * this._itemSize;\r\n                newRange.start = Math.floor(firstVisibleIndex);\r\n            }\r\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\r\n        }\r\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\r\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\r\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\r\n            newRange.start = Math.max(0, newRange.start - expandStart);\r\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\r\n        }\r\n        else {\r\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\r\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\r\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\r\n                if (expandEnd > 0) {\r\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\r\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\r\n                }\r\n            }\r\n        }\r\n        this._viewport.setRenderedRange(newRange);\r\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\r\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\r\n    }\r\n}\r\n/**\r\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\r\n * `FixedSizeVirtualScrollStrategy` from the given directive.\r\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\r\n *     `FixedSizeVirtualScrollStrategy` from.\r\n */\r\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\r\n    return fixedSizeDir._scrollStrategy;\r\n}\r\n/** A virtual scroll strategy that supports fixed-size items. */\r\nclass CdkFixedSizeVirtualScroll {\r\n    constructor() {\r\n        this._itemSize = 20;\r\n        this._minBufferPx = 100;\r\n        this._maxBufferPx = 200;\r\n        /** The scroll strategy used by this directive. */\r\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n    /** The size of the items in the list (in pixels). */\r\n    get itemSize() { return this._itemSize; }\r\n    set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\r\n    /**\r\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\r\n     */\r\n    get minBufferPx() { return this._minBufferPx; }\r\n    set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\r\n    /**\r\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\r\n     */\r\n    get maxBufferPx() { return this._maxBufferPx; }\r\n    set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\r\n    ngOnChanges() {\r\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n}\r\nCdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\r\nCdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: VIRTUAL_SCROLL_STRATEGY,\r\n                useFactory: _fixedSizeVirtualScrollStrategyFactory,\r\n                deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\r\n            }]), ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkFixedSizeVirtualScroll.propDecorators = {\r\n    itemSize: [{ type: Input }],\r\n    minBufferPx: [{ type: Input }],\r\n    maxBufferPx: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFixedSizeVirtualScroll, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-virtual-scroll-viewport[itemSize]',\r\n                providers: [{\r\n                        provide: VIRTUAL_SCROLL_STRATEGY,\r\n                        useFactory: _fixedSizeVirtualScrollStrategyFactory,\r\n                        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\r\n                    }]\r\n            }]\r\n    }], function () { return []; }, { itemSize: [{\r\n            type: Input\r\n        }], minBufferPx: [{\r\n            type: Input\r\n        }], maxBufferPx: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Time in ms to throttle the scrolling events by default. */\r\nconst DEFAULT_SCROLL_TIME = 20;\r\n/**\r\n * Service contained all registered Scrollable references and emits an event when any one of the\r\n * Scrollable references emit a scrolled event.\r\n */\r\nclass ScrollDispatcher {\r\n    constructor(_ngZone, _platform, document) {\r\n        this._ngZone = _ngZone;\r\n        this._platform = _platform;\r\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\r\n        this._scrolled = new Subject();\r\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\r\n        this._globalSubscription = null;\r\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\r\n        this._scrolledCount = 0;\r\n        /**\r\n         * Map of all the scrollable references that are registered with the service and their\r\n         * scroll event subscriptions.\r\n         */\r\n        this.scrollContainers = new Map();\r\n        this._document = document;\r\n    }\r\n    /**\r\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\r\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\r\n     * @param scrollable Scrollable instance to be registered.\r\n     */\r\n    register(scrollable) {\r\n        if (!this.scrollContainers.has(scrollable)) {\r\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled()\r\n                .subscribe(() => this._scrolled.next(scrollable)));\r\n        }\r\n    }\r\n    /**\r\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\n     * @param scrollable Scrollable instance to be deregistered.\r\n     */\r\n    deregister(scrollable) {\r\n        const scrollableReference = this.scrollContainers.get(scrollable);\r\n        if (scrollableReference) {\r\n            scrollableReference.unsubscribe();\r\n            this.scrollContainers.delete(scrollable);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an observable that emits an event whenever any of the registered Scrollable\r\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\r\n     * to override the default \"throttle\" time.\r\n     *\r\n     * **Note:** in order to avoid hitting change detection for every scroll event,\r\n     * all of the events emitted from this stream will be run outside the Angular zone.\r\n     * If you need to update any data bindings as a result of a scroll event, you have\r\n     * to run the callback using `NgZone.run`.\r\n     */\r\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\r\n        if (!this._platform.isBrowser) {\r\n            return of();\r\n        }\r\n        return new Observable((observer) => {\r\n            if (!this._globalSubscription) {\r\n                this._addGlobalListener();\r\n            }\r\n            // In the case of a 0ms delay, use an observable without auditTime\r\n            // since it does add a perceptible delay in processing overhead.\r\n            const subscription = auditTimeInMs > 0 ?\r\n                this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\r\n                this._scrolled.subscribe(observer);\r\n            this._scrolledCount++;\r\n            return () => {\r\n                subscription.unsubscribe();\r\n                this._scrolledCount--;\r\n                if (!this._scrolledCount) {\r\n                    this._removeGlobalListener();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this._removeGlobalListener();\r\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\r\n        this._scrolled.complete();\r\n    }\r\n    /**\r\n     * Returns an observable that emits whenever any of the\r\n     * scrollable ancestors of an element are scrolled.\r\n     * @param elementOrElementRef Element whose ancestors to listen for.\r\n     * @param auditTimeInMs Time to throttle the scroll events.\r\n     */\r\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\r\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\r\n        return this.scrolled(auditTimeInMs).pipe(filter(target => {\r\n            return !target || ancestors.indexOf(target) > -1;\r\n        }));\r\n    }\r\n    /** Returns all registered Scrollables that contain the provided element. */\r\n    getAncestorScrollContainers(elementOrElementRef) {\r\n        const scrollingContainers = [];\r\n        this.scrollContainers.forEach((_subscription, scrollable) => {\r\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\r\n                scrollingContainers.push(scrollable);\r\n            }\r\n        });\r\n        return scrollingContainers;\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    /** Returns true if the element is contained within the provided Scrollable. */\r\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\r\n        let element = coerceElement(elementOrElementRef);\r\n        let scrollableElement = scrollable.getElementRef().nativeElement;\r\n        // Traverse through the element parents until we reach null, checking if any of the elements\r\n        // are the scrollable's element.\r\n        do {\r\n            if (element == scrollableElement) {\r\n                return true;\r\n            }\r\n        } while (element = element.parentElement);\r\n        return false;\r\n    }\r\n    /** Sets up the global scroll listeners. */\r\n    _addGlobalListener() {\r\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\r\n            const window = this._getWindow();\r\n            return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\r\n        });\r\n    }\r\n    /** Cleans up the global scroll listener. */\r\n    _removeGlobalListener() {\r\n        if (this._globalSubscription) {\r\n            this._globalSubscription.unsubscribe();\r\n            this._globalSubscription = null;\r\n        }\r\n    }\r\n}\r\nScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(DOCUMENT, 8)); };\r\nScrollDispatcher.ɵprov = ɵɵdefineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\r\nScrollDispatcher.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Platform },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollDispatcher, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Sends an event when the directive's element is scrolled. Registers itself with the\r\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\r\n * can be listened to through the service.\r\n */\r\nclass CdkScrollable {\r\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\r\n        this.elementRef = elementRef;\r\n        this.scrollDispatcher = scrollDispatcher;\r\n        this.ngZone = ngZone;\r\n        this.dir = dir;\r\n        this._destroyed = new Subject();\r\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\r\n            .subscribe(observer)));\r\n    }\r\n    ngOnInit() {\r\n        this.scrollDispatcher.register(this);\r\n    }\r\n    ngOnDestroy() {\r\n        this.scrollDispatcher.deregister(this);\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /** Returns observable that emits when a scroll event is fired on the host element. */\r\n    elementScrolled() {\r\n        return this._elementScrolled;\r\n    }\r\n    /** Gets the ElementRef for the viewport. */\r\n    getElementRef() {\r\n        return this.elementRef;\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param options specified the offsets to scroll to.\r\n     */\r\n    scrollTo(options) {\r\n        const el = this.elementRef.nativeElement;\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        // Rewrite start & end offsets as right or left offsets.\r\n        if (options.left == null) {\r\n            options.left = isRtl ? options.end : options.start;\r\n        }\r\n        if (options.right == null) {\r\n            options.right = isRtl ? options.start : options.end;\r\n        }\r\n        // Rewrite the bottom offset as a top offset.\r\n        if (options.bottom != null) {\r\n            options.top =\r\n                el.scrollHeight - el.clientHeight - options.bottom;\r\n        }\r\n        // Rewrite the right offset as a left offset.\r\n        if (isRtl && getRtlScrollAxisType() != 0 /* NORMAL */) {\r\n            if (options.left != null) {\r\n                options.right =\r\n                    el.scrollWidth - el.clientWidth - options.left;\r\n            }\r\n            if (getRtlScrollAxisType() == 2 /* INVERTED */) {\r\n                options.left = options.right;\r\n            }\r\n            else if (getRtlScrollAxisType() == 1 /* NEGATED */) {\r\n                options.left = options.right ? -options.right : options.right;\r\n            }\r\n        }\r\n        else {\r\n            if (options.right != null) {\r\n                options.left =\r\n                    el.scrollWidth - el.clientWidth - options.right;\r\n            }\r\n        }\r\n        this._applyScrollToOptions(options);\r\n    }\r\n    _applyScrollToOptions(options) {\r\n        const el = this.elementRef.nativeElement;\r\n        if (supportsScrollBehavior()) {\r\n            el.scrollTo(options);\r\n        }\r\n        else {\r\n            if (options.top != null) {\r\n                el.scrollTop = options.top;\r\n            }\r\n            if (options.left != null) {\r\n                el.scrollLeft = options.left;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\r\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\r\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param from The edge to measure from.\r\n     */\r\n    measureScrollOffset(from) {\r\n        const LEFT = 'left';\r\n        const RIGHT = 'right';\r\n        const el = this.elementRef.nativeElement;\r\n        if (from == 'top') {\r\n            return el.scrollTop;\r\n        }\r\n        if (from == 'bottom') {\r\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\r\n        }\r\n        // Rewrite start & end as left or right offsets.\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        if (from == 'start') {\r\n            from = isRtl ? RIGHT : LEFT;\r\n        }\r\n        else if (from == 'end') {\r\n            from = isRtl ? LEFT : RIGHT;\r\n        }\r\n        if (isRtl && getRtlScrollAxisType() == 2 /* INVERTED */) {\r\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollLeft;\r\n            }\r\n        }\r\n        else if (isRtl && getRtlScrollAxisType() == 1 /* NEGATED */) {\r\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\r\n            }\r\n            else {\r\n                return -el.scrollLeft;\r\n            }\r\n        }\r\n        else {\r\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\r\n            // (scrollWidth - clientWidth) when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n        }\r\n    }\r\n}\r\nCdkScrollable.ɵfac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8)); };\r\nCdkScrollable.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\r\nCdkScrollable.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ScrollDispatcher },\r\n    { type: NgZone },\r\n    { type: Directionality, decorators: [{ type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkScrollable, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdk-scrollable], [cdkScrollable]'\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScrollDispatcher }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Time in ms to throttle the resize events by default. */\r\nconst DEFAULT_RESIZE_TIME = 20;\r\n/**\r\n * Simple utility for getting the bounds of the browser viewport.\r\n * @docs-private\r\n */\r\nclass ViewportRuler {\r\n    constructor(_platform, ngZone, document) {\r\n        this._platform = _platform;\r\n        /** Stream of viewport change events. */\r\n        this._change = new Subject();\r\n        /** Event listener that will be used to handle the viewport change events. */\r\n        this._changeListener = (event) => {\r\n            this._change.next(event);\r\n        };\r\n        this._document = document;\r\n        ngZone.runOutsideAngular(() => {\r\n            if (_platform.isBrowser) {\r\n                const window = this._getWindow();\r\n                // Note that bind the events ourselves, rather than going through something like RxJS's\r\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\r\n                window.addEventListener('resize', this._changeListener);\r\n                window.addEventListener('orientationchange', this._changeListener);\r\n            }\r\n            // We don't need to keep track of the subscription,\r\n            // because we complete the `change` stream on destroy.\r\n            this.change().subscribe(() => this._updateViewportSize());\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._platform.isBrowser) {\r\n            const window = this._getWindow();\r\n            window.removeEventListener('resize', this._changeListener);\r\n            window.removeEventListener('orientationchange', this._changeListener);\r\n        }\r\n        this._change.complete();\r\n    }\r\n    /** Returns the viewport's width and height. */\r\n    getViewportSize() {\r\n        if (!this._viewportSize) {\r\n            this._updateViewportSize();\r\n        }\r\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\r\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\r\n        if (!this._platform.isBrowser) {\r\n            this._viewportSize = null;\r\n        }\r\n        return output;\r\n    }\r\n    /** Gets a ClientRect for the viewport's bounds. */\r\n    getViewportRect() {\r\n        // Use the document element's bounding rect rather than the window scroll properties\r\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n        // We use the documentElement instead of the body because, by default (without a css reset)\r\n        // browsers typically give the document body an 8px margin, which is not included in\r\n        // getBoundingClientRect().\r\n        const scrollPosition = this.getViewportScrollPosition();\r\n        const { width, height } = this.getViewportSize();\r\n        return {\r\n            top: scrollPosition.top,\r\n            left: scrollPosition.left,\r\n            bottom: scrollPosition.top + height,\r\n            right: scrollPosition.left + width,\r\n            height,\r\n            width,\r\n        };\r\n    }\r\n    /** Gets the (top, left) scroll position of the viewport. */\r\n    getViewportScrollPosition() {\r\n        // While we can get a reference to the fake document\r\n        // during SSR, it doesn't have getBoundingClientRect.\r\n        if (!this._platform.isBrowser) {\r\n            return { top: 0, left: 0 };\r\n        }\r\n        // The top-left-corner of the viewport is determined by the scroll position of the document\r\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n        // `document.documentElement` works consistently, where the `top` and `left` values will\r\n        // equal negative the scroll position.\r\n        const document = this._document;\r\n        const window = this._getWindow();\r\n        const documentElement = document.documentElement;\r\n        const documentRect = documentElement.getBoundingClientRect();\r\n        const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\r\n            documentElement.scrollTop || 0;\r\n        const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\r\n            documentElement.scrollLeft || 0;\r\n        return { top, left };\r\n    }\r\n    /**\r\n     * Returns a stream that emits whenever the size of the viewport changes.\r\n     * @param throttleTime Time in milliseconds to throttle the stream.\r\n     */\r\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\r\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    /** Updates the cached viewport size. */\r\n    _updateViewportSize() {\r\n        const window = this._getWindow();\r\n        this._viewportSize = this._platform.isBrowser ?\r\n            { width: window.innerWidth, height: window.innerHeight } :\r\n            { width: 0, height: 0 };\r\n    }\r\n}\r\nViewportRuler.ɵfac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT, 8)); };\r\nViewportRuler.ɵprov = ɵɵdefineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8)); }, token: ViewportRuler, providedIn: \"root\" });\r\nViewportRuler.ctorParameters = () => [\r\n    { type: Platform },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewportRuler, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Checks if the given ranges are equal. */\r\nfunction rangesEqual(r1, r2) {\r\n    return r1.start == r2.start && r1.end == r2.end;\r\n}\r\n/**\r\n * Scheduler to be used for scroll events. Needs to fall back to\r\n * something that doesn't rely on requestAnimationFrame on environments\r\n * that don't support it (e.g. server-side rendering).\r\n */\r\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\r\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\r\nclass CdkVirtualScrollViewport extends CdkScrollable {\r\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {\r\n        super(elementRef, scrollDispatcher, ngZone, dir);\r\n        this.elementRef = elementRef;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._scrollStrategy = _scrollStrategy;\r\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\r\n        this._detachedSubject = new Subject();\r\n        /** Emits when the rendered range changes. */\r\n        this._renderedRangeSubject = new Subject();\r\n        this._orientation = 'vertical';\r\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\r\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\r\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\r\n        // performance.\r\n        /** Emits when the index of the first element visible in the viewport changes. */\r\n        this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\r\n        /** A stream that emits whenever the rendered range changes. */\r\n        this.renderedRangeStream = this._renderedRangeSubject;\r\n        /**\r\n         * The total size of all content (in pixels), including content that is not currently rendered.\r\n         */\r\n        this._totalContentSize = 0;\r\n        /** A string representing the `style.width` property value to be used for the spacer element. */\r\n        this._totalContentWidth = '';\r\n        /** A string representing the `style.height` property value to be used for the spacer element. */\r\n        this._totalContentHeight = '';\r\n        /** The currently rendered range of indices. */\r\n        this._renderedRange = { start: 0, end: 0 };\r\n        /** The length of the data bound to this viewport (in number of items). */\r\n        this._dataLength = 0;\r\n        /** The size of the viewport (in pixels). */\r\n        this._viewportSize = 0;\r\n        /** The last rendered content offset that was set. */\r\n        this._renderedContentOffset = 0;\r\n        /**\r\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\r\n         * be rewritten as an offset to the start of the content).\r\n         */\r\n        this._renderedContentOffsetNeedsRewrite = false;\r\n        /** Whether there is a pending change detection cycle. */\r\n        this._isChangeDetectionPending = false;\r\n        /** A list of functions to run after the next change detection cycle. */\r\n        this._runAfterChangeDetection = [];\r\n        /** Subscription to changes in the viewport size. */\r\n        this._viewportChanges = Subscription.EMPTY;\r\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\r\n        }\r\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\r\n            this.checkViewportSize();\r\n        });\r\n    }\r\n    /** The direction the viewport scrolls. */\r\n    get orientation() {\r\n        return this._orientation;\r\n    }\r\n    set orientation(orientation) {\r\n        if (this._orientation !== orientation) {\r\n            this._orientation = orientation;\r\n            this._calculateSpacerSize();\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        super.ngOnInit();\r\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\r\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\r\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\r\n        // ourselves instead.\r\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n            this._measureViewportSize();\r\n            this._scrollStrategy.attach(this);\r\n            this.elementScrolled()\r\n                .pipe(\r\n            // Start off with a fake scroll event so we properly detect our initial position.\r\n            startWith(null), \r\n            // Collect multiple events into one until the next animation frame. This way if\r\n            // there are multiple scroll events in the same frame we only need to recheck\r\n            // our layout once.\r\n            auditTime(0, SCROLL_SCHEDULER))\r\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\r\n            this._markChangeDetectionNeeded();\r\n        }));\r\n    }\r\n    ngOnDestroy() {\r\n        this.detach();\r\n        this._scrollStrategy.detach();\r\n        // Complete all subjects\r\n        this._renderedRangeSubject.complete();\r\n        this._detachedSubject.complete();\r\n        this._viewportChanges.unsubscribe();\r\n        super.ngOnDestroy();\r\n    }\r\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\r\n    attach(forOf) {\r\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('CdkVirtualScrollViewport is already attached.');\r\n        }\r\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\r\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\r\n        // change detection loop ourselves.\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this._forOf = forOf;\r\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\r\n                const newLength = data.length;\r\n                if (newLength !== this._dataLength) {\r\n                    this._dataLength = newLength;\r\n                    this._scrollStrategy.onDataLengthChanged();\r\n                }\r\n                this._doChangeDetection();\r\n            });\r\n        });\r\n    }\r\n    /** Detaches the current `CdkVirtualForOf`. */\r\n    detach() {\r\n        this._forOf = null;\r\n        this._detachedSubject.next();\r\n    }\r\n    /** Gets the length of the data bound to this viewport (in number of items). */\r\n    getDataLength() {\r\n        return this._dataLength;\r\n    }\r\n    /** Gets the size of the viewport (in pixels). */\r\n    getViewportSize() {\r\n        return this._viewportSize;\r\n    }\r\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\r\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\r\n    // setting it to something else, but its error prone and should probably be split into\r\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\r\n    /** Get the current rendered range of items. */\r\n    getRenderedRange() {\r\n        return this._renderedRange;\r\n    }\r\n    /**\r\n     * Sets the total size of all content (in pixels), including content that is not currently\r\n     * rendered.\r\n     */\r\n    setTotalContentSize(size) {\r\n        if (this._totalContentSize !== size) {\r\n            this._totalContentSize = size;\r\n            this._calculateSpacerSize();\r\n            this._markChangeDetectionNeeded();\r\n        }\r\n    }\r\n    /** Sets the currently rendered range of indices. */\r\n    setRenderedRange(range) {\r\n        if (!rangesEqual(this._renderedRange, range)) {\r\n            this._renderedRangeSubject.next(this._renderedRange = range);\r\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\r\n        }\r\n    }\r\n    /**\r\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\r\n     */\r\n    getOffsetToRenderedContentStart() {\r\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\r\n    }\r\n    /**\r\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\r\n     * (in pixels).\r\n     */\r\n    setRenderedContentOffset(offset, to = 'to-start') {\r\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\r\n        // in the negative direction.\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        const isHorizontal = this.orientation == 'horizontal';\r\n        const axis = isHorizontal ? 'X' : 'Y';\r\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\r\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\r\n        this._renderedContentOffset = offset;\r\n        if (to === 'to-end') {\r\n            transform += ` translate${axis}(-100%)`;\r\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\r\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\r\n            // expand upward).\r\n            this._renderedContentOffsetNeedsRewrite = true;\r\n        }\r\n        if (this._renderedContentTransform != transform) {\r\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\r\n            // into the string.\r\n            this._renderedContentTransform = transform;\r\n            this._markChangeDetectionNeeded(() => {\r\n                if (this._renderedContentOffsetNeedsRewrite) {\r\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\r\n                    this._renderedContentOffsetNeedsRewrite = false;\r\n                    this.setRenderedContentOffset(this._renderedContentOffset);\r\n                }\r\n                else {\r\n                    this._scrollStrategy.onRenderedOffsetChanged();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\r\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\r\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\r\n     * @param offset The offset to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToOffset(offset, behavior = 'auto') {\r\n        const options = { behavior };\r\n        if (this.orientation === 'horizontal') {\r\n            options.start = offset;\r\n        }\r\n        else {\r\n            options.top = offset;\r\n        }\r\n        this.scrollTo(options);\r\n    }\r\n    /**\r\n     * Scrolls to the offset for the given index.\r\n     * @param index The index of the element to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToIndex(index, behavior = 'auto') {\r\n        this._scrollStrategy.scrollToIndex(index, behavior);\r\n    }\r\n    /**\r\n     * Gets the current scroll offset from the start of the viewport (in pixels).\r\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\r\n     *     in horizontal mode.\r\n     */\r\n    measureScrollOffset(from) {\r\n        return from ?\r\n            super.measureScrollOffset(from) :\r\n            super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\r\n    }\r\n    /** Measure the combined size of all of the rendered items. */\r\n    measureRenderedContentSize() {\r\n        const contentEl = this._contentWrapper.nativeElement;\r\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\r\n    }\r\n    /**\r\n     * Measure the total combined size of the given range. Throws if the range includes items that are\r\n     * not rendered.\r\n     */\r\n    measureRangeSize(range) {\r\n        if (!this._forOf) {\r\n            return 0;\r\n        }\r\n        return this._forOf.measureRangeSize(range, this.orientation);\r\n    }\r\n    /** Update the viewport dimensions and re-render. */\r\n    checkViewportSize() {\r\n        // TODO: Cleanup later when add logic for handling content resize\r\n        this._measureViewportSize();\r\n        this._scrollStrategy.onDataLengthChanged();\r\n    }\r\n    /** Measure the viewport size. */\r\n    _measureViewportSize() {\r\n        const viewportEl = this.elementRef.nativeElement;\r\n        this._viewportSize = this.orientation === 'horizontal' ?\r\n            viewportEl.clientWidth : viewportEl.clientHeight;\r\n    }\r\n    /** Queue up change detection to run. */\r\n    _markChangeDetectionNeeded(runAfter) {\r\n        if (runAfter) {\r\n            this._runAfterChangeDetection.push(runAfter);\r\n        }\r\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\r\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\r\n        if (!this._isChangeDetectionPending) {\r\n            this._isChangeDetectionPending = true;\r\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n                this._doChangeDetection();\r\n            }));\r\n        }\r\n    }\r\n    /** Run change detection. */\r\n    _doChangeDetection() {\r\n        this._isChangeDetectionPending = false;\r\n        // Apply the content transform. The transform can't be set via an Angular binding because\r\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\r\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\r\n        // the `Number` function first to coerce it to a numeric value.\r\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\r\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\r\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\r\n        // instead does not properly check the projected content.\r\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\r\n        const runAfterChangeDetection = this._runAfterChangeDetection;\r\n        this._runAfterChangeDetection = [];\r\n        for (const fn of runAfterChangeDetection) {\r\n            fn();\r\n        }\r\n    }\r\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\r\n    _calculateSpacerSize() {\r\n        this._totalContentHeight =\r\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\r\n        this._totalContentWidth =\r\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\r\n    }\r\n}\r\nCdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ViewportRuler)); };\r\nCdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);\r\n    } }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\r\n    } }, inputs: { orientation: \"orientation\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: CdkScrollable,\r\n                useExisting: CdkVirtualScrollViewport\r\n            }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\r\n        ɵngcc0.ɵɵprojection(2);\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelement(3, \"div\", 2);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵadvance(3);\r\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\r\n    } }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\r\nCdkVirtualScrollViewport.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ChangeDetectorRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [VIRTUAL_SCROLL_STRATEGY,] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: ScrollDispatcher },\r\n    { type: ViewportRuler }\r\n];\r\nCdkVirtualScrollViewport.propDecorators = {\r\n    orientation: [{ type: Input }],\r\n    scrolledIndexChange: [{ type: Output }],\r\n    _contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { static: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkVirtualScrollViewport, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-virtual-scroll-viewport',\r\n                template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\r\n                host: {\r\n                    'class': 'cdk-virtual-scroll-viewport',\r\n                    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\r\n                    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"'\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                providers: [{\r\n                        provide: CdkScrollable,\r\n                        useExisting: CdkVirtualScrollViewport\r\n                    }],\r\n                styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [VIRTUAL_SCROLL_STRATEGY]\r\n            }] }, { type: ɵngcc2.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ScrollDispatcher }, { type: ViewportRuler }]; }, { scrolledIndexChange: [{\r\n            type: Output\r\n        }], orientation: [{\r\n            type: Input\r\n        }], _contentWrapper: [{\r\n            type: ViewChild,\r\n            args: ['contentWrapper', { static: true }]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Helper to extract the offset of a DOM Node in a certain direction. */\r\nfunction getOffset(orientation, direction, node) {\r\n    const el = node;\r\n    if (!el.getBoundingClientRect) {\r\n        return 0;\r\n    }\r\n    const rect = el.getBoundingClientRect();\r\n    if (orientation === 'horizontal') {\r\n        return direction === 'start' ? rect.left : rect.right;\r\n    }\r\n    return direction === 'start' ? rect.top : rect.bottom;\r\n}\r\n/**\r\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\r\n * container.\r\n */\r\nclass CdkVirtualForOf {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    _viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    _template, \r\n    /** The set of available differs. */\r\n    _differs, \r\n    /** The strategy used to render items in the virtual scroll viewport. */\r\n    _viewRepeater, \r\n    /** The virtual scrolling viewport that these items are being rendered in. */\r\n    _viewport, ngZone) {\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._template = _template;\r\n        this._differs = _differs;\r\n        this._viewRepeater = _viewRepeater;\r\n        this._viewport = _viewport;\r\n        /** Emits when the rendered view of the data changes. */\r\n        this.viewChange = new Subject();\r\n        /** Subject that emits when a new DataSource instance is given. */\r\n        this._dataSourceChanges = new Subject();\r\n        /** Emits whenever the data in the current DataSource changes. */\r\n        this.dataStream = this._dataSourceChanges\r\n            .pipe(\r\n        // Start off with null `DataSource`.\r\n        startWith(null), \r\n        // Bundle up the previous and current data sources so we can work with both.\r\n        pairwise(), \r\n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\r\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\r\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\r\n        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), \r\n        // Replay the last emitted data when someone subscribes.\r\n        shareReplay(1));\r\n        /** The differ used to calculate changes to the data. */\r\n        this._differ = null;\r\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\r\n        this._needsUpdate = false;\r\n        this._destroyed = new Subject();\r\n        this.dataStream.subscribe(data => {\r\n            this._data = data;\r\n            this._onRenderedDataChange();\r\n        });\r\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\r\n            this._renderedRange = range;\r\n            ngZone.run(() => this.viewChange.next(this._renderedRange));\r\n            this._onRenderedDataChange();\r\n        });\r\n        this._viewport.attach(this);\r\n    }\r\n    /** The DataSource to display. */\r\n    get cdkVirtualForOf() {\r\n        return this._cdkVirtualForOf;\r\n    }\r\n    set cdkVirtualForOf(value) {\r\n        this._cdkVirtualForOf = value;\r\n        if (isDataSource(value)) {\r\n            this._dataSourceChanges.next(value);\r\n        }\r\n        else {\r\n            // If value is an an NgIterable, convert it to an array.\r\n            this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\r\n        }\r\n    }\r\n    /**\r\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\r\n     * the item and produces a value to be used as the item's identity when tracking changes.\r\n     */\r\n    get cdkVirtualForTrackBy() {\r\n        return this._cdkVirtualForTrackBy;\r\n    }\r\n    set cdkVirtualForTrackBy(fn) {\r\n        this._needsUpdate = true;\r\n        this._cdkVirtualForTrackBy = fn ?\r\n            (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\r\n            undefined;\r\n    }\r\n    /** The template used to stamp out new elements. */\r\n    set cdkVirtualForTemplate(value) {\r\n        if (value) {\r\n            this._needsUpdate = true;\r\n            this._template = value;\r\n        }\r\n    }\r\n    /**\r\n     * The size of the cache used to store templates that are not being used for re-use later.\r\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\r\n     */\r\n    get cdkVirtualForTemplateCacheSize() {\r\n        return this._viewRepeater.viewCacheSize;\r\n    }\r\n    set cdkVirtualForTemplateCacheSize(size) {\r\n        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\r\n    }\r\n    /**\r\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\r\n     * in the specified range. Throws an error if the range includes items that are not currently\r\n     * rendered.\r\n     */\r\n    measureRangeSize(range, orientation) {\r\n        if (range.start >= range.end) {\r\n            return 0;\r\n        }\r\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\r\n        }\r\n        // The index into the list of rendered views for the first item in the range.\r\n        const renderedStartIndex = range.start - this._renderedRange.start;\r\n        // The length of the range we're measuring.\r\n        const rangeLen = range.end - range.start;\r\n        // Loop over all the views, find the first and land node and compute the size by subtracting\r\n        // the top of the first node from the bottom of the last one.\r\n        let firstNode;\r\n        let lastNode;\r\n        // Find the first node by starting from the beginning and going forwards.\r\n        for (let i = 0; i < rangeLen; i++) {\r\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\r\n            if (view && view.rootNodes.length) {\r\n                firstNode = lastNode = view.rootNodes[0];\r\n                break;\r\n            }\r\n        }\r\n        // Find the last node by starting from the end and going backwards.\r\n        for (let i = rangeLen - 1; i > -1; i--) {\r\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\r\n            if (view && view.rootNodes.length) {\r\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        return firstNode && lastNode ?\r\n            getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\r\n    }\r\n    ngDoCheck() {\r\n        if (this._differ && this._needsUpdate) {\r\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\r\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\r\n            // changing (need to do this diff).\r\n            const changes = this._differ.diff(this._renderedItems);\r\n            if (!changes) {\r\n                this._updateContext();\r\n            }\r\n            else {\r\n                this._applyChanges(changes);\r\n            }\r\n            this._needsUpdate = false;\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._viewport.detach();\r\n        this._dataSourceChanges.next(undefined);\r\n        this._dataSourceChanges.complete();\r\n        this.viewChange.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n        this._viewRepeater.detach();\r\n    }\r\n    /** React to scroll state changes in the viewport. */\r\n    _onRenderedDataChange() {\r\n        if (!this._renderedRange) {\r\n            return;\r\n        }\r\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\r\n        if (!this._differ) {\r\n            // Use a wrapper function for the `trackBy` so any new values are\r\n            // picked up automatically without having to recreate the differ.\r\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\r\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\r\n            });\r\n        }\r\n        this._needsUpdate = true;\r\n    }\r\n    /** Swap out one `DataSource` for another. */\r\n    _changeDataSource(oldDs, newDs) {\r\n        if (oldDs) {\r\n            oldDs.disconnect(this);\r\n        }\r\n        this._needsUpdate = true;\r\n        return newDs ? newDs.connect(this) : of();\r\n    }\r\n    /** Update the `CdkVirtualForOfContext` for all views. */\r\n    _updateContext() {\r\n        const count = this._data.length;\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            const view = this._viewContainerRef.get(i);\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n            view.detectChanges();\r\n        }\r\n    }\r\n    /** Apply changes to the DOM. */\r\n    _applyChanges(changes) {\r\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);\r\n        // Update $implicit for any items that had an identity change.\r\n        changes.forEachIdentityChange((record) => {\r\n            const view = this._viewContainerRef.get(record.currentIndex);\r\n            view.context.$implicit = record.item;\r\n        });\r\n        // Update the context variables on all items.\r\n        const count = this._data.length;\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            const view = this._viewContainerRef.get(i);\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n        }\r\n    }\r\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\r\n    _updateComputedContextProperties(context) {\r\n        context.first = context.index === 0;\r\n        context.last = context.index === context.count - 1;\r\n        context.even = context.index % 2 === 0;\r\n        context.odd = !context.even;\r\n    }\r\n    _getEmbeddedViewArgs(record, index) {\r\n        // Note that it's important that we insert the item directly at the proper index,\r\n        // rather than inserting it and the moving it in place, because if there's a directive\r\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\r\n        // comment node which can throw off the move when it's being repeated for all items.\r\n        return {\r\n            templateRef: this._template,\r\n            context: {\r\n                $implicit: record.item,\r\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\r\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\r\n                cdkVirtualForOf: this._cdkVirtualForOf,\r\n                index: -1,\r\n                count: -1,\r\n                first: false,\r\n                last: false,\r\n                odd: false,\r\n                even: false\r\n            },\r\n            index,\r\n        };\r\n    }\r\n}\r\nCdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵngcc0.ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\r\nCdkVirtualForOf.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\r\n        ])] });\r\nCdkVirtualForOf.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: _RecycleViewRepeaterStrategy, decorators: [{ type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },\r\n    { type: CdkVirtualScrollViewport, decorators: [{ type: SkipSelf }] },\r\n    { type: NgZone }\r\n];\r\nCdkVirtualForOf.propDecorators = {\r\n    cdkVirtualForOf: [{ type: Input }],\r\n    cdkVirtualForTrackBy: [{ type: Input }],\r\n    cdkVirtualForTemplate: [{ type: Input }],\r\n    cdkVirtualForTemplateCacheSize: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkVirtualForOf, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkVirtualFor][cdkVirtualForOf]',\r\n                providers: [\r\n                    { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\r\n                ]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc3._RecycleViewRepeaterStrategy, decorators: [{\r\n                type: Inject,\r\n                args: [_VIEW_REPEATER_STRATEGY]\r\n            }] }, { type: CdkVirtualScrollViewport, decorators: [{\r\n                type: SkipSelf\r\n            }] }, { type: ɵngcc0.NgZone }]; }, { cdkVirtualForOf: [{\r\n            type: Input\r\n        }], cdkVirtualForTrackBy: [{\r\n            type: Input\r\n        }], cdkVirtualForTemplate: [{\r\n            type: Input\r\n        }], cdkVirtualForTemplateCacheSize: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass CdkScrollableModule {\r\n}\r\nCdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); };\r\nCdkScrollableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CdkScrollableModule });\r\nCdkScrollableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkScrollableModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: [CdkScrollable],\r\n                declarations: [CdkScrollable]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkScrollableModule, { declarations: [CdkScrollable], exports: [CdkScrollable] }); })();\r\n/**\r\n * @docs-primary-export\r\n */\r\nclass ScrollingModule {\r\n}\r\nScrollingModule.ɵfac = function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); };\r\nScrollingModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ScrollingModule });\r\nScrollingModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[\r\n            BidiModule,\r\n            PlatformModule,\r\n            CdkScrollableModule\r\n        ], BidiModule, CdkScrollableModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollingModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    BidiModule,\r\n                    PlatformModule,\r\n                    CdkScrollableModule\r\n                ],\r\n                exports: [\r\n                    BidiModule,\r\n                    CdkScrollableModule,\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ],\r\n                declarations: [\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollingModule, { declarations: function () { return [CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; }, imports: function () { return [BidiModule,\r\n        PlatformModule, CdkScrollableModule]; }, exports: function () { return [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\r\n\r\n","import { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { isDataSource, _VIEW_REPEATER_STRATEGY, _DisposeViewRepeaterStrategy } from '@angular/cdk/collections';\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/bidi';\r\nimport * as ɵngcc2 from '@angular/cdk/platform';\r\nimport * as ɵngcc3 from '@angular/cdk/scrolling';\r\n\r\nconst _c0 = [[[\"caption\"]], [[\"colgroup\"], [\"col\"]]];\r\nconst _c1 = [\"caption\", \"colgroup, col\"];\r\nfunction CdkTextColumn_th_1_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"th\", 3);\r\n    ɵngcc0.ɵɵtext(1);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵstyleProp(\"text-align\", ctx_r0.justify);\r\n    ɵngcc0.ɵɵadvance(1);\r\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r0.headerText, \" \");\r\n} }\r\nfunction CdkTextColumn_td_2_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"td\", 4);\r\n    ɵngcc0.ɵɵtext(1);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const data_r2 = ctx.$implicit;\r\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵstyleProp(\"text-align\", ctx_r1.justify);\r\n    ɵngcc0.ɵɵadvance(1);\r\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.dataAccessor(data_r2, ctx_r1.name), \" \");\r\n} }\r\nexport { DataSource } from '@angular/cdk/collections';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ViewportRuler, ScrollingModule } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { InjectionToken, Directive, TemplateRef, Inject, Optional, Input, ContentChild, ElementRef, Injectable, NgZone, IterableDiffers, ViewContainerRef, Component, ChangeDetectionStrategy, ViewEncapsulation, EmbeddedViewRef, ChangeDetectorRef, Attribute, SkipSelf, ViewChild, ContentChildren, NgModule } from '@angular/core';\r\nimport { Subject, from, BehaviorSubject, isObservable, of } from 'rxjs';\r\nimport { takeUntil, take } from 'rxjs/operators';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Mixin to provide a directive with a function that checks if the sticky input has been\r\n * changed since the last time the function was called. Essentially adds a dirty-check to the\r\n * sticky value.\r\n * @docs-private\r\n */\r\nfunction mixinHasStickyInput(base) {\r\n    return class extends base {\r\n        constructor(...args) {\r\n            super(...args);\r\n            this._sticky = false;\r\n            /** Whether the sticky input has changed since it was last checked. */\r\n            this._hasStickyChanged = false;\r\n        }\r\n        /** Whether sticky positioning should be applied. */\r\n        get sticky() { return this._sticky; }\r\n        set sticky(v) {\r\n            const prevValue = this._sticky;\r\n            this._sticky = coerceBooleanProperty(v);\r\n            this._hasStickyChanged = prevValue !== this._sticky;\r\n        }\r\n        /** Whether the sticky value has changed since this was last called. */\r\n        hasStickyChanged() {\r\n            const hasStickyChanged = this._hasStickyChanged;\r\n            this._hasStickyChanged = false;\r\n            return hasStickyChanged;\r\n        }\r\n        /** Resets the dirty check for cases where the sticky state has been used without checking. */\r\n        resetStickyChanged() {\r\n            this._hasStickyChanged = false;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Used to provide a table to some of the sub-components without causing a circular dependency.\r\n * @docs-private\r\n */\r\nconst CDK_TABLE = new InjectionToken('CDK_TABLE');\r\n/** Injection token that can be used to specify the text column options. */\r\nconst TEXT_COLUMN_OPTIONS = new InjectionToken('text-column-options');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Cell definition for a CDK table.\r\n * Captures the template of a column's data row cell as well as cell-specific properties.\r\n */\r\nclass CdkCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkCellDef.ɵfac = function CdkCellDef_Factory(t) { return new (t || CdkCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCellDef, selectors: [[\"\", \"cdkCellDef\", \"\"]] });\r\nCdkCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n/**\r\n * Header cell definition for a CDK table.\r\n * Captures the template of a column's header cell and as well as cell-specific properties.\r\n */\r\nclass CdkHeaderCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) { return new (t || CdkHeaderCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkHeaderCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCellDef, selectors: [[\"\", \"cdkHeaderCellDef\", \"\"]] });\r\nCdkHeaderCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkHeaderCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n/**\r\n * Footer cell definition for a CDK table.\r\n * Captures the template of a column's footer cell and as well as cell-specific properties.\r\n */\r\nclass CdkFooterCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) { return new (t || CdkFooterCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkFooterCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCellDef, selectors: [[\"\", \"cdkFooterCellDef\", \"\"]] });\r\nCdkFooterCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkFooterCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkColumnDef.\r\n/** @docs-private */\r\nclass CdkColumnDefBase {\r\n}\r\nconst _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);\r\n/**\r\n * Column definition for the CDK table.\r\n * Defines a set of cells available for a table column.\r\n */\r\nclass CdkColumnDef extends _CdkColumnDefBase {\r\n    constructor(_table) {\r\n        super();\r\n        this._table = _table;\r\n        this._stickyEnd = false;\r\n    }\r\n    /** Unique name for this column. */\r\n    get name() { return this._name; }\r\n    set name(name) { this._setNameInput(name); }\r\n    /**\r\n     * Whether this column should be sticky positioned on the end of the row. Should make sure\r\n     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value\r\n     * has been changed.\r\n     */\r\n    get stickyEnd() {\r\n        return this._stickyEnd;\r\n    }\r\n    set stickyEnd(v) {\r\n        const prevValue = this._stickyEnd;\r\n        this._stickyEnd = coerceBooleanProperty(v);\r\n        this._hasStickyChanged = prevValue !== this._stickyEnd;\r\n    }\r\n    /**\r\n     * Overridable method that sets the css classes that will be added to every cell in this\r\n     * column.\r\n     * In the future, columnCssClassName will change from type string[] to string and this\r\n     * will set a single string value.\r\n     * @docs-private\r\n     */\r\n    _updateColumnCssClassName() {\r\n        this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];\r\n    }\r\n    /**\r\n     * This has been extracted to a util because of TS 4 and VE.\r\n     * View Engine doesn't support property rename inheritance.\r\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\r\n     * @docs-private\r\n     */\r\n    _setNameInput(value) {\r\n        // If the directive is set without a name (updated programmatically), then this setter will\r\n        // trigger with an empty string and should not overwrite the programmatically set value.\r\n        if (value) {\r\n            this._name = value;\r\n            this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/ig, '-');\r\n            this._updateColumnCssClassName();\r\n        }\r\n    }\r\n}\r\nCdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) { return new (t || CdkColumnDef)(ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkColumnDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkColumnDef, selectors: [[\"\", \"cdkColumnDef\", \"\"]], contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkCellDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerCell = _t.first);\r\n    } }, inputs: { sticky: \"sticky\", name: [\"cdkColumnDef\", \"name\"], stickyEnd: \"stickyEnd\" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]), ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkColumnDef.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\nCdkColumnDef.propDecorators = {\r\n    name: [{ type: Input, args: ['cdkColumnDef',] }],\r\n    stickyEnd: [{ type: Input, args: ['stickyEnd',] }],\r\n    cell: [{ type: ContentChild, args: [CdkCellDef,] }],\r\n    headerCell: [{ type: ContentChild, args: [CdkHeaderCellDef,] }],\r\n    footerCell: [{ type: ContentChild, args: [CdkFooterCellDef,] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkColumnDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkColumnDef]',\r\n                inputs: ['sticky'],\r\n                providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]\r\n            }]\r\n    }], function () { return [{ type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, { name: [{\r\n            type: Input,\r\n            args: ['cdkColumnDef']\r\n        }], stickyEnd: [{\r\n            type: Input,\r\n            args: ['stickyEnd']\r\n        }], cell: [{\r\n            type: ContentChild,\r\n            args: [CdkCellDef]\r\n        }], headerCell: [{\r\n            type: ContentChild,\r\n            args: [CdkHeaderCellDef]\r\n        }], footerCell: [{\r\n            type: ContentChild,\r\n            args: [CdkFooterCellDef]\r\n        }] }); })();\r\n/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */\r\nclass BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        // If IE 11 is dropped before we switch to setting a single class name, change to multi param\r\n        // with destructuring.\r\n        const classList = elementRef.nativeElement.classList;\r\n        for (const className of columnDef._columnCssClassName) {\r\n            classList.add(className);\r\n        }\r\n    }\r\n}\r\n/** Header cell template container that adds the right classes and role. */\r\nclass CdkHeaderCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) { return new (t || CdkHeaderCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkHeaderCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCell, selectors: [[\"cdk-header-cell\"], [\"th\", \"cdk-header-cell\", \"\"]], hostAttrs: [\"role\", \"columnheader\", 1, \"cdk-header-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkHeaderCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-header-cell, th[cdk-header-cell]',\r\n                host: {\r\n                    'class': 'cdk-header-cell',\r\n                    'role': 'columnheader'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/** Footer cell template container that adds the right classes and role. */\r\nclass CdkFooterCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) { return new (t || CdkFooterCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkFooterCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCell, selectors: [[\"cdk-footer-cell\"], [\"td\", \"cdk-footer-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-footer-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkFooterCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-footer-cell, td[cdk-footer-cell]',\r\n                host: {\r\n                    'class': 'cdk-footer-cell',\r\n                    'role': 'gridcell'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/** Cell template container that adds the right classes and role. */\r\nclass CdkCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkCell.ɵfac = function CdkCell_Factory(t) { return new (t || CdkCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCell, selectors: [[\"cdk-cell\"], [\"td\", \"cdk-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-cell, td[cdk-cell]',\r\n                host: {\r\n                    'class': 'cdk-cell',\r\n                    'role': 'gridcell'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @docs-private\r\n */\r\nclass _Schedule {\r\n    constructor() {\r\n        this.tasks = [];\r\n        this.endTasks = [];\r\n    }\r\n}\r\n/** Injection token used to provide a coalesced style scheduler. */\r\nconst _COALESCED_STYLE_SCHEDULER = new InjectionToken('_COALESCED_STYLE_SCHEDULER');\r\n/**\r\n * Allows grouping up CSSDom mutations after the current execution context.\r\n * This can significantly improve performance when separate consecutive functions are\r\n * reading from the CSSDom and then mutating it.\r\n *\r\n * @docs-private\r\n */\r\nclass _CoalescedStyleScheduler {\r\n    constructor(_ngZone) {\r\n        this._ngZone = _ngZone;\r\n        this._currentSchedule = null;\r\n        this._destroyed = new Subject();\r\n    }\r\n    /**\r\n     * Schedules the specified task to run at the end of the current VM turn.\r\n     */\r\n    schedule(task) {\r\n        this._createScheduleIfNeeded();\r\n        this._currentSchedule.tasks.push(task);\r\n    }\r\n    /**\r\n     * Schedules the specified task to run after other scheduled tasks at the end of the current\r\n     * VM turn.\r\n     */\r\n    scheduleEnd(task) {\r\n        this._createScheduleIfNeeded();\r\n        this._currentSchedule.endTasks.push(task);\r\n    }\r\n    /** Prevent any further tasks from running. */\r\n    ngOnDestroy() {\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    _createScheduleIfNeeded() {\r\n        if (this._currentSchedule) {\r\n            return;\r\n        }\r\n        this._currentSchedule = new _Schedule();\r\n        this._getScheduleObservable().pipe(takeUntil(this._destroyed)).subscribe(() => {\r\n            while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {\r\n                const schedule = this._currentSchedule;\r\n                // Capture new tasks scheduled by the current set of tasks.\r\n                this._currentSchedule = new _Schedule();\r\n                for (const task of schedule.tasks) {\r\n                    task();\r\n                }\r\n                for (const task of schedule.endTasks) {\r\n                    task();\r\n                }\r\n            }\r\n            this._currentSchedule = null;\r\n        });\r\n    }\r\n    _getScheduleObservable() {\r\n        // Use onStable when in the context of an ongoing change detection cycle so that we\r\n        // do not accidentally trigger additional cycles.\r\n        return this._ngZone.isStable ?\r\n            from(Promise.resolve(undefined)) :\r\n            this._ngZone.onStable.pipe(take(1));\r\n    }\r\n}\r\n_CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) { return new (t || _CoalescedStyleScheduler)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };\r\n_CoalescedStyleScheduler.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: _CoalescedStyleScheduler, factory: _CoalescedStyleScheduler.ɵfac });\r\n_CoalescedStyleScheduler.ctorParameters = () => [\r\n    { type: NgZone }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_CoalescedStyleScheduler, [{\r\n        type: Injectable\r\n    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The row template that can be used by the mat-table. Should not be used outside of the\r\n * material library.\r\n */\r\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\r\n/**\r\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\r\n * for changes and notifying the table.\r\n */\r\nclass BaseRowDef {\r\n    constructor(\r\n    /** @docs-private */ template, _differs) {\r\n        this.template = template;\r\n        this._differs = _differs;\r\n    }\r\n    ngOnChanges(changes) {\r\n        // Create a new columns differ if one does not yet exist. Initialize it based on initial value\r\n        // of the columns property or an empty array if none is provided.\r\n        if (!this._columnsDiffer) {\r\n            const columns = (changes['columns'] && changes['columns'].currentValue) || [];\r\n            this._columnsDiffer = this._differs.find(columns).create();\r\n            this._columnsDiffer.diff(columns);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the difference between the current columns and the columns from the last diff, or null\r\n     * if there is no difference.\r\n     */\r\n    getColumnsDiff() {\r\n        return this._columnsDiffer.diff(this.columns);\r\n    }\r\n    /** Gets this row def's relevant cell template from the provided column def. */\r\n    extractCellTemplate(column) {\r\n        if (this instanceof CdkHeaderRowDef) {\r\n            return column.headerCell.template;\r\n        }\r\n        if (this instanceof CdkFooterRowDef) {\r\n            return column.footerCell.template;\r\n        }\r\n        else {\r\n            return column.cell.template;\r\n        }\r\n    }\r\n}\r\nBaseRowDef.ɵfac = function BaseRowDef_Factory(t) { return new (t || BaseRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };\r\nBaseRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseRowDef, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\r\nBaseRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseRowDef, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkHeaderRowDef.\r\n/** @docs-private */\r\nclass CdkHeaderRowDefBase extends BaseRowDef {\r\n}\r\nconst _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);\r\n/**\r\n * Header row definition for the CDK table.\r\n * Captures the header row's template and other header properties such as the columns to display.\r\n */\r\nclass CdkHeaderRowDef extends _CdkHeaderRowDefBase {\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\r\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\r\n    ngOnChanges(changes) {\r\n        super.ngOnChanges(changes);\r\n    }\r\n}\r\nCdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) { return new (t || CdkHeaderRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkHeaderRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderRowDef, selectors: [[\"\", \"cdkHeaderRowDef\", \"\"]], inputs: { columns: [\"cdkHeaderRowDef\", \"columns\"], sticky: [\"cdkHeaderRowDefSticky\", \"sticky\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkHeaderRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkHeaderRowDef]',\r\n                inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkFooterRowDef.\r\n/** @docs-private */\r\nclass CdkFooterRowDefBase extends BaseRowDef {\r\n}\r\nconst _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);\r\n/**\r\n * Footer row definition for the CDK table.\r\n * Captures the footer row's template and other footer properties such as the columns to display.\r\n */\r\nclass CdkFooterRowDef extends _CdkFooterRowDefBase {\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\r\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\r\n    ngOnChanges(changes) {\r\n        super.ngOnChanges(changes);\r\n    }\r\n}\r\nCdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) { return new (t || CdkFooterRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkFooterRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterRowDef, selectors: [[\"\", \"cdkFooterRowDef\", \"\"]], inputs: { columns: [\"cdkFooterRowDef\", \"columns\"], sticky: [\"cdkFooterRowDefSticky\", \"sticky\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkFooterRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkFooterRowDef]',\r\n                inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n/**\r\n * Data row definition for the CDK table.\r\n * Captures the header row's template and other row properties such as the columns to display and\r\n * a when predicate that describes when this row should be used.\r\n */\r\nclass CdkRowDef extends BaseRowDef {\r\n    // TODO(andrewseguin): Add an input for providing a switch function to determine\r\n    //   if this template should be used.\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n}\r\nCdkRowDef.ɵfac = function CdkRowDef_Factory(t) { return new (t || CdkRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkRowDef, selectors: [[\"\", \"cdkRowDef\", \"\"]], inputs: { columns: [\"cdkRowDefColumns\", \"columns\"], when: [\"cdkRowDefWhen\", \"when\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkRowDef]',\r\n                inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n/**\r\n * Outlet for rendering cells inside of a row or header row.\r\n * @docs-private\r\n */\r\nclass CdkCellOutlet {\r\n    constructor(_viewContainer) {\r\n        this._viewContainer = _viewContainer;\r\n        CdkCellOutlet.mostRecentCellOutlet = this;\r\n    }\r\n    ngOnDestroy() {\r\n        // If this was the last outlet being rendered in the view, remove the reference\r\n        // from the static property after it has been destroyed to avoid leaking memory.\r\n        if (CdkCellOutlet.mostRecentCellOutlet === this) {\r\n            CdkCellOutlet.mostRecentCellOutlet = null;\r\n        }\r\n    }\r\n}\r\nCdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) { return new (t || CdkCellOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\r\nCdkCellOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCellOutlet, selectors: [[\"\", \"cdkCellOutlet\", \"\"]] });\r\n/**\r\n * Static property containing the latest constructed instance of this class.\r\n * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\r\n * createEmbeddedView. After one of these components are created, this property will provide\r\n * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\r\n * construct the cells with the provided context.\r\n */\r\nCdkCellOutlet.mostRecentCellOutlet = null;\r\nCdkCellOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCellOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkCellOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();\r\n/** Header template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkHeaderRow {\r\n}\r\nCdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) { return new (t || CdkHeaderRow)(); };\r\nCdkHeaderRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkHeaderRow, selectors: [[\"cdk-header-row\"], [\"tr\", \"cdk-header-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-header-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkHeaderRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-header-row, tr[cdk-header-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-header-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkFooterRow {\r\n}\r\nCdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) { return new (t || CdkFooterRow)(); };\r\nCdkFooterRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkFooterRow, selectors: [[\"cdk-footer-row\"], [\"tr\", \"cdk-footer-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-footer-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkFooterRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-footer-row, tr[cdk-footer-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-footer-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkRow {\r\n}\r\nCdkRow.ɵfac = function CdkRow_Factory(t) { return new (t || CdkRow)(); };\r\nCdkRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkRow, selectors: [[\"cdk-row\"], [\"tr\", \"cdk-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-row, tr[cdk-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Row that can be used to display a message when no data is shown in the table. */\r\nclass CdkNoDataRow {\r\n    constructor(templateRef) {\r\n        this.templateRef = templateRef;\r\n    }\r\n}\r\nCdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) { return new (t || CdkNoDataRow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkNoDataRow.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkNoDataRow, selectors: [[\"ng-template\", \"cdkNoDataRow\", \"\"]] });\r\nCdkNoDataRow.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkNoDataRow, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'ng-template[cdkNoDataRow]'\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * List of all possible directions that can be used for sticky positioning.\r\n * @docs-private\r\n */\r\nconst STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];\r\n/**\r\n * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.\r\n * @docs-private\r\n */\r\nclass StickyStyler {\r\n    /**\r\n     * @param _isNativeHtmlTable Whether the sticky logic should be based on a table\r\n     *     that uses the native `<table>` element.\r\n     * @param _stickCellCss The CSS class that will be applied to every row/cell that has\r\n     *     sticky positioning applied.\r\n     * @param direction The directionality context of the table (ltr/rtl); affects column positioning\r\n     *     by reversing left/right positions.\r\n     * @param _isBrowser Whether the table is currently being rendered on the server or the client.\r\n     * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells\r\n     *     using inline styles. If false, it is assumed that position: sticky is included in\r\n     *     the component stylesheet for _stickCellCss.\r\n     * @param _positionListener A listener that is notified of changes to sticky rows/columns\r\n     *     and their dimensions.\r\n     */\r\n    constructor(_isNativeHtmlTable, _stickCellCss, direction, \r\n    /**\r\n     * @deprecated `_coalescedStyleScheduler` parameter to become required.\r\n     * @breaking-change 11.0.0\r\n     */\r\n    _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener) {\r\n        this._isNativeHtmlTable = _isNativeHtmlTable;\r\n        this._stickCellCss = _stickCellCss;\r\n        this.direction = direction;\r\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\r\n        this._isBrowser = _isBrowser;\r\n        this._needsPositionStickyOnElement = _needsPositionStickyOnElement;\r\n        this._positionListener = _positionListener;\r\n        this._cachedCellWidths = [];\r\n        this._borderCellCss = {\r\n            'top': `${_stickCellCss}-border-elem-top`,\r\n            'bottom': `${_stickCellCss}-border-elem-bottom`,\r\n            'left': `${_stickCellCss}-border-elem-left`,\r\n            'right': `${_stickCellCss}-border-elem-right`,\r\n        };\r\n    }\r\n    /**\r\n     * Clears the sticky positioning styles from the row and its cells by resetting the `position`\r\n     * style, setting the zIndex to 0, and unsetting each provided sticky direction.\r\n     * @param rows The list of rows that should be cleared from sticking in the provided directions\r\n     * @param stickyDirections The directions that should no longer be set as sticky on the rows.\r\n     */\r\n    clearStickyPositioning(rows, stickyDirections) {\r\n        const elementsToClear = [];\r\n        for (const row of rows) {\r\n            // If the row isn't an element (e.g. if it's an `ng-container`),\r\n            // it won't have inline styles or `children` so we skip it.\r\n            if (row.nodeType !== row.ELEMENT_NODE) {\r\n                continue;\r\n            }\r\n            elementsToClear.push(row);\r\n            for (let i = 0; i < row.children.length; i++) {\r\n                elementsToClear.push(row.children[i]);\r\n            }\r\n        }\r\n        // Coalesce with sticky row/column updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            for (const element of elementsToClear) {\r\n                this._removeStickyStyle(element, stickyDirections);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Applies sticky left and right positions to the cells of each row according to the sticky\r\n     * states of the rendered column definitions.\r\n     * @param rows The rows that should have its set of cells stuck according to the sticky states.\r\n     * @param stickyStartStates A list of boolean states where each state represents whether the cell\r\n     *     in this index position should be stuck to the start of the row.\r\n     * @param stickyEndStates A list of boolean states where each state represents whether the cell\r\n     *     in this index position should be stuck to the end of the row.\r\n     * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each\r\n     *     column cell. If `false` cached widths will be used instead.\r\n     */\r\n    updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {\r\n        if (!rows.length || !this._isBrowser || !(stickyStartStates.some(state => state) ||\r\n            stickyEndStates.some(state => state))) {\r\n            if (this._positionListener) {\r\n                this._positionListener.stickyColumnsUpdated({ sizes: [] });\r\n                this._positionListener.stickyEndColumnsUpdated({ sizes: [] });\r\n            }\r\n            return;\r\n        }\r\n        const firstRow = rows[0];\r\n        const numCells = firstRow.children.length;\r\n        const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);\r\n        const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);\r\n        const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);\r\n        const lastStickyStart = stickyStartStates.lastIndexOf(true);\r\n        const firstStickyEnd = stickyEndStates.indexOf(true);\r\n        // Coalesce with sticky row updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            const isRtl = this.direction === 'rtl';\r\n            const start = isRtl ? 'right' : 'left';\r\n            const end = isRtl ? 'left' : 'right';\r\n            for (const row of rows) {\r\n                for (let i = 0; i < numCells; i++) {\r\n                    const cell = row.children[i];\r\n                    if (stickyStartStates[i]) {\r\n                        this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);\r\n                    }\r\n                    if (stickyEndStates[i]) {\r\n                        this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);\r\n                    }\r\n                }\r\n            }\r\n            if (this._positionListener) {\r\n                this._positionListener.stickyColumnsUpdated({\r\n                    sizes: lastStickyStart === -1 ?\r\n                        [] :\r\n                        cellWidths\r\n                            .slice(0, lastStickyStart + 1)\r\n                            .map((width, index) => stickyStartStates[index] ? width : null)\r\n                });\r\n                this._positionListener.stickyEndColumnsUpdated({\r\n                    sizes: firstStickyEnd === -1 ?\r\n                        [] :\r\n                        cellWidths\r\n                            .slice(firstStickyEnd)\r\n                            .map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null)\r\n                            .reverse()\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Applies sticky positioning to the row's cells if using the native table layout, and to the\r\n     * row itself otherwise.\r\n     * @param rowsToStick The list of rows that should be stuck according to their corresponding\r\n     *     sticky state and to the provided top or bottom position.\r\n     * @param stickyStates A list of boolean states where each state represents whether the row\r\n     *     should be stuck in the particular top or bottom position.\r\n     * @param position The position direction in which the row should be stuck if that row should be\r\n     *     sticky.\r\n     *\r\n     */\r\n    stickRows(rowsToStick, stickyStates, position) {\r\n        // Since we can't measure the rows on the server, we can't stick the rows properly.\r\n        if (!this._isBrowser) {\r\n            return;\r\n        }\r\n        // If positioning the rows to the bottom, reverse their order when evaluating the sticky\r\n        // position such that the last row stuck will be \"bottom: 0px\" and so on. Note that the\r\n        // sticky states need to be reversed as well.\r\n        const rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;\r\n        const states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates;\r\n        // Measure row heights all at once before adding sticky styles to reduce layout thrashing.\r\n        const stickyOffsets = [];\r\n        const stickyCellHeights = [];\r\n        const elementsToStick = [];\r\n        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {\r\n            stickyOffsets[rowIndex] = stickyOffset;\r\n            if (!states[rowIndex]) {\r\n                continue;\r\n            }\r\n            const row = rows[rowIndex];\r\n            elementsToStick[rowIndex] = this._isNativeHtmlTable ?\r\n                Array.from(row.children) : [row];\r\n            const height = row.getBoundingClientRect().height;\r\n            stickyOffset += height;\r\n            stickyCellHeights[rowIndex] = height;\r\n        }\r\n        const borderedRowIndex = states.lastIndexOf(true);\r\n        // Coalesce with other sticky row updates (top/bottom), sticky columns updates\r\n        // (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            var _a, _b;\r\n            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n                if (!states[rowIndex]) {\r\n                    continue;\r\n                }\r\n                const offset = stickyOffsets[rowIndex];\r\n                const isBorderedRowIndex = rowIndex === borderedRowIndex;\r\n                for (const element of elementsToStick[rowIndex]) {\r\n                    this._addStickyStyle(element, position, offset, isBorderedRowIndex);\r\n                }\r\n            }\r\n            if (position === 'top') {\r\n                (_a = this._positionListener) === null || _a === void 0 ? void 0 : _a.stickyHeaderRowsUpdated({ sizes: stickyCellHeights, elements: elementsToStick });\r\n            }\r\n            else {\r\n                (_b = this._positionListener) === null || _b === void 0 ? void 0 : _b.stickyFooterRowsUpdated({ sizes: stickyCellHeights, elements: elementsToStick });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick\r\n     * footer rows is to apply sticky styling to the tfoot container. This should only be done if\r\n     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from\r\n     * the tfoot element.\r\n     */\r\n    updateStickyFooterContainer(tableElement, stickyStates) {\r\n        if (!this._isNativeHtmlTable) {\r\n            return;\r\n        }\r\n        const tfoot = tableElement.querySelector('tfoot');\r\n        // Coalesce with other sticky updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            if (stickyStates.some(state => !state)) {\r\n                this._removeStickyStyle(tfoot, ['bottom']);\r\n            }\r\n            else {\r\n                this._addStickyStyle(tfoot, 'bottom', 0, false);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating\r\n     * the zIndex, removing each of the provided sticky directions, and removing the\r\n     * sticky position if there are no more directions.\r\n     */\r\n    _removeStickyStyle(element, stickyDirections) {\r\n        for (const dir of stickyDirections) {\r\n            element.style[dir] = '';\r\n            element.classList.remove(this._borderCellCss[dir]);\r\n        }\r\n        // If the element no longer has any more sticky directions, remove sticky positioning and\r\n        // the sticky CSS class.\r\n        // Short-circuit checking element.style[dir] for stickyDirections as they\r\n        // were already removed above.\r\n        const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);\r\n        if (hasDirection) {\r\n            element.style.zIndex = this._getCalculatedZIndex(element);\r\n        }\r\n        else {\r\n            // When not hasDirection, _getCalculatedZIndex will always return ''.\r\n            element.style.zIndex = '';\r\n            if (this._needsPositionStickyOnElement) {\r\n                element.style.position = '';\r\n            }\r\n            element.classList.remove(this._stickCellCss);\r\n        }\r\n    }\r\n    /**\r\n     * Adds the sticky styling to the element by adding the sticky style class, changing position\r\n     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky\r\n     * direction and value.\r\n     */\r\n    _addStickyStyle(element, dir, dirValue, isBorderElement) {\r\n        element.classList.add(this._stickCellCss);\r\n        if (isBorderElement) {\r\n            element.classList.add(this._borderCellCss[dir]);\r\n        }\r\n        element.style[dir] = `${dirValue}px`;\r\n        element.style.zIndex = this._getCalculatedZIndex(element);\r\n        if (this._needsPositionStickyOnElement) {\r\n            element.style.cssText += 'position: -webkit-sticky; position: sticky; ';\r\n        }\r\n    }\r\n    /**\r\n     * Calculate what the z-index should be for the element, depending on what directions (top,\r\n     * bottom, left, right) have been set. It should be true that elements with a top direction\r\n     * should have the highest index since these are elements like a table header. If any of those\r\n     * elements are also sticky in another direction, then they should appear above other elements\r\n     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements\r\n     * (e.g. footer rows) should then be next in the ordering such that they are below the header\r\n     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)\r\n     * should minimally increment so that they are above non-sticky elements but below top and bottom\r\n     * elements.\r\n     */\r\n    _getCalculatedZIndex(element) {\r\n        const zIndexIncrements = {\r\n            top: 100,\r\n            bottom: 10,\r\n            left: 1,\r\n            right: 1,\r\n        };\r\n        let zIndex = 0;\r\n        // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\r\n        // loses the array generic type in the `for of`. But we *also* have to use `Array` because\r\n        // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\r\n        for (const dir of STICKY_DIRECTIONS) {\r\n            if (element.style[dir]) {\r\n                zIndex += zIndexIncrements[dir];\r\n            }\r\n        }\r\n        return zIndex ? `${zIndex}` : '';\r\n    }\r\n    /** Gets the widths for each cell in the provided row. */\r\n    _getCellWidths(row, recalculateCellWidths = true) {\r\n        if (!recalculateCellWidths && this._cachedCellWidths.length) {\r\n            return this._cachedCellWidths;\r\n        }\r\n        const cellWidths = [];\r\n        const firstRowCells = row.children;\r\n        for (let i = 0; i < firstRowCells.length; i++) {\r\n            let cell = firstRowCells[i];\r\n            cellWidths.push(cell.getBoundingClientRect().width);\r\n        }\r\n        this._cachedCellWidths = cellWidths;\r\n        return cellWidths;\r\n    }\r\n    /**\r\n     * Determines the left and right positions of each sticky column cell, which will be the\r\n     * accumulation of all sticky column cell widths to the left and right, respectively.\r\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\r\n     */\r\n    _getStickyStartColumnPositions(widths, stickyStates) {\r\n        const positions = [];\r\n        let nextPosition = 0;\r\n        for (let i = 0; i < widths.length; i++) {\r\n            if (stickyStates[i]) {\r\n                positions[i] = nextPosition;\r\n                nextPosition += widths[i];\r\n            }\r\n        }\r\n        return positions;\r\n    }\r\n    /**\r\n     * Determines the left and right positions of each sticky column cell, which will be the\r\n     * accumulation of all sticky column cell widths to the left and right, respectively.\r\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\r\n     */\r\n    _getStickyEndColumnPositions(widths, stickyStates) {\r\n        const positions = [];\r\n        let nextPosition = 0;\r\n        for (let i = widths.length; i > 0; i--) {\r\n            if (stickyStates[i]) {\r\n                positions[i] = nextPosition;\r\n                nextPosition += widths[i];\r\n            }\r\n        }\r\n        return positions;\r\n    }\r\n    /**\r\n     * Schedules styles to be applied when the style scheduler deems appropriate.\r\n     * @breaking-change 11.0.0 This method can be removed in favor of calling\r\n     * `CoalescedStyleScheduler.schedule` directly once the scheduler is a required parameter.\r\n     */\r\n    _scheduleStyleChanges(changes) {\r\n        if (this._coalescedStyleScheduler) {\r\n            this._coalescedStyleScheduler.schedule(changes);\r\n        }\r\n        else {\r\n            changes();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Returns an error to be thrown when attempting to find an unexisting column.\r\n * @param id Id whose lookup failed.\r\n * @docs-private\r\n */\r\nfunction getTableUnknownColumnError(id) {\r\n    return Error(`Could not find column with id \"${id}\".`);\r\n}\r\n/**\r\n * Returns an error to be thrown when two column definitions have the same name.\r\n * @docs-private\r\n */\r\nfunction getTableDuplicateColumnNameError(name) {\r\n    return Error(`Duplicate column definition name provided: \"${name}\".`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there are multiple rows that are missing a when function.\r\n * @docs-private\r\n */\r\nfunction getTableMultipleDefaultRowDefsError() {\r\n    return Error(`There can only be one default row without a when predicate function.`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there are no matching row defs for a particular set of data.\r\n * @docs-private\r\n */\r\nfunction getTableMissingMatchingRowDefError(data) {\r\n    return Error(`Could not find a matching row definition for the` +\r\n        `provided row data: ${JSON.stringify(data)}`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there is no row definitions present in the content.\r\n * @docs-private\r\n */\r\nfunction getTableMissingRowDefsError() {\r\n    return Error('Missing definitions for header, footer, and row; ' +\r\n        'cannot determine which columns should be rendered.');\r\n}\r\n/**\r\n * Returns an error to be thrown when the data source does not match the compatible types.\r\n * @docs-private\r\n */\r\nfunction getTableUnknownDataSourceError() {\r\n    return Error(`Provided data source did not match an array, Observable, or DataSource`);\r\n}\r\n/**\r\n * Returns an error to be thrown when the text column cannot find a parent table to inject.\r\n * @docs-private\r\n */\r\nfunction getTableTextColumnMissingParentTableError() {\r\n    return Error(`Text column could not find a parent table for registration.`);\r\n}\r\n/**\r\n * Returns an error to be thrown when a table text column doesn't have a name.\r\n * @docs-private\r\n */\r\nfunction getTableTextColumnMissingNameError() {\r\n    return Error(`Table text column must have a name.`);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** The injection token used to specify the StickyPositioningListener. */\r\nconst STICKY_POSITIONING_LISTENER = new InjectionToken('CDK_SPL');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\r\n * @docs-private\r\n */\r\nclass DataRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nDataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) { return new (t || DataRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nDataRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DataRowOutlet, selectors: [[\"\", \"rowOutlet\", \"\"]] });\r\nDataRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[rowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\r\n * @docs-private\r\n */\r\nclass HeaderRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nHeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) { return new (t || HeaderRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nHeaderRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HeaderRowOutlet, selectors: [[\"\", \"headerRowOutlet\", \"\"]] });\r\nHeaderRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[headerRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the footer.\r\n * @docs-private\r\n */\r\nclass FooterRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nFooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) { return new (t || FooterRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nFooterRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FooterRowOutlet, selectors: [[\"\", \"footerRowOutlet\", \"\"]] });\r\nFooterRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[footerRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view\r\n * container's ng-container to insert the no data row.\r\n * @docs-private\r\n */\r\nclass NoDataRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nNoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) { return new (t || NoDataRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nNoDataRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NoDataRowOutlet, selectors: [[\"\", \"noDataRowOutlet\", \"\"]] });\r\nNoDataRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NoDataRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[noDataRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * The table template that can be used by the mat-table. Should not be used outside of the\r\n * material library.\r\n * @docs-private\r\n */\r\nconst CDK_TABLE_TEMPLATE = \r\n// Note that according to MDN, the `caption` element has to be projected as the **first**\r\n// element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption\r\n`\r\n  <ng-content select=\"caption\"></ng-content>\r\n  <ng-content select=\"colgroup, col\"></ng-content>\r\n  <ng-container headerRowOutlet></ng-container>\r\n  <ng-container rowOutlet></ng-container>\r\n  <ng-container noDataRowOutlet></ng-container>\r\n  <ng-container footerRowOutlet></ng-container>\r\n`;\r\n/**\r\n * Class used to conveniently type the embedded view ref for rows with a context.\r\n * @docs-private\r\n */\r\nclass RowViewRef extends EmbeddedViewRef {\r\n}\r\n/**\r\n * A data table that can render a header row, data rows, and a footer row.\r\n * Uses the dataSource input to determine the data to be rendered. The data can be provided either\r\n * as a data array, an Observable stream that emits the data array to render, or a DataSource with a\r\n * connect function that will return an Observable stream that emits the data array to render.\r\n */\r\nclass CdkTable {\r\n    constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, \r\n    /**\r\n     * @deprecated `_coalescedStyleScheduler`, `_viewRepeater` and `_viewportRuler`\r\n     *    parameters to become required.\r\n     * @breaking-change 11.0.0\r\n     */\r\n    _viewRepeater, _coalescedStyleScheduler, _stickyPositioningListener, \r\n    // Optional for backwards compatibility. The viewport ruler is provided in root. Therefore,\r\n    // this property will never be null.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _viewportRuler) {\r\n        this._differs = _differs;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._elementRef = _elementRef;\r\n        this._dir = _dir;\r\n        this._platform = _platform;\r\n        this._viewRepeater = _viewRepeater;\r\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\r\n        this._stickyPositioningListener = _stickyPositioningListener;\r\n        this._viewportRuler = _viewportRuler;\r\n        /** Subject that emits when the component has been destroyed. */\r\n        this._onDestroy = new Subject();\r\n        /**\r\n         * Map of all the user's defined columns (header, data, and footer cell template) identified by\r\n         * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\r\n         * any custom column definitions added to `_customColumnDefs`.\r\n         */\r\n        this._columnDefsByName = new Map();\r\n        /**\r\n         * Column definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * column definitions as *its* content child.\r\n         */\r\n        this._customColumnDefs = new Set();\r\n        /**\r\n         * Data row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * built-in data rows as *its* content child.\r\n         */\r\n        this._customRowDefs = new Set();\r\n        /**\r\n         * Header row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * built-in header rows as *its* content child.\r\n         */\r\n        this._customHeaderRowDefs = new Set();\r\n        /**\r\n         * Footer row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\r\n         * built-in footer row as *its* content child.\r\n         */\r\n        this._customFooterRowDefs = new Set();\r\n        /**\r\n         * Whether the header row definition has been changed. Triggers an update to the header row after\r\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n         */\r\n        this._headerRowDefChanged = true;\r\n        /**\r\n         * Whether the footer row definition has been changed. Triggers an update to the footer row after\r\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n         */\r\n        this._footerRowDefChanged = true;\r\n        /**\r\n         * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\r\n         * change.\r\n         */\r\n        this._stickyColumnStylesNeedReset = true;\r\n        /**\r\n         * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\r\n         * `false`, cached values will be used instead. This is only applicable to tables with\r\n         * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\r\n         */\r\n        this._forceRecalculateCellWidths = true;\r\n        /**\r\n         * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\r\n         * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\r\n         * the cached `RenderRow` objects when possible, the row identity is preserved when the data\r\n         * and row template matches, which allows the `IterableDiffer` to check rows by reference\r\n         * and understand which rows are added/moved/removed.\r\n         *\r\n         * Implemented as a map of maps where the first key is the `data: T` object and the second is the\r\n         * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\r\n         * contains an array of created pairs. The array is necessary to handle cases where the data\r\n         * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\r\n         * stored.\r\n         */\r\n        this._cachedRenderRowsMap = new Map();\r\n        /**\r\n         * CSS class added to any row or cell that has sticky positioning applied. May be overriden by\r\n         * table subclasses.\r\n         */\r\n        this.stickyCssClass = 'cdk-table-sticky';\r\n        /**\r\n         * Whether to manually add positon: sticky to all sticky cell elements. Not needed if\r\n         * the position is set in a selector associated with the value of stickyCssClass. May be\r\n         * overridden by table subclasses\r\n         */\r\n        this.needsPositionStickyOnElement = true;\r\n        /** Whether the no data row is currently showing anything. */\r\n        this._isShowingNoDataRow = false;\r\n        this._multiTemplateDataRows = false;\r\n        this._fixedLayout = false;\r\n        // TODO(andrewseguin): Remove max value as the end index\r\n        //   and instead calculate the view on init and scroll.\r\n        /**\r\n         * Stream containing the latest information on what rows are being displayed on screen.\r\n         * Can be used by the data source to as a heuristic of what data should be provided.\r\n         *\r\n         * @docs-private\r\n         */\r\n        this.viewChange = new BehaviorSubject({ start: 0, end: Number.MAX_VALUE });\r\n        if (!role) {\r\n            this._elementRef.nativeElement.setAttribute('role', 'grid');\r\n        }\r\n        this._document = _document;\r\n        this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';\r\n    }\r\n    /**\r\n     * Tracking function that will be used to check the differences in data changes. Used similarly\r\n     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\r\n     * relative to the function to know if a row should be added/removed/moved.\r\n     * Accepts a function that takes two parameters, `index` and `item`.\r\n     */\r\n    get trackBy() {\r\n        return this._trackByFn;\r\n    }\r\n    set trackBy(fn) {\r\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\r\n            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\r\n        }\r\n        this._trackByFn = fn;\r\n    }\r\n    /**\r\n     * The table's source of data, which can be provided in three ways (in order of complexity):\r\n     *   - Simple data array (each object represents one table row)\r\n     *   - Stream that emits a data array each time the array changes\r\n     *   - `DataSource` object that implements the connect/disconnect interface.\r\n     *\r\n     * If a data array is provided, the table must be notified when the array's objects are\r\n     * added, removed, or moved. This can be done by calling the `renderRows()` function which will\r\n     * render the diff since the last table render. If the data array reference is changed, the table\r\n     * will automatically trigger an update to the rows.\r\n     *\r\n     * When providing an Observable stream, the table will trigger an update automatically when the\r\n     * stream emits a new array of data.\r\n     *\r\n     * Finally, when providing a `DataSource` object, the table will use the Observable stream\r\n     * provided by the connect function and trigger updates when that stream emits new data array\r\n     * values. During the table's ngOnDestroy or when the data source is removed from the table, the\r\n     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\r\n     * subscriptions registered during the connect process).\r\n     */\r\n    get dataSource() {\r\n        return this._dataSource;\r\n    }\r\n    set dataSource(dataSource) {\r\n        if (this._dataSource !== dataSource) {\r\n            this._switchDataSource(dataSource);\r\n        }\r\n    }\r\n    /**\r\n     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\r\n     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\r\n     * dataobject will render the first row that evaluates its when predicate to true, in the order\r\n     * defined in the table, or otherwise the default row which does not have a when predicate.\r\n     */\r\n    get multiTemplateDataRows() {\r\n        return this._multiTemplateDataRows;\r\n    }\r\n    set multiTemplateDataRows(v) {\r\n        this._multiTemplateDataRows = coerceBooleanProperty(v);\r\n        // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),\r\n        // this setter will be invoked before the row outlet has been defined hence the null check.\r\n        if (this._rowOutlet && this._rowOutlet.viewContainer.length) {\r\n            this._forceRenderDataRows();\r\n            this.updateStickyColumnStyles();\r\n        }\r\n    }\r\n    /**\r\n     * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\r\n     * and optimize rendering sticky styles for native tables. No-op for flex tables.\r\n     */\r\n    get fixedLayout() {\r\n        return this._fixedLayout;\r\n    }\r\n    set fixedLayout(v) {\r\n        this._fixedLayout = coerceBooleanProperty(v);\r\n        // Toggling `fixedLayout` may change column widths. Sticky column styles should be recalculated.\r\n        this._forceRecalculateCellWidths = true;\r\n        this._stickyColumnStylesNeedReset = true;\r\n    }\r\n    ngOnInit() {\r\n        this._setupStickyStyler();\r\n        if (this._isNativeHtmlTable) {\r\n            this._applyNativeTableSections();\r\n        }\r\n        // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If\r\n        // the user has provided a custom trackBy, return the result of that function as evaluated\r\n        // with the values of the `RenderRow`'s data and index.\r\n        this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {\r\n            return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;\r\n        });\r\n        // Table cell dimensions may change after resizing the window. Signal the sticky styler to\r\n        // refresh its cache of cell widths the next time sticky styles are updated.\r\n        // @breaking-change 11.0.0 Remove null check for _viewportRuler once it's a required parameter.\r\n        if (this._viewportRuler) {\r\n            this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {\r\n                this._forceRecalculateCellWidths = true;\r\n            });\r\n        }\r\n    }\r\n    ngAfterContentChecked() {\r\n        // Cache the row and column definitions gathered by ContentChildren and programmatic injection.\r\n        this._cacheRowDefs();\r\n        this._cacheColumnDefs();\r\n        // Make sure that the user has at least added header, footer, or data row def.\r\n        if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMissingRowDefsError();\r\n        }\r\n        // Render updates if the list of columns have been changed for the header, row, or footer defs.\r\n        const columnsChanged = this._renderUpdatedColumns();\r\n        const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;\r\n        // Ensure sticky column styles are reset if set to `true` elsewhere.\r\n        this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;\r\n        this._forceRecalculateCellWidths = rowDefsChanged;\r\n        // If the header row definition has been changed, trigger a render to the header row.\r\n        if (this._headerRowDefChanged) {\r\n            this._forceRenderHeaderRows();\r\n            this._headerRowDefChanged = false;\r\n        }\r\n        // If the footer row definition has been changed, trigger a render to the footer row.\r\n        if (this._footerRowDefChanged) {\r\n            this._forceRenderFooterRows();\r\n            this._footerRowDefChanged = false;\r\n        }\r\n        // If there is a data source and row definitions, connect to the data source unless a\r\n        // connection has already been made.\r\n        if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\r\n            this._observeRenderChanges();\r\n        }\r\n        else if (this._stickyColumnStylesNeedReset) {\r\n            // In the above case, _observeRenderChanges will result in updateStickyColumnStyles being\r\n            // called when it row data arrives. Otherwise, we need to call it proactively.\r\n            this.updateStickyColumnStyles();\r\n        }\r\n        this._checkStickyStates();\r\n    }\r\n    ngOnDestroy() {\r\n        this._rowOutlet.viewContainer.clear();\r\n        this._noDataRowOutlet.viewContainer.clear();\r\n        this._headerRowOutlet.viewContainer.clear();\r\n        this._footerRowOutlet.viewContainer.clear();\r\n        this._cachedRenderRowsMap.clear();\r\n        this._onDestroy.next();\r\n        this._onDestroy.complete();\r\n        if (isDataSource(this.dataSource)) {\r\n            this.dataSource.disconnect(this);\r\n        }\r\n    }\r\n    /**\r\n     * Renders rows based on the table's latest set of data, which was either provided directly as an\r\n     * input or retrieved through an Observable stream (directly or from a DataSource).\r\n     * Checks for differences in the data since the last diff to perform only the necessary\r\n     * changes (add/remove/move rows).\r\n     *\r\n     * If the table's data source is a DataSource or Observable, this will be invoked automatically\r\n     * each time the provided Observable stream emits a new data array. Otherwise if your data is\r\n     * an array, this function will need to be called to render any changes.\r\n     */\r\n    renderRows() {\r\n        this._renderRows = this._getAllRenderRows();\r\n        const changes = this._dataDiffer.diff(this._renderRows);\r\n        if (!changes) {\r\n            this._updateNoDataRow();\r\n            return;\r\n        }\r\n        const viewContainer = this._rowOutlet.viewContainer;\r\n        // @breaking-change 11.0.0 Remove null check for `_viewRepeater` and the\r\n        // `else` clause once `_viewRepeater` is turned into a required parameter.\r\n        if (this._viewRepeater) {\r\n            this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {\r\n                if (change.operation === 1 /* INSERTED */ && change.context) {\r\n                    this._renderCellTemplateForItem(change.record.item.rowDef, change.context);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            changes.forEachOperation((record, prevIndex, currentIndex) => {\r\n                if (record.previousIndex == null) {\r\n                    const renderRow = record.item;\r\n                    const rowDef = renderRow.rowDef;\r\n                    const context = { $implicit: renderRow.data };\r\n                    this._renderRow(this._rowOutlet, rowDef, currentIndex, context);\r\n                }\r\n                else if (currentIndex == null) {\r\n                    viewContainer.remove(prevIndex);\r\n                }\r\n                else {\r\n                    const view = viewContainer.get(prevIndex);\r\n                    viewContainer.move(view, currentIndex);\r\n                }\r\n            });\r\n        }\r\n        // Update the meta context of a row's context data (index, count, first, last, ...)\r\n        this._updateRowIndexContext();\r\n        // Update rows that did not get added/removed/moved but may have had their identity changed,\r\n        // e.g. if trackBy matched data on some property but the actual data reference changed.\r\n        changes.forEachIdentityChange((record) => {\r\n            const rowView = viewContainer.get(record.currentIndex);\r\n            rowView.context.$implicit = record.item.data;\r\n        });\r\n        this._updateNoDataRow();\r\n        this.updateStickyColumnStyles();\r\n    }\r\n    /** Adds a column definition that was not included as part of the content children. */\r\n    addColumnDef(columnDef) {\r\n        this._customColumnDefs.add(columnDef);\r\n    }\r\n    /** Removes a column definition that was not included as part of the content children. */\r\n    removeColumnDef(columnDef) {\r\n        this._customColumnDefs.delete(columnDef);\r\n    }\r\n    /** Adds a row definition that was not included as part of the content children. */\r\n    addRowDef(rowDef) {\r\n        this._customRowDefs.add(rowDef);\r\n    }\r\n    /** Removes a row definition that was not included as part of the content children. */\r\n    removeRowDef(rowDef) {\r\n        this._customRowDefs.delete(rowDef);\r\n    }\r\n    /** Adds a header row definition that was not included as part of the content children. */\r\n    addHeaderRowDef(headerRowDef) {\r\n        this._customHeaderRowDefs.add(headerRowDef);\r\n        this._headerRowDefChanged = true;\r\n    }\r\n    /** Removes a header row definition that was not included as part of the content children. */\r\n    removeHeaderRowDef(headerRowDef) {\r\n        this._customHeaderRowDefs.delete(headerRowDef);\r\n        this._headerRowDefChanged = true;\r\n    }\r\n    /** Adds a footer row definition that was not included as part of the content children. */\r\n    addFooterRowDef(footerRowDef) {\r\n        this._customFooterRowDefs.add(footerRowDef);\r\n        this._footerRowDefChanged = true;\r\n    }\r\n    /** Removes a footer row definition that was not included as part of the content children. */\r\n    removeFooterRowDef(footerRowDef) {\r\n        this._customFooterRowDefs.delete(footerRowDef);\r\n        this._footerRowDefChanged = true;\r\n    }\r\n    /** Sets a no data row definition that was not included as a part of the content children. */\r\n    setNoDataRow(noDataRow) {\r\n        this._customNoDataRow = noDataRow;\r\n    }\r\n    /**\r\n     * Updates the header sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\r\n     * automatically called when the header row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyHeaderRowStyles() {\r\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\r\n        const tableElement = this._elementRef.nativeElement;\r\n        // Hide the thead element if there are no header rows. This is necessary to satisfy\r\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\r\n        // required child `row`.\r\n        const thead = tableElement.querySelector('thead');\r\n        if (thead) {\r\n            thead.style.display = headerRows.length ? '' : 'none';\r\n        }\r\n        const stickyStates = this._headerRowDefs.map(def => def.sticky);\r\n        this._stickyStyler.clearStickyPositioning(headerRows, ['top']);\r\n        this._stickyStyler.stickRows(headerRows, stickyStates, 'top');\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        this._headerRowDefs.forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Updates the footer sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\r\n     * automatically called when the footer row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyFooterRowStyles() {\r\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\r\n        const tableElement = this._elementRef.nativeElement;\r\n        // Hide the tfoot element if there are no footer rows. This is necessary to satisfy\r\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\r\n        // required child `row`.\r\n        const tfoot = tableElement.querySelector('tfoot');\r\n        if (tfoot) {\r\n            tfoot.style.display = footerRows.length ? '' : 'none';\r\n        }\r\n        const stickyStates = this._footerRowDefs.map(def => def.sticky);\r\n        this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);\r\n        this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');\r\n        this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        this._footerRowDefs.forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Updates the column sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the left and right. Then sticky styles are added for the left and right according\r\n     * to the column definitions for each cell in each row. This is automatically called when\r\n     * the data source provides a new set of data or when a column definition changes its sticky\r\n     * input. May be called manually for cases where the cell content changes outside of these events.\r\n     */\r\n    updateStickyColumnStyles() {\r\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\r\n        const dataRows = this._getRenderedRows(this._rowOutlet);\r\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\r\n        // For tables not using a fixed layout, the column widths may change when new rows are rendered.\r\n        // In a table using a fixed layout, row content won't affect column width, so sticky styles\r\n        // don't need to be cleared unless either the sticky column config changes or one of the row\r\n        // defs change.\r\n        if ((this._isNativeHtmlTable && !this._fixedLayout)\r\n            || this._stickyColumnStylesNeedReset) {\r\n            // Clear the left and right positioning from all columns in the table across all rows since\r\n            // sticky columns span across all table sections (header, data, footer)\r\n            this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ['left', 'right']);\r\n            this._stickyColumnStylesNeedReset = false;\r\n        }\r\n        // Update the sticky styles for each header row depending on the def's sticky state\r\n        headerRows.forEach((headerRow, i) => {\r\n            this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);\r\n        });\r\n        // Update the sticky styles for each data row depending on its def's sticky state\r\n        this._rowDefs.forEach(rowDef => {\r\n            // Collect all the rows rendered with this row definition.\r\n            const rows = [];\r\n            for (let i = 0; i < dataRows.length; i++) {\r\n                if (this._renderRows[i].rowDef === rowDef) {\r\n                    rows.push(dataRows[i]);\r\n                }\r\n            }\r\n            this._addStickyColumnStyles(rows, rowDef);\r\n        });\r\n        // Update the sticky styles for each footer row depending on the def's sticky state\r\n        footerRows.forEach((footerRow, i) => {\r\n            this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);\r\n        });\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Get the list of RenderRow objects to render according to the current list of data and defined\r\n     * row definitions. If the previous list already contained a particular pair, it should be reused\r\n     * so that the differ equates their references.\r\n     */\r\n    _getAllRenderRows() {\r\n        const renderRows = [];\r\n        // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the\r\n        // new cache while unused ones can be picked up by garbage collection.\r\n        const prevCachedRenderRows = this._cachedRenderRowsMap;\r\n        this._cachedRenderRowsMap = new Map();\r\n        // For each data object, get the list of rows that should be rendered, represented by the\r\n        // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.\r\n        for (let i = 0; i < this._data.length; i++) {\r\n            let data = this._data[i];\r\n            const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));\r\n            if (!this._cachedRenderRowsMap.has(data)) {\r\n                this._cachedRenderRowsMap.set(data, new WeakMap());\r\n            }\r\n            for (let j = 0; j < renderRowsForData.length; j++) {\r\n                let renderRow = renderRowsForData[j];\r\n                const cache = this._cachedRenderRowsMap.get(renderRow.data);\r\n                if (cache.has(renderRow.rowDef)) {\r\n                    cache.get(renderRow.rowDef).push(renderRow);\r\n                }\r\n                else {\r\n                    cache.set(renderRow.rowDef, [renderRow]);\r\n                }\r\n                renderRows.push(renderRow);\r\n            }\r\n        }\r\n        return renderRows;\r\n    }\r\n    /**\r\n     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\r\n     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\r\n     * `(T, CdkRowDef)` pair.\r\n     */\r\n    _getRenderRowsForData(data, dataIndex, cache) {\r\n        const rowDefs = this._getRowDefs(data, dataIndex);\r\n        return rowDefs.map(rowDef => {\r\n            const cachedRenderRows = (cache && cache.has(rowDef)) ? cache.get(rowDef) : [];\r\n            if (cachedRenderRows.length) {\r\n                const dataRow = cachedRenderRows.shift();\r\n                dataRow.dataIndex = dataIndex;\r\n                return dataRow;\r\n            }\r\n            else {\r\n                return { data, rowDef, dataIndex };\r\n            }\r\n        });\r\n    }\r\n    /** Update the map containing the content's column definitions. */\r\n    _cacheColumnDefs() {\r\n        this._columnDefsByName.clear();\r\n        const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);\r\n        columnDefs.forEach(columnDef => {\r\n            if (this._columnDefsByName.has(columnDef.name) &&\r\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableDuplicateColumnNameError(columnDef.name);\r\n            }\r\n            this._columnDefsByName.set(columnDef.name, columnDef);\r\n        });\r\n    }\r\n    /** Update the list of all available row definitions that can be used. */\r\n    _cacheRowDefs() {\r\n        this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);\r\n        this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);\r\n        this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);\r\n        // After all row definitions are determined, find the row definition to be considered default.\r\n        const defaultRowDefs = this._rowDefs.filter(def => !def.when);\r\n        if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMultipleDefaultRowDefsError();\r\n        }\r\n        this._defaultRowDef = defaultRowDefs[0];\r\n    }\r\n    /**\r\n     * Check if the header, data, or footer rows have changed what columns they want to display or\r\n     * whether the sticky states have changed for the header or footer. If there is a diff, then\r\n     * re-render that section.\r\n     */\r\n    _renderUpdatedColumns() {\r\n        const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();\r\n        // Force re-render data rows if the list of column definitions have changed.\r\n        const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);\r\n        if (dataColumnsChanged) {\r\n            this._forceRenderDataRows();\r\n        }\r\n        // Force re-render header/footer rows if the list of column definitions have changed.\r\n        const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);\r\n        if (headerColumnsChanged) {\r\n            this._forceRenderHeaderRows();\r\n        }\r\n        const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);\r\n        if (footerColumnsChanged) {\r\n            this._forceRenderFooterRows();\r\n        }\r\n        return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;\r\n    }\r\n    /**\r\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\r\n     * render change subscription if one exists. If the data source is null, interpret this by\r\n     * clearing the row outlet. Otherwise start listening for new data.\r\n     */\r\n    _switchDataSource(dataSource) {\r\n        this._data = [];\r\n        if (isDataSource(this.dataSource)) {\r\n            this.dataSource.disconnect(this);\r\n        }\r\n        // Stop listening for data from the previous data source.\r\n        if (this._renderChangeSubscription) {\r\n            this._renderChangeSubscription.unsubscribe();\r\n            this._renderChangeSubscription = null;\r\n        }\r\n        if (!dataSource) {\r\n            if (this._dataDiffer) {\r\n                this._dataDiffer.diff([]);\r\n            }\r\n            this._rowOutlet.viewContainer.clear();\r\n        }\r\n        this._dataSource = dataSource;\r\n    }\r\n    /** Set up a subscription for the data provided by the data source. */\r\n    _observeRenderChanges() {\r\n        // If no data source has been set, there is nothing to observe for changes.\r\n        if (!this.dataSource) {\r\n            return;\r\n        }\r\n        let dataStream;\r\n        if (isDataSource(this.dataSource)) {\r\n            dataStream = this.dataSource.connect(this);\r\n        }\r\n        else if (isObservable(this.dataSource)) {\r\n            dataStream = this.dataSource;\r\n        }\r\n        else if (Array.isArray(this.dataSource)) {\r\n            dataStream = of(this.dataSource);\r\n        }\r\n        if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableUnknownDataSourceError();\r\n        }\r\n        this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy))\r\n            .subscribe(data => {\r\n            this._data = data || [];\r\n            this.renderRows();\r\n        });\r\n    }\r\n    /**\r\n     * Clears any existing content in the header row outlet and creates a new embedded view\r\n     * in the outlet using the header row definition.\r\n     */\r\n    _forceRenderHeaderRows() {\r\n        // Clear the header row outlet if any content exists.\r\n        if (this._headerRowOutlet.viewContainer.length > 0) {\r\n            this._headerRowOutlet.viewContainer.clear();\r\n        }\r\n        this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));\r\n        this.updateStickyHeaderRowStyles();\r\n    }\r\n    /**\r\n     * Clears any existing content in the footer row outlet and creates a new embedded view\r\n     * in the outlet using the footer row definition.\r\n     */\r\n    _forceRenderFooterRows() {\r\n        // Clear the footer row outlet if any content exists.\r\n        if (this._footerRowOutlet.viewContainer.length > 0) {\r\n            this._footerRowOutlet.viewContainer.clear();\r\n        }\r\n        this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));\r\n        this.updateStickyFooterRowStyles();\r\n    }\r\n    /** Adds the sticky column styles for the rows according to the columns' stick states. */\r\n    _addStickyColumnStyles(rows, rowDef) {\r\n        const columnDefs = Array.from(rowDef.columns || []).map(columnName => {\r\n            const columnDef = this._columnDefsByName.get(columnName);\r\n            if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableUnknownColumnError(columnName);\r\n            }\r\n            return columnDef;\r\n        });\r\n        const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);\r\n        const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);\r\n        this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);\r\n    }\r\n    /** Gets the list of rows that have been rendered in the row outlet. */\r\n    _getRenderedRows(rowOutlet) {\r\n        const renderedRows = [];\r\n        for (let i = 0; i < rowOutlet.viewContainer.length; i++) {\r\n            const viewRef = rowOutlet.viewContainer.get(i);\r\n            renderedRows.push(viewRef.rootNodes[0]);\r\n        }\r\n        return renderedRows;\r\n    }\r\n    /**\r\n     * Get the matching row definitions that should be used for this row data. If there is only\r\n     * one row definition, it is returned. Otherwise, find the row definitions that has a when\r\n     * predicate that returns true with the data. If none return true, return the default row\r\n     * definition.\r\n     */\r\n    _getRowDefs(data, dataIndex) {\r\n        if (this._rowDefs.length == 1) {\r\n            return [this._rowDefs[0]];\r\n        }\r\n        let rowDefs = [];\r\n        if (this.multiTemplateDataRows) {\r\n            rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));\r\n        }\r\n        else {\r\n            let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;\r\n            if (rowDef) {\r\n                rowDefs.push(rowDef);\r\n            }\r\n        }\r\n        if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMissingMatchingRowDefError(data);\r\n        }\r\n        return rowDefs;\r\n    }\r\n    _getEmbeddedViewArgs(renderRow, index) {\r\n        const rowDef = renderRow.rowDef;\r\n        const context = { $implicit: renderRow.data };\r\n        return {\r\n            templateRef: rowDef.template,\r\n            context,\r\n            index,\r\n        };\r\n    }\r\n    /**\r\n     * Creates a new row template in the outlet and fills it with the set of cell templates.\r\n     * Optionally takes a context to provide to the row and cells, as well as an optional index\r\n     * of where to place the new row template in the outlet.\r\n     */\r\n    _renderRow(outlet, rowDef, index, context = {}) {\r\n        // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView\r\n        const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);\r\n        this._renderCellTemplateForItem(rowDef, context);\r\n        return view;\r\n    }\r\n    _renderCellTemplateForItem(rowDef, context) {\r\n        for (let cellTemplate of this._getCellTemplates(rowDef)) {\r\n            if (CdkCellOutlet.mostRecentCellOutlet) {\r\n                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);\r\n            }\r\n        }\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /**\r\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\r\n     * e.g. first/last/even/odd.\r\n     */\r\n    _updateRowIndexContext() {\r\n        const viewContainer = this._rowOutlet.viewContainer;\r\n        for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\r\n            const viewRef = viewContainer.get(renderIndex);\r\n            const context = viewRef.context;\r\n            context.count = count;\r\n            context.first = renderIndex === 0;\r\n            context.last = renderIndex === count - 1;\r\n            context.even = renderIndex % 2 === 0;\r\n            context.odd = !context.even;\r\n            if (this.multiTemplateDataRows) {\r\n                context.dataIndex = this._renderRows[renderIndex].dataIndex;\r\n                context.renderIndex = renderIndex;\r\n            }\r\n            else {\r\n                context.index = this._renderRows[renderIndex].dataIndex;\r\n            }\r\n        }\r\n    }\r\n    /** Gets the column definitions for the provided row def. */\r\n    _getCellTemplates(rowDef) {\r\n        if (!rowDef || !rowDef.columns) {\r\n            return [];\r\n        }\r\n        return Array.from(rowDef.columns, columnId => {\r\n            const column = this._columnDefsByName.get(columnId);\r\n            if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableUnknownColumnError(columnId);\r\n            }\r\n            return rowDef.extractCellTemplate(column);\r\n        });\r\n    }\r\n    /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\r\n    _applyNativeTableSections() {\r\n        const documentFragment = this._document.createDocumentFragment();\r\n        const sections = [\r\n            { tag: 'thead', outlets: [this._headerRowOutlet] },\r\n            { tag: 'tbody', outlets: [this._rowOutlet, this._noDataRowOutlet] },\r\n            { tag: 'tfoot', outlets: [this._footerRowOutlet] },\r\n        ];\r\n        for (const section of sections) {\r\n            const element = this._document.createElement(section.tag);\r\n            element.setAttribute('role', 'rowgroup');\r\n            for (const outlet of section.outlets) {\r\n                element.appendChild(outlet.elementRef.nativeElement);\r\n            }\r\n            documentFragment.appendChild(element);\r\n        }\r\n        // Use a DocumentFragment so we don't hit the DOM on each iteration.\r\n        this._elementRef.nativeElement.appendChild(documentFragment);\r\n    }\r\n    /**\r\n     * Forces a re-render of the data rows. Should be called in cases where there has been an input\r\n     * change that affects the evaluation of which rows should be rendered, e.g. toggling\r\n     * `multiTemplateDataRows` or adding/removing row definitions.\r\n     */\r\n    _forceRenderDataRows() {\r\n        this._dataDiffer.diff([]);\r\n        this._rowOutlet.viewContainer.clear();\r\n        this.renderRows();\r\n    }\r\n    /**\r\n     * Checks if there has been a change in sticky states since last check and applies the correct\r\n     * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\r\n     * during a change detection and after the inputs are settled (after content check).\r\n     */\r\n    _checkStickyStates() {\r\n        const stickyCheckReducer = (acc, d) => {\r\n            return acc || d.hasStickyChanged();\r\n        };\r\n        // Note that the check needs to occur for every definition since it notifies the definition\r\n        // that it can reset its dirty state. Using another operator like `some` may short-circuit\r\n        // remaining definitions and leave them in an unchecked state.\r\n        if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {\r\n            this.updateStickyHeaderRowStyles();\r\n        }\r\n        if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {\r\n            this.updateStickyFooterRowStyles();\r\n        }\r\n        if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {\r\n            this._stickyColumnStylesNeedReset = true;\r\n            this.updateStickyColumnStyles();\r\n        }\r\n    }\r\n    /**\r\n     * Creates the sticky styler that will be used for sticky rows and columns. Listens\r\n     * for directionality changes and provides the latest direction to the styler. Re-applies column\r\n     * stickiness when directionality changes.\r\n     */\r\n    _setupStickyStyler() {\r\n        const direction = this._dir ? this._dir.value : 'ltr';\r\n        this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);\r\n        (this._dir ? this._dir.change : of())\r\n            .pipe(takeUntil(this._onDestroy))\r\n            .subscribe(value => {\r\n            this._stickyStyler.direction = value;\r\n            this.updateStickyColumnStyles();\r\n        });\r\n    }\r\n    /** Filters definitions that belong to this table from a QueryList. */\r\n    _getOwnDefs(items) {\r\n        return items.filter(item => !item._table || item._table === this);\r\n    }\r\n    /** Creates or removes the no data row, depending on whether any data is being shown. */\r\n    _updateNoDataRow() {\r\n        const noDataRow = this._customNoDataRow || this._noDataRow;\r\n        if (noDataRow) {\r\n            const shouldShow = this._rowOutlet.viewContainer.length === 0;\r\n            if (shouldShow !== this._isShowingNoDataRow) {\r\n                const container = this._noDataRowOutlet.viewContainer;\r\n                shouldShow ? container.createEmbeddedView(noDataRow.templateRef) : container.clear();\r\n                this._isShowingNoDataRow = shouldShow;\r\n            }\r\n        }\r\n    }\r\n}\r\nCdkTable.ɵfac = function CdkTable_Factory(t) { return new (t || CdkTable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER, 8), ɵngcc0.ɵɵdirectiveInject(STICKY_POSITIONING_LISTENER, 12), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ViewportRuler, 8)); };\r\nCdkTable.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkTable, selectors: [[\"cdk-table\"], [\"table\", \"cdk-table\", \"\"]], contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkRowDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._noDataRow = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentRowDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);\r\n    } }, viewQuery: function CdkTable_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(DataRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(HeaderRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(FooterRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(NoDataRowOutlet, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._headerRowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._footerRowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._noDataRowOutlet = _t.first);\r\n    } }, hostAttrs: [1, \"cdk-table\"], hostVars: 2, hostBindings: function CdkTable_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"cdk-table-fixed-layout\", ctx.fixedLayout);\r\n    } }, inputs: { trackBy: \"trackBy\", dataSource: \"dataSource\", multiTemplateDataRows: \"multiTemplateDataRows\", fixedLayout: \"fixedLayout\" }, exportAs: [\"cdkTable\"], features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: CDK_TABLE, useExisting: CdkTable },\r\n            { provide: _VIEW_REPEATER_STRATEGY, useClass: _DisposeViewRepeaterStrategy },\r\n            { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\r\n            // Prevent nested tables from seeing this table's StickyPositioningListener.\r\n            { provide: STICKY_POSITIONING_LISTENER, useValue: null },\r\n        ])], ngContentSelectors: _c1, decls: 6, vars: 0, consts: [[\"headerRowOutlet\", \"\"], [\"rowOutlet\", \"\"], [\"noDataRowOutlet\", \"\"], [\"footerRowOutlet\", \"\"]], template: function CdkTable_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef(_c0);\r\n        ɵngcc0.ɵɵprojection(0);\r\n        ɵngcc0.ɵɵprojection(1, 1);\r\n        ɵngcc0.ɵɵelementContainer(2, 0);\r\n        ɵngcc0.ɵɵelementContainer(3, 1);\r\n        ɵngcc0.ɵɵelementContainer(4, 2);\r\n        ɵngcc0.ɵɵelementContainer(5, 3);\r\n    } }, directives: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet], styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"], encapsulation: 2 });\r\nCdkTable.ctorParameters = () => [\r\n    { type: IterableDiffers },\r\n    { type: ChangeDetectorRef },\r\n    { type: ElementRef },\r\n    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: Platform },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },\r\n    { type: _CoalescedStyleScheduler, decorators: [{ type: Optional }, { type: Inject, args: [_COALESCED_STYLE_SCHEDULER,] }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [STICKY_POSITIONING_LISTENER,] }] },\r\n    { type: ViewportRuler, decorators: [{ type: Optional }] }\r\n];\r\nCdkTable.propDecorators = {\r\n    trackBy: [{ type: Input }],\r\n    dataSource: [{ type: Input }],\r\n    multiTemplateDataRows: [{ type: Input }],\r\n    fixedLayout: [{ type: Input }],\r\n    _rowOutlet: [{ type: ViewChild, args: [DataRowOutlet, { static: true },] }],\r\n    _headerRowOutlet: [{ type: ViewChild, args: [HeaderRowOutlet, { static: true },] }],\r\n    _footerRowOutlet: [{ type: ViewChild, args: [FooterRowOutlet, { static: true },] }],\r\n    _noDataRowOutlet: [{ type: ViewChild, args: [NoDataRowOutlet, { static: true },] }],\r\n    _contentColumnDefs: [{ type: ContentChildren, args: [CdkColumnDef, { descendants: true },] }],\r\n    _contentRowDefs: [{ type: ContentChildren, args: [CdkRowDef, { descendants: true },] }],\r\n    _contentHeaderRowDefs: [{ type: ContentChildren, args: [CdkHeaderRowDef, {\r\n                    descendants: true\r\n                },] }],\r\n    _contentFooterRowDefs: [{ type: ContentChildren, args: [CdkFooterRowDef, {\r\n                    descendants: true\r\n                },] }],\r\n    _noDataRow: [{ type: ContentChild, args: [CdkNoDataRow,] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTable, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-table, table[cdk-table]',\r\n                exportAs: 'cdkTable',\r\n                template: CDK_TABLE_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-table',\r\n                    '[class.cdk-table-fixed-layout]': 'fixedLayout'\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                // The \"OnPush\" status for the `MatTable` component is effectively a noop, so we are removing it.\r\n                // The view for `MatTable` consists entirely of templates declared in other views. As they are\r\n                // declared elsewhere, they are checked when their declaration points are checked.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                providers: [\r\n                    { provide: CDK_TABLE, useExisting: CdkTable },\r\n                    { provide: _VIEW_REPEATER_STRATEGY, useClass: _DisposeViewRepeaterStrategy },\r\n                    { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\r\n                    // Prevent nested tables from seeing this table's StickyPositioningListener.\r\n                    { provide: STICKY_POSITIONING_LISTENER, useValue: null },\r\n                ],\r\n                styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{\r\n                type: Attribute,\r\n                args: ['role']\r\n            }] }, { type: ɵngcc1.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: ɵngcc2.Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [_VIEW_REPEATER_STRATEGY]\r\n            }] }, { type: _CoalescedStyleScheduler, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [_COALESCED_STYLE_SCHEDULER]\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: SkipSelf\r\n            }, {\r\n                type: Inject,\r\n                args: [STICKY_POSITIONING_LISTENER]\r\n            }] }, { type: ɵngcc3.ViewportRuler, decorators: [{\r\n                type: Optional\r\n            }] }]; }, { trackBy: [{\r\n            type: Input\r\n        }], dataSource: [{\r\n            type: Input\r\n        }], multiTemplateDataRows: [{\r\n            type: Input\r\n        }], fixedLayout: [{\r\n            type: Input\r\n        }], _rowOutlet: [{\r\n            type: ViewChild,\r\n            args: [DataRowOutlet, { static: true }]\r\n        }], _headerRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [HeaderRowOutlet, { static: true }]\r\n        }], _footerRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [FooterRowOutlet, { static: true }]\r\n        }], _noDataRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [NoDataRowOutlet, { static: true }]\r\n        }], _contentColumnDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkColumnDef, { descendants: true }]\r\n        }], _contentRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkRowDef, { descendants: true }]\r\n        }], _contentHeaderRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkHeaderRowDef, {\r\n                    descendants: true\r\n                }]\r\n        }], _contentFooterRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkFooterRowDef, {\r\n                    descendants: true\r\n                }]\r\n        }], _noDataRow: [{\r\n            type: ContentChild,\r\n            args: [CdkNoDataRow]\r\n        }] }); })();\r\n/** Utility function that gets a merged list of the entries in an array and values of a Set. */\r\nfunction mergeArrayAndSet(array, set) {\r\n    return array.concat(Array.from(set));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Column that simply shows text content for the header and row cells. Assumes that the table\r\n * is using the native table implementation (`<table>`).\r\n *\r\n * By default, the name of this column will be the header text and data property accessor.\r\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\r\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\r\n * input.\r\n */\r\nclass CdkTextColumn {\r\n    constructor(\r\n    // `CdkTextColumn` is always requiring a table, but we just assert it manually\r\n    // for better error reporting.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _table, _options) {\r\n        this._table = _table;\r\n        this._options = _options;\r\n        /** Alignment of the cell values. */\r\n        this.justify = 'start';\r\n        this._options = _options || {};\r\n    }\r\n    /** Column name that should be used to reference this column. */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    set name(name) {\r\n        this._name = name;\r\n        // With Ivy, inputs can be initialized before static query results are\r\n        // available. In that case, we defer the synchronization until \"ngOnInit\" fires.\r\n        this._syncColumnDefName();\r\n    }\r\n    ngOnInit() {\r\n        this._syncColumnDefName();\r\n        if (this.headerText === undefined) {\r\n            this.headerText = this._createDefaultHeaderText();\r\n        }\r\n        if (!this.dataAccessor) {\r\n            this.dataAccessor =\r\n                this._options.defaultDataAccessor || ((data, name) => data[name]);\r\n        }\r\n        if (this._table) {\r\n            // Provide the cell and headerCell directly to the table with the static `ViewChild` query,\r\n            // since the columnDef will not pick up its content by the time the table finishes checking\r\n            // its content and initializing the rows.\r\n            this.columnDef.cell = this.cell;\r\n            this.columnDef.headerCell = this.headerCell;\r\n            this._table.addColumnDef(this.columnDef);\r\n        }\r\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n            throw getTableTextColumnMissingParentTableError();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._table) {\r\n            this._table.removeColumnDef(this.columnDef);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a default header text. Use the options' header text transformation function if one\r\n     * has been provided. Otherwise simply capitalize the column name.\r\n     */\r\n    _createDefaultHeaderText() {\r\n        const name = this.name;\r\n        if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableTextColumnMissingNameError();\r\n        }\r\n        if (this._options && this._options.defaultHeaderTextTransform) {\r\n            return this._options.defaultHeaderTextTransform(name);\r\n        }\r\n        return name[0].toUpperCase() + name.slice(1);\r\n    }\r\n    /** Synchronizes the column definition name with the text column name. */\r\n    _syncColumnDefName() {\r\n        if (this.columnDef) {\r\n            this.columnDef.name = this.name;\r\n        }\r\n    }\r\n}\r\nCdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) { return new (t || CdkTextColumn)(ɵngcc0.ɵɵdirectiveInject(CdkTable, 8), ɵngcc0.ɵɵdirectiveInject(TEXT_COLUMN_OPTIONS, 8)); };\r\nCdkTextColumn.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkTextColumn, selectors: [[\"cdk-text-column\"]], viewQuery: function CdkTextColumn_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(CdkColumnDef, 7);\r\n        ɵngcc0.ɵɵviewQuery(CdkCellDef, 7);\r\n        ɵngcc0.ɵɵviewQuery(CdkHeaderCellDef, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnDef = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\r\n    } }, inputs: { justify: \"justify\", name: \"name\", headerText: \"headerText\", dataAccessor: \"dataAccessor\" }, decls: 3, vars: 0, consts: [[\"cdkColumnDef\", \"\"], [\"cdk-header-cell\", \"\", 3, \"text-align\", 4, \"cdkHeaderCellDef\"], [\"cdk-cell\", \"\", 3, \"text-align\", 4, \"cdkCellDef\"], [\"cdk-header-cell\", \"\"], [\"cdk-cell\", \"\"]], template: function CdkTextColumn_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainerStart(0, 0);\r\n        ɵngcc0.ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, \"th\", 1);\r\n        ɵngcc0.ɵɵtemplate(2, CdkTextColumn_td_2_Template, 2, 3, \"td\", 2);\r\n        ɵngcc0.ɵɵelementContainerEnd();\r\n    } }, directives: [CdkColumnDef, CdkHeaderCellDef, CdkCellDef, CdkHeaderCell, CdkCell], encapsulation: 2 });\r\nCdkTextColumn.ctorParameters = () => [\r\n    { type: CdkTable, decorators: [{ type: Optional }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TEXT_COLUMN_OPTIONS,] }] }\r\n];\r\nCdkTextColumn.propDecorators = {\r\n    name: [{ type: Input }],\r\n    headerText: [{ type: Input }],\r\n    dataAccessor: [{ type: Input }],\r\n    justify: [{ type: Input }],\r\n    columnDef: [{ type: ViewChild, args: [CdkColumnDef, { static: true },] }],\r\n    cell: [{ type: ViewChild, args: [CdkCellDef, { static: true },] }],\r\n    headerCell: [{ type: ViewChild, args: [CdkHeaderCellDef, { static: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTextColumn, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-text-column',\r\n                template: `\r\n    <ng-container cdkColumnDef>\r\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\r\n        {{headerText}}\r\n      </th>\r\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\r\n        {{dataAccessor(data, name)}}\r\n      </td>\r\n    </ng-container>\r\n  `,\r\n                encapsulation: ViewEncapsulation.None,\r\n                // Change detection is intentionally not set to OnPush. This component's template will be provided\r\n                // to the table to be inserted into its view. This is problematic when change detection runs since\r\n                // the bindings in this template will be evaluated _after_ the table's view is evaluated, which\r\n                // mean's the template in the table's view will not have the updated value (and in fact will cause\r\n                // an ExpressionChangedAfterItHasBeenCheckedError).\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default\r\n            }]\r\n    }], function () { return [{ type: CdkTable, decorators: [{\r\n                type: Optional\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [TEXT_COLUMN_OPTIONS]\r\n            }] }]; }, { justify: [{\r\n            type: Input\r\n        }], name: [{\r\n            type: Input\r\n        }], headerText: [{\r\n            type: Input\r\n        }], dataAccessor: [{\r\n            type: Input\r\n        }], columnDef: [{\r\n            type: ViewChild,\r\n            args: [CdkColumnDef, { static: true }]\r\n        }], cell: [{\r\n            type: ViewChild,\r\n            args: [CdkCellDef, { static: true }]\r\n        }], headerCell: [{\r\n            type: ViewChild,\r\n            args: [CdkHeaderCellDef, { static: true }]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst EXPORTED_DECLARATIONS = [\r\n    CdkTable,\r\n    CdkRowDef,\r\n    CdkCellDef,\r\n    CdkCellOutlet,\r\n    CdkHeaderCellDef,\r\n    CdkFooterCellDef,\r\n    CdkColumnDef,\r\n    CdkCell,\r\n    CdkRow,\r\n    CdkHeaderCell,\r\n    CdkFooterCell,\r\n    CdkHeaderRow,\r\n    CdkHeaderRowDef,\r\n    CdkFooterRow,\r\n    CdkFooterRowDef,\r\n    DataRowOutlet,\r\n    HeaderRowOutlet,\r\n    FooterRowOutlet,\r\n    CdkTextColumn,\r\n    CdkNoDataRow,\r\n    NoDataRowOutlet,\r\n];\r\nclass CdkTableModule {\r\n}\r\nCdkTableModule.ɵfac = function CdkTableModule_Factory(t) { return new (t || CdkTableModule)(); };\r\nCdkTableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CdkTableModule });\r\nCdkTableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ScrollingModule]] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTableModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: EXPORTED_DECLARATIONS,\r\n                declarations: EXPORTED_DECLARATIONS,\r\n                imports: [ScrollingModule]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkTableModule, { declarations: function () { return [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, NoDataRowOutlet]; }, imports: function () { return [ScrollingModule]; }, exports: function () { return [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, NoDataRowOutlet]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { BaseCdkCell, BaseRowDef, CDK_ROW_TEMPLATE, CDK_TABLE, CDK_TABLE_TEMPLATE, CdkCell, CdkCellDef, CdkCellOutlet, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkFooterRow, CdkFooterRowDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkNoDataRow, CdkRow, CdkRowDef, CdkTable, CdkTableModule, CdkTextColumn, DataRowOutlet, FooterRowOutlet, HeaderRowOutlet, NoDataRowOutlet, STICKY_DIRECTIONS, STICKY_POSITIONING_LISTENER, StickyStyler, TEXT_COLUMN_OPTIONS, _COALESCED_STYLE_SCHEDULER, _CoalescedStyleScheduler, _Schedule, mixinHasStickyInput };\r\n\r\n"]}