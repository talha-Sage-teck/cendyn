{"version":3,"mappings":"+ZAEIA,EAAW,IAAIC,IACfC,EAAoB,IAAID,IACxBE,KACAC,KACJ,WAAmBC,GACf,OAAOA,EAAOC,QAAQ,UAAW,KAAKC,OAsD1C,WAAuBC,GACnB,IAAIC,EAAWC,EAAUF,GACzB,IAAKR,EAASW,IAAIF,GAAW,CACzB,IAAIG,KAASC,SAAML,EAAQ,CACvBJ,8BAA+BA,IAEnC,IAAKQ,GAA0B,aAAhBA,EAAOE,KAClB,MAAM,IAAIC,MAAM,iCAEpBf,EAASgB,IAAIP,EA5BrB,SAAkBQ,GACd,IAAIC,EAAU,IAAIC,IAAIF,EAAIG,aAC1BF,EAAQG,QAAQ,SAAUC,GAClBA,EAAKC,YACED,EAAKC,IAChBC,OAAOC,KAAKH,GAAMD,QAAQ,SAAUK,GAChC,IAAIC,EAAQL,EAAKI,GACbC,GAA0B,iBAAVA,GAChBT,EAAQU,IAAID,OAIxB,IAAIJ,EAAMN,EAAIM,IACd,OAAIA,WACOA,EAAIM,kBACJN,EAAIO,UAERb,EAjBX,CA9BA,SAA0Bc,GACtB,IAAIC,EAAW,IAAIb,IACfC,EAAc,GAClBW,SAAIX,YAAYC,QAAQ,SAAUY,GAC9B,GAAgC,uBAA5BA,EAAmBnB,KAA+B,CAClD,IAAIoB,EAAeD,EAAmBE,KAAKR,MACvCS,EAThB,SAAyBb,GACrB,OAAOb,EAAUa,EAAIf,OAAO6B,KAAKC,UAAUf,EAAIgB,MAAOhB,EAAIiB,MAD9D,CAS4CP,EAAmBV,KAC/CkB,EAAevC,EAAkBwC,IAAIR,GACrCO,IAAiBA,EAAa9B,IAAIyB,GAC9BjC,GACAwC,QAAQC,KAAK,+BAAiCV,EAAe,iMAK3DO,GACNvC,EAAkBc,IAAIkB,EAAcO,EAAe,IAAItB,KAE3DsB,EAAab,IAAIQ,GACZJ,EAASrB,IAAIyB,KACdJ,EAASJ,IAAIQ,GACbhB,EAAYyB,KAAKZ,SAIrBb,EAAYyB,KAAKZ,QAGlBa,SAASA,MAAS,GAAIf,GAAM,CAAEX,YAAaA,IA5BtD,CA0DyDR,KAErD,OAAOZ,EAAS0C,IAAIjC,GAEjB,WAAasC,GAEhB,QADIC,EAAO,GACFC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAKC,EAAK,GAAKC,UAAUD,GAEL,iBAAbF,IACPA,EAAW,CAACA,IAEhB,IAAIK,EAASL,EAAS,GACtBC,SAAK3B,QAAQ,SAAUgC,EAAKC,GAEpBF,GADAC,GAAoB,aAAbA,EAAIvC,KACDuC,EAAI9B,IAAIf,OAAO6B,KAGfgB,EAEdD,GAAUL,EAASO,EAAI,KAEpBC,EAAcH,GAElB,aACHpD,EAASwD,QACTtD,EAAkBsD,QAEf,aACHrD,KAEG,aACHC,KAEG,aACHA,KAEJ,IAOWqD,EAPPC,EACKC,EADLD,EAEaE,EAFbF,EAGyBG,EAHzBH,EAIqCI,EAJrCJ,EAKsCK,GAE/BN,EAERE,IAAQA,EAAM,KADPA,IAAMD,EAAYD,EAAMG,YAAcF,EAAoBD,EAAMI,wBAA0BH,EAAgCD,EAAMK,oCAAsCJ,EAA4CD,EAAMM,qCAAuCL,EAEzQC,UAAiBA,EACjBK,UAAeL","names":["docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","string","replace","trim","source","cacheKey","normalize","has","parsed","parse","kind","Error","set","doc","workSet","Set","definitions","forEach","node","loc","Object","keys","key","value","add","startToken","endToken","ast","seenKeys","fragmentDefinition","fragmentName","name","sourceKey","body","substring","start","end","sourceKeySet","get","console","warn","push","__assign","literals","args","_i","arguments","length","result","arg","i","parseDocument","clear","gql_1","extras","gql","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","f"],"sources":["webpack:///node_modules/graphql-tag/lib/index.js"],"sourcesContent":["import { __assign } from \"tslib\";\r\nimport { parse } from 'graphql';\r\nvar docCache = new Map();\r\nvar fragmentSourceMap = new Map();\r\nvar printFragmentWarnings = true;\r\nvar experimentalFragmentVariables = false;\r\nfunction normalize(string) {\r\n    return string.replace(/[\\s,]+/g, ' ').trim();\r\n}\r\nfunction cacheKeyFromLoc(loc) {\r\n    return normalize(loc.source.body.substring(loc.start, loc.end));\r\n}\r\nfunction processFragments(ast) {\r\n    var seenKeys = new Set();\r\n    var definitions = [];\r\n    ast.definitions.forEach(function (fragmentDefinition) {\r\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\r\n            var fragmentName = fragmentDefinition.name.value;\r\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\r\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\r\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\r\n                if (printFragmentWarnings) {\r\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\r\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\r\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\r\n                }\r\n            }\r\n            else if (!sourceKeySet) {\r\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\r\n            }\r\n            sourceKeySet.add(sourceKey);\r\n            if (!seenKeys.has(sourceKey)) {\r\n                seenKeys.add(sourceKey);\r\n                definitions.push(fragmentDefinition);\r\n            }\r\n        }\r\n        else {\r\n            definitions.push(fragmentDefinition);\r\n        }\r\n    });\r\n    return __assign(__assign({}, ast), { definitions: definitions });\r\n}\r\nfunction stripLoc(doc) {\r\n    var workSet = new Set(doc.definitions);\r\n    workSet.forEach(function (node) {\r\n        if (node.loc)\r\n            delete node.loc;\r\n        Object.keys(node).forEach(function (key) {\r\n            var value = node[key];\r\n            if (value && typeof value === 'object') {\r\n                workSet.add(value);\r\n            }\r\n        });\r\n    });\r\n    var loc = doc.loc;\r\n    if (loc) {\r\n        delete loc.startToken;\r\n        delete loc.endToken;\r\n    }\r\n    return doc;\r\n}\r\nfunction parseDocument(source) {\r\n    var cacheKey = normalize(source);\r\n    if (!docCache.has(cacheKey)) {\r\n        var parsed = parse(source, {\r\n            experimentalFragmentVariables: experimentalFragmentVariables\r\n        });\r\n        if (!parsed || parsed.kind !== 'Document') {\r\n            throw new Error('Not a valid GraphQL document.');\r\n        }\r\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\r\n    }\r\n    return docCache.get(cacheKey);\r\n}\r\nexport function gql(literals) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    if (typeof literals === 'string') {\r\n        literals = [literals];\r\n    }\r\n    var result = literals[0];\r\n    args.forEach(function (arg, i) {\r\n        if (arg && arg.kind === 'Document') {\r\n            result += arg.loc.source.body;\r\n        }\r\n        else {\r\n            result += arg;\r\n        }\r\n        result += literals[i + 1];\r\n    });\r\n    return parseDocument(result);\r\n}\r\nexport function resetCaches() {\r\n    docCache.clear();\r\n    fragmentSourceMap.clear();\r\n}\r\nexport function disableFragmentWarnings() {\r\n    printFragmentWarnings = false;\r\n}\r\nexport function enableExperimentalFragmentVariables() {\r\n    experimentalFragmentVariables = true;\r\n}\r\nexport function disableExperimentalFragmentVariables() {\r\n    experimentalFragmentVariables = false;\r\n}\r\nvar extras = {\r\n    gql: gql,\r\n    resetCaches: resetCaches,\r\n    disableFragmentWarnings: disableFragmentWarnings,\r\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\r\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\r\n};\r\n(function (gql_1) {\r\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\r\n})(gql || (gql = {}));\r\ngql[\"default\"] = gql;\r\nexport default gql;\r\n"]}