(function () {
  "use strict";

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  (self["webpackChunkshell"] = self["webpackChunkshell"] || []).push([["node_modules_angular_cdk_fesm2015_table_js-_50fc0"], {
    /***/
    99952: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "BidiModule": function BidiModule() {
          return (
            /* binding */
            _BidiModule
          );
        },

        /* harmony export */
        "DIR_DOCUMENT": function DIR_DOCUMENT() {
          return (
            /* binding */
            _DIR_DOCUMENT
          );
        },

        /* harmony export */
        "Dir": function Dir() {
          return (
            /* binding */
            _Dir
          );
        },

        /* harmony export */
        "Directionality": function Directionality() {
          return (
            /* binding */
            _Directionality
          );
        },

        /* harmony export */
        "ɵangular_material_src_cdk_bidi_bidi_a": function ɵangular_material_src_cdk_bidi_bidi_a() {
          return (
            /* binding */
            DIR_DOCUMENT_FACTORY
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Injection token used to inject the document into Directionality.
       * This is used so that the value can be faked in tests.
       *
       * We can't use the real document in tests because changing the real `dir` causes geometry-based
       * tests in Safari to fail.
       *
       * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
       * themselves use things like `querySelector` in test code.
       *
       * This token is defined in a separate file from Directionality as a workaround for
       * https://github.com/angular/angular/issues/22559
       *
       * @docs-private
       */


      var _DIR_DOCUMENT = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('cdk-dir-doc', {
        providedIn: 'root',
        factory: DIR_DOCUMENT_FACTORY
      });
      /** @docs-private */


      function DIR_DOCUMENT_FACTORY() {
        return (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * The directionality (LTR / RTL) context for the application (or a subtree of it).
       * Exposes the current direction and a stream of direction changes.
       */


      var _Directionality = /*#__PURE__*/function () {
        var Directionality = /*#__PURE__*/function () {
          function Directionality(_document) {
            _classCallCheck(this, Directionality);

            /** The current 'ltr' or 'rtl' value. */
            this.value = 'ltr';
            /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */

            this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();

            if (_document) {
              // TODO: handle 'auto' value -
              // We still need to account for dir="auto".
              // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
              // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
              var bodyDir = _document.body ? _document.body.dir : null;
              var htmlDir = _document.documentElement ? _document.documentElement.dir : null;
              var value = bodyDir || htmlDir;
              this.value = value === 'ltr' || value === 'rtl' ? value : 'ltr';
            }
          }

          _createClass(Directionality, [{
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.change.complete();
            }
          }]);

          return Directionality;
        }();

        Directionality.ɵfac = function Directionality_Factory(t) {
          return new (t || Directionality)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_DIR_DOCUMENT, 8));
        };

        Directionality.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function Directionality_Factory() {
            return new Directionality((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_DIR_DOCUMENT, 8));
          },
          token: Directionality,
          providedIn: "root"
        });
        return Directionality;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Directive to listen for changes of direction of part of the DOM.
       *
       * Provides itself as Directionality such that descendant directives only need to ever inject
       * Directionality to get the closest direction.
       */


      var _Dir = /*#__PURE__*/function () {
        var Dir = /*#__PURE__*/function () {
          function Dir() {
            _classCallCheck(this, Dir);

            /** Normalized direction that accounts for invalid/unsupported values. */
            this._dir = 'ltr';
            /** Whether the `value` has been set to its initial value. */

            this._isInitialized = false;
            /** Event emitted when the direction changes. */

            this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          }
          /** @docs-private */


          _createClass(Dir, [{
            key: "dir",
            get: function get() {
              return this._dir;
            },
            set: function set(value) {
              var old = this._dir;
              var normalizedValue = value ? value.toLowerCase() : value;
              this._rawDir = value;
              this._dir = normalizedValue === 'ltr' || normalizedValue === 'rtl' ? normalizedValue : 'ltr';

              if (old !== this._dir && this._isInitialized) {
                this.change.emit(this._dir);
              }
            }
            /** Current layout direction of the element. */

          }, {
            key: "value",
            get: function get() {
              return this.dir;
            }
            /** Initialize once default value has been set. */

          }, {
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              this._isInitialized = true;
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.change.complete();
            }
          }]);

          return Dir;
        }();

        Dir.ɵfac = function Dir_Factory(t) {
          return new (t || Dir)();
        };

        Dir.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: Dir,
          selectors: [["", "dir", ""]],
          hostVars: 1,
          hostBindings: function Dir_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("dir", ctx._rawDir);
            }
          },
          inputs: {
            dir: "dir"
          },
          outputs: {
            change: "dirChange"
          },
          exportAs: ["dir"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _Directionality,
            useExisting: Dir
          }])]
        });
        return Dir;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _BidiModule = /*#__PURE__*/function () {
        var BidiModule = function BidiModule() {
          _classCallCheck(this, BidiModule);
        };

        BidiModule.ɵfac = function BidiModule_Factory(t) {
          return new (t || BidiModule)();
        };

        BidiModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: BidiModule
        });
        BidiModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return BidiModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_BidiModule, {
          declarations: [_Dir],
          exports: [_Dir]
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    },

    /***/
    79933: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "_isNumberValue": function _isNumberValue() {
          return (
            /* binding */
            _isNumberValue2
          );
        },

        /* harmony export */
        "coerceArray": function coerceArray() {
          return (
            /* binding */
            _coerceArray
          );
        },

        /* harmony export */
        "coerceBooleanProperty": function coerceBooleanProperty() {
          return (
            /* binding */
            _coerceBooleanProperty
          );
        },

        /* harmony export */
        "coerceCssPixelValue": function coerceCssPixelValue() {
          return (
            /* binding */
            _coerceCssPixelValue
          );
        },

        /* harmony export */
        "coerceElement": function coerceElement() {
          return (
            /* binding */
            _coerceElement
          );
        },

        /* harmony export */
        "coerceNumberProperty": function coerceNumberProperty() {
          return (
            /* binding */
            _coerceNumberProperty
          );
        },

        /* harmony export */
        "coerceStringArray": function coerceStringArray() {
          return (
            /* binding */
            _coerceStringArray
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Coerces a data-bound value (typically a string) to a boolean. */


      function _coerceBooleanProperty(value) {
        return value != null && "".concat(value) !== 'false';
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      function _coerceNumberProperty(value) {
        var fallbackValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return _isNumberValue2(value) ? Number(value) : fallbackValue;
      }
      /**
       * Whether the provided value is considered a number.
       * @docs-private
       */


      function _isNumberValue2(value) {
        // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
        // and other non-number values as NaN, where Number just uses 0) but it considers the string
        // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
        return !isNaN(parseFloat(value)) && !isNaN(Number(value));
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      function _coerceArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Coerces a value to a CSS pixel value. */


      function _coerceCssPixelValue(value) {
        if (value == null) {
          return '';
        }

        return typeof value === 'string' ? value : "".concat(value, "px");
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Coerces an ElementRef or an Element into an element.
       * Useful for APIs that can accept either a ref or the native element itself.
       */


      function _coerceElement(elementOrRef) {
        return elementOrRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef ? elementOrRef.nativeElement : elementOrRef;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Coerces a value to an array of trimmed non-empty strings.
       * Any input that is not an array, `null` or `undefined` will be turned into a string
       * via `toString()` and subsequently split with the given separator.
       * `null` and `undefined` will result in an empty array.
       * This results in the following outcomes:
       * - `null` -&gt; `[]`
       * - `[null]` -&gt; `["null"]`
       * - `["a", "b ", " "]` -&gt; `["a", "b"]`
       * - `[1, [2, 3]]` -&gt; `["1", "2,3"]`
       * - `[{ a: 0 }]` -&gt; `["[object Object]"]`
       * - `{ a: 0 }` -&gt; `["[object", "Object]"]`
       *
       * Useful for defining CSS classes or table columns.
       * @param value the value to coerce into an array of strings
       * @param separator split-separator if value isn't an array
       */


      function _coerceStringArray(value) {
        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\s+/;
        var result = [];

        if (value != null) {
          var sourceValues = Array.isArray(value) ? value : "".concat(value).split(separator);

          var _iterator = _createForOfIteratorHelper(sourceValues),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var sourceValue = _step.value;
              var trimmedString = "".concat(sourceValue).trim();

              if (trimmedString) {
                result.push(trimmedString);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return result;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /***/

    },

    /***/
    64797: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ArrayDataSource": function ArrayDataSource() {
          return (
            /* binding */
            _ArrayDataSource
          );
        },

        /* harmony export */
        "DataSource": function DataSource() {
          return (
            /* binding */
            _DataSource
          );
        },

        /* harmony export */
        "SelectionModel": function SelectionModel() {
          return (
            /* binding */
            _SelectionModel
          );
        },

        /* harmony export */
        "UniqueSelectionDispatcher": function UniqueSelectionDispatcher() {
          return (
            /* binding */
            _UniqueSelectionDispatcher
          );
        },

        /* harmony export */
        "_DisposeViewRepeaterStrategy": function _DisposeViewRepeaterStrategy() {
          return (
            /* binding */
            _DisposeViewRepeaterStrategy2
          );
        },

        /* harmony export */
        "_RecycleViewRepeaterStrategy": function _RecycleViewRepeaterStrategy() {
          return (
            /* binding */
            _RecycleViewRepeaterStrategy2
          );
        },

        /* harmony export */
        "_VIEW_REPEATER_STRATEGY": function _VIEW_REPEATER_STRATEGY() {
          return (
            /* binding */
            _VIEW_REPEATER_STRATEGY2
          );
        },

        /* harmony export */
        "getMultipleValuesInSingleSelectionError": function getMultipleValuesInSingleSelectionError() {
          return (
            /* binding */
            _getMultipleValuesInSingleSelectionError
          );
        },

        /* harmony export */
        "isDataSource": function isDataSource() {
          return (
            /* binding */
            _isDataSource
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _DataSource = function _DataSource() {
        _classCallCheck(this, _DataSource);
      };
      /** Checks whether an object is a data source. */


      function _isDataSource(value) {
        // Check if the value is a DataSource by observing if it has a connect function. Cannot
        // be checked as an `instanceof DataSource` since people could create their own sources
        // that match the interface, but don't extend DataSource.
        return value && typeof value.connect === 'function';
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** DataSource wrapper for a native array. */


      var _ArrayDataSource = /*#__PURE__*/function (_DataSource2) {
        _inherits(_ArrayDataSource, _DataSource2);

        var _super = _createSuper(_ArrayDataSource);

        function _ArrayDataSource(_data) {
          var _this;

          _classCallCheck(this, _ArrayDataSource);

          _this = _super.call(this);
          _this._data = _data;
          return _this;
        }

        _createClass(_ArrayDataSource, [{
          key: "connect",
          value: function connect() {
            return (0, rxjs__WEBPACK_IMPORTED_MODULE_0__.isObservable)(this._data) ? this._data : (0, rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(this._data);
          }
        }, {
          key: "disconnect",
          value: function disconnect() {}
        }]);

        return _ArrayDataSource;
      }(_DataSource);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A repeater that destroys views when they are removed from a
       * {@link ViewContainerRef}. When new items are inserted into the container,
       * the repeater will always construct a new embedded view for each item.
       *
       * @template T The type for the embedded view's $implicit property.
       * @template R The type for the item in each IterableDiffer change record.
       * @template C The type for the context passed to each embedded view.
       */


      var _DisposeViewRepeaterStrategy2 = /*#__PURE__*/function () {
        function _DisposeViewRepeaterStrategy2() {
          _classCallCheck(this, _DisposeViewRepeaterStrategy2);
        }

        _createClass(_DisposeViewRepeaterStrategy2, [{
          key: "applyChanges",
          value: function applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
            changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {
              var view;
              var operation;

              if (record.previousIndex == null) {
                var insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);
                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);
                operation = 1
                /* INSERTED */
                ;
              } else if (currentIndex == null) {
                viewContainerRef.remove(adjustedPreviousIndex);
                operation = 3
                /* REMOVED */
                ;
              } else {
                view = viewContainerRef.get(adjustedPreviousIndex);
                viewContainerRef.move(view, currentIndex);
                operation = 2
                /* MOVED */
                ;
              }

              if (itemViewChanged) {
                itemViewChanged({
                  context: view === null || view === void 0 ? void 0 : view.context,
                  operation: operation,
                  record: record
                });
              }
            });
          }
        }, {
          key: "detach",
          value: function detach() {}
        }]);

        return _DisposeViewRepeaterStrategy2;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A repeater that caches views when they are removed from a
       * {@link ViewContainerRef}. When new items are inserted into the container,
       * the repeater will reuse one of the cached views instead of creating a new
       * embedded view. Recycling cached views reduces the quantity of expensive DOM
       * inserts.
       *
       * @template T The type for the embedded view's $implicit property.
       * @template R The type for the item in each IterableDiffer change record.
       * @template C The type for the context passed to each embedded view.
       */


      var _RecycleViewRepeaterStrategy2 = /*#__PURE__*/function () {
        function _RecycleViewRepeaterStrategy2() {
          _classCallCheck(this, _RecycleViewRepeaterStrategy2);

          /**
           * The size of the cache used to store unused views.
           * Setting the cache size to `0` will disable caching. Defaults to 20 views.
           */
          this.viewCacheSize = 20;
          /**
           * View cache that stores embedded view instances that have been previously stamped out,
           * but don't are not currently rendered. The view repeater will reuse these views rather than
           * creating brand new ones.
           *
           * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
           */

          this._viewCache = [];
        }
        /** Apply changes to the DOM. */


        _createClass(_RecycleViewRepeaterStrategy2, [{
          key: "applyChanges",
          value: function applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
            var _this2 = this;

            // Rearrange the views to put them in the right location.
            changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {
              var view;
              var operation;

              if (record.previousIndex == null) {
                // Item added.
                var viewArgsFactory = function viewArgsFactory() {
                  return itemContextFactory(record, adjustedPreviousIndex, currentIndex);
                };

                view = _this2._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
                operation = view ? 1
                /* INSERTED */
                : 0
                /* REPLACED */
                ;
              } else if (currentIndex == null) {
                // Item removed.
                _this2._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);

                operation = 3
                /* REMOVED */
                ;
              } else {
                // Item moved.
                view = _this2._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
                operation = 2
                /* MOVED */
                ;
              }

              if (itemViewChanged) {
                itemViewChanged({
                  context: view === null || view === void 0 ? void 0 : view.context,
                  operation: operation,
                  record: record
                });
              }
            });
          }
        }, {
          key: "detach",
          value: function detach() {
            var _iterator2 = _createForOfIteratorHelper(this._viewCache),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var view = _step2.value;
                view.destroy();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            this._viewCache = [];
          }
          /**
           * Inserts a view for a new item, either from the cache or by creating a new
           * one. Returns `undefined` if the item was inserted into a cached view.
           */

        }, {
          key: "_insertView",
          value: function _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
            var cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);

            if (cachedView) {
              cachedView.context.$implicit = value;
              return undefined;
            }

            var viewArgs = viewArgsFactory();
            return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
          }
          /** Detaches the view at the given index and inserts into the view cache. */

        }, {
          key: "_detachAndCacheView",
          value: function _detachAndCacheView(index, viewContainerRef) {
            var detachedView = viewContainerRef.detach(index);

            this._maybeCacheView(detachedView, viewContainerRef);
          }
          /** Moves view at the previous index to the current index. */

        }, {
          key: "_moveView",
          value: function _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
            var view = viewContainerRef.get(adjustedPreviousIndex);
            viewContainerRef.move(view, currentIndex);
            view.context.$implicit = value;
            return view;
          }
          /**
           * Cache the given detached view. If the cache is full, the view will be
           * destroyed.
           */

        }, {
          key: "_maybeCacheView",
          value: function _maybeCacheView(view, viewContainerRef) {
            if (this._viewCache.length < this.viewCacheSize) {
              this._viewCache.push(view);
            } else {
              var index = viewContainerRef.indexOf(view); // The host component could remove views from the container outside of
              // the view repeater. It's unlikely this will occur, but just in case,
              // destroy the view on its own, otherwise destroy it through the
              // container to ensure that all the references are removed.

              if (index === -1) {
                view.destroy();
              } else {
                viewContainerRef.remove(index);
              }
            }
          }
          /** Inserts a recycled view from the cache at the given index. */

        }, {
          key: "_insertViewFromCache",
          value: function _insertViewFromCache(index, viewContainerRef) {
            var cachedView = this._viewCache.pop();

            if (cachedView) {
              viewContainerRef.insert(cachedView, index);
            }

            return cachedView || null;
          }
        }]);

        return _RecycleViewRepeaterStrategy2;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Class to be used to power selecting one or more options from a list.
       */


      var _SelectionModel = /*#__PURE__*/function () {
        function _SelectionModel() {
          var _this3 = this;

          var _multiple = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          var initiallySelectedValues = arguments.length > 1 ? arguments[1] : undefined;

          var _emitChanges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          _classCallCheck(this, _SelectionModel);

          this._multiple = _multiple;
          this._emitChanges = _emitChanges;
          /** Currently-selected values. */

          this._selection = new Set();
          /** Keeps track of the deselected options that haven't been emitted by the change event. */

          this._deselectedToEmit = [];
          /** Keeps track of the selected options that haven't been emitted by the change event. */

          this._selectedToEmit = [];
          /** Event emitted when the value has changed. */

          this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();

          if (initiallySelectedValues && initiallySelectedValues.length) {
            if (_multiple) {
              initiallySelectedValues.forEach(function (value) {
                return _this3._markSelected(value);
              });
            } else {
              this._markSelected(initiallySelectedValues[0]);
            } // Clear the array in order to avoid firing the change event for preselected values.


            this._selectedToEmit.length = 0;
          }
        }
        /** Selected values. */


        _createClass(_SelectionModel, [{
          key: "selected",
          get: function get() {
            if (!this._selected) {
              this._selected = Array.from(this._selection.values());
            }

            return this._selected;
          }
          /**
           * Selects a value or an array of values.
           */

        }, {
          key: "select",
          value: function select() {
            var _this4 = this;

            for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
              values[_key] = arguments[_key];
            }

            this._verifyValueAssignment(values);

            values.forEach(function (value) {
              return _this4._markSelected(value);
            });

            this._emitChangeEvent();
          }
          /**
           * Deselects a value or an array of values.
           */

        }, {
          key: "deselect",
          value: function deselect() {
            var _this5 = this;

            for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              values[_key2] = arguments[_key2];
            }

            this._verifyValueAssignment(values);

            values.forEach(function (value) {
              return _this5._unmarkSelected(value);
            });

            this._emitChangeEvent();
          }
          /**
           * Toggles a value between selected and deselected.
           */

        }, {
          key: "toggle",
          value: function toggle(value) {
            this.isSelected(value) ? this.deselect(value) : this.select(value);
          }
          /**
           * Clears all of the selected values.
           */

        }, {
          key: "clear",
          value: function clear() {
            this._unmarkAll();

            this._emitChangeEvent();
          }
          /**
           * Determines whether a value is selected.
           */

        }, {
          key: "isSelected",
          value: function isSelected(value) {
            return this._selection.has(value);
          }
          /**
           * Determines whether the model does not have a value.
           */

        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return this._selection.size === 0;
          }
          /**
           * Determines whether the model has a value.
           */

        }, {
          key: "hasValue",
          value: function hasValue() {
            return !this.isEmpty();
          }
          /**
           * Sorts the selected values based on a predicate function.
           */

        }, {
          key: "sort",
          value: function sort(predicate) {
            if (this._multiple && this.selected) {
              this._selected.sort(predicate);
            }
          }
          /**
           * Gets whether multiple values can be selected.
           */

        }, {
          key: "isMultipleSelection",
          value: function isMultipleSelection() {
            return this._multiple;
          }
          /** Emits a change event and clears the records of selected and deselected values. */

        }, {
          key: "_emitChangeEvent",
          value: function _emitChangeEvent() {
            // Clear the selected values so they can be re-cached.
            this._selected = null;

            if (this._selectedToEmit.length || this._deselectedToEmit.length) {
              this.changed.next({
                source: this,
                added: this._selectedToEmit,
                removed: this._deselectedToEmit
              });
              this._deselectedToEmit = [];
              this._selectedToEmit = [];
            }
          }
          /** Selects a value. */

        }, {
          key: "_markSelected",
          value: function _markSelected(value) {
            if (!this.isSelected(value)) {
              if (!this._multiple) {
                this._unmarkAll();
              }

              this._selection.add(value);

              if (this._emitChanges) {
                this._selectedToEmit.push(value);
              }
            }
          }
          /** Deselects a value. */

        }, {
          key: "_unmarkSelected",
          value: function _unmarkSelected(value) {
            if (this.isSelected(value)) {
              this._selection["delete"](value);

              if (this._emitChanges) {
                this._deselectedToEmit.push(value);
              }
            }
          }
          /** Clears out the selected values. */

        }, {
          key: "_unmarkAll",
          value: function _unmarkAll() {
            var _this6 = this;

            if (!this.isEmpty()) {
              this._selection.forEach(function (value) {
                return _this6._unmarkSelected(value);
              });
            }
          }
          /**
           * Verifies the value assignment and throws an error if the specified value array is
           * including multiple values while the selection model is not supporting multiple values.
           */

        }, {
          key: "_verifyValueAssignment",
          value: function _verifyValueAssignment(values) {
            if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw _getMultipleValuesInSingleSelectionError();
            }
          }
        }]);

        return _SelectionModel;
      }();
      /**
       * Returns an error that reports that multiple values are passed into a selection model
       * with a single value.
       * @docs-private
       */


      function _getMultipleValuesInSingleSelectionError() {
        return Error('Cannot pass multiple values into SelectionModel with single-value mode.');
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Class to coordinate unique selection based on name.
       * Intended to be consumed as an Angular service.
       * This service is needed because native radio change events are only fired on the item currently
       * being selected, and we still need to uncheck the previous selection.
       *
       * This service does not *store* any IDs and names because they may change at any time, so it is
       * less error-prone if they are simply passed through when the events occur.
       */


      var _UniqueSelectionDispatcher = /*#__PURE__*/function () {
        var UniqueSelectionDispatcher = /*#__PURE__*/function () {
          function UniqueSelectionDispatcher() {
            _classCallCheck(this, UniqueSelectionDispatcher);

            this._listeners = [];
          }
          /**
           * Notify other items that selection for the given name has been set.
           * @param id ID of the item.
           * @param name Name of the item.
           */


          _createClass(UniqueSelectionDispatcher, [{
            key: "notify",
            value: function notify(id, name) {
              var _iterator3 = _createForOfIteratorHelper(this._listeners),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var listener = _step3.value;
                  listener(id, name);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
            /**
             * Listen for future changes to item selection.
             * @return Function used to deregister listener
             */

          }, {
            key: "listen",
            value: function listen(listener) {
              var _this7 = this;

              this._listeners.push(listener);

              return function () {
                _this7._listeners = _this7._listeners.filter(function (registered) {
                  return listener !== registered;
                });
              };
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._listeners = [];
            }
          }]);

          return UniqueSelectionDispatcher;
        }();

        UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) {
          return new (t || UniqueSelectionDispatcher)();
        };

        UniqueSelectionDispatcher.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
          factory: function UniqueSelectionDispatcher_Factory() {
            return new UniqueSelectionDispatcher();
          },
          token: UniqueSelectionDispatcher,
          providedIn: "root"
        });
        return UniqueSelectionDispatcher;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.
       * @docs-private
       */


      var _VIEW_REPEATER_STRATEGY2 = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('_ViewRepeater');
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    },

    /***/
    97637: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "Platform": function Platform() {
          return (
            /* binding */
            _Platform
          );
        },

        /* harmony export */
        "PlatformModule": function PlatformModule() {
          return (
            /* binding */
            _PlatformModule
          );
        },

        /* harmony export */
        "_getShadowRoot": function _getShadowRoot() {
          return (
            /* binding */
            _getShadowRoot2
          );
        },

        /* harmony export */
        "_supportsShadowDom": function _supportsShadowDom() {
          return (
            /* binding */
            _supportsShadowDom2
          );
        },

        /* harmony export */
        "getRtlScrollAxisType": function getRtlScrollAxisType() {
          return (
            /* binding */
            _getRtlScrollAxisType
          );
        },

        /* harmony export */
        "getSupportedInputTypes": function getSupportedInputTypes() {
          return (
            /* binding */
            _getSupportedInputTypes
          );
        },

        /* harmony export */
        "normalizePassiveListenerOptions": function normalizePassiveListenerOptions() {
          return (
            /* binding */
            _normalizePassiveListenerOptions
          );
        },

        /* harmony export */
        "supportsPassiveEventListeners": function supportsPassiveEventListeners() {
          return (
            /* binding */
            _supportsPassiveEventListeners
          );
        },

        /* harmony export */
        "supportsScrollBehavior": function supportsScrollBehavior() {
          return (
            /* binding */
            _supportsScrollBehavior
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // Whether the current platform supports the V8 Break Iterator. The V8 check
      // is necessary to detect all Blink based browsers.


      var hasV8BreakIterator; // We need a try/catch around the reference to `Intl`, because accessing it in some cases can
      // cause IE to throw. These cases are tied to particular versions of Windows and can happen if
      // the consumer is providing a polyfilled `Map`. See:
      // https://github.com/Microsoft/ChakraCore/issues/3189
      // https://github.com/angular/components/issues/15687

      try {
        hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;
      } catch (_a) {
        hasV8BreakIterator = false;
      }
      /**
       * Service to detect the current platform by comparing the userAgent strings and
       * checking browser-specific global properties.
       */


      var _Platform = /*#__PURE__*/function () {
        var Platform = function Platform(_platformId) {
          _classCallCheck(this, Platform);

          this._platformId = _platformId; // We want to use the Angular platform check because if the Document is shimmed
          // without the navigator, the following checks will fail. This is preferred because
          // sometimes the Document may be shimmed without the user's knowledge or intention

          /** Whether the Angular application is being rendered in the browser. */

          this.isBrowser = this._platformId ? (0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this._platformId) : typeof document === 'object' && !!document;
          /** Whether the current browser is Microsoft Edge. */

          this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
          /** Whether the current rendering engine is Microsoft Trident. */

          this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent); // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.

          /** Whether the current rendering engine is Blink. */

          this.BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT; // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
          // ensure that Webkit runs standalone and is not used as another engine's base.

          /** Whether the current rendering engine is WebKit. */

          this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
          /** Whether the current platform is Apple iOS. */

          this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window); // It's difficult to detect the plain Gecko engine, because most of the browsers identify
          // them self as Gecko-like browsers and modify the userAgent's according to that.
          // Since we only cover one explicit Firefox case, we can simply check for Firefox
          // instead of having an unstable check for Gecko.

          /** Whether the current browser is Firefox. */

          this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
          /** Whether the current platform is Android. */
          // Trident on mobile adds the android platform to the userAgent to trick detections.

          this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT; // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
          // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
          // Safari browser should also use Webkit as its layout engine.

          /** Whether the current browser is Safari. */

          this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
        };

        Platform.ɵfac = function Platform_Factory(t) {
          return new (t || Platform)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID));
        };

        Platform.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function Platform_Factory() {
            return new Platform((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID));
          },
          token: Platform,
          providedIn: "root"
        });
        return Platform;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _PlatformModule = /*#__PURE__*/function () {
        var PlatformModule = function PlatformModule() {
          _classCallCheck(this, PlatformModule);
        };

        PlatformModule.ɵfac = function PlatformModule_Factory(t) {
          return new (t || PlatformModule)();
        };

        PlatformModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: PlatformModule
        });
        PlatformModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return PlatformModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result Set of input types support by the current browser. */


      var supportedInputTypes;
      /** Types of `<input>` that *might* be supported. */

      var candidateInputTypes = [// `color` must come first. Chrome 56 shows a warning if we change the type to `color` after
      // first changing it to something else:
      // The specified value "" does not conform to the required format.
      // The format is "#rrggbb" where rr, gg, bb are two-digit hexadecimal numbers.
      'color', 'button', 'checkbox', 'date', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week'];
      /** @returns The input types supported by this browser. */

      function _getSupportedInputTypes() {
        // Result is cached.
        if (supportedInputTypes) {
          return supportedInputTypes;
        } // We can't check if an input type is not supported until we're on the browser, so say that
        // everything is supported when not on the browser. We don't use `Platform` here since it's
        // just a helper function and can't inject it.


        if (typeof document !== 'object' || !document) {
          supportedInputTypes = new Set(candidateInputTypes);
          return supportedInputTypes;
        }

        var featureTestInput = document.createElement('input');
        supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {
          featureTestInput.setAttribute('type', value);
          return featureTestInput.type === value;
        }));
        return supportedInputTypes;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result of whether the user's browser supports passive event listeners. */


      var supportsPassiveEvents;
      /**
       * Checks whether the user's browser supports passive event listeners.
       * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
       */

      function _supportsPassiveEventListeners() {
        if (supportsPassiveEvents == null && typeof window !== 'undefined') {
          try {
            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
              get: function get() {
                return supportsPassiveEvents = true;
              }
            }));
          } finally {
            supportsPassiveEvents = supportsPassiveEvents || false;
          }
        }

        return supportsPassiveEvents;
      }
      /**
       * Normalizes an `AddEventListener` object to something that can be passed
       * to `addEventListener` on any browser, no matter whether it supports the
       * `options` parameter.
       * @param options Object to be normalized.
       */


      function _normalizePassiveListenerOptions(options) {
        return _supportsPassiveEventListeners() ? options : !!options.capture;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */


      var rtlScrollAxisType;
      /** Cached result of the check that indicates whether the browser supports scroll behaviors. */

      var scrollBehaviorSupported;
      /** Check whether the browser supports scroll behaviors. */

      function _supportsScrollBehavior() {
        if (scrollBehaviorSupported == null) {
          // If we're not in the browser, it can't be supported. Also check for `Element`, because
          // some projects stub out the global `document` during SSR which can throw us off.
          if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {
            scrollBehaviorSupported = false;
            return scrollBehaviorSupported;
          } // If the element can have a `scrollBehavior` style, we can be sure that it's supported.


          if ('scrollBehavior' in document.documentElement.style) {
            scrollBehaviorSupported = true;
          } else {
            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's
            // supported but it doesn't handle scroll behavior, or it has been polyfilled.
            var scrollToFunction = Element.prototype.scrollTo;

            if (scrollToFunction) {
              // We can detect if the function has been polyfilled by calling `toString` on it. Native
              // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get
              // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider
              // polyfilled functions as supporting scroll behavior.
              scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
            } else {
              scrollBehaviorSupported = false;
            }
          }
        }

        return scrollBehaviorSupported;
      }
      /**
       * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,
       * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.
       */


      function _getRtlScrollAxisType() {
        // We can't check unless we're on the browser. Just assume 'normal' if we're not.
        if (typeof document !== 'object' || !document) {
          return 0
          /* NORMAL */
          ;
        }

        if (rtlScrollAxisType == null) {
          // Create a 1px wide scrolling container and a 2px wide content element.
          var scrollContainer = document.createElement('div');
          var containerStyle = scrollContainer.style;
          scrollContainer.dir = 'rtl';
          containerStyle.width = '1px';
          containerStyle.overflow = 'auto';
          containerStyle.visibility = 'hidden';
          containerStyle.pointerEvents = 'none';
          containerStyle.position = 'absolute';
          var content = document.createElement('div');
          var contentStyle = content.style;
          contentStyle.width = '2px';
          contentStyle.height = '1px';
          scrollContainer.appendChild(content);
          document.body.appendChild(scrollContainer);
          rtlScrollAxisType = 0
          /* NORMAL */
          ; // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL
          // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're
          // dealing with one of the other two types of browsers.

          if (scrollContainer.scrollLeft === 0) {
            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an
            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by
            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will
            // return 0 when we read it again.
            scrollContainer.scrollLeft = 1;
            rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? 1
            /* NEGATED */
            : 2
            /* INVERTED */
            ;
          }

          scrollContainer.parentNode.removeChild(scrollContainer);
        }

        return rtlScrollAxisType;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var shadowDomIsSupported;
      /** Checks whether the user's browser support Shadow DOM. */

      function _supportsShadowDom2() {
        if (shadowDomIsSupported == null) {
          var head = typeof document !== 'undefined' ? document.head : null;
          shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
        }

        return shadowDomIsSupported;
      }
      /** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */


      function _getShadowRoot2(element) {
        if (_supportsShadowDom2()) {
          var rootNode = element.getRootNode ? element.getRootNode() : null; // Note that this should be caught by `_supportsShadowDom`, but some
          // teams have been able to hit this code path on unsupported browsers.

          if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {
            return rootNode;
          }
        }

        return null;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    },

    /***/
    39996: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "CdkFixedSizeVirtualScroll": function CdkFixedSizeVirtualScroll() {
          return (
            /* binding */
            _CdkFixedSizeVirtualScroll
          );
        },

        /* harmony export */
        "CdkScrollable": function CdkScrollable() {
          return (
            /* binding */
            _CdkScrollable
          );
        },

        /* harmony export */
        "CdkScrollableModule": function CdkScrollableModule() {
          return (
            /* binding */
            _CdkScrollableModule
          );
        },

        /* harmony export */
        "CdkVirtualForOf": function CdkVirtualForOf() {
          return (
            /* binding */
            _CdkVirtualForOf
          );
        },

        /* harmony export */
        "CdkVirtualScrollViewport": function CdkVirtualScrollViewport() {
          return (
            /* binding */
            _CdkVirtualScrollViewport
          );
        },

        /* harmony export */
        "DEFAULT_RESIZE_TIME": function DEFAULT_RESIZE_TIME() {
          return (
            /* binding */
            _DEFAULT_RESIZE_TIME
          );
        },

        /* harmony export */
        "DEFAULT_SCROLL_TIME": function DEFAULT_SCROLL_TIME() {
          return (
            /* binding */
            _DEFAULT_SCROLL_TIME
          );
        },

        /* harmony export */
        "FixedSizeVirtualScrollStrategy": function FixedSizeVirtualScrollStrategy() {
          return (
            /* binding */
            _FixedSizeVirtualScrollStrategy
          );
        },

        /* harmony export */
        "ScrollDispatcher": function ScrollDispatcher() {
          return (
            /* binding */
            _ScrollDispatcher
          );
        },

        /* harmony export */
        "ScrollingModule": function ScrollingModule() {
          return (
            /* binding */
            _ScrollingModule
          );
        },

        /* harmony export */
        "VIRTUAL_SCROLL_STRATEGY": function VIRTUAL_SCROLL_STRATEGY() {
          return (
            /* binding */
            _VIRTUAL_SCROLL_STRATEGY
          );
        },

        /* harmony export */
        "ViewportRuler": function ViewportRuler() {
          return (
            /* binding */
            _ViewportRuler
          );
        },

        /* harmony export */
        "_fixedSizeVirtualScrollStrategyFactory": function _fixedSizeVirtualScrollStrategyFactory() {
          return (
            /* binding */
            _fixedSizeVirtualScrollStrategyFactory2
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      79933);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_1__);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs/operators */
      92343);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__);
      /* harmony import */


      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/cdk/platform */
      97637);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_3__);
      /* harmony import */


      var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! @angular/cdk/bidi */
      99952);
      /* harmony import */


      var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! @angular/cdk/collections */
      64797);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** The injection token used to specify the virtual scrolling strategy. */


      var _c0 = ["contentWrapper"];
      var _c1 = ["*"];

      var _VIRTUAL_SCROLL_STRATEGY = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('VIRTUAL_SCROLL_STRATEGY');
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Virtual scrolling strategy for lists with items of known fixed size. */


      var _FixedSizeVirtualScrollStrategy = /*#__PURE__*/function () {
        /**
         * @param itemSize The size of the items in the virtually scrolling list.
         * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
         * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
         */
        function _FixedSizeVirtualScrollStrategy(itemSize, minBufferPx, maxBufferPx) {
          _classCallCheck(this, _FixedSizeVirtualScrollStrategy);

          this._scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** @docs-private Implemented as part of VirtualScrollStrategy. */

          this.scrolledIndexChange = this._scrolledIndexChange.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.distinctUntilChanged)());
          /** The attached viewport. */

          this._viewport = null;
          this._itemSize = itemSize;
          this._minBufferPx = minBufferPx;
          this._maxBufferPx = maxBufferPx;
        }
        /**
         * Attaches this scroll strategy to a viewport.
         * @param viewport The viewport to attach this strategy to.
         */


        _createClass(_FixedSizeVirtualScrollStrategy, [{
          key: "attach",
          value: function attach(viewport) {
            this._viewport = viewport;

            this._updateTotalContentSize();

            this._updateRenderedRange();
          }
          /** Detaches this scroll strategy from the currently attached viewport. */

        }, {
          key: "detach",
          value: function detach() {
            this._scrolledIndexChange.complete();

            this._viewport = null;
          }
          /**
           * Update the item size and buffer size.
           * @param itemSize The size of the items in the virtually scrolling list.
           * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
           * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
           */

        }, {
          key: "updateItemAndBufferSize",
          value: function updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
            if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');
            }

            this._itemSize = itemSize;
            this._minBufferPx = minBufferPx;
            this._maxBufferPx = maxBufferPx;

            this._updateTotalContentSize();

            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */

        }, {
          key: "onContentScrolled",
          value: function onContentScrolled() {
            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */

        }, {
          key: "onDataLengthChanged",
          value: function onDataLengthChanged() {
            this._updateTotalContentSize();

            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */

        }, {
          key: "onContentRendered",
          value: function onContentRendered() {}
          /** @docs-private Implemented as part of VirtualScrollStrategy. */

        }, {
          key: "onRenderedOffsetChanged",
          value: function onRenderedOffsetChanged() {}
          /**
           * Scroll to the offset for the given index.
           * @param index The index of the element to scroll to.
           * @param behavior The ScrollBehavior to use when scrolling.
           */

        }, {
          key: "scrollToIndex",
          value: function scrollToIndex(index, behavior) {
            if (this._viewport) {
              this._viewport.scrollToOffset(index * this._itemSize, behavior);
            }
          }
          /** Update the viewport's total content size. */

        }, {
          key: "_updateTotalContentSize",
          value: function _updateTotalContentSize() {
            if (!this._viewport) {
              return;
            }

            this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
          }
          /** Update the viewport's rendered range. */

        }, {
          key: "_updateRenderedRange",
          value: function _updateRenderedRange() {
            if (!this._viewport) {
              return;
            }

            var renderedRange = this._viewport.getRenderedRange();

            var newRange = {
              start: renderedRange.start,
              end: renderedRange.end
            };

            var viewportSize = this._viewport.getViewportSize();

            var dataLength = this._viewport.getDataLength();

            var scrollOffset = this._viewport.measureScrollOffset(); // Prevent NaN as result when dividing by zero.


            var firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0; // If user scrolls to the bottom of the list and data changes to a smaller list

            if (newRange.end > dataLength) {
              // We have to recalculate the first visible index based on new data length and viewport size.
              var maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
              var newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems)); // If first visible index changed we must update scroll offset to handle start/end buffers
              // Current range must also be adjusted to cover the new position (bottom of new list).

              if (firstVisibleIndex != newVisibleIndex) {
                firstVisibleIndex = newVisibleIndex;
                scrollOffset = newVisibleIndex * this._itemSize;
                newRange.start = Math.floor(firstVisibleIndex);
              }

              newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
            }

            var startBuffer = scrollOffset - newRange.start * this._itemSize;

            if (startBuffer < this._minBufferPx && newRange.start != 0) {
              var expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
              newRange.start = Math.max(0, newRange.start - expandStart);
              newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
            } else {
              var endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);

              if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
                var expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);

                if (expandEnd > 0) {
                  newRange.end = Math.min(dataLength, newRange.end + expandEnd);
                  newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
                }
              }
            }

            this._viewport.setRenderedRange(newRange);

            this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);

            this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
          }
        }]);

        return _FixedSizeVirtualScrollStrategy;
      }();
      /**
       * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created
       * `FixedSizeVirtualScrollStrategy` from the given directive.
       * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the
       *     `FixedSizeVirtualScrollStrategy` from.
       */


      function _fixedSizeVirtualScrollStrategyFactory2(fixedSizeDir) {
        return fixedSizeDir._scrollStrategy;
      }
      /** A virtual scroll strategy that supports fixed-size items. */


      var _CdkFixedSizeVirtualScroll = /*#__PURE__*/function () {
        var CdkFixedSizeVirtualScroll = /*#__PURE__*/function () {
          function CdkFixedSizeVirtualScroll() {
            _classCallCheck(this, CdkFixedSizeVirtualScroll);

            this._itemSize = 20;
            this._minBufferPx = 100;
            this._maxBufferPx = 200;
            /** The scroll strategy used by this directive. */

            this._scrollStrategy = new _FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
          }
          /** The size of the items in the list (in pixels). */


          _createClass(CdkFixedSizeVirtualScroll, [{
            key: "itemSize",
            get: function get() {
              return this._itemSize;
            },
            set: function set(value) {
              this._itemSize = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);
            }
            /**
             * The minimum amount of buffer rendered beyond the viewport (in pixels).
             * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
             */

          }, {
            key: "minBufferPx",
            get: function get() {
              return this._minBufferPx;
            },
            set: function set(value) {
              this._minBufferPx = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);
            }
            /**
             * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
             */

          }, {
            key: "maxBufferPx",
            get: function get() {
              return this._maxBufferPx;
            },
            set: function set(value) {
              this._maxBufferPx = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);
            }
          }, {
            key: "ngOnChanges",
            value: function ngOnChanges() {
              this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
            }
          }]);

          return CdkFixedSizeVirtualScroll;
        }();

        CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) {
          return new (t || CdkFixedSizeVirtualScroll)();
        };

        CdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkFixedSizeVirtualScroll,
          selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
          inputs: {
            itemSize: "itemSize",
            minBufferPx: "minBufferPx",
            maxBufferPx: "maxBufferPx"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _VIRTUAL_SCROLL_STRATEGY,
            useFactory: _fixedSizeVirtualScrollStrategyFactory2,
            deps: [(0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
              return CdkFixedSizeVirtualScroll;
            })]
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return CdkFixedSizeVirtualScroll;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Time in ms to throttle the scrolling events by default. */


      var _DEFAULT_SCROLL_TIME = 20;
      /**
       * Service contained all registered Scrollable references and emits an event when any one of the
       * Scrollable references emit a scrolled event.
       */

      var _ScrollDispatcher = /*#__PURE__*/function () {
        var ScrollDispatcher = /*#__PURE__*/function () {
          function ScrollDispatcher(_ngZone, _platform, document) {
            _classCallCheck(this, ScrollDispatcher);

            this._ngZone = _ngZone;
            this._platform = _platform;
            /** Subject for notifying that a registered scrollable reference element has been scrolled. */

            this._scrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            /** Keeps track of the global `scroll` and `resize` subscriptions. */

            this._globalSubscription = null;
            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */

            this._scrolledCount = 0;
            /**
             * Map of all the scrollable references that are registered with the service and their
             * scroll event subscriptions.
             */

            this.scrollContainers = new Map();
            this._document = document;
          }
          /**
           * Registers a scrollable instance with the service and listens for its scrolled events. When the
           * scrollable is scrolled, the service emits the event to its scrolled observable.
           * @param scrollable Scrollable instance to be registered.
           */


          _createClass(ScrollDispatcher, [{
            key: "register",
            value: function register(scrollable) {
              var _this8 = this;

              if (!this.scrollContainers.has(scrollable)) {
                this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(function () {
                  return _this8._scrolled.next(scrollable);
                }));
              }
            }
            /**
             * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
             * @param scrollable Scrollable instance to be deregistered.
             */

          }, {
            key: "deregister",
            value: function deregister(scrollable) {
              var scrollableReference = this.scrollContainers.get(scrollable);

              if (scrollableReference) {
                scrollableReference.unsubscribe();
                this.scrollContainers["delete"](scrollable);
              }
            }
            /**
             * Returns an observable that emits an event whenever any of the registered Scrollable
             * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
             * to override the default "throttle" time.
             *
             * **Note:** in order to avoid hitting change detection for every scroll event,
             * all of the events emitted from this stream will be run outside the Angular zone.
             * If you need to update any data bindings as a result of a scroll event, you have
             * to run the callback using `NgZone.run`.
             */

          }, {
            key: "scrolled",
            value: function scrolled() {
              var _this9 = this;

              var auditTimeInMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DEFAULT_SCROLL_TIME;

              if (!this._platform.isBrowser) {
                return (0, rxjs__WEBPACK_IMPORTED_MODULE_1__.of)();
              }

              return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
                if (!_this9._globalSubscription) {
                  _this9._addGlobalListener();
                } // In the case of a 0ms delay, use an observable without auditTime
                // since it does add a perceptible delay in processing overhead.


                var subscription = auditTimeInMs > 0 ? _this9._scrolled.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(auditTimeInMs)).subscribe(observer) : _this9._scrolled.subscribe(observer);
                _this9._scrolledCount++;
                return function () {
                  subscription.unsubscribe();
                  _this9._scrolledCount--;

                  if (!_this9._scrolledCount) {
                    _this9._removeGlobalListener();
                  }
                };
              });
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              var _this10 = this;

              this._removeGlobalListener();

              this.scrollContainers.forEach(function (_, container) {
                return _this10.deregister(container);
              });

              this._scrolled.complete();
            }
            /**
             * Returns an observable that emits whenever any of the
             * scrollable ancestors of an element are scrolled.
             * @param elementOrElementRef Element whose ancestors to listen for.
             * @param auditTimeInMs Time to throttle the scroll events.
             */

          }, {
            key: "ancestorScrolled",
            value: function ancestorScrolled(elementOrElementRef, auditTimeInMs) {
              var ancestors = this.getAncestorScrollContainers(elementOrElementRef);
              return this.scrolled(auditTimeInMs).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.filter)(function (target) {
                return !target || ancestors.indexOf(target) > -1;
              }));
            }
            /** Returns all registered Scrollables that contain the provided element. */

          }, {
            key: "getAncestorScrollContainers",
            value: function getAncestorScrollContainers(elementOrElementRef) {
              var _this11 = this;

              var scrollingContainers = [];
              this.scrollContainers.forEach(function (_subscription, scrollable) {
                if (_this11._scrollableContainsElement(scrollable, elementOrElementRef)) {
                  scrollingContainers.push(scrollable);
                }
              });
              return scrollingContainers;
            }
            /** Use defaultView of injected document if available or fallback to global window reference */

          }, {
            key: "_getWindow",
            value: function _getWindow() {
              return this._document.defaultView || window;
            }
            /** Returns true if the element is contained within the provided Scrollable. */

          }, {
            key: "_scrollableContainsElement",
            value: function _scrollableContainsElement(scrollable, elementOrElementRef) {
              var element = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceElement)(elementOrElementRef);
              var scrollableElement = scrollable.getElementRef().nativeElement; // Traverse through the element parents until we reach null, checking if any of the elements
              // are the scrollable's element.

              do {
                if (element == scrollableElement) {
                  return true;
                }
              } while (element = element.parentElement);

              return false;
            }
            /** Sets up the global scroll listeners. */

          }, {
            key: "_addGlobalListener",
            value: function _addGlobalListener() {
              var _this12 = this;

              this._globalSubscription = this._ngZone.runOutsideAngular(function () {
                var window = _this12._getWindow();

                return (0, rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window.document, 'scroll').subscribe(function () {
                  return _this12._scrolled.next();
                });
              });
            }
            /** Cleans up the global scroll listener. */

          }, {
            key: "_removeGlobalListener",
            value: function _removeGlobalListener() {
              if (this._globalSubscription) {
                this._globalSubscription.unsubscribe();

                this._globalSubscription = null;
              }
            }
          }]);

          return ScrollDispatcher;
        }();

        ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) {
          return new (t || ScrollDispatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, 8));
        };

        ScrollDispatcher.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function ScrollDispatcher_Factory() {
            return new ScrollDispatcher((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, 8));
          },
          token: ScrollDispatcher,
          providedIn: "root"
        });
        return ScrollDispatcher;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Sends an event when the directive's element is scrolled. Registers itself with the
       * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
       * can be listened to through the service.
       */


      var _CdkScrollable = /*#__PURE__*/function () {
        var CdkScrollable = /*#__PURE__*/function () {
          function CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {
            var _this13 = this;

            _classCallCheck(this, CdkScrollable);

            this.elementRef = elementRef;
            this.scrollDispatcher = scrollDispatcher;
            this.ngZone = ngZone;
            this.dir = dir;
            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            this._elementScrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
              return _this13.ngZone.runOutsideAngular(function () {
                return (0, rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(_this13.elementRef.nativeElement, 'scroll').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(_this13._destroyed)).subscribe(observer);
              });
            });
          }

          _createClass(CdkScrollable, [{
            key: "ngOnInit",
            value: function ngOnInit() {
              this.scrollDispatcher.register(this);
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.scrollDispatcher.deregister(this);

              this._destroyed.next();

              this._destroyed.complete();
            }
            /** Returns observable that emits when a scroll event is fired on the host element. */

          }, {
            key: "elementScrolled",
            value: function elementScrolled() {
              return this._elementScrolled;
            }
            /** Gets the ElementRef for the viewport. */

          }, {
            key: "getElementRef",
            value: function getElementRef() {
              return this.elementRef;
            }
            /**
             * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
             * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
             * left and right always refer to the left and right side of the scrolling container irrespective
             * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
             * in an RTL context.
             * @param options specified the offsets to scroll to.
             */

          }, {
            key: "scrollTo",
            value: function scrollTo(options) {
              var el = this.elementRef.nativeElement;
              var isRtl = this.dir && this.dir.value == 'rtl'; // Rewrite start & end offsets as right or left offsets.

              if (options.left == null) {
                options.left = isRtl ? options.end : options.start;
              }

              if (options.right == null) {
                options.right = isRtl ? options.start : options.end;
              } // Rewrite the bottom offset as a top offset.


              if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
              } // Rewrite the right offset as a left offset.


              if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() != 0
              /* NORMAL */
              ) {
                if (options.left != null) {
                  options.right = el.scrollWidth - el.clientWidth - options.left;
                }

                if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 2
                /* INVERTED */
                ) {
                  options.left = options.right;
                } else if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 1
                /* NEGATED */
                ) {
                  options.left = options.right ? -options.right : options.right;
                }
              } else {
                if (options.right != null) {
                  options.left = el.scrollWidth - el.clientWidth - options.right;
                }
              }

              this._applyScrollToOptions(options);
            }
          }, {
            key: "_applyScrollToOptions",
            value: function _applyScrollToOptions(options) {
              var el = this.elementRef.nativeElement;

              if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.supportsScrollBehavior)()) {
                el.scrollTo(options);
              } else {
                if (options.top != null) {
                  el.scrollTop = options.top;
                }

                if (options.left != null) {
                  el.scrollLeft = options.left;
                }
              }
            }
            /**
             * Measures the scroll offset relative to the specified edge of the viewport. This method can be
             * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
             * about what scrollLeft means in RTL. The values returned by this method are normalized such that
             * left and right always refer to the left and right side of the scrolling container irrespective
             * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
             * in an RTL context.
             * @param from The edge to measure from.
             */

          }, {
            key: "measureScrollOffset",
            value: function measureScrollOffset(from) {
              var LEFT = 'left';
              var RIGHT = 'right';
              var el = this.elementRef.nativeElement;

              if (from == 'top') {
                return el.scrollTop;
              }

              if (from == 'bottom') {
                return el.scrollHeight - el.clientHeight - el.scrollTop;
              } // Rewrite start & end as left or right offsets.


              var isRtl = this.dir && this.dir.value == 'rtl';

              if (from == 'start') {
                from = isRtl ? RIGHT : LEFT;
              } else if (from == 'end') {
                from = isRtl ? LEFT : RIGHT;
              }

              if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 2
              /* INVERTED */
              ) {
                // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and
                // 0 when scrolled all the way right.
                if (from == LEFT) {
                  return el.scrollWidth - el.clientWidth - el.scrollLeft;
                } else {
                  return el.scrollLeft;
                }
              } else if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 1
              /* NEGATED */
              ) {
                // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and
                // 0 when scrolled all the way right.
                if (from == LEFT) {
                  return el.scrollLeft + el.scrollWidth - el.clientWidth;
                } else {
                  return -el.scrollLeft;
                }
              } else {
                // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and
                // (scrollWidth - clientWidth) when scrolled all the way right.
                if (from == LEFT) {
                  return el.scrollLeft;
                } else {
                  return el.scrollWidth - el.clientWidth - el.scrollLeft;
                }
              }
            }
          }]);

          return CdkScrollable;
        }();

        CdkScrollable.ɵfac = function CdkScrollable_Factory(t) {
          return new (t || CdkScrollable)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, 8));
        };

        CdkScrollable.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkScrollable,
          selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
        });
        return CdkScrollable;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Time in ms to throttle the resize events by default. */


      var _DEFAULT_RESIZE_TIME = 20;
      /**
       * Simple utility for getting the bounds of the browser viewport.
       * @docs-private
       */

      var _ViewportRuler = /*#__PURE__*/function () {
        var ViewportRuler = /*#__PURE__*/function () {
          function ViewportRuler(_platform, ngZone, document) {
            var _this14 = this;

            _classCallCheck(this, ViewportRuler);

            this._platform = _platform;
            /** Stream of viewport change events. */

            this._change = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            /** Event listener that will be used to handle the viewport change events. */

            this._changeListener = function (event) {
              _this14._change.next(event);
            };

            this._document = document;
            ngZone.runOutsideAngular(function () {
              if (_platform.isBrowser) {
                var _window = _this14._getWindow(); // Note that bind the events ourselves, rather than going through something like RxJS's
                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.


                _window.addEventListener('resize', _this14._changeListener);

                _window.addEventListener('orientationchange', _this14._changeListener);
              } // We don't need to keep track of the subscription,
              // because we complete the `change` stream on destroy.


              _this14.change().subscribe(function () {
                return _this14._updateViewportSize();
              });
            });
          }

          _createClass(ViewportRuler, [{
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              if (this._platform.isBrowser) {
                var _window2 = this._getWindow();

                _window2.removeEventListener('resize', this._changeListener);

                _window2.removeEventListener('orientationchange', this._changeListener);
              }

              this._change.complete();
            }
            /** Returns the viewport's width and height. */

          }, {
            key: "getViewportSize",
            value: function getViewportSize() {
              if (!this._viewportSize) {
                this._updateViewportSize();
              }

              var output = {
                width: this._viewportSize.width,
                height: this._viewportSize.height
              }; // If we're not on a browser, don't cache the size since it'll be mocked out anyway.

              if (!this._platform.isBrowser) {
                this._viewportSize = null;
              }

              return output;
            }
            /** Gets a ClientRect for the viewport's bounds. */

          }, {
            key: "getViewportRect",
            value: function getViewportRect() {
              // Use the document element's bounding rect rather than the window scroll properties
              // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
              // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
              // conceptual viewports. Under most circumstances these viewports are equivalent, but they
              // can disagree when the page is pinch-zoomed (on devices that support touch).
              // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
              // We use the documentElement instead of the body because, by default (without a css reset)
              // browsers typically give the document body an 8px margin, which is not included in
              // getBoundingClientRect().
              var scrollPosition = this.getViewportScrollPosition();

              var _this$getViewportSize = this.getViewportSize(),
                  width = _this$getViewportSize.width,
                  height = _this$getViewportSize.height;

              return {
                top: scrollPosition.top,
                left: scrollPosition.left,
                bottom: scrollPosition.top + height,
                right: scrollPosition.left + width,
                height: height,
                width: width
              };
            }
            /** Gets the (top, left) scroll position of the viewport. */

          }, {
            key: "getViewportScrollPosition",
            value: function getViewportScrollPosition() {
              // While we can get a reference to the fake document
              // during SSR, it doesn't have getBoundingClientRect.
              if (!this._platform.isBrowser) {
                return {
                  top: 0,
                  left: 0
                };
              } // The top-left-corner of the viewport is determined by the scroll position of the document
              // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
              // whether `document.body` or `document.documentElement` is the scrolled element, so reading
              // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
              // `document.documentElement` works consistently, where the `top` and `left` values will
              // equal negative the scroll position.


              var document = this._document;

              var window = this._getWindow();

              var documentElement = document.documentElement;
              var documentRect = documentElement.getBoundingClientRect();
              var top = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
              var left = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
              return {
                top: top,
                left: left
              };
            }
            /**
             * Returns a stream that emits whenever the size of the viewport changes.
             * @param throttleTime Time in milliseconds to throttle the stream.
             */

          }, {
            key: "change",
            value: function change() {
              var throttleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DEFAULT_RESIZE_TIME;
              return throttleTime > 0 ? this._change.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(throttleTime)) : this._change;
            }
            /** Use defaultView of injected document if available or fallback to global window reference */

          }, {
            key: "_getWindow",
            value: function _getWindow() {
              return this._document.defaultView || window;
            }
            /** Updates the cached viewport size. */

          }, {
            key: "_updateViewportSize",
            value: function _updateViewportSize() {
              var window = this._getWindow();

              this._viewportSize = this._platform.isBrowser ? {
                width: window.innerWidth,
                height: window.innerHeight
              } : {
                width: 0,
                height: 0
              };
            }
          }]);

          return ViewportRuler;
        }();

        ViewportRuler.ɵfac = function ViewportRuler_Factory(t) {
          return new (t || ViewportRuler)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, 8));
        };

        ViewportRuler.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function ViewportRuler_Factory() {
            return new ViewportRuler((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, 8));
          },
          token: ViewportRuler,
          providedIn: "root"
        });
        return ViewportRuler;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Checks if the given ranges are equal. */


      function rangesEqual(r1, r2) {
        return r1.start == r2.start && r1.end == r2.end;
      }
      /**
       * Scheduler to be used for scroll events. Needs to fall back to
       * something that doesn't rely on requestAnimationFrame on environments
       * that don't support it (e.g. server-side rendering).
       */


      var SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? rxjs__WEBPACK_IMPORTED_MODULE_1__.animationFrameScheduler : rxjs__WEBPACK_IMPORTED_MODULE_1__.asapScheduler;
      /** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */

      var _CdkVirtualScrollViewport = /*#__PURE__*/function () {
        var CdkVirtualScrollViewport = /*#__PURE__*/function (_CdkScrollable2) {
          _inherits(CdkVirtualScrollViewport, _CdkScrollable2);

          var _super2 = _createSuper(CdkVirtualScrollViewport);

          function CdkVirtualScrollViewport(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {
            var _this15;

            _classCallCheck(this, CdkVirtualScrollViewport);

            _this15 = _super2.call(this, elementRef, scrollDispatcher, ngZone, dir);
            _this15.elementRef = elementRef;
            _this15._changeDetectorRef = _changeDetectorRef;
            _this15._scrollStrategy = _scrollStrategy;
            /** Emits when the viewport is detached from a CdkVirtualForOf. */

            _this15._detachedSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            /** Emits when the rendered range changes. */

            _this15._renderedRangeSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            _this15._orientation = 'vertical'; // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
            // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
            // depending on how the strategy calculates the scrolled index, it may come at a cost to
            // performance.

            /** Emits when the index of the first element visible in the viewport changes. */

            _this15.scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
              return _this15._scrollStrategy.scrolledIndexChange.subscribe(function (index) {
                return Promise.resolve().then(function () {
                  return _this15.ngZone.run(function () {
                    return observer.next(index);
                  });
                });
              });
            });
            /** A stream that emits whenever the rendered range changes. */

            _this15.renderedRangeStream = _this15._renderedRangeSubject;
            /**
             * The total size of all content (in pixels), including content that is not currently rendered.
             */

            _this15._totalContentSize = 0;
            /** A string representing the `style.width` property value to be used for the spacer element. */

            _this15._totalContentWidth = '';
            /** A string representing the `style.height` property value to be used for the spacer element. */

            _this15._totalContentHeight = '';
            /** The currently rendered range of indices. */

            _this15._renderedRange = {
              start: 0,
              end: 0
            };
            /** The length of the data bound to this viewport (in number of items). */

            _this15._dataLength = 0;
            /** The size of the viewport (in pixels). */

            _this15._viewportSize = 0;
            /** The last rendered content offset that was set. */

            _this15._renderedContentOffset = 0;
            /**
             * Whether the last rendered content offset was to the end of the content (and therefore needs to
             * be rewritten as an offset to the start of the content).
             */

            _this15._renderedContentOffsetNeedsRewrite = false;
            /** Whether there is a pending change detection cycle. */

            _this15._isChangeDetectionPending = false;
            /** A list of functions to run after the next change detection cycle. */

            _this15._runAfterChangeDetection = [];
            /** Subscription to changes in the viewport size. */

            _this15._viewportChanges = rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;

            if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
            }

            _this15._viewportChanges = viewportRuler.change().subscribe(function () {
              _this15.checkViewportSize();
            });
            return _this15;
          }
          /** The direction the viewport scrolls. */


          _createClass(CdkVirtualScrollViewport, [{
            key: "orientation",
            get: function get() {
              return this._orientation;
            },
            set: function set(orientation) {
              if (this._orientation !== orientation) {
                this._orientation = orientation;

                this._calculateSpacerSize();
              }
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              var _this16 = this;

              _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "ngOnInit", this).call(this); // It's still too early to measure the viewport at this point. Deferring with a promise allows
              // the Viewport to be rendered with the correct size before we measure. We run this outside the
              // zone to avoid causing more change detection cycles. We handle the change detection loop
              // ourselves instead.


              this.ngZone.runOutsideAngular(function () {
                return Promise.resolve().then(function () {
                  _this16._measureViewportSize();

                  _this16._scrollStrategy.attach(_this16);

                  _this16.elementScrolled().pipe( // Start off with a fake scroll event so we properly detect our initial position.
                  (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.startWith)(null), // Collect multiple events into one until the next animation frame. This way if
                  // there are multiple scroll events in the same frame we only need to recheck
                  // our layout once.
                  (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(0, SCROLL_SCHEDULER)).subscribe(function () {
                    return _this16._scrollStrategy.onContentScrolled();
                  });

                  _this16._markChangeDetectionNeeded();
                });
              });
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this.detach();

              this._scrollStrategy.detach(); // Complete all subjects


              this._renderedRangeSubject.complete();

              this._detachedSubject.complete();

              this._viewportChanges.unsubscribe();

              _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "ngOnDestroy", this).call(this);
            }
            /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */

          }, {
            key: "attach",
            value: function attach(forOf) {
              var _this17 = this;

              if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw Error('CdkVirtualScrollViewport is already attached.');
              } // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length
              // changes. Run outside the zone to avoid triggering change detection, since we're managing the
              // change detection loop ourselves.


              this.ngZone.runOutsideAngular(function () {
                _this17._forOf = forOf;

                _this17._forOf.dataStream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(_this17._detachedSubject)).subscribe(function (data) {
                  var newLength = data.length;

                  if (newLength !== _this17._dataLength) {
                    _this17._dataLength = newLength;

                    _this17._scrollStrategy.onDataLengthChanged();
                  }

                  _this17._doChangeDetection();
                });
              });
            }
            /** Detaches the current `CdkVirtualForOf`. */

          }, {
            key: "detach",
            value: function detach() {
              this._forOf = null;

              this._detachedSubject.next();
            }
            /** Gets the length of the data bound to this viewport (in number of items). */

          }, {
            key: "getDataLength",
            value: function getDataLength() {
              return this._dataLength;
            }
            /** Gets the size of the viewport (in pixels). */

          }, {
            key: "getViewportSize",
            value: function getViewportSize() {
              return this._viewportSize;
            } // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
            // cycle happens. I'm being careful to only call it after the render cycle is complete and before
            // setting it to something else, but its error prone and should probably be split into
            // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.

            /** Get the current rendered range of items. */

          }, {
            key: "getRenderedRange",
            value: function getRenderedRange() {
              return this._renderedRange;
            }
            /**
             * Sets the total size of all content (in pixels), including content that is not currently
             * rendered.
             */

          }, {
            key: "setTotalContentSize",
            value: function setTotalContentSize(size) {
              if (this._totalContentSize !== size) {
                this._totalContentSize = size;

                this._calculateSpacerSize();

                this._markChangeDetectionNeeded();
              }
            }
            /** Sets the currently rendered range of indices. */

          }, {
            key: "setRenderedRange",
            value: function setRenderedRange(range) {
              var _this18 = this;

              if (!rangesEqual(this._renderedRange, range)) {
                this._renderedRangeSubject.next(this._renderedRange = range);

                this._markChangeDetectionNeeded(function () {
                  return _this18._scrollStrategy.onContentRendered();
                });
              }
            }
            /**
             * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
             */

          }, {
            key: "getOffsetToRenderedContentStart",
            value: function getOffsetToRenderedContentStart() {
              return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
            }
            /**
             * Sets the offset from the start of the viewport to either the start or end of the rendered data
             * (in pixels).
             */

          }, {
            key: "setRenderedContentOffset",
            value: function setRenderedContentOffset(offset) {
              var _this19 = this;

              var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'to-start';
              // For a horizontal viewport in a right-to-left language we need to translate along the x-axis
              // in the negative direction.
              var isRtl = this.dir && this.dir.value == 'rtl';
              var isHorizontal = this.orientation == 'horizontal';
              var axis = isHorizontal ? 'X' : 'Y';
              var axisDirection = isHorizontal && isRtl ? -1 : 1;
              var transform = "translate".concat(axis, "(").concat(Number(axisDirection * offset), "px)");
              this._renderedContentOffset = offset;

              if (to === 'to-end') {
                transform += " translate".concat(axis, "(-100%)"); // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise
                // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would
                // expand upward).

                this._renderedContentOffsetNeedsRewrite = true;
              }

              if (this._renderedContentTransform != transform) {
                // We know this value is safe because we parse `offset` with `Number()` before passing it
                // into the string.
                this._renderedContentTransform = transform;

                this._markChangeDetectionNeeded(function () {
                  if (_this19._renderedContentOffsetNeedsRewrite) {
                    _this19._renderedContentOffset -= _this19.measureRenderedContentSize();
                    _this19._renderedContentOffsetNeedsRewrite = false;

                    _this19.setRenderedContentOffset(_this19._renderedContentOffset);
                  } else {
                    _this19._scrollStrategy.onRenderedOffsetChanged();
                  }
                });
              }
            }
            /**
             * Scrolls to the given offset from the start of the viewport. Please note that this is not always
             * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
             * direction, this would be the equivalent of setting a fictional `scrollRight` property.
             * @param offset The offset to scroll to.
             * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
             */

          }, {
            key: "scrollToOffset",
            value: function scrollToOffset(offset) {
              var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
              var options = {
                behavior: behavior
              };

              if (this.orientation === 'horizontal') {
                options.start = offset;
              } else {
                options.top = offset;
              }

              this.scrollTo(options);
            }
            /**
             * Scrolls to the offset for the given index.
             * @param index The index of the element to scroll to.
             * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
             */

          }, {
            key: "scrollToIndex",
            value: function scrollToIndex(index) {
              var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';

              this._scrollStrategy.scrollToIndex(index, behavior);
            }
            /**
             * Gets the current scroll offset from the start of the viewport (in pixels).
             * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
             *     in horizontal mode.
             */

          }, {
            key: "measureScrollOffset",
            value: function measureScrollOffset(from) {
              return from ? _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "measureScrollOffset", this).call(this, from) : _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "measureScrollOffset", this).call(this, this.orientation === 'horizontal' ? 'start' : 'top');
            }
            /** Measure the combined size of all of the rendered items. */

          }, {
            key: "measureRenderedContentSize",
            value: function measureRenderedContentSize() {
              var contentEl = this._contentWrapper.nativeElement;
              return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;
            }
            /**
             * Measure the total combined size of the given range. Throws if the range includes items that are
             * not rendered.
             */

          }, {
            key: "measureRangeSize",
            value: function measureRangeSize(range) {
              if (!this._forOf) {
                return 0;
              }

              return this._forOf.measureRangeSize(range, this.orientation);
            }
            /** Update the viewport dimensions and re-render. */

          }, {
            key: "checkViewportSize",
            value: function checkViewportSize() {
              // TODO: Cleanup later when add logic for handling content resize
              this._measureViewportSize();

              this._scrollStrategy.onDataLengthChanged();
            }
            /** Measure the viewport size. */

          }, {
            key: "_measureViewportSize",
            value: function _measureViewportSize() {
              var viewportEl = this.elementRef.nativeElement;
              this._viewportSize = this.orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;
            }
            /** Queue up change detection to run. */

          }, {
            key: "_markChangeDetectionNeeded",
            value: function _markChangeDetectionNeeded(runAfter) {
              var _this20 = this;

              if (runAfter) {
                this._runAfterChangeDetection.push(runAfter);
              } // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of
              // properties sequentially we only have to run `_doChangeDetection` once at the end.


              if (!this._isChangeDetectionPending) {
                this._isChangeDetectionPending = true;
                this.ngZone.runOutsideAngular(function () {
                  return Promise.resolve().then(function () {
                    _this20._doChangeDetection();
                  });
                });
              }
            }
            /** Run change detection. */

          }, {
            key: "_doChangeDetection",
            value: function _doChangeDetection() {
              var _this21 = this;

              this._isChangeDetectionPending = false; // Apply the content transform. The transform can't be set via an Angular binding because
              // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of
              // string literals, a variable that can only be 'X' or 'Y', and user input that is run through
              // the `Number` function first to coerce it to a numeric value.

              this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform; // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection
              // from the root, since the repeated items are content projected in. Calling `detectChanges`
              // instead does not properly check the projected content.

              this.ngZone.run(function () {
                return _this21._changeDetectorRef.markForCheck();
              });
              var runAfterChangeDetection = this._runAfterChangeDetection;
              this._runAfterChangeDetection = [];

              var _iterator4 = _createForOfIteratorHelper(runAfterChangeDetection),
                  _step4;

              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var fn = _step4.value;
                  fn();
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
            /** Calculates the `style.width` and `style.height` for the spacer element. */

          }, {
            key: "_calculateSpacerSize",
            value: function _calculateSpacerSize() {
              this._totalContentHeight = this.orientation === 'horizontal' ? '' : "".concat(this._totalContentSize, "px");
              this._totalContentWidth = this.orientation === 'horizontal' ? "".concat(this._totalContentSize, "px") : '';
            }
          }]);

          return CdkVirtualScrollViewport;
        }(_CdkScrollable);

        CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) {
          return new (t || CdkVirtualScrollViewport)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_VIRTUAL_SCROLL_STRATEGY, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ViewportRuler));
        };

        CdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkVirtualScrollViewport,
          selectors: [["cdk-virtual-scroll-viewport"]],
          viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c0, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentWrapper = _t.first);
            }
          },
          hostAttrs: [1, "cdk-virtual-scroll-viewport"],
          hostVars: 4,
          hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
            }
          },
          inputs: {
            orientation: "orientation"
          },
          outputs: {
            scrolledIndexChange: "scrolledIndexChange"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _CdkScrollable,
            useExisting: CdkVirtualScrollViewport
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
          ngContentSelectors: _c1,
          decls: 4,
          vars: 4,
          consts: [[1, "cdk-virtual-scroll-content-wrapper"], ["contentWrapper", ""], [1, "cdk-virtual-scroll-spacer"]],
          template: function CdkVirtualScrollViewport_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0, 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "div", 2);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
            }
          },
          styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\n"],
          encapsulation: 2,
          changeDetection: 0
        });
        return CdkVirtualScrollViewport;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Helper to extract the offset of a DOM Node in a certain direction. */


      function getOffset(orientation, direction, node) {
        var el = node;

        if (!el.getBoundingClientRect) {
          return 0;
        }

        var rect = el.getBoundingClientRect();

        if (orientation === 'horizontal') {
          return direction === 'start' ? rect.left : rect.right;
        }

        return direction === 'start' ? rect.top : rect.bottom;
      }
      /**
       * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling
       * container.
       */


      var _CdkVirtualForOf = /*#__PURE__*/function () {
        var CdkVirtualForOf = /*#__PURE__*/function () {
          function CdkVirtualForOf(
          /** The view container to add items to. */
          _viewContainerRef,
          /** The template to use when stamping out new items. */
          _template,
          /** The set of available differs. */
          _differs,
          /** The strategy used to render items in the virtual scroll viewport. */
          _viewRepeater,
          /** The virtual scrolling viewport that these items are being rendered in. */
          _viewport, ngZone) {
            var _this22 = this;

            _classCallCheck(this, CdkVirtualForOf);

            this._viewContainerRef = _viewContainerRef;
            this._template = _template;
            this._differs = _differs;
            this._viewRepeater = _viewRepeater;
            this._viewport = _viewport;
            /** Emits when the rendered view of the data changes. */

            this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            /** Subject that emits when a new DataSource instance is given. */

            this._dataSourceChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            /** Emits whenever the data in the current DataSource changes. */

            this.dataStream = this._dataSourceChanges.pipe( // Start off with null `DataSource`.
            (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.startWith)(null), // Bundle up the previous and current data sources so we can work with both.
            (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.pairwise)(), // Use `_changeDataSource` to disconnect from the previous data source and connect to the
            // new one, passing back a stream of data changes which we run through `switchMap` to give
            // us a data stream that emits the latest data from whatever the current `DataSource` is.
            (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.switchMap)(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  prev = _ref2[0],
                  cur = _ref2[1];

              return _this22._changeDataSource(prev, cur);
            }), // Replay the last emitted data when someone subscribes.
            (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.shareReplay)(1));
            /** The differ used to calculate changes to the data. */

            this._differ = null;
            /** Whether the rendered data should be updated during the next ngDoCheck cycle. */

            this._needsUpdate = false;
            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
            this.dataStream.subscribe(function (data) {
              _this22._data = data;

              _this22._onRenderedDataChange();
            });

            this._viewport.renderedRangeStream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._destroyed)).subscribe(function (range) {
              _this22._renderedRange = range;
              ngZone.run(function () {
                return _this22.viewChange.next(_this22._renderedRange);
              });

              _this22._onRenderedDataChange();
            });

            this._viewport.attach(this);
          }
          /** The DataSource to display. */


          _createClass(CdkVirtualForOf, [{
            key: "cdkVirtualForOf",
            get: function get() {
              return this._cdkVirtualForOf;
            },
            set: function set(value) {
              this._cdkVirtualForOf = value;

              if ((0, _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__.isDataSource)(value)) {
                this._dataSourceChanges.next(value);
              } else {
                // If value is an an NgIterable, convert it to an array.
                this._dataSourceChanges.next(new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__.ArrayDataSource((0, rxjs__WEBPACK_IMPORTED_MODULE_1__.isObservable)(value) ? value : Array.from(value || [])));
              }
            }
            /**
             * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
             * the item and produces a value to be used as the item's identity when tracking changes.
             */

          }, {
            key: "cdkVirtualForTrackBy",
            get: function get() {
              return this._cdkVirtualForTrackBy;
            },
            set: function set(fn) {
              var _this23 = this;

              this._needsUpdate = true;
              this._cdkVirtualForTrackBy = fn ? function (index, item) {
                return fn(index + (_this23._renderedRange ? _this23._renderedRange.start : 0), item);
              } : undefined;
            }
            /** The template used to stamp out new elements. */

          }, {
            key: "cdkVirtualForTemplate",
            set: function set(value) {
              if (value) {
                this._needsUpdate = true;
                this._template = value;
              }
            }
            /**
             * The size of the cache used to store templates that are not being used for re-use later.
             * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
             */

          }, {
            key: "cdkVirtualForTemplateCacheSize",
            get: function get() {
              return this._viewRepeater.viewCacheSize;
            },
            set: function set(size) {
              this._viewRepeater.viewCacheSize = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(size);
            }
            /**
             * Measures the combined size (width for horizontal orientation, height for vertical) of all items
             * in the specified range. Throws an error if the range includes items that are not currently
             * rendered.
             */

          }, {
            key: "measureRangeSize",
            value: function measureRangeSize(range, orientation) {
              if (range.start >= range.end) {
                return 0;
              }

              if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw Error("Error: attempted to measure an item that isn't rendered.");
              } // The index into the list of rendered views for the first item in the range.


              var renderedStartIndex = range.start - this._renderedRange.start; // The length of the range we're measuring.

              var rangeLen = range.end - range.start; // Loop over all the views, find the first and land node and compute the size by subtracting
              // the top of the first node from the bottom of the last one.

              var firstNode;
              var lastNode; // Find the first node by starting from the beginning and going forwards.

              for (var i = 0; i < rangeLen; i++) {
                var view = this._viewContainerRef.get(i + renderedStartIndex);

                if (view && view.rootNodes.length) {
                  firstNode = lastNode = view.rootNodes[0];
                  break;
                }
              } // Find the last node by starting from the end and going backwards.


              for (var _i2 = rangeLen - 1; _i2 > -1; _i2--) {
                var _view = this._viewContainerRef.get(_i2 + renderedStartIndex);

                if (_view && _view.rootNodes.length) {
                  lastNode = _view.rootNodes[_view.rootNodes.length - 1];
                  break;
                }
              }

              return firstNode && lastNode ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;
            }
          }, {
            key: "ngDoCheck",
            value: function ngDoCheck() {
              if (this._differ && this._needsUpdate) {
                // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of
                // this list being rendered (can use simpler algorithm) vs needs update due to data actually
                // changing (need to do this diff).
                var changes = this._differ.diff(this._renderedItems);

                if (!changes) {
                  this._updateContext();
                } else {
                  this._applyChanges(changes);
                }

                this._needsUpdate = false;
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._viewport.detach();

              this._dataSourceChanges.next(undefined);

              this._dataSourceChanges.complete();

              this.viewChange.complete();

              this._destroyed.next();

              this._destroyed.complete();

              this._viewRepeater.detach();
            }
            /** React to scroll state changes in the viewport. */

          }, {
            key: "_onRenderedDataChange",
            value: function _onRenderedDataChange() {
              var _this24 = this;

              if (!this._renderedRange) {
                return;
              }

              this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);

              if (!this._differ) {
                // Use a wrapper function for the `trackBy` so any new values are
                // picked up automatically without having to recreate the differ.
                this._differ = this._differs.find(this._renderedItems).create(function (index, item) {
                  return _this24.cdkVirtualForTrackBy ? _this24.cdkVirtualForTrackBy(index, item) : item;
                });
              }

              this._needsUpdate = true;
            }
            /** Swap out one `DataSource` for another. */

          }, {
            key: "_changeDataSource",
            value: function _changeDataSource(oldDs, newDs) {
              if (oldDs) {
                oldDs.disconnect(this);
              }

              this._needsUpdate = true;
              return newDs ? newDs.connect(this) : (0, rxjs__WEBPACK_IMPORTED_MODULE_1__.of)();
            }
            /** Update the `CdkVirtualForOfContext` for all views. */

          }, {
            key: "_updateContext",
            value: function _updateContext() {
              var count = this._data.length;
              var i = this._viewContainerRef.length;

              while (i--) {
                var view = this._viewContainerRef.get(i);

                view.context.index = this._renderedRange.start + i;
                view.context.count = count;

                this._updateComputedContextProperties(view.context);

                view.detectChanges();
              }
            }
            /** Apply changes to the DOM. */

          }, {
            key: "_applyChanges",
            value: function _applyChanges(changes) {
              var _this25 = this;

              this._viewRepeater.applyChanges(changes, this._viewContainerRef, function (record, _adjustedPreviousIndex, currentIndex) {
                return _this25._getEmbeddedViewArgs(record, currentIndex);
              }, function (record) {
                return record.item;
              }); // Update $implicit for any items that had an identity change.


              changes.forEachIdentityChange(function (record) {
                var view = _this25._viewContainerRef.get(record.currentIndex);

                view.context.$implicit = record.item;
              }); // Update the context variables on all items.

              var count = this._data.length;
              var i = this._viewContainerRef.length;

              while (i--) {
                var view = this._viewContainerRef.get(i);

                view.context.index = this._renderedRange.start + i;
                view.context.count = count;

                this._updateComputedContextProperties(view.context);
              }
            }
            /** Update the computed properties on the `CdkVirtualForOfContext`. */

          }, {
            key: "_updateComputedContextProperties",
            value: function _updateComputedContextProperties(context) {
              context.first = context.index === 0;
              context.last = context.index === context.count - 1;
              context.even = context.index % 2 === 0;
              context.odd = !context.even;
            }
          }, {
            key: "_getEmbeddedViewArgs",
            value: function _getEmbeddedViewArgs(record, index) {
              // Note that it's important that we insert the item directly at the proper index,
              // rather than inserting it and the moving it in place, because if there's a directive
              // on the same node that injects the `ViewContainerRef`, Angular will insert another
              // comment node which can throw off the move when it's being repeated for all items.
              return {
                templateRef: this._template,
                context: {
                  $implicit: record.item,
                  // It's guaranteed that the iterable is not "undefined" or "null" because we only
                  // generate views for elements if the "cdkVirtualForOf" iterable has elements.
                  cdkVirtualForOf: this._cdkVirtualForOf,
                  index: -1,
                  count: -1,
                  first: false,
                  last: false,
                  odd: false,
                  even: false
                },
                index: index
              };
            }
          }]);

          return CdkVirtualForOf;
        }();

        CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) {
          return new (t || CdkVirtualForOf)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkVirtualScrollViewport, 4), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        CdkVirtualForOf.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkVirtualForOf,
          selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
          inputs: {
            cdkVirtualForOf: "cdkVirtualForOf",
            cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
            cdkVirtualForTemplate: "cdkVirtualForTemplate",
            cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY,
            useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._RecycleViewRepeaterStrategy
          }])]
        });
        return CdkVirtualForOf;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _CdkScrollableModule = /*#__PURE__*/function () {
        var CdkScrollableModule = function CdkScrollableModule() {
          _classCallCheck(this, CdkScrollableModule);
        };

        CdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) {
          return new (t || CdkScrollableModule)();
        };

        CdkScrollableModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: CdkScrollableModule
        });
        CdkScrollableModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
        return CdkScrollableModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_CdkScrollableModule, {
          declarations: [_CdkScrollable],
          exports: [_CdkScrollable]
        });
      })();
      /**
       * @docs-primary-export
       */


      var _ScrollingModule = /*#__PURE__*/function () {
        var ScrollingModule = function ScrollingModule() {
          _classCallCheck(this, ScrollingModule);
        };

        ScrollingModule.ɵfac = function ScrollingModule_Factory(t) {
          return new (t || ScrollingModule)();
        };

        ScrollingModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: ScrollingModule
        });
        ScrollingModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.PlatformModule, _CdkScrollableModule], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, _CdkScrollableModule]
        });
        return ScrollingModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_ScrollingModule, {
          declarations: function declarations() {
            return [_CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport];
          },
          imports: function imports() {
            return [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.PlatformModule, _CdkScrollableModule];
          },
          exports: function exports() {
            return [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, _CdkScrollableModule, _CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport];
          }
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    },

    /***/
    59251: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "DataSource": function DataSource() {
          return (
            /* reexport safe */
            _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__.DataSource
          );
        },

        /* harmony export */
        "BaseCdkCell": function BaseCdkCell() {
          return (
            /* binding */
            _BaseCdkCell
          );
        },

        /* harmony export */
        "BaseRowDef": function BaseRowDef() {
          return (
            /* binding */
            _BaseRowDef
          );
        },

        /* harmony export */
        "CDK_ROW_TEMPLATE": function CDK_ROW_TEMPLATE() {
          return (
            /* binding */
            _CDK_ROW_TEMPLATE
          );
        },

        /* harmony export */
        "CDK_TABLE": function CDK_TABLE() {
          return (
            /* binding */
            _CDK_TABLE
          );
        },

        /* harmony export */
        "CDK_TABLE_TEMPLATE": function CDK_TABLE_TEMPLATE() {
          return (
            /* binding */
            _CDK_TABLE_TEMPLATE
          );
        },

        /* harmony export */
        "CdkCell": function CdkCell() {
          return (
            /* binding */
            _CdkCell
          );
        },

        /* harmony export */
        "CdkCellDef": function CdkCellDef() {
          return (
            /* binding */
            _CdkCellDef
          );
        },

        /* harmony export */
        "CdkCellOutlet": function CdkCellOutlet() {
          return (
            /* binding */
            _CdkCellOutlet
          );
        },

        /* harmony export */
        "CdkColumnDef": function CdkColumnDef() {
          return (
            /* binding */
            _CdkColumnDef
          );
        },

        /* harmony export */
        "CdkFooterCell": function CdkFooterCell() {
          return (
            /* binding */
            _CdkFooterCell
          );
        },

        /* harmony export */
        "CdkFooterCellDef": function CdkFooterCellDef() {
          return (
            /* binding */
            _CdkFooterCellDef
          );
        },

        /* harmony export */
        "CdkFooterRow": function CdkFooterRow() {
          return (
            /* binding */
            _CdkFooterRow
          );
        },

        /* harmony export */
        "CdkFooterRowDef": function CdkFooterRowDef() {
          return (
            /* binding */
            _CdkFooterRowDef
          );
        },

        /* harmony export */
        "CdkHeaderCell": function CdkHeaderCell() {
          return (
            /* binding */
            _CdkHeaderCell
          );
        },

        /* harmony export */
        "CdkHeaderCellDef": function CdkHeaderCellDef() {
          return (
            /* binding */
            _CdkHeaderCellDef
          );
        },

        /* harmony export */
        "CdkHeaderRow": function CdkHeaderRow() {
          return (
            /* binding */
            _CdkHeaderRow
          );
        },

        /* harmony export */
        "CdkHeaderRowDef": function CdkHeaderRowDef() {
          return (
            /* binding */
            _CdkHeaderRowDef
          );
        },

        /* harmony export */
        "CdkNoDataRow": function CdkNoDataRow() {
          return (
            /* binding */
            _CdkNoDataRow
          );
        },

        /* harmony export */
        "CdkRow": function CdkRow() {
          return (
            /* binding */
            _CdkRow
          );
        },

        /* harmony export */
        "CdkRowDef": function CdkRowDef() {
          return (
            /* binding */
            _CdkRowDef
          );
        },

        /* harmony export */
        "CdkTable": function CdkTable() {
          return (
            /* binding */
            _CdkTable
          );
        },

        /* harmony export */
        "CdkTableModule": function CdkTableModule() {
          return (
            /* binding */
            _CdkTableModule
          );
        },

        /* harmony export */
        "CdkTextColumn": function CdkTextColumn() {
          return (
            /* binding */
            _CdkTextColumn
          );
        },

        /* harmony export */
        "DataRowOutlet": function DataRowOutlet() {
          return (
            /* binding */
            _DataRowOutlet
          );
        },

        /* harmony export */
        "FooterRowOutlet": function FooterRowOutlet() {
          return (
            /* binding */
            _FooterRowOutlet
          );
        },

        /* harmony export */
        "HeaderRowOutlet": function HeaderRowOutlet() {
          return (
            /* binding */
            _HeaderRowOutlet
          );
        },

        /* harmony export */
        "NoDataRowOutlet": function NoDataRowOutlet() {
          return (
            /* binding */
            _NoDataRowOutlet
          );
        },

        /* harmony export */
        "STICKY_DIRECTIONS": function STICKY_DIRECTIONS() {
          return (
            /* binding */
            _STICKY_DIRECTIONS
          );
        },

        /* harmony export */
        "STICKY_POSITIONING_LISTENER": function STICKY_POSITIONING_LISTENER() {
          return (
            /* binding */
            _STICKY_POSITIONING_LISTENER
          );
        },

        /* harmony export */
        "StickyStyler": function StickyStyler() {
          return (
            /* binding */
            _StickyStyler
          );
        },

        /* harmony export */
        "TEXT_COLUMN_OPTIONS": function TEXT_COLUMN_OPTIONS() {
          return (
            /* binding */
            _TEXT_COLUMN_OPTIONS
          );
        },

        /* harmony export */
        "_COALESCED_STYLE_SCHEDULER": function _COALESCED_STYLE_SCHEDULER() {
          return (
            /* binding */
            _COALESCED_STYLE_SCHEDULER2
          );
        },

        /* harmony export */
        "_CoalescedStyleScheduler": function _CoalescedStyleScheduler() {
          return (
            /* binding */
            _CoalescedStyleScheduler2
          );
        },

        /* harmony export */
        "_Schedule": function _Schedule() {
          return (
            /* binding */
            _Schedule2
          );
        },

        /* harmony export */
        "mixinHasStickyInput": function mixinHasStickyInput() {
          return (
            /* binding */
            _mixinHasStickyInput
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      79933);
      /* harmony import */


      var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/cdk/collections */
      64797);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! @angular/cdk/bidi */
      99952);
      /* harmony import */


      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! @angular/cdk/platform */
      97637);
      /* harmony import */


      var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! @angular/cdk/scrolling */
      39996);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_2__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_3__);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! rxjs/operators */
      92343);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__);

      var _c0 = [[["caption"]], [["colgroup"], ["col"]]];
      var _c1 = ["caption", "colgroup, col"];

      function CdkTextColumn_th_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("text-align", ctx_r0.justify);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r0.headerText, " ");
        }
      }

      function CdkTextColumn_td_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var data_r2 = ctx.$implicit;

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("text-align", ctx_r1.justify);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r1.dataAccessor(data_r2, ctx_r1.name), " ");
        }
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Mixin to provide a directive with a function that checks if the sticky input has been
       * changed since the last time the function was called. Essentially adds a dirty-check to the
       * sticky value.
       * @docs-private
       */


      function _mixinHasStickyInput(base) {
        return /*#__PURE__*/function (_base) {
          _inherits(_class, _base);

          var _super3 = _createSuper(_class);

          function _class() {
            var _this26;

            _classCallCheck(this, _class);

            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            _this26 = _super3.call.apply(_super3, [this].concat(args));
            _this26._sticky = false;
            /** Whether the sticky input has changed since it was last checked. */

            _this26._hasStickyChanged = false;
            return _this26;
          }
          /** Whether sticky positioning should be applied. */


          _createClass(_class, [{
            key: "sticky",
            get: function get() {
              return this._sticky;
            },
            set: function set(v) {
              var prevValue = this._sticky;
              this._sticky = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);
              this._hasStickyChanged = prevValue !== this._sticky;
            }
            /** Whether the sticky value has changed since this was last called. */

          }, {
            key: "hasStickyChanged",
            value: function hasStickyChanged() {
              var hasStickyChanged = this._hasStickyChanged;
              this._hasStickyChanged = false;
              return hasStickyChanged;
            }
            /** Resets the dirty check for cases where the sticky state has been used without checking. */

          }, {
            key: "resetStickyChanged",
            value: function resetStickyChanged() {
              this._hasStickyChanged = false;
            }
          }]);

          return _class;
        }(base);
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Used to provide a table to some of the sub-components without causing a circular dependency.
       * @docs-private
       */


      var _CDK_TABLE = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('CDK_TABLE');
      /** Injection token that can be used to specify the text column options. */


      var _TEXT_COLUMN_OPTIONS = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('text-column-options');
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Cell definition for a CDK table.
       * Captures the template of a column's data row cell as well as cell-specific properties.
       */


      var _CdkCellDef = /*#__PURE__*/function () {
        var CdkCellDef = function CdkCellDef(
        /** @docs-private */
        template) {
          _classCallCheck(this, CdkCellDef);

          this.template = template;
        };

        CdkCellDef.ɵfac = function CdkCellDef_Factory(t) {
          return new (t || CdkCellDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        CdkCellDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkCellDef,
          selectors: [["", "cdkCellDef", ""]]
        });
        return CdkCellDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Header cell definition for a CDK table.
       * Captures the template of a column's header cell and as well as cell-specific properties.
       */


      var _CdkHeaderCellDef = /*#__PURE__*/function () {
        var CdkHeaderCellDef = function CdkHeaderCellDef(
        /** @docs-private */
        template) {
          _classCallCheck(this, CdkHeaderCellDef);

          this.template = template;
        };

        CdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) {
          return new (t || CdkHeaderCellDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        CdkHeaderCellDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkHeaderCellDef,
          selectors: [["", "cdkHeaderCellDef", ""]]
        });
        return CdkHeaderCellDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Footer cell definition for a CDK table.
       * Captures the template of a column's footer cell and as well as cell-specific properties.
       */


      var _CdkFooterCellDef = /*#__PURE__*/function () {
        var CdkFooterCellDef = function CdkFooterCellDef(
        /** @docs-private */
        template) {
          _classCallCheck(this, CdkFooterCellDef);

          this.template = template;
        };

        CdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) {
          return new (t || CdkFooterCellDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        CdkFooterCellDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkFooterCellDef,
          selectors: [["", "cdkFooterCellDef", ""]]
        });
        return CdkFooterCellDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })(); // Boilerplate for applying mixins to CdkColumnDef.

      /** @docs-private */


      var CdkColumnDefBase = function CdkColumnDefBase() {
        _classCallCheck(this, CdkColumnDefBase);
      };

      var _CdkColumnDefBase = /*#__PURE__*/_mixinHasStickyInput(CdkColumnDefBase);
      /**
       * Column definition for the CDK table.
       * Defines a set of cells available for a table column.
       */


      var _CdkColumnDef = /*#__PURE__*/function () {
        var CdkColumnDef = /*#__PURE__*/function (_CdkColumnDefBase2) {
          _inherits(CdkColumnDef, _CdkColumnDefBase2);

          var _super4 = _createSuper(CdkColumnDef);

          function CdkColumnDef(_table) {
            var _this27;

            _classCallCheck(this, CdkColumnDef);

            _this27 = _super4.call(this);
            _this27._table = _table;
            _this27._stickyEnd = false;
            return _this27;
          }
          /** Unique name for this column. */


          _createClass(CdkColumnDef, [{
            key: "name",
            get: function get() {
              return this._name;
            },
            set: function set(name) {
              this._setNameInput(name);
            }
            /**
             * Whether this column should be sticky positioned on the end of the row. Should make sure
             * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
             * has been changed.
             */

          }, {
            key: "stickyEnd",
            get: function get() {
              return this._stickyEnd;
            },
            set: function set(v) {
              var prevValue = this._stickyEnd;
              this._stickyEnd = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);
              this._hasStickyChanged = prevValue !== this._stickyEnd;
            }
            /**
             * Overridable method that sets the css classes that will be added to every cell in this
             * column.
             * In the future, columnCssClassName will change from type string[] to string and this
             * will set a single string value.
             * @docs-private
             */

          }, {
            key: "_updateColumnCssClassName",
            value: function _updateColumnCssClassName() {
              this._columnCssClassName = ["cdk-column-".concat(this.cssClassFriendlyName)];
            }
            /**
             * This has been extracted to a util because of TS 4 and VE.
             * View Engine doesn't support property rename inheritance.
             * TS 4.0 doesn't allow properties to override accessors or vice-versa.
             * @docs-private
             */

          }, {
            key: "_setNameInput",
            value: function _setNameInput(value) {
              // If the directive is set without a name (updated programmatically), then this setter will
              // trigger with an empty string and should not overwrite the programmatically set value.
              if (value) {
                this._name = value;
                this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/ig, '-');

                this._updateColumnCssClassName();
              }
            }
          }]);

          return CdkColumnDef;
        }(_CdkColumnDefBase);

        CdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) {
          return new (t || CdkColumnDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CDK_TABLE, 8));
        };

        CdkColumnDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkColumnDef,
          selectors: [["", "cdkColumnDef", ""]],
          contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkCellDef, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkHeaderCellDef, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkFooterCellDef, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.cell = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.headerCell = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.footerCell = _t.first);
            }
          },
          inputs: {
            sticky: "sticky",
            name: ["cdkColumnDef", "name"],
            stickyEnd: "stickyEnd"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: 'MAT_SORT_HEADER_COLUMN_DEF',
            useExisting: CdkColumnDef
          }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return CdkColumnDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */


      var _BaseCdkCell = function _BaseCdkCell(columnDef, elementRef) {
        _classCallCheck(this, _BaseCdkCell);

        // If IE 11 is dropped before we switch to setting a single class name, change to multi param
        // with destructuring.
        var classList = elementRef.nativeElement.classList;

        var _iterator5 = _createForOfIteratorHelper(columnDef._columnCssClassName),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var className = _step5.value;
            classList.add(className);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };
      /** Header cell template container that adds the right classes and role. */


      var _CdkHeaderCell = /*#__PURE__*/function () {
        var CdkHeaderCell = /*#__PURE__*/function (_BaseCdkCell2) {
          _inherits(CdkHeaderCell, _BaseCdkCell2);

          var _super5 = _createSuper(CdkHeaderCell);

          function CdkHeaderCell(columnDef, elementRef) {
            _classCallCheck(this, CdkHeaderCell);

            return _super5.call(this, columnDef, elementRef);
          }

          return CdkHeaderCell;
        }(_BaseCdkCell);

        CdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) {
          return new (t || CdkHeaderCell)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkColumnDef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        CdkHeaderCell.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkHeaderCell,
          selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]],
          hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return CdkHeaderCell;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Footer cell template container that adds the right classes and role. */


      var _CdkFooterCell = /*#__PURE__*/function () {
        var CdkFooterCell = /*#__PURE__*/function (_BaseCdkCell3) {
          _inherits(CdkFooterCell, _BaseCdkCell3);

          var _super6 = _createSuper(CdkFooterCell);

          function CdkFooterCell(columnDef, elementRef) {
            _classCallCheck(this, CdkFooterCell);

            return _super6.call(this, columnDef, elementRef);
          }

          return CdkFooterCell;
        }(_BaseCdkCell);

        CdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) {
          return new (t || CdkFooterCell)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkColumnDef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        CdkFooterCell.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkFooterCell,
          selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]],
          hostAttrs: ["role", "gridcell", 1, "cdk-footer-cell"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return CdkFooterCell;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Cell template container that adds the right classes and role. */


      var _CdkCell = /*#__PURE__*/function () {
        var CdkCell = /*#__PURE__*/function (_BaseCdkCell4) {
          _inherits(CdkCell, _BaseCdkCell4);

          var _super7 = _createSuper(CdkCell);

          function CdkCell(columnDef, elementRef) {
            _classCallCheck(this, CdkCell);

            return _super7.call(this, columnDef, elementRef);
          }

          return CdkCell;
        }(_BaseCdkCell);

        CdkCell.ɵfac = function CdkCell_Factory(t) {
          return new (t || CdkCell)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkColumnDef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        CdkCell.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkCell,
          selectors: [["cdk-cell"], ["td", "cdk-cell", ""]],
          hostAttrs: ["role", "gridcell", 1, "cdk-cell"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return CdkCell;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @docs-private
       */


      var _Schedule2 = function _Schedule2() {
        _classCallCheck(this, _Schedule2);

        this.tasks = [];
        this.endTasks = [];
      };
      /** Injection token used to provide a coalesced style scheduler. */


      var _COALESCED_STYLE_SCHEDULER2 = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('_COALESCED_STYLE_SCHEDULER');
      /**
       * Allows grouping up CSSDom mutations after the current execution context.
       * This can significantly improve performance when separate consecutive functions are
       * reading from the CSSDom and then mutating it.
       *
       * @docs-private
       */


      var _CoalescedStyleScheduler2 = /*#__PURE__*/function () {
        var _CoalescedStyleScheduler = /*#__PURE__*/function () {
          function _CoalescedStyleScheduler(_ngZone) {
            _classCallCheck(this, _CoalescedStyleScheduler);

            this._ngZone = _ngZone;
            this._currentSchedule = null;
            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
          }
          /**
           * Schedules the specified task to run at the end of the current VM turn.
           */


          _createClass(_CoalescedStyleScheduler, [{
            key: "schedule",
            value: function schedule(task) {
              this._createScheduleIfNeeded();

              this._currentSchedule.tasks.push(task);
            }
            /**
             * Schedules the specified task to run after other scheduled tasks at the end of the current
             * VM turn.
             */

          }, {
            key: "scheduleEnd",
            value: function scheduleEnd(task) {
              this._createScheduleIfNeeded();

              this._currentSchedule.endTasks.push(task);
            }
            /** Prevent any further tasks from running. */

          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._destroyed.next();

              this._destroyed.complete();
            }
          }, {
            key: "_createScheduleIfNeeded",
            value: function _createScheduleIfNeeded() {
              var _this28 = this;

              if (this._currentSchedule) {
                return;
              }

              this._currentSchedule = new _Schedule2();

              this._getScheduleObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._destroyed)).subscribe(function () {
                while (_this28._currentSchedule.tasks.length || _this28._currentSchedule.endTasks.length) {
                  var schedule = _this28._currentSchedule; // Capture new tasks scheduled by the current set of tasks.

                  _this28._currentSchedule = new _Schedule2();

                  var _iterator6 = _createForOfIteratorHelper(schedule.tasks),
                      _step6;

                  try {
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                      var task = _step6.value;
                      task();
                    }
                  } catch (err) {
                    _iterator6.e(err);
                  } finally {
                    _iterator6.f();
                  }

                  var _iterator7 = _createForOfIteratorHelper(schedule.endTasks),
                      _step7;

                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                      var _task = _step7.value;

                      _task();
                    }
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                }

                _this28._currentSchedule = null;
              });
            }
          }, {
            key: "_getScheduleObservable",
            value: function _getScheduleObservable() {
              // Use onStable when in the context of an ongoing change detection cycle so that we
              // do not accidentally trigger additional cycles.
              return this._ngZone.isStable ? (0, rxjs__WEBPACK_IMPORTED_MODULE_3__.from)(Promise.resolve(undefined)) : this._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.take)(1));
            }
          }]);

          return _CoalescedStyleScheduler;
        }();

        _CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) {
          return new (t || _CoalescedStyleScheduler)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        _CoalescedStyleScheduler.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: _CoalescedStyleScheduler,
          factory: _CoalescedStyleScheduler.ɵfac
        });
        return _CoalescedStyleScheduler;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * The row template that can be used by the mat-table. Should not be used outside of the
       * material library.
       */


      var _CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
      /**
       * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
       * for changes and notifying the table.
       */

      var _BaseRowDef = /*#__PURE__*/function () {
        var BaseRowDef = /*#__PURE__*/function () {
          function BaseRowDef(
          /** @docs-private */
          template, _differs) {
            _classCallCheck(this, BaseRowDef);

            this.template = template;
            this._differs = _differs;
          }

          _createClass(BaseRowDef, [{
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              // Create a new columns differ if one does not yet exist. Initialize it based on initial value
              // of the columns property or an empty array if none is provided.
              if (!this._columnsDiffer) {
                var columns = changes['columns'] && changes['columns'].currentValue || [];
                this._columnsDiffer = this._differs.find(columns).create();

                this._columnsDiffer.diff(columns);
              }
            }
            /**
             * Returns the difference between the current columns and the columns from the last diff, or null
             * if there is no difference.
             */

          }, {
            key: "getColumnsDiff",
            value: function getColumnsDiff() {
              return this._columnsDiffer.diff(this.columns);
            }
            /** Gets this row def's relevant cell template from the provided column def. */

          }, {
            key: "extractCellTemplate",
            value: function extractCellTemplate(column) {
              if (this instanceof _CdkHeaderRowDef) {
                return column.headerCell.template;
              }

              if (this instanceof _CdkFooterRowDef) {
                return column.footerCell.template;
              } else {
                return column.cell.template;
              }
            }
          }]);

          return BaseRowDef;
        }();

        BaseRowDef.ɵfac = function BaseRowDef_Factory(t) {
          return new (t || BaseRowDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers));
        };

        BaseRowDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: BaseRowDef,
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return BaseRowDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })(); // Boilerplate for applying mixins to CdkHeaderRowDef.

      /** @docs-private */


      var CdkHeaderRowDefBase = /*#__PURE__*/function (_BaseRowDef2) {
        _inherits(CdkHeaderRowDefBase, _BaseRowDef2);

        var _super8 = _createSuper(CdkHeaderRowDefBase);

        function CdkHeaderRowDefBase() {
          _classCallCheck(this, CdkHeaderRowDefBase);

          return _super8.apply(this, arguments);
        }

        return CdkHeaderRowDefBase;
      }(_BaseRowDef);

      var _CdkHeaderRowDefBase = /*#__PURE__*/_mixinHasStickyInput(CdkHeaderRowDefBase);
      /**
       * Header row definition for the CDK table.
       * Captures the header row's template and other header properties such as the columns to display.
       */


      var _CdkHeaderRowDef = /*#__PURE__*/function () {
        var CdkHeaderRowDef = /*#__PURE__*/function (_CdkHeaderRowDefBase2) {
          _inherits(CdkHeaderRowDef, _CdkHeaderRowDefBase2);

          var _super9 = _createSuper(CdkHeaderRowDef);

          function CdkHeaderRowDef(template, _differs, _table) {
            var _this29;

            _classCallCheck(this, CdkHeaderRowDef);

            _this29 = _super9.call(this, template, _differs);
            _this29._table = _table;
            return _this29;
          } // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
          // Explicitly define it so that the method is called as part of the Angular lifecycle.


          _createClass(CdkHeaderRowDef, [{
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              _get(_getPrototypeOf(CdkHeaderRowDef.prototype), "ngOnChanges", this).call(this, changes);
            }
          }]);

          return CdkHeaderRowDef;
        }(_CdkHeaderRowDefBase);

        CdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) {
          return new (t || CdkHeaderRowDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CDK_TABLE, 8));
        };

        CdkHeaderRowDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkHeaderRowDef,
          selectors: [["", "cdkHeaderRowDef", ""]],
          inputs: {
            columns: ["cdkHeaderRowDef", "columns"],
            sticky: ["cdkHeaderRowDefSticky", "sticky"]
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return CdkHeaderRowDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })(); // Boilerplate for applying mixins to CdkFooterRowDef.

      /** @docs-private */


      var CdkFooterRowDefBase = /*#__PURE__*/function (_BaseRowDef3) {
        _inherits(CdkFooterRowDefBase, _BaseRowDef3);

        var _super10 = _createSuper(CdkFooterRowDefBase);

        function CdkFooterRowDefBase() {
          _classCallCheck(this, CdkFooterRowDefBase);

          return _super10.apply(this, arguments);
        }

        return CdkFooterRowDefBase;
      }(_BaseRowDef);

      var _CdkFooterRowDefBase = /*#__PURE__*/_mixinHasStickyInput(CdkFooterRowDefBase);
      /**
       * Footer row definition for the CDK table.
       * Captures the footer row's template and other footer properties such as the columns to display.
       */


      var _CdkFooterRowDef = /*#__PURE__*/function () {
        var CdkFooterRowDef = /*#__PURE__*/function (_CdkFooterRowDefBase2) {
          _inherits(CdkFooterRowDef, _CdkFooterRowDefBase2);

          var _super11 = _createSuper(CdkFooterRowDef);

          function CdkFooterRowDef(template, _differs, _table) {
            var _this30;

            _classCallCheck(this, CdkFooterRowDef);

            _this30 = _super11.call(this, template, _differs);
            _this30._table = _table;
            return _this30;
          } // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
          // Explicitly define it so that the method is called as part of the Angular lifecycle.


          _createClass(CdkFooterRowDef, [{
            key: "ngOnChanges",
            value: function ngOnChanges(changes) {
              _get(_getPrototypeOf(CdkFooterRowDef.prototype), "ngOnChanges", this).call(this, changes);
            }
          }]);

          return CdkFooterRowDef;
        }(_CdkFooterRowDefBase);

        CdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) {
          return new (t || CdkFooterRowDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CDK_TABLE, 8));
        };

        CdkFooterRowDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkFooterRowDef,
          selectors: [["", "cdkFooterRowDef", ""]],
          inputs: {
            columns: ["cdkFooterRowDef", "columns"],
            sticky: ["cdkFooterRowDefSticky", "sticky"]
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
        });
        return CdkFooterRowDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Data row definition for the CDK table.
       * Captures the header row's template and other row properties such as the columns to display and
       * a when predicate that describes when this row should be used.
       */


      var _CdkRowDef = /*#__PURE__*/function () {
        var CdkRowDef = /*#__PURE__*/function (_BaseRowDef4) {
          _inherits(CdkRowDef, _BaseRowDef4);

          var _super12 = _createSuper(CdkRowDef);

          // TODO(andrewseguin): Add an input for providing a switch function to determine
          //   if this template should be used.
          function CdkRowDef(template, _differs, _table) {
            var _this31;

            _classCallCheck(this, CdkRowDef);

            _this31 = _super12.call(this, template, _differs);
            _this31._table = _table;
            return _this31;
          }

          return CdkRowDef;
        }(_BaseRowDef);

        CdkRowDef.ɵfac = function CdkRowDef_Factory(t) {
          return new (t || CdkRowDef)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CDK_TABLE, 8));
        };

        CdkRowDef.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkRowDef,
          selectors: [["", "cdkRowDef", ""]],
          inputs: {
            columns: ["cdkRowDefColumns", "columns"],
            when: ["cdkRowDefWhen", "when"]
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
        });
        return CdkRowDef;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Outlet for rendering cells inside of a row or header row.
       * @docs-private
       */


      var _CdkCellOutlet = /*#__PURE__*/function () {
        var CdkCellOutlet = /*#__PURE__*/function () {
          function CdkCellOutlet(_viewContainer) {
            _classCallCheck(this, CdkCellOutlet);

            this._viewContainer = _viewContainer;
            CdkCellOutlet.mostRecentCellOutlet = this;
          }

          _createClass(CdkCellOutlet, [{
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              // If this was the last outlet being rendered in the view, remove the reference
              // from the static property after it has been destroyed to avoid leaking memory.
              if (CdkCellOutlet.mostRecentCellOutlet === this) {
                CdkCellOutlet.mostRecentCellOutlet = null;
              }
            }
          }]);

          return CdkCellOutlet;
        }();

        CdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) {
          return new (t || CdkCellOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef));
        };

        CdkCellOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkCellOutlet,
          selectors: [["", "cdkCellOutlet", ""]]
        });
        /**
         * Static property containing the latest constructed instance of this class.
         * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
         * createEmbeddedView. After one of these components are created, this property will provide
         * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
         * construct the cells with the provided context.
         */

        CdkCellOutlet.mostRecentCellOutlet = null;
        return CdkCellOutlet;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Header template container that contains the cell outlet. Adds the right class and role. */


      var _CdkHeaderRow = /*#__PURE__*/function () {
        var CdkHeaderRow = function CdkHeaderRow() {
          _classCallCheck(this, CdkHeaderRow);
        };

        CdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) {
          return new (t || CdkHeaderRow)();
        };

        CdkHeaderRow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkHeaderRow,
          selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]],
          hostAttrs: ["role", "row", 1, "cdk-header-row"],
          decls: 1,
          vars: 0,
          consts: [["cdkCellOutlet", ""]],
          template: function CdkHeaderRow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 0);
            }
          },
          directives: [_CdkCellOutlet],
          encapsulation: 2
        });
        return CdkHeaderRow;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Footer template container that contains the cell outlet. Adds the right class and role. */


      var _CdkFooterRow = /*#__PURE__*/function () {
        var CdkFooterRow = function CdkFooterRow() {
          _classCallCheck(this, CdkFooterRow);
        };

        CdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) {
          return new (t || CdkFooterRow)();
        };

        CdkFooterRow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkFooterRow,
          selectors: [["cdk-footer-row"], ["tr", "cdk-footer-row", ""]],
          hostAttrs: ["role", "row", 1, "cdk-footer-row"],
          decls: 1,
          vars: 0,
          consts: [["cdkCellOutlet", ""]],
          template: function CdkFooterRow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 0);
            }
          },
          directives: [_CdkCellOutlet],
          encapsulation: 2
        });
        return CdkFooterRow;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Data row template container that contains the cell outlet. Adds the right class and role. */


      var _CdkRow = /*#__PURE__*/function () {
        var CdkRow = function CdkRow() {
          _classCallCheck(this, CdkRow);
        };

        CdkRow.ɵfac = function CdkRow_Factory(t) {
          return new (t || CdkRow)();
        };

        CdkRow.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkRow,
          selectors: [["cdk-row"], ["tr", "cdk-row", ""]],
          hostAttrs: ["role", "row", 1, "cdk-row"],
          decls: 1,
          vars: 0,
          consts: [["cdkCellOutlet", ""]],
          template: function CdkRow_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 0);
            }
          },
          directives: [_CdkCellOutlet],
          encapsulation: 2
        });
        return CdkRow;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Row that can be used to display a message when no data is shown in the table. */


      var _CdkNoDataRow = /*#__PURE__*/function () {
        var CdkNoDataRow = function CdkNoDataRow(templateRef) {
          _classCallCheck(this, CdkNoDataRow);

          this.templateRef = templateRef;
        };

        CdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) {
          return new (t || CdkNoDataRow)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
        };

        CdkNoDataRow.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkNoDataRow,
          selectors: [["ng-template", "cdkNoDataRow", ""]]
        });
        return CdkNoDataRow;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * List of all possible directions that can be used for sticky positioning.
       * @docs-private
       */


      var _STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
      /**
       * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
       * @docs-private
       */

      var _StickyStyler = /*#__PURE__*/function () {
        /**
         * @param _isNativeHtmlTable Whether the sticky logic should be based on a table
         *     that uses the native `<table>` element.
         * @param _stickCellCss The CSS class that will be applied to every row/cell that has
         *     sticky positioning applied.
         * @param direction The directionality context of the table (ltr/rtl); affects column positioning
         *     by reversing left/right positions.
         * @param _isBrowser Whether the table is currently being rendered on the server or the client.
         * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells
         *     using inline styles. If false, it is assumed that position: sticky is included in
         *     the component stylesheet for _stickCellCss.
         * @param _positionListener A listener that is notified of changes to sticky rows/columns
         *     and their dimensions.
         */
        function _StickyStyler(_isNativeHtmlTable, _stickCellCss, direction,
        /**
         * @deprecated `_coalescedStyleScheduler` parameter to become required.
         * @breaking-change 11.0.0
         */
        _coalescedStyleScheduler) {
          var _isBrowser = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

          var _needsPositionStickyOnElement = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

          var _positionListener = arguments.length > 6 ? arguments[6] : undefined;

          _classCallCheck(this, _StickyStyler);

          this._isNativeHtmlTable = _isNativeHtmlTable;
          this._stickCellCss = _stickCellCss;
          this.direction = direction;
          this._coalescedStyleScheduler = _coalescedStyleScheduler;
          this._isBrowser = _isBrowser;
          this._needsPositionStickyOnElement = _needsPositionStickyOnElement;
          this._positionListener = _positionListener;
          this._cachedCellWidths = [];
          this._borderCellCss = {
            'top': "".concat(_stickCellCss, "-border-elem-top"),
            'bottom': "".concat(_stickCellCss, "-border-elem-bottom"),
            'left': "".concat(_stickCellCss, "-border-elem-left"),
            'right': "".concat(_stickCellCss, "-border-elem-right")
          };
        }
        /**
         * Clears the sticky positioning styles from the row and its cells by resetting the `position`
         * style, setting the zIndex to 0, and unsetting each provided sticky direction.
         * @param rows The list of rows that should be cleared from sticking in the provided directions
         * @param stickyDirections The directions that should no longer be set as sticky on the rows.
         */


        _createClass(_StickyStyler, [{
          key: "clearStickyPositioning",
          value: function clearStickyPositioning(rows, stickyDirections) {
            var _this32 = this;

            var elementsToClear = [];

            var _iterator8 = _createForOfIteratorHelper(rows),
                _step8;

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var row = _step8.value;

                // If the row isn't an element (e.g. if it's an `ng-container`),
                // it won't have inline styles or `children` so we skip it.
                if (row.nodeType !== row.ELEMENT_NODE) {
                  continue;
                }

                elementsToClear.push(row);

                for (var i = 0; i < row.children.length; i++) {
                  elementsToClear.push(row.children[i]);
                }
              } // Coalesce with sticky row/column updates (and potentially other changes like column resize).

            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }

            this._scheduleStyleChanges(function () {
              var _iterator9 = _createForOfIteratorHelper(elementsToClear),
                  _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var element = _step9.value;

                  _this32._removeStickyStyle(element, stickyDirections);
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
            });
          }
          /**
           * Applies sticky left and right positions to the cells of each row according to the sticky
           * states of the rendered column definitions.
           * @param rows The rows that should have its set of cells stuck according to the sticky states.
           * @param stickyStartStates A list of boolean states where each state represents whether the cell
           *     in this index position should be stuck to the start of the row.
           * @param stickyEndStates A list of boolean states where each state represents whether the cell
           *     in this index position should be stuck to the end of the row.
           * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each
           *     column cell. If `false` cached widths will be used instead.
           */

        }, {
          key: "updateStickyColumns",
          value: function updateStickyColumns(rows, stickyStartStates, stickyEndStates) {
            var _this33 = this;

            var recalculateCellWidths = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

            if (!rows.length || !this._isBrowser || !(stickyStartStates.some(function (state) {
              return state;
            }) || stickyEndStates.some(function (state) {
              return state;
            }))) {
              if (this._positionListener) {
                this._positionListener.stickyColumnsUpdated({
                  sizes: []
                });

                this._positionListener.stickyEndColumnsUpdated({
                  sizes: []
                });
              }

              return;
            }

            var firstRow = rows[0];
            var numCells = firstRow.children.length;

            var cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);

            var startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);

            var endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);

            var lastStickyStart = stickyStartStates.lastIndexOf(true);
            var firstStickyEnd = stickyEndStates.indexOf(true); // Coalesce with sticky row updates (and potentially other changes like column resize).

            this._scheduleStyleChanges(function () {
              var isRtl = _this33.direction === 'rtl';
              var start = isRtl ? 'right' : 'left';
              var end = isRtl ? 'left' : 'right';

              var _iterator10 = _createForOfIteratorHelper(rows),
                  _step10;

              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var row = _step10.value;

                  for (var i = 0; i < numCells; i++) {
                    var cell = row.children[i];

                    if (stickyStartStates[i]) {
                      _this33._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);
                    }

                    if (stickyEndStates[i]) {
                      _this33._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);
                    }
                  }
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }

              if (_this33._positionListener) {
                _this33._positionListener.stickyColumnsUpdated({
                  sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map(function (width, index) {
                    return stickyStartStates[index] ? width : null;
                  })
                });

                _this33._positionListener.stickyEndColumnsUpdated({
                  sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map(function (width, index) {
                    return stickyEndStates[index + firstStickyEnd] ? width : null;
                  }).reverse()
                });
              }
            });
          }
          /**
           * Applies sticky positioning to the row's cells if using the native table layout, and to the
           * row itself otherwise.
           * @param rowsToStick The list of rows that should be stuck according to their corresponding
           *     sticky state and to the provided top or bottom position.
           * @param stickyStates A list of boolean states where each state represents whether the row
           *     should be stuck in the particular top or bottom position.
           * @param position The position direction in which the row should be stuck if that row should be
           *     sticky.
           *
           */

        }, {
          key: "stickRows",
          value: function stickRows(rowsToStick, stickyStates, position) {
            var _this34 = this;

            // Since we can't measure the rows on the server, we can't stick the rows properly.
            if (!this._isBrowser) {
              return;
            } // If positioning the rows to the bottom, reverse their order when evaluating the sticky
            // position such that the last row stuck will be "bottom: 0px" and so on. Note that the
            // sticky states need to be reversed as well.


            var rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;
            var states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates; // Measure row heights all at once before adding sticky styles to reduce layout thrashing.

            var stickyOffsets = [];
            var stickyCellHeights = [];
            var elementsToStick = [];

            for (var rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {
              stickyOffsets[rowIndex] = stickyOffset;

              if (!states[rowIndex]) {
                continue;
              }

              var row = rows[rowIndex];
              elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];
              var height = row.getBoundingClientRect().height;
              stickyOffset += height;
              stickyCellHeights[rowIndex] = height;
            }

            var borderedRowIndex = states.lastIndexOf(true); // Coalesce with other sticky row updates (top/bottom), sticky columns updates
            // (and potentially other changes like column resize).

            this._scheduleStyleChanges(function () {
              var _a, _b;

              for (var _rowIndex = 0; _rowIndex < rows.length; _rowIndex++) {
                if (!states[_rowIndex]) {
                  continue;
                }

                var offset = stickyOffsets[_rowIndex];
                var isBorderedRowIndex = _rowIndex === borderedRowIndex;

                var _iterator11 = _createForOfIteratorHelper(elementsToStick[_rowIndex]),
                    _step11;

                try {
                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                    var element = _step11.value;

                    _this34._addStickyStyle(element, position, offset, isBorderedRowIndex);
                  }
                } catch (err) {
                  _iterator11.e(err);
                } finally {
                  _iterator11.f();
                }
              }

              if (position === 'top') {
                (_a = _this34._positionListener) === null || _a === void 0 ? void 0 : _a.stickyHeaderRowsUpdated({
                  sizes: stickyCellHeights,
                  elements: elementsToStick
                });
              } else {
                (_b = _this34._positionListener) === null || _b === void 0 ? void 0 : _b.stickyFooterRowsUpdated({
                  sizes: stickyCellHeights,
                  elements: elementsToStick
                });
              }
            });
          }
          /**
           * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
           * footer rows is to apply sticky styling to the tfoot container. This should only be done if
           * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
           * the tfoot element.
           */

        }, {
          key: "updateStickyFooterContainer",
          value: function updateStickyFooterContainer(tableElement, stickyStates) {
            var _this35 = this;

            if (!this._isNativeHtmlTable) {
              return;
            }

            var tfoot = tableElement.querySelector('tfoot'); // Coalesce with other sticky updates (and potentially other changes like column resize).

            this._scheduleStyleChanges(function () {
              if (stickyStates.some(function (state) {
                return !state;
              })) {
                _this35._removeStickyStyle(tfoot, ['bottom']);
              } else {
                _this35._addStickyStyle(tfoot, 'bottom', 0, false);
              }
            });
          }
          /**
           * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
           * the zIndex, removing each of the provided sticky directions, and removing the
           * sticky position if there are no more directions.
           */

        }, {
          key: "_removeStickyStyle",
          value: function _removeStickyStyle(element, stickyDirections) {
            var _iterator12 = _createForOfIteratorHelper(stickyDirections),
                _step12;

            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var dir = _step12.value;
                element.style[dir] = '';
                element.classList.remove(this._borderCellCss[dir]);
              } // If the element no longer has any more sticky directions, remove sticky positioning and
              // the sticky CSS class.
              // Short-circuit checking element.style[dir] for stickyDirections as they
              // were already removed above.

            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }

            var hasDirection = _STICKY_DIRECTIONS.some(function (dir) {
              return stickyDirections.indexOf(dir) === -1 && element.style[dir];
            });

            if (hasDirection) {
              element.style.zIndex = this._getCalculatedZIndex(element);
            } else {
              // When not hasDirection, _getCalculatedZIndex will always return ''.
              element.style.zIndex = '';

              if (this._needsPositionStickyOnElement) {
                element.style.position = '';
              }

              element.classList.remove(this._stickCellCss);
            }
          }
          /**
           * Adds the sticky styling to the element by adding the sticky style class, changing position
           * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
           * direction and value.
           */

        }, {
          key: "_addStickyStyle",
          value: function _addStickyStyle(element, dir, dirValue, isBorderElement) {
            element.classList.add(this._stickCellCss);

            if (isBorderElement) {
              element.classList.add(this._borderCellCss[dir]);
            }

            element.style[dir] = "".concat(dirValue, "px");
            element.style.zIndex = this._getCalculatedZIndex(element);

            if (this._needsPositionStickyOnElement) {
              element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
            }
          }
          /**
           * Calculate what the z-index should be for the element, depending on what directions (top,
           * bottom, left, right) have been set. It should be true that elements with a top direction
           * should have the highest index since these are elements like a table header. If any of those
           * elements are also sticky in another direction, then they should appear above other elements
           * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
           * (e.g. footer rows) should then be next in the ordering such that they are below the header
           * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
           * should minimally increment so that they are above non-sticky elements but below top and bottom
           * elements.
           */

        }, {
          key: "_getCalculatedZIndex",
          value: function _getCalculatedZIndex(element) {
            var zIndexIncrements = {
              top: 100,
              bottom: 10,
              left: 1,
              right: 1
            };
            var zIndex = 0; // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,
            // loses the array generic type in the `for of`. But we *also* have to use `Array` because
            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`

            var _iterator13 = _createForOfIteratorHelper(_STICKY_DIRECTIONS),
                _step13;

            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var dir = _step13.value;

                if (element.style[dir]) {
                  zIndex += zIndexIncrements[dir];
                }
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }

            return zIndex ? "".concat(zIndex) : '';
          }
          /** Gets the widths for each cell in the provided row. */

        }, {
          key: "_getCellWidths",
          value: function _getCellWidths(row) {
            var recalculateCellWidths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            if (!recalculateCellWidths && this._cachedCellWidths.length) {
              return this._cachedCellWidths;
            }

            var cellWidths = [];
            var firstRowCells = row.children;

            for (var i = 0; i < firstRowCells.length; i++) {
              var cell = firstRowCells[i];
              cellWidths.push(cell.getBoundingClientRect().width);
            }

            this._cachedCellWidths = cellWidths;
            return cellWidths;
          }
          /**
           * Determines the left and right positions of each sticky column cell, which will be the
           * accumulation of all sticky column cell widths to the left and right, respectively.
           * Non-sticky cells do not need to have a value set since their positions will not be applied.
           */

        }, {
          key: "_getStickyStartColumnPositions",
          value: function _getStickyStartColumnPositions(widths, stickyStates) {
            var positions = [];
            var nextPosition = 0;

            for (var i = 0; i < widths.length; i++) {
              if (stickyStates[i]) {
                positions[i] = nextPosition;
                nextPosition += widths[i];
              }
            }

            return positions;
          }
          /**
           * Determines the left and right positions of each sticky column cell, which will be the
           * accumulation of all sticky column cell widths to the left and right, respectively.
           * Non-sticky cells do not need to have a value set since their positions will not be applied.
           */

        }, {
          key: "_getStickyEndColumnPositions",
          value: function _getStickyEndColumnPositions(widths, stickyStates) {
            var positions = [];
            var nextPosition = 0;

            for (var i = widths.length; i > 0; i--) {
              if (stickyStates[i]) {
                positions[i] = nextPosition;
                nextPosition += widths[i];
              }
            }

            return positions;
          }
          /**
           * Schedules styles to be applied when the style scheduler deems appropriate.
           * @breaking-change 11.0.0 This method can be removed in favor of calling
           * `CoalescedStyleScheduler.schedule` directly once the scheduler is a required parameter.
           */

        }, {
          key: "_scheduleStyleChanges",
          value: function _scheduleStyleChanges(changes) {
            if (this._coalescedStyleScheduler) {
              this._coalescedStyleScheduler.schedule(changes);
            } else {
              changes();
            }
          }
        }]);

        return _StickyStyler;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Returns an error to be thrown when attempting to find an unexisting column.
       * @param id Id whose lookup failed.
       * @docs-private
       */


      function getTableUnknownColumnError(id) {
        return Error("Could not find column with id \"".concat(id, "\"."));
      }
      /**
       * Returns an error to be thrown when two column definitions have the same name.
       * @docs-private
       */


      function getTableDuplicateColumnNameError(name) {
        return Error("Duplicate column definition name provided: \"".concat(name, "\"."));
      }
      /**
       * Returns an error to be thrown when there are multiple rows that are missing a when function.
       * @docs-private
       */


      function getTableMultipleDefaultRowDefsError() {
        return Error("There can only be one default row without a when predicate function.");
      }
      /**
       * Returns an error to be thrown when there are no matching row defs for a particular set of data.
       * @docs-private
       */


      function getTableMissingMatchingRowDefError(data) {
        return Error("Could not find a matching row definition for the" + "provided row data: ".concat(JSON.stringify(data)));
      }
      /**
       * Returns an error to be thrown when there is no row definitions present in the content.
       * @docs-private
       */


      function getTableMissingRowDefsError() {
        return Error('Missing definitions for header, footer, and row; ' + 'cannot determine which columns should be rendered.');
      }
      /**
       * Returns an error to be thrown when the data source does not match the compatible types.
       * @docs-private
       */


      function getTableUnknownDataSourceError() {
        return Error("Provided data source did not match an array, Observable, or DataSource");
      }
      /**
       * Returns an error to be thrown when the text column cannot find a parent table to inject.
       * @docs-private
       */


      function getTableTextColumnMissingParentTableError() {
        return Error("Text column could not find a parent table for registration.");
      }
      /**
       * Returns an error to be thrown when a table text column doesn't have a name.
       * @docs-private
       */


      function getTableTextColumnMissingNameError() {
        return Error("Table text column must have a name.");
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** The injection token used to specify the StickyPositioningListener. */


      var _STICKY_POSITIONING_LISTENER = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('CDK_SPL');
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Provides a handle for the table to grab the view container's ng-container to insert data rows.
       * @docs-private
       */


      var _DataRowOutlet = /*#__PURE__*/function () {
        var DataRowOutlet = function DataRowOutlet(viewContainer, elementRef) {
          _classCallCheck(this, DataRowOutlet);

          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
        };

        DataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) {
          return new (t || DataRowOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        DataRowOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: DataRowOutlet,
          selectors: [["", "rowOutlet", ""]]
        });
        return DataRowOutlet;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Provides a handle for the table to grab the view container's ng-container to insert the header.
       * @docs-private
       */


      var _HeaderRowOutlet = /*#__PURE__*/function () {
        var HeaderRowOutlet = function HeaderRowOutlet(viewContainer, elementRef) {
          _classCallCheck(this, HeaderRowOutlet);

          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
        };

        HeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) {
          return new (t || HeaderRowOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        HeaderRowOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: HeaderRowOutlet,
          selectors: [["", "headerRowOutlet", ""]]
        });
        return HeaderRowOutlet;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Provides a handle for the table to grab the view container's ng-container to insert the footer.
       * @docs-private
       */


      var _FooterRowOutlet = /*#__PURE__*/function () {
        var FooterRowOutlet = function FooterRowOutlet(viewContainer, elementRef) {
          _classCallCheck(this, FooterRowOutlet);

          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
        };

        FooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) {
          return new (t || FooterRowOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        FooterRowOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: FooterRowOutlet,
          selectors: [["", "footerRowOutlet", ""]]
        });
        return FooterRowOutlet;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Provides a handle for the table to grab the view
       * container's ng-container to insert the no data row.
       * @docs-private
       */


      var _NoDataRowOutlet = /*#__PURE__*/function () {
        var NoDataRowOutlet = function NoDataRowOutlet(viewContainer, elementRef) {
          _classCallCheck(this, NoDataRowOutlet);

          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
        };

        NoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) {
          return new (t || NoDataRowOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
        };

        NoDataRowOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: NoDataRowOutlet,
          selectors: [["", "noDataRowOutlet", ""]]
        });
        return NoDataRowOutlet;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * The table template that can be used by the mat-table. Should not be used outside of the
       * material library.
       * @docs-private
       */


      var _CDK_TABLE_TEMPLATE = // Note that according to MDN, the `caption` element has to be projected as the **first**
      // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
      "\n  <ng-content select=\"caption\"></ng-content>\n  <ng-content select=\"colgroup, col\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container noDataRowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n";
      /**
       * Class used to conveniently type the embedded view ref for rows with a context.
       * @docs-private
       */

      var RowViewRef = /*#__PURE__*/function (_angular_core__WEBPAC) {
        _inherits(RowViewRef, _angular_core__WEBPAC);

        var _super13 = _createSuper(RowViewRef);

        function RowViewRef() {
          _classCallCheck(this, RowViewRef);

          return _super13.apply(this, arguments);
        }

        return RowViewRef;
      }(_angular_core__WEBPACK_IMPORTED_MODULE_0__.EmbeddedViewRef);
      /**
       * A data table that can render a header row, data rows, and a footer row.
       * Uses the dataSource input to determine the data to be rendered. The data can be provided either
       * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
       * connect function that will return an Observable stream that emits the data array to render.
       */


      var _CdkTable = /*#__PURE__*/function () {
        var CdkTable = /*#__PURE__*/function () {
          function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform,
          /**
           * @deprecated `_coalescedStyleScheduler`, `_viewRepeater` and `_viewportRuler`
           *    parameters to become required.
           * @breaking-change 11.0.0
           */
          _viewRepeater, _coalescedStyleScheduler, _stickyPositioningListener, // Optional for backwards compatibility. The viewport ruler is provided in root. Therefore,
          // this property will never be null.
          // tslint:disable-next-line: lightweight-tokens
          _viewportRuler) {
            _classCallCheck(this, CdkTable);

            this._differs = _differs;
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this._dir = _dir;
            this._platform = _platform;
            this._viewRepeater = _viewRepeater;
            this._coalescedStyleScheduler = _coalescedStyleScheduler;
            this._stickyPositioningListener = _stickyPositioningListener;
            this._viewportRuler = _viewportRuler;
            /** Subject that emits when the component has been destroyed. */

            this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
            /**
             * Map of all the user's defined columns (header, data, and footer cell template) identified by
             * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
             * any custom column definitions added to `_customColumnDefs`.
             */

            this._columnDefsByName = new Map();
            /**
             * Column definitions that were defined outside of the direct content children of the table.
             * These will be defined when, e.g., creating a wrapper around the cdkTable that has
             * column definitions as *its* content child.
             */

            this._customColumnDefs = new Set();
            /**
             * Data row definitions that were defined outside of the direct content children of the table.
             * These will be defined when, e.g., creating a wrapper around the cdkTable that has
             * built-in data rows as *its* content child.
             */

            this._customRowDefs = new Set();
            /**
             * Header row definitions that were defined outside of the direct content children of the table.
             * These will be defined when, e.g., creating a wrapper around the cdkTable that has
             * built-in header rows as *its* content child.
             */

            this._customHeaderRowDefs = new Set();
            /**
             * Footer row definitions that were defined outside of the direct content children of the table.
             * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
             * built-in footer row as *its* content child.
             */

            this._customFooterRowDefs = new Set();
            /**
             * Whether the header row definition has been changed. Triggers an update to the header row after
             * content is checked. Initialized as true so that the table renders the initial set of rows.
             */

            this._headerRowDefChanged = true;
            /**
             * Whether the footer row definition has been changed. Triggers an update to the footer row after
             * content is checked. Initialized as true so that the table renders the initial set of rows.
             */

            this._footerRowDefChanged = true;
            /**
             * Whether the sticky column styles need to be updated. Set to `true` when the visible columns
             * change.
             */

            this._stickyColumnStylesNeedReset = true;
            /**
             * Whether the sticky styler should recalculate cell widths when applying sticky styles. If
             * `false`, cached values will be used instead. This is only applicable to tables with
             * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.
             */

            this._forceRecalculateCellWidths = true;
            /**
             * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
             * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
             * the cached `RenderRow` objects when possible, the row identity is preserved when the data
             * and row template matches, which allows the `IterableDiffer` to check rows by reference
             * and understand which rows are added/moved/removed.
             *
             * Implemented as a map of maps where the first key is the `data: T` object and the second is the
             * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
             * contains an array of created pairs. The array is necessary to handle cases where the data
             * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
             * stored.
             */

            this._cachedRenderRowsMap = new Map();
            /**
             * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
             * table subclasses.
             */

            this.stickyCssClass = 'cdk-table-sticky';
            /**
             * Whether to manually add positon: sticky to all sticky cell elements. Not needed if
             * the position is set in a selector associated with the value of stickyCssClass. May be
             * overridden by table subclasses
             */

            this.needsPositionStickyOnElement = true;
            /** Whether the no data row is currently showing anything. */

            this._isShowingNoDataRow = false;
            this._multiTemplateDataRows = false;
            this._fixedLayout = false; // TODO(andrewseguin): Remove max value as the end index
            //   and instead calculate the view on init and scroll.

            /**
             * Stream containing the latest information on what rows are being displayed on screen.
             * Can be used by the data source to as a heuristic of what data should be provided.
             *
             * @docs-private
             */

            this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_3__.BehaviorSubject({
              start: 0,
              end: Number.MAX_VALUE
            });

            if (!role) {
              this._elementRef.nativeElement.setAttribute('role', 'grid');
            }

            this._document = _document;
            this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
          }
          /**
           * Tracking function that will be used to check the differences in data changes. Used similarly
           * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
           * relative to the function to know if a row should be added/removed/moved.
           * Accepts a function that takes two parameters, `index` and `item`.
           */


          _createClass(CdkTable, [{
            key: "trackBy",
            get: function get() {
              return this._trackByFn;
            },
            set: function set(fn) {
              if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {
                console.warn("trackBy must be a function, but received ".concat(JSON.stringify(fn), "."));
              }

              this._trackByFn = fn;
            }
            /**
             * The table's source of data, which can be provided in three ways (in order of complexity):
             *   - Simple data array (each object represents one table row)
             *   - Stream that emits a data array each time the array changes
             *   - `DataSource` object that implements the connect/disconnect interface.
             *
             * If a data array is provided, the table must be notified when the array's objects are
             * added, removed, or moved. This can be done by calling the `renderRows()` function which will
             * render the diff since the last table render. If the data array reference is changed, the table
             * will automatically trigger an update to the rows.
             *
             * When providing an Observable stream, the table will trigger an update automatically when the
             * stream emits a new array of data.
             *
             * Finally, when providing a `DataSource` object, the table will use the Observable stream
             * provided by the connect function and trigger updates when that stream emits new data array
             * values. During the table's ngOnDestroy or when the data source is removed from the table, the
             * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
             * subscriptions registered during the connect process).
             */

          }, {
            key: "dataSource",
            get: function get() {
              return this._dataSource;
            },
            set: function set(dataSource) {
              if (this._dataSource !== dataSource) {
                this._switchDataSource(dataSource);
              }
            }
            /**
             * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
             * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
             * dataobject will render the first row that evaluates its when predicate to true, in the order
             * defined in the table, or otherwise the default row which does not have a when predicate.
             */

          }, {
            key: "multiTemplateDataRows",
            get: function get() {
              return this._multiTemplateDataRows;
            },
            set: function set(v) {
              this._multiTemplateDataRows = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v); // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),
              // this setter will be invoked before the row outlet has been defined hence the null check.

              if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
                this._forceRenderDataRows();

                this.updateStickyColumnStyles();
              }
            }
            /**
             * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths
             * and optimize rendering sticky styles for native tables. No-op for flex tables.
             */

          }, {
            key: "fixedLayout",
            get: function get() {
              return this._fixedLayout;
            },
            set: function set(v) {
              this._fixedLayout = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v); // Toggling `fixedLayout` may change column widths. Sticky column styles should be recalculated.

              this._forceRecalculateCellWidths = true;
              this._stickyColumnStylesNeedReset = true;
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              var _this36 = this;

              this._setupStickyStyler();

              if (this._isNativeHtmlTable) {
                this._applyNativeTableSections();
              } // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
              // the user has provided a custom trackBy, return the result of that function as evaluated
              // with the values of the `RenderRow`'s data and index.


              this._dataDiffer = this._differs.find([]).create(function (_i, dataRow) {
                return _this36.trackBy ? _this36.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
              }); // Table cell dimensions may change after resizing the window. Signal the sticky styler to
              // refresh its cache of cell widths the next time sticky styles are updated.
              // @breaking-change 11.0.0 Remove null check for _viewportRuler once it's a required parameter.

              if (this._viewportRuler) {
                this._viewportRuler.change().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy)).subscribe(function () {
                  _this36._forceRecalculateCellWidths = true;
                });
              }
            }
          }, {
            key: "ngAfterContentChecked",
            value: function ngAfterContentChecked() {
              // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
              this._cacheRowDefs();

              this._cacheColumnDefs(); // Make sure that the user has at least added header, footer, or data row def.


              if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getTableMissingRowDefsError();
              } // Render updates if the list of columns have been changed for the header, row, or footer defs.


              var columnsChanged = this._renderUpdatedColumns();

              var rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged; // Ensure sticky column styles are reset if set to `true` elsewhere.

              this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;
              this._forceRecalculateCellWidths = rowDefsChanged; // If the header row definition has been changed, trigger a render to the header row.

              if (this._headerRowDefChanged) {
                this._forceRenderHeaderRows();

                this._headerRowDefChanged = false;
              } // If the footer row definition has been changed, trigger a render to the footer row.


              if (this._footerRowDefChanged) {
                this._forceRenderFooterRows();

                this._footerRowDefChanged = false;
              } // If there is a data source and row definitions, connect to the data source unless a
              // connection has already been made.


              if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
                this._observeRenderChanges();
              } else if (this._stickyColumnStylesNeedReset) {
                // In the above case, _observeRenderChanges will result in updateStickyColumnStyles being
                // called when it row data arrives. Otherwise, we need to call it proactively.
                this.updateStickyColumnStyles();
              }

              this._checkStickyStates();
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._rowOutlet.viewContainer.clear();

              this._noDataRowOutlet.viewContainer.clear();

              this._headerRowOutlet.viewContainer.clear();

              this._footerRowOutlet.viewContainer.clear();

              this._cachedRenderRowsMap.clear();

              this._onDestroy.next();

              this._onDestroy.complete();

              if ((0, _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__.isDataSource)(this.dataSource)) {
                this.dataSource.disconnect(this);
              }
            }
            /**
             * Renders rows based on the table's latest set of data, which was either provided directly as an
             * input or retrieved through an Observable stream (directly or from a DataSource).
             * Checks for differences in the data since the last diff to perform only the necessary
             * changes (add/remove/move rows).
             *
             * If the table's data source is a DataSource or Observable, this will be invoked automatically
             * each time the provided Observable stream emits a new data array. Otherwise if your data is
             * an array, this function will need to be called to render any changes.
             */

          }, {
            key: "renderRows",
            value: function renderRows() {
              var _this37 = this;

              this._renderRows = this._getAllRenderRows();

              var changes = this._dataDiffer.diff(this._renderRows);

              if (!changes) {
                this._updateNoDataRow();

                return;
              }

              var viewContainer = this._rowOutlet.viewContainer; // @breaking-change 11.0.0 Remove null check for `_viewRepeater` and the
              // `else` clause once `_viewRepeater` is turned into a required parameter.

              if (this._viewRepeater) {
                this._viewRepeater.applyChanges(changes, viewContainer, function (record, _adjustedPreviousIndex, currentIndex) {
                  return _this37._getEmbeddedViewArgs(record.item, currentIndex);
                }, function (record) {
                  return record.item.data;
                }, function (change) {
                  if (change.operation === 1
                  /* INSERTED */
                  && change.context) {
                    _this37._renderCellTemplateForItem(change.record.item.rowDef, change.context);
                  }
                });
              } else {
                changes.forEachOperation(function (record, prevIndex, currentIndex) {
                  if (record.previousIndex == null) {
                    var renderRow = record.item;
                    var rowDef = renderRow.rowDef;
                    var context = {
                      $implicit: renderRow.data
                    };

                    _this37._renderRow(_this37._rowOutlet, rowDef, currentIndex, context);
                  } else if (currentIndex == null) {
                    viewContainer.remove(prevIndex);
                  } else {
                    var view = viewContainer.get(prevIndex);
                    viewContainer.move(view, currentIndex);
                  }
                });
              } // Update the meta context of a row's context data (index, count, first, last, ...)


              this._updateRowIndexContext(); // Update rows that did not get added/removed/moved but may have had their identity changed,
              // e.g. if trackBy matched data on some property but the actual data reference changed.


              changes.forEachIdentityChange(function (record) {
                var rowView = viewContainer.get(record.currentIndex);
                rowView.context.$implicit = record.item.data;
              });

              this._updateNoDataRow();

              this.updateStickyColumnStyles();
            }
            /** Adds a column definition that was not included as part of the content children. */

          }, {
            key: "addColumnDef",
            value: function addColumnDef(columnDef) {
              this._customColumnDefs.add(columnDef);
            }
            /** Removes a column definition that was not included as part of the content children. */

          }, {
            key: "removeColumnDef",
            value: function removeColumnDef(columnDef) {
              this._customColumnDefs["delete"](columnDef);
            }
            /** Adds a row definition that was not included as part of the content children. */

          }, {
            key: "addRowDef",
            value: function addRowDef(rowDef) {
              this._customRowDefs.add(rowDef);
            }
            /** Removes a row definition that was not included as part of the content children. */

          }, {
            key: "removeRowDef",
            value: function removeRowDef(rowDef) {
              this._customRowDefs["delete"](rowDef);
            }
            /** Adds a header row definition that was not included as part of the content children. */

          }, {
            key: "addHeaderRowDef",
            value: function addHeaderRowDef(headerRowDef) {
              this._customHeaderRowDefs.add(headerRowDef);

              this._headerRowDefChanged = true;
            }
            /** Removes a header row definition that was not included as part of the content children. */

          }, {
            key: "removeHeaderRowDef",
            value: function removeHeaderRowDef(headerRowDef) {
              this._customHeaderRowDefs["delete"](headerRowDef);

              this._headerRowDefChanged = true;
            }
            /** Adds a footer row definition that was not included as part of the content children. */

          }, {
            key: "addFooterRowDef",
            value: function addFooterRowDef(footerRowDef) {
              this._customFooterRowDefs.add(footerRowDef);

              this._footerRowDefChanged = true;
            }
            /** Removes a footer row definition that was not included as part of the content children. */

          }, {
            key: "removeFooterRowDef",
            value: function removeFooterRowDef(footerRowDef) {
              this._customFooterRowDefs["delete"](footerRowDef);

              this._footerRowDefChanged = true;
            }
            /** Sets a no data row definition that was not included as a part of the content children. */

          }, {
            key: "setNoDataRow",
            value: function setNoDataRow(noDataRow) {
              this._customNoDataRow = noDataRow;
            }
            /**
             * Updates the header sticky styles. First resets all applied styles with respect to the cells
             * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
             * automatically called when the header row changes its displayed set of columns, or if its
             * sticky input changes. May be called manually for cases where the cell content changes outside
             * of these events.
             */

          }, {
            key: "updateStickyHeaderRowStyles",
            value: function updateStickyHeaderRowStyles() {
              var headerRows = this._getRenderedRows(this._headerRowOutlet);

              var tableElement = this._elementRef.nativeElement; // Hide the thead element if there are no header rows. This is necessary to satisfy
              // overzealous a11y checkers that fail because the `rowgroup` element does not contain
              // required child `row`.

              var thead = tableElement.querySelector('thead');

              if (thead) {
                thead.style.display = headerRows.length ? '' : 'none';
              }

              var stickyStates = this._headerRowDefs.map(function (def) {
                return def.sticky;
              });

              this._stickyStyler.clearStickyPositioning(headerRows, ['top']);

              this._stickyStyler.stickRows(headerRows, stickyStates, 'top'); // Reset the dirty state of the sticky input change since it has been used.


              this._headerRowDefs.forEach(function (def) {
                return def.resetStickyChanged();
              });
            }
            /**
             * Updates the footer sticky styles. First resets all applied styles with respect to the cells
             * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
             * automatically called when the footer row changes its displayed set of columns, or if its
             * sticky input changes. May be called manually for cases where the cell content changes outside
             * of these events.
             */

          }, {
            key: "updateStickyFooterRowStyles",
            value: function updateStickyFooterRowStyles() {
              var footerRows = this._getRenderedRows(this._footerRowOutlet);

              var tableElement = this._elementRef.nativeElement; // Hide the tfoot element if there are no footer rows. This is necessary to satisfy
              // overzealous a11y checkers that fail because the `rowgroup` element does not contain
              // required child `row`.

              var tfoot = tableElement.querySelector('tfoot');

              if (tfoot) {
                tfoot.style.display = footerRows.length ? '' : 'none';
              }

              var stickyStates = this._footerRowDefs.map(function (def) {
                return def.sticky;
              });

              this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);

              this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');

              this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates); // Reset the dirty state of the sticky input change since it has been used.


              this._footerRowDefs.forEach(function (def) {
                return def.resetStickyChanged();
              });
            }
            /**
             * Updates the column sticky styles. First resets all applied styles with respect to the cells
             * sticking to the left and right. Then sticky styles are added for the left and right according
             * to the column definitions for each cell in each row. This is automatically called when
             * the data source provides a new set of data or when a column definition changes its sticky
             * input. May be called manually for cases where the cell content changes outside of these events.
             */

          }, {
            key: "updateStickyColumnStyles",
            value: function updateStickyColumnStyles() {
              var _this38 = this;

              var headerRows = this._getRenderedRows(this._headerRowOutlet);

              var dataRows = this._getRenderedRows(this._rowOutlet);

              var footerRows = this._getRenderedRows(this._footerRowOutlet); // For tables not using a fixed layout, the column widths may change when new rows are rendered.
              // In a table using a fixed layout, row content won't affect column width, so sticky styles
              // don't need to be cleared unless either the sticky column config changes or one of the row
              // defs change.


              if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {
                // Clear the left and right positioning from all columns in the table across all rows since
                // sticky columns span across all table sections (header, data, footer)
                this._stickyStyler.clearStickyPositioning([].concat(_toConsumableArray(headerRows), _toConsumableArray(dataRows), _toConsumableArray(footerRows)), ['left', 'right']);

                this._stickyColumnStylesNeedReset = false;
              } // Update the sticky styles for each header row depending on the def's sticky state


              headerRows.forEach(function (headerRow, i) {
                _this38._addStickyColumnStyles([headerRow], _this38._headerRowDefs[i]);
              }); // Update the sticky styles for each data row depending on its def's sticky state

              this._rowDefs.forEach(function (rowDef) {
                // Collect all the rows rendered with this row definition.
                var rows = [];

                for (var i = 0; i < dataRows.length; i++) {
                  if (_this38._renderRows[i].rowDef === rowDef) {
                    rows.push(dataRows[i]);
                  }
                }

                _this38._addStickyColumnStyles(rows, rowDef);
              }); // Update the sticky styles for each footer row depending on the def's sticky state


              footerRows.forEach(function (footerRow, i) {
                _this38._addStickyColumnStyles([footerRow], _this38._footerRowDefs[i]);
              }); // Reset the dirty state of the sticky input change since it has been used.

              Array.from(this._columnDefsByName.values()).forEach(function (def) {
                return def.resetStickyChanged();
              });
            }
            /**
             * Get the list of RenderRow objects to render according to the current list of data and defined
             * row definitions. If the previous list already contained a particular pair, it should be reused
             * so that the differ equates their references.
             */

          }, {
            key: "_getAllRenderRows",
            value: function _getAllRenderRows() {
              var renderRows = []; // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
              // new cache while unused ones can be picked up by garbage collection.

              var prevCachedRenderRows = this._cachedRenderRowsMap;
              this._cachedRenderRowsMap = new Map(); // For each data object, get the list of rows that should be rendered, represented by the
              // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.

              for (var i = 0; i < this._data.length; i++) {
                var data = this._data[i];

                var renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));

                if (!this._cachedRenderRowsMap.has(data)) {
                  this._cachedRenderRowsMap.set(data, new WeakMap());
                }

                for (var j = 0; j < renderRowsForData.length; j++) {
                  var renderRow = renderRowsForData[j];

                  var cache = this._cachedRenderRowsMap.get(renderRow.data);

                  if (cache.has(renderRow.rowDef)) {
                    cache.get(renderRow.rowDef).push(renderRow);
                  } else {
                    cache.set(renderRow.rowDef, [renderRow]);
                  }

                  renderRows.push(renderRow);
                }
              }

              return renderRows;
            }
            /**
             * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
             * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
             * `(T, CdkRowDef)` pair.
             */

          }, {
            key: "_getRenderRowsForData",
            value: function _getRenderRowsForData(data, dataIndex, cache) {
              var rowDefs = this._getRowDefs(data, dataIndex);

              return rowDefs.map(function (rowDef) {
                var cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];

                if (cachedRenderRows.length) {
                  var dataRow = cachedRenderRows.shift();
                  dataRow.dataIndex = dataIndex;
                  return dataRow;
                } else {
                  return {
                    data: data,
                    rowDef: rowDef,
                    dataIndex: dataIndex
                  };
                }
              });
            }
            /** Update the map containing the content's column definitions. */

          }, {
            key: "_cacheColumnDefs",
            value: function _cacheColumnDefs() {
              var _this39 = this;

              this._columnDefsByName.clear();

              var columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);
              columnDefs.forEach(function (columnDef) {
                if (_this39._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                  throw getTableDuplicateColumnNameError(columnDef.name);
                }

                _this39._columnDefsByName.set(columnDef.name, columnDef);
              });
            }
            /** Update the list of all available row definitions that can be used. */

          }, {
            key: "_cacheRowDefs",
            value: function _cacheRowDefs() {
              this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);
              this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);
              this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs); // After all row definitions are determined, find the row definition to be considered default.

              var defaultRowDefs = this._rowDefs.filter(function (def) {
                return !def.when;
              });

              if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getTableMultipleDefaultRowDefsError();
              }

              this._defaultRowDef = defaultRowDefs[0];
            }
            /**
             * Check if the header, data, or footer rows have changed what columns they want to display or
             * whether the sticky states have changed for the header or footer. If there is a diff, then
             * re-render that section.
             */

          }, {
            key: "_renderUpdatedColumns",
            value: function _renderUpdatedColumns() {
              var columnsDiffReducer = function columnsDiffReducer(acc, def) {
                return acc || !!def.getColumnsDiff();
              }; // Force re-render data rows if the list of column definitions have changed.


              var dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);

              if (dataColumnsChanged) {
                this._forceRenderDataRows();
              } // Force re-render header/footer rows if the list of column definitions have changed.


              var headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);

              if (headerColumnsChanged) {
                this._forceRenderHeaderRows();
              }

              var footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);

              if (footerColumnsChanged) {
                this._forceRenderFooterRows();
              }

              return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;
            }
            /**
             * Switch to the provided data source by resetting the data and unsubscribing from the current
             * render change subscription if one exists. If the data source is null, interpret this by
             * clearing the row outlet. Otherwise start listening for new data.
             */

          }, {
            key: "_switchDataSource",
            value: function _switchDataSource(dataSource) {
              this._data = [];

              if ((0, _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__.isDataSource)(this.dataSource)) {
                this.dataSource.disconnect(this);
              } // Stop listening for data from the previous data source.


              if (this._renderChangeSubscription) {
                this._renderChangeSubscription.unsubscribe();

                this._renderChangeSubscription = null;
              }

              if (!dataSource) {
                if (this._dataDiffer) {
                  this._dataDiffer.diff([]);
                }

                this._rowOutlet.viewContainer.clear();
              }

              this._dataSource = dataSource;
            }
            /** Set up a subscription for the data provided by the data source. */

          }, {
            key: "_observeRenderChanges",
            value: function _observeRenderChanges() {
              var _this40 = this;

              // If no data source has been set, there is nothing to observe for changes.
              if (!this.dataSource) {
                return;
              }

              var dataStream;

              if ((0, _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__.isDataSource)(this.dataSource)) {
                dataStream = this.dataSource.connect(this);
              } else if ((0, rxjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(this.dataSource)) {
                dataStream = this.dataSource;
              } else if (Array.isArray(this.dataSource)) {
                dataStream = (0, rxjs__WEBPACK_IMPORTED_MODULE_3__.of)(this.dataSource);
              }

              if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getTableUnknownDataSourceError();
              }

              this._renderChangeSubscription = dataStream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy)).subscribe(function (data) {
                _this40._data = data || [];

                _this40.renderRows();
              });
            }
            /**
             * Clears any existing content in the header row outlet and creates a new embedded view
             * in the outlet using the header row definition.
             */

          }, {
            key: "_forceRenderHeaderRows",
            value: function _forceRenderHeaderRows() {
              var _this41 = this;

              // Clear the header row outlet if any content exists.
              if (this._headerRowOutlet.viewContainer.length > 0) {
                this._headerRowOutlet.viewContainer.clear();
              }

              this._headerRowDefs.forEach(function (def, i) {
                return _this41._renderRow(_this41._headerRowOutlet, def, i);
              });

              this.updateStickyHeaderRowStyles();
            }
            /**
             * Clears any existing content in the footer row outlet and creates a new embedded view
             * in the outlet using the footer row definition.
             */

          }, {
            key: "_forceRenderFooterRows",
            value: function _forceRenderFooterRows() {
              var _this42 = this;

              // Clear the footer row outlet if any content exists.
              if (this._footerRowOutlet.viewContainer.length > 0) {
                this._footerRowOutlet.viewContainer.clear();
              }

              this._footerRowDefs.forEach(function (def, i) {
                return _this42._renderRow(_this42._footerRowOutlet, def, i);
              });

              this.updateStickyFooterRowStyles();
            }
            /** Adds the sticky column styles for the rows according to the columns' stick states. */

          }, {
            key: "_addStickyColumnStyles",
            value: function _addStickyColumnStyles(rows, rowDef) {
              var _this43 = this;

              var columnDefs = Array.from(rowDef.columns || []).map(function (columnName) {
                var columnDef = _this43._columnDefsByName.get(columnName);

                if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                  throw getTableUnknownColumnError(columnName);
                }

                return columnDef;
              });
              var stickyStartStates = columnDefs.map(function (columnDef) {
                return columnDef.sticky;
              });
              var stickyEndStates = columnDefs.map(function (columnDef) {
                return columnDef.stickyEnd;
              });

              this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);
            }
            /** Gets the list of rows that have been rendered in the row outlet. */

          }, {
            key: "_getRenderedRows",
            value: function _getRenderedRows(rowOutlet) {
              var renderedRows = [];

              for (var i = 0; i < rowOutlet.viewContainer.length; i++) {
                var viewRef = rowOutlet.viewContainer.get(i);
                renderedRows.push(viewRef.rootNodes[0]);
              }

              return renderedRows;
            }
            /**
             * Get the matching row definitions that should be used for this row data. If there is only
             * one row definition, it is returned. Otherwise, find the row definitions that has a when
             * predicate that returns true with the data. If none return true, return the default row
             * definition.
             */

          }, {
            key: "_getRowDefs",
            value: function _getRowDefs(data, dataIndex) {
              if (this._rowDefs.length == 1) {
                return [this._rowDefs[0]];
              }

              var rowDefs = [];

              if (this.multiTemplateDataRows) {
                rowDefs = this._rowDefs.filter(function (def) {
                  return !def.when || def.when(dataIndex, data);
                });
              } else {
                var rowDef = this._rowDefs.find(function (def) {
                  return def.when && def.when(dataIndex, data);
                }) || this._defaultRowDef;

                if (rowDef) {
                  rowDefs.push(rowDef);
                }
              }

              if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getTableMissingMatchingRowDefError(data);
              }

              return rowDefs;
            }
          }, {
            key: "_getEmbeddedViewArgs",
            value: function _getEmbeddedViewArgs(renderRow, index) {
              var rowDef = renderRow.rowDef;
              var context = {
                $implicit: renderRow.data
              };
              return {
                templateRef: rowDef.template,
                context: context,
                index: index
              };
            }
            /**
             * Creates a new row template in the outlet and fills it with the set of cell templates.
             * Optionally takes a context to provide to the row and cells, as well as an optional index
             * of where to place the new row template in the outlet.
             */

          }, {
            key: "_renderRow",
            value: function _renderRow(outlet, rowDef, index) {
              var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
              var view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);

              this._renderCellTemplateForItem(rowDef, context);

              return view;
            }
          }, {
            key: "_renderCellTemplateForItem",
            value: function _renderCellTemplateForItem(rowDef, context) {
              var _iterator14 = _createForOfIteratorHelper(this._getCellTemplates(rowDef)),
                  _step14;

              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var cellTemplate = _step14.value;

                  if (_CdkCellOutlet.mostRecentCellOutlet) {
                    _CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
                  }
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }

              this._changeDetectorRef.markForCheck();
            }
            /**
             * Updates the index-related context for each row to reflect any changes in the index of the rows,
             * e.g. first/last/even/odd.
             */

          }, {
            key: "_updateRowIndexContext",
            value: function _updateRowIndexContext() {
              var viewContainer = this._rowOutlet.viewContainer;

              for (var renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
                var viewRef = viewContainer.get(renderIndex);
                var context = viewRef.context;
                context.count = count;
                context.first = renderIndex === 0;
                context.last = renderIndex === count - 1;
                context.even = renderIndex % 2 === 0;
                context.odd = !context.even;

                if (this.multiTemplateDataRows) {
                  context.dataIndex = this._renderRows[renderIndex].dataIndex;
                  context.renderIndex = renderIndex;
                } else {
                  context.index = this._renderRows[renderIndex].dataIndex;
                }
              }
            }
            /** Gets the column definitions for the provided row def. */

          }, {
            key: "_getCellTemplates",
            value: function _getCellTemplates(rowDef) {
              var _this44 = this;

              if (!rowDef || !rowDef.columns) {
                return [];
              }

              return Array.from(rowDef.columns, function (columnId) {
                var column = _this44._columnDefsByName.get(columnId);

                if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                  throw getTableUnknownColumnError(columnId);
                }

                return rowDef.extractCellTemplate(column);
              });
            }
            /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */

          }, {
            key: "_applyNativeTableSections",
            value: function _applyNativeTableSections() {
              var documentFragment = this._document.createDocumentFragment();

              var sections = [{
                tag: 'thead',
                outlets: [this._headerRowOutlet]
              }, {
                tag: 'tbody',
                outlets: [this._rowOutlet, this._noDataRowOutlet]
              }, {
                tag: 'tfoot',
                outlets: [this._footerRowOutlet]
              }];

              for (var _i3 = 0, _sections = sections; _i3 < _sections.length; _i3++) {
                var section = _sections[_i3];

                var element = this._document.createElement(section.tag);

                element.setAttribute('role', 'rowgroup');

                var _iterator15 = _createForOfIteratorHelper(section.outlets),
                    _step15;

                try {
                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                    var outlet = _step15.value;
                    element.appendChild(outlet.elementRef.nativeElement);
                  }
                } catch (err) {
                  _iterator15.e(err);
                } finally {
                  _iterator15.f();
                }

                documentFragment.appendChild(element);
              } // Use a DocumentFragment so we don't hit the DOM on each iteration.


              this._elementRef.nativeElement.appendChild(documentFragment);
            }
            /**
             * Forces a re-render of the data rows. Should be called in cases where there has been an input
             * change that affects the evaluation of which rows should be rendered, e.g. toggling
             * `multiTemplateDataRows` or adding/removing row definitions.
             */

          }, {
            key: "_forceRenderDataRows",
            value: function _forceRenderDataRows() {
              this._dataDiffer.diff([]);

              this._rowOutlet.viewContainer.clear();

              this.renderRows();
            }
            /**
             * Checks if there has been a change in sticky states since last check and applies the correct
             * sticky styles. Since checking resets the "dirty" state, this should only be performed once
             * during a change detection and after the inputs are settled (after content check).
             */

          }, {
            key: "_checkStickyStates",
            value: function _checkStickyStates() {
              var stickyCheckReducer = function stickyCheckReducer(acc, d) {
                return acc || d.hasStickyChanged();
              }; // Note that the check needs to occur for every definition since it notifies the definition
              // that it can reset its dirty state. Using another operator like `some` may short-circuit
              // remaining definitions and leave them in an unchecked state.


              if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
                this.updateStickyHeaderRowStyles();
              }

              if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
                this.updateStickyFooterRowStyles();
              }

              if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
                this._stickyColumnStylesNeedReset = true;
                this.updateStickyColumnStyles();
              }
            }
            /**
             * Creates the sticky styler that will be used for sticky rows and columns. Listens
             * for directionality changes and provides the latest direction to the styler. Re-applies column
             * stickiness when directionality changes.
             */

          }, {
            key: "_setupStickyStyler",
            value: function _setupStickyStyler() {
              var _this45 = this;

              var direction = this._dir ? this._dir.value : 'ltr';
              this._stickyStyler = new _StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);
              (this._dir ? this._dir.change : (0, rxjs__WEBPACK_IMPORTED_MODULE_3__.of)()).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy)).subscribe(function (value) {
                _this45._stickyStyler.direction = value;

                _this45.updateStickyColumnStyles();
              });
            }
            /** Filters definitions that belong to this table from a QueryList. */

          }, {
            key: "_getOwnDefs",
            value: function _getOwnDefs(items) {
              var _this46 = this;

              return items.filter(function (item) {
                return !item._table || item._table === _this46;
              });
            }
            /** Creates or removes the no data row, depending on whether any data is being shown. */

          }, {
            key: "_updateNoDataRow",
            value: function _updateNoDataRow() {
              var noDataRow = this._customNoDataRow || this._noDataRow;

              if (noDataRow) {
                var shouldShow = this._rowOutlet.viewContainer.length === 0;

                if (shouldShow !== this._isShowingNoDataRow) {
                  var container = this._noDataRowOutlet.viewContainer;
                  shouldShow ? container.createEmbeddedView(noDataRow.templateRef) : container.clear();
                  this._isShowingNoDataRow = shouldShow;
                }
              }
            }
          }]);

          return CdkTable;
        }();

        CdkTable.ɵfac = function CdkTable_Factory(t) {
          return new (t || CdkTable)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinjectAttribute"]('role'), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__._VIEW_REPEATER_STRATEGY, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_COALESCED_STYLE_SCHEDULER2, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_STICKY_POSITIONING_LISTENER, 12), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ViewportRuler, 8));
        };

        CdkTable.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkTable,
          selectors: [["cdk-table"], ["table", "cdk-table", ""]],
          contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkNoDataRow, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkColumnDef, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkRowDef, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkHeaderRowDef, 5);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _CdkFooterRowDef, 5);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._noDataRow = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentColumnDefs = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentRowDefs = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentHeaderRowDefs = _t);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentFooterRowDefs = _t);
            }
          },
          viewQuery: function CdkTable_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_DataRowOutlet, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_HeaderRowOutlet, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_FooterRowOutlet, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_NoDataRowOutlet, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._rowOutlet = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._headerRowOutlet = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._footerRowOutlet = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._noDataRowOutlet = _t.first);
            }
          },
          hostAttrs: [1, "cdk-table"],
          hostVars: 2,
          hostBindings: function CdkTable_HostBindings(rf, ctx) {
            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("cdk-table-fixed-layout", ctx.fixedLayout);
            }
          },
          inputs: {
            trackBy: "trackBy",
            dataSource: "dataSource",
            multiTemplateDataRows: "multiTemplateDataRows",
            fixedLayout: "fixedLayout"
          },
          exportAs: ["cdkTable"],
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
            provide: _CDK_TABLE,
            useExisting: CdkTable
          }, {
            provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__._VIEW_REPEATER_STRATEGY,
            useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_1__._DisposeViewRepeaterStrategy
          }, {
            provide: _COALESCED_STYLE_SCHEDULER2,
            useClass: _CoalescedStyleScheduler2
          }, // Prevent nested tables from seeing this table's StickyPositioningListener.
          {
            provide: _STICKY_POSITIONING_LISTENER,
            useValue: null
          }])],
          ngContentSelectors: _c1,
          decls: 6,
          vars: 0,
          consts: [["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
          template: function CdkTable_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"](_c0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](1, 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](2, 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](3, 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](4, 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](5, 3);
            }
          },
          directives: [_HeaderRowOutlet, _DataRowOutlet, _NoDataRowOutlet, _FooterRowOutlet],
          styles: [".cdk-table-fixed-layout{table-layout:fixed}\n"],
          encapsulation: 2
        });
        return CdkTable;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** Utility function that gets a merged list of the entries in an array and values of a Set. */


      function mergeArrayAndSet(array, set) {
        return array.concat(Array.from(set));
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Column that simply shows text content for the header and row cells. Assumes that the table
       * is using the native table implementation (`<table>`).
       *
       * By default, the name of this column will be the header text and data property accessor.
       * The header text can be overridden with the `headerText` input. Cell values can be overridden with
       * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
       * input.
       */


      var _CdkTextColumn = /*#__PURE__*/function () {
        var CdkTextColumn = /*#__PURE__*/function () {
          function CdkTextColumn( // `CdkTextColumn` is always requiring a table, but we just assert it manually
          // for better error reporting.
          // tslint:disable-next-line: lightweight-tokens
          _table, _options) {
            _classCallCheck(this, CdkTextColumn);

            this._table = _table;
            this._options = _options;
            /** Alignment of the cell values. */

            this.justify = 'start';
            this._options = _options || {};
          }
          /** Column name that should be used to reference this column. */


          _createClass(CdkTextColumn, [{
            key: "name",
            get: function get() {
              return this._name;
            },
            set: function set(name) {
              this._name = name; // With Ivy, inputs can be initialized before static query results are
              // available. In that case, we defer the synchronization until "ngOnInit" fires.

              this._syncColumnDefName();
            }
          }, {
            key: "ngOnInit",
            value: function ngOnInit() {
              this._syncColumnDefName();

              if (this.headerText === undefined) {
                this.headerText = this._createDefaultHeaderText();
              }

              if (!this.dataAccessor) {
                this.dataAccessor = this._options.defaultDataAccessor || function (data, name) {
                  return data[name];
                };
              }

              if (this._table) {
                // Provide the cell and headerCell directly to the table with the static `ViewChild` query,
                // since the columnDef will not pick up its content by the time the table finishes checking
                // its content and initializing the rows.
                this.columnDef.cell = this.cell;
                this.columnDef.headerCell = this.headerCell;

                this._table.addColumnDef(this.columnDef);
              } else if (typeof ngDevMode === 'undefined' || ngDevMode) {
                throw getTableTextColumnMissingParentTableError();
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              if (this._table) {
                this._table.removeColumnDef(this.columnDef);
              }
            }
            /**
             * Creates a default header text. Use the options' header text transformation function if one
             * has been provided. Otherwise simply capitalize the column name.
             */

          }, {
            key: "_createDefaultHeaderText",
            value: function _createDefaultHeaderText() {
              var name = this.name;

              if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getTableTextColumnMissingNameError();
              }

              if (this._options && this._options.defaultHeaderTextTransform) {
                return this._options.defaultHeaderTextTransform(name);
              }

              return name[0].toUpperCase() + name.slice(1);
            }
            /** Synchronizes the column definition name with the text column name. */

          }, {
            key: "_syncColumnDefName",
            value: function _syncColumnDefName() {
              if (this.columnDef) {
                this.columnDef.name = this.name;
              }
            }
          }]);

          return CdkTextColumn;
        }();

        CdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) {
          return new (t || CdkTextColumn)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkTable, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_TEXT_COLUMN_OPTIONS, 8));
        };

        CdkTextColumn.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
          type: CdkTextColumn,
          selectors: [["cdk-text-column"]],
          viewQuery: function CdkTextColumn_Query(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_CdkColumnDef, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_CdkCellDef, 7);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_CdkHeaderCellDef, 7);
            }

            if (rf & 2) {
              var _t;

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.columnDef = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.cell = _t.first);
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.headerCell = _t.first);
            }
          },
          inputs: {
            justify: "justify",
            name: "name",
            headerText: "headerText",
            dataAccessor: "dataAccessor"
          },
          decls: 3,
          vars: 0,
          consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]],
          template: function CdkTextColumn_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0, 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CdkTextColumn_th_1_Template, 2, 3, "th", 1);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);

              _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
            }
          },
          directives: [_CdkColumnDef, _CdkHeaderCellDef, _CdkCellDef, _CdkHeaderCell, _CdkCell],
          encapsulation: 2
        });
        return CdkTextColumn;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var EXPORTED_DECLARATIONS = [_CdkTable, _CdkRowDef, _CdkCellDef, _CdkCellOutlet, _CdkHeaderCellDef, _CdkFooterCellDef, _CdkColumnDef, _CdkCell, _CdkRow, _CdkHeaderCell, _CdkFooterCell, _CdkHeaderRow, _CdkHeaderRowDef, _CdkFooterRow, _CdkFooterRowDef, _DataRowOutlet, _HeaderRowOutlet, _FooterRowOutlet, _CdkTextColumn, _CdkNoDataRow, _NoDataRowOutlet];

      var _CdkTableModule = /*#__PURE__*/function () {
        var CdkTableModule = function CdkTableModule() {
          _classCallCheck(this, CdkTableModule);
        };

        CdkTableModule.ɵfac = function CdkTableModule_Factory(t) {
          return new (t || CdkTableModule)();
        };

        CdkTableModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: CdkTableModule
        });
        CdkTableModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          imports: [[_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ScrollingModule]]
        });
        return CdkTableModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_CdkTableModule, {
          declarations: function declarations() {
            return [_CdkTable, _CdkRowDef, _CdkCellDef, _CdkCellOutlet, _CdkHeaderCellDef, _CdkFooterCellDef, _CdkColumnDef, _CdkCell, _CdkRow, _CdkHeaderCell, _CdkFooterCell, _CdkHeaderRow, _CdkHeaderRowDef, _CdkFooterRow, _CdkFooterRowDef, _DataRowOutlet, _HeaderRowOutlet, _FooterRowOutlet, _CdkTextColumn, _CdkNoDataRow, _NoDataRowOutlet];
          },
          imports: function imports() {
            return [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ScrollingModule];
          },
          exports: function exports() {
            return [_CdkTable, _CdkRowDef, _CdkCellDef, _CdkCellOutlet, _CdkHeaderCellDef, _CdkFooterCellDef, _CdkColumnDef, _CdkCell, _CdkRow, _CdkHeaderCell, _CdkFooterCell, _CdkHeaderRow, _CdkHeaderRowDef, _CdkFooterRow, _CdkFooterRowDef, _DataRowOutlet, _HeaderRowOutlet, _FooterRowOutlet, _CdkTextColumn, _CdkNoDataRow, _NoDataRowOutlet];
          }
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    }
  }]);
})();
//# sourceMappingURL=node_modules_angular_cdk_fesm2015_table_js-_50fc0-es5.900aeae437c73ab3c14e.js.map