"use strict";
(self["webpackChunkshell"] = self["webpackChunkshell"] || []).push([["node_modules_angular-svg-icon_fesm2015_angular-svg-icon_js-_85731"],{

/***/ 48622:
/*!********************************************************************!*\
  !*** ./node_modules/angular-svg-icon/fesm2015/angular-svg-icon.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngularSvgIconModule": function() { return /* binding */ AngularSvgIconModule; },
/* harmony export */   "SERVER_URL": function() { return /* binding */ SERVER_URL; },
/* harmony export */   "SVG_ICON_REGISTRY_PROVIDER": function() { return /* binding */ SVG_ICON_REGISTRY_PROVIDER; },
/* harmony export */   "SVG_ICON_REGISTRY_PROVIDER_FACTORY": function() { return /* binding */ SVG_ICON_REGISTRY_PROVIDER_FACTORY; },
/* harmony export */   "SvgHttpLoader": function() { return /* binding */ SvgHttpLoader; },
/* harmony export */   "SvgIconComponent": function() { return /* binding */ SvgIconComponent; },
/* harmony export */   "SvgIconRegistryService": function() { return /* binding */ SvgIconRegistryService; },
/* harmony export */   "SvgLoader": function() { return /* binding */ SvgLoader; }
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 14468);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 1090);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 71180);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 92343);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common/http */ 12445);
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_angular_common_http__WEBPACK_IMPORTED_MODULE_4__);







const _c0 = ["*"];

class SvgLoader {}

let SvgHttpLoader = /*#__PURE__*/(() => {
  class SvgHttpLoader extends SvgLoader {
    constructor(http) {
      super();
      this.http = http;
    }

    getSvg(url) {
      return this.http.get(url, {
        responseType: 'text'
      });
    }

  }

  SvgHttpLoader.ɵfac = function SvgHttpLoader_Factory(t) {
    return new (t || SvgHttpLoader)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_4__.HttpClient));
  };

  SvgHttpLoader.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: SvgHttpLoader,
    factory: SvgHttpLoader.ɵfac
  });
  return SvgHttpLoader;
})();

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

const SERVER_URL = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('SERVER_URL');
let SvgIconRegistryService = /*#__PURE__*/(() => {
  class SvgIconRegistryService {
    constructor(loader, platformId, serverUrl, _document) {
      this.loader = loader;
      this.platformId = platformId;
      this.serverUrl = serverUrl;
      this._document = _document;
      this.iconsByUrl = new Map();
      this.iconsLoadingByUrl = new Map();
      this.document = this._document;
    }
    /** Add a SVG to the registry by passing a name and the SVG. */


    addSvg(name, data) {
      if (!this.iconsByUrl.has(name)) {
        const div = this.document.createElement('DIV');
        div.innerHTML = data;
        const svg = div.querySelector('svg');
        this.iconsByUrl.set(name, svg);
      }
    }
    /** Load a SVG to the registry from a URL. */


    loadSvg(url, name = url) {
      // not sure if there should be a possibility to use name for server usage
      // so overriding it for now if provided
      // maybe should separate functionality for url and name use-cases
      if (this.serverUrl && url.match(/^(http(s)?):/) === null) {
        url = this.serverUrl + url;
        name = url;
      }

      if (this.iconsByUrl.has(name)) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.iconsByUrl.get(name));
      } else if (this.iconsLoadingByUrl.has(name)) {
        return this.iconsLoadingByUrl.get(name);
      }

      const o = this.loader.getSvg(url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(svg => {
        const div = this.document.createElement('DIV');
        div.innerHTML = svg;
        return div.querySelector('svg');
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(svg => this.iconsByUrl.set(name, svg)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.catchError)(err => {
        console.error(err);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.throwError)(err);
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.finalize)(() => this.iconsLoadingByUrl.delete(name)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.share)());
      this.iconsLoadingByUrl.set(name, o);
      return o;
    }
    /** Get loaded SVG from registry by name. (also works by url because of blended map) */


    getSvgByName(name) {
      if (this.iconsByUrl.has(name)) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.iconsByUrl.get(name));
      } else if (this.iconsLoadingByUrl.has(name)) {
        return this.iconsLoadingByUrl.get(name);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.throwError)(`No svg with name '${name}' has been loaded`);
    }
    /** Remove a SVG from the registry by URL (or name). */


    unloadSvg(url) {
      if (this.iconsByUrl.has(url)) {
        this.iconsByUrl.delete(url);
      }
    }

  }

  SvgIconRegistryService.ɵfac = function SvgIconRegistryService_Factory(t) {
    return new (t || SvgIconRegistryService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](SvgLoader), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](SERVER_URL, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT, 8));
  };

  SvgIconRegistryService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: SvgIconRegistryService,
    factory: SvgIconRegistryService.ɵfac
  });
  return SvgIconRegistryService;
})();

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, loader, platformId, serverUrl, document) {
  return parentRegistry || new SvgIconRegistryService(loader, platformId, serverUrl, document);
}

const SVG_ICON_REGISTRY_PROVIDER = {
  provide: SvgIconRegistryService,
  deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), SvgIconRegistryService], SvgLoader, [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID], [new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), SERVER_URL], [new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), _angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]],
  useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
};

class SvgIconHelper {
  constructor() {
    this.loaded = false;
  }

}

let SvgIconComponent = /*#__PURE__*/(() => {
  class SvgIconComponent {
    constructor(element, differs, renderer, iconReg, cdr) {
      this.element = element;
      this.differs = differs;
      this.renderer = renderer;
      this.iconReg = iconReg;
      this.cdr = cdr;
      this.stretch = false;
      this.applyClass = false;
      /** @deprecated since 9.1.0 */

      this.applyCss = false;
      this.helper = new SvgIconHelper();
      this._svgStyle = null;
    } // Adapted from ngStyle (see:  angular/packages/common/src/directives/ng_style.ts)


    set svgStyle(values) {
      this._svgStyle = values;

      if (!this.helper.differ && values) {
        this.helper.differ = this.differs.find(values).create();
      }
    }

    ngOnInit() {
      this.init();
    }

    ngOnDestroy() {
      this.destroy();
    }

    ngOnChanges(changeRecord) {
      const elemSvg = this.element.nativeElement.firstChild;

      if (changeRecord.src || changeRecord.name) {
        if (this.helper.loaded) {
          this.destroy();
        }

        this.init();
      }

      if (changeRecord.stretch) {
        this.stylize();
      }

      if (changeRecord.applyClass) {
        if (this.applyClass) {
          this.setClass(elemSvg, null, this.klass);
        } else {
          this.setClass(elemSvg, this.klass, null);
        }
      }

      if (changeRecord.svgClass) {
        this.setClass(elemSvg, changeRecord.svgClass.previousValue, changeRecord.svgClass.currentValue);
      }

      if (changeRecord.klass) {
        const elem = this.element.nativeElement;
        this.setClass(elem, changeRecord.klass.previousValue, changeRecord.klass.currentValue);

        if (this.applyClass) {
          this.setClass(elemSvg, changeRecord.klass.previousValue, changeRecord.klass.currentValue);
        } else {
          this.setClass(elemSvg, changeRecord.klass.previousValue, null);
        }
      }

      if (changeRecord.viewBox) {
        if (this.helper.loaded) {
          this.destroy();
        }

        this.init();
      }

      if (changeRecord.applyCss) {
        console.warn('applyCss deprecated since 9.1.0, will be removed in 10.0.0');
        console.warn('use applyClass instead');
      }

      if (changeRecord.svgAriaLabel) {
        this.doAria(changeRecord.svgAriaLabel.currentValue);
      }
    }

    ngDoCheck() {
      if (this.helper.svg && this.helper.differ) {
        const changes = this.helper.differ.diff(this._svgStyle);

        if (changes) {
          this.applyChanges(changes);
        }
      }
    }

    init() {
      if (this.name) {
        const svgObs = this.iconReg.getSvgByName(this.name);

        if (svgObs) {
          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));
        }
      } else if (this.src) {
        const svgObs = this.iconReg.loadSvg(this.src);

        if (svgObs) {
          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));
        }
      } else {
        const elem = this.element.nativeElement;
        elem.innerHTML = '';
        this.cdr.markForCheck();
      }
    }

    initSvg(svg) {
      if (!this.helper.loaded && svg) {
        this.setSvg(svg);
        this.resetDiffer();
      }
    }

    destroy() {
      if (this.helper.icnSub) {
        this.helper.icnSub.unsubscribe();
      }

      this.helper = new SvgIconHelper();
    }

    resetDiffer() {
      if (this._svgStyle && !this.helper.differ) {
        this.helper.differ = this.differs.find(this._svgStyle).create();
      }
    }

    setSvg(svg) {
      if (!this.helper.loaded && svg) {
        this.helper.svg = svg;
        const icon = svg.cloneNode(true);
        const elem = this.element.nativeElement;
        elem.innerHTML = '';
        this.renderer.appendChild(elem, icon);
        this.helper.loaded = true;
        this.copyNgContentAttribute(elem, icon);

        if (this.klass && this.applyClass) {
          this.setClass(elem.firstChild, null, this.klass);
        }

        if (this.svgClass) {
          this.setClass(elem.firstChild, null, this.svgClass);
        }

        if (this.viewBox) {
          if (this.viewBox === 'auto') {
            // Attempt to convert height & width to a viewBox.
            const w = icon.getAttribute('width');
            const h = icon.getAttribute('height');

            if (h && w) {
              const vb = `0 0 ${w} ${h}`;
              this.renderer.setAttribute(icon, 'viewBox', vb);
              this.renderer.removeAttribute(icon, 'width');
              this.renderer.removeAttribute(icon, 'height');
            }
          } else if (this.viewBox !== '') {
            this.renderer.setAttribute(icon, 'viewBox', this.viewBox);
            this.renderer.removeAttribute(icon, 'width');
            this.renderer.removeAttribute(icon, 'height');
          }
        }

        this.stylize(); // If there is not a svgAriaLabel and the SVG has an arial-label, then do not override
        // the SVG's aria-label.

        if (!(this.svgAriaLabel === undefined && elem.firstChild.hasAttribute('aria-label'))) {
          this.doAria(this.svgAriaLabel || '');
        }

        this.cdr.markForCheck();
      }
    }

    copyNgContentAttribute(hostElem, icon) {
      const attributes = hostElem.attributes;
      const len = attributes.length;

      for (let i = 0; i < len; i += 1) {
        const attribute = attributes.item(i);

        if (attribute && attribute.name.startsWith('_ngcontent')) {
          this.setNgContentAttribute(icon, attribute.name);
          break;
        }
      }
    }

    setNgContentAttribute(parent, attributeName) {
      this.renderer.setAttribute(parent, attributeName, '');
      const len = parent.childNodes.length;

      for (let i = 0; i < len; i += 1) {
        const child = parent.childNodes[i];

        if (child instanceof Element) {
          this.setNgContentAttribute(child, attributeName);
        }
      }
    }

    stylize() {
      if (this.helper.svg) {
        const svg = this.element.nativeElement.firstChild;

        if (this.stretch === true) {
          this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
        } else if (this.stretch === false) {
          this.renderer.removeAttribute(svg, 'preserveAspectRatio');
        }
      }
    }

    applyChanges(changes) {
      changes.forEachRemovedItem(record => this.setStyle(record.key, null));
      changes.forEachAddedItem(record => this.setStyle(record.key, record.currentValue));
      changes.forEachChangedItem(record => this.setStyle(record.key, record.currentValue));
    }

    setStyle(nameAndUnit, value) {
      const [name, unit] = nameAndUnit.split('.');
      value = value !== null && unit ? `${value}${unit}` : value;
      const svg = this.element.nativeElement.firstChild;

      if (value !== null) {
        this.renderer.setStyle(svg, name, value);
      } else {
        this.renderer.removeStyle(svg, name);
      }
    }

    setClass(target, previous, current) {
      if (target) {
        if (previous) {
          const klasses = Array.isArray(previous) ? previous : previous.split(' ');

          for (const k of klasses) {
            this.renderer.removeClass(target, k);
          }
        }

        if (current) {
          const klasses = Array.isArray(current) ? current : current.split(' ');

          for (const k of klasses) {
            this.renderer.addClass(target, k);
          }
        }
      }
    }

    doAria(label) {
      const svg = this.element.nativeElement.firstChild;

      if (svg) {
        if (label === '') {
          this.renderer.setAttribute(svg, 'aria-hidden', 'true');
          this.renderer.removeAttribute(svg, 'aria-label');
        } else {
          this.renderer.removeAttribute(svg, 'aria-hidden');
          this.renderer.setAttribute(svg, 'aria-label', label);
        }
      }
    }

  }

  SvgIconComponent.ɵfac = function SvgIconComponent_Factory(t) {
    return new (t || SvgIconComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.KeyValueDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](SvgIconRegistryService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
  };

  SvgIconComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: SvgIconComponent,
    selectors: [["svg-icon"]],
    inputs: {
      stretch: "stretch",
      applyClass: "applyClass",
      applyCss: "applyCss",
      svgStyle: "svgStyle",
      src: "src",
      name: "name",
      svgClass: "svgClass",
      klass: ["class", "klass"],
      viewBox: "viewBox",
      svgAriaLabel: "svgAriaLabel"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function SvgIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2
  });
  return SvgIconComponent;
})();

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

let AngularSvgIconModule = /*#__PURE__*/(() => {
  class AngularSvgIconModule {
    static forRoot(config = {}) {
      return {
        ngModule: AngularSvgIconModule,
        providers: [SVG_ICON_REGISTRY_PROVIDER, config.loader || {
          provide: SvgLoader,
          useClass: SvgHttpLoader
        }]
      };
    }

  }

  AngularSvgIconModule.ɵfac = function AngularSvgIconModule_Factory(t) {
    return new (t || AngularSvgIconModule)();
  };

  AngularSvgIconModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: AngularSvgIconModule
  });
  AngularSvgIconModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
  });
  return AngularSvgIconModule;
})();

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](AngularSvgIconModule, {
    declarations: function () {
      return [SvgIconComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
    },
    exports: function () {
      return [SvgIconComponent];
    }
  });
})();
/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=node_modules_angular-svg-icon_fesm2015_angular-svg-icon_js-_85731-es2015.c37f858c89d04bd9613b.js.map