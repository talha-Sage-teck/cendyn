(function () {
  "use strict";

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  (self["webpackChunkshell"] = self["webpackChunkshell"] || []).push([["node_modules_angular_cdk_fesm2015_observers_js-_208d1"], {
    /***/
    41494: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "CdkObserveContent": function CdkObserveContent() {
          return (
            /* binding */
            _CdkObserveContent
          );
        },

        /* harmony export */
        "ContentObserver": function ContentObserver() {
          return (
            /* binding */
            _ContentObserver
          );
        },

        /* harmony export */
        "MutationObserverFactory": function MutationObserverFactory() {
          return (
            /* binding */
            _MutationObserverFactory
          );
        },

        /* harmony export */
        "ObserversModule": function ObserversModule() {
          return (
            /* binding */
            _ObserversModule
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      79933);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_1__);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs/operators */
      92343);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.
       * @docs-private
       */


      var _MutationObserverFactory = /*#__PURE__*/function () {
        var MutationObserverFactory = /*#__PURE__*/function () {
          function MutationObserverFactory() {
            _classCallCheck(this, MutationObserverFactory);
          }

          _createClass(MutationObserverFactory, [{
            key: "create",
            value: function create(callback) {
              return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);
            }
          }]);

          return MutationObserverFactory;
        }();

        MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) {
          return new (t || MutationObserverFactory)();
        };

        MutationObserverFactory.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function MutationObserverFactory_Factory() {
            return new MutationObserverFactory();
          },
          token: MutationObserverFactory,
          providedIn: "root"
        });
        return MutationObserverFactory;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /** An injectable service that allows watching elements for changes to their content. */


      var _ContentObserver = /*#__PURE__*/function () {
        var ContentObserver = /*#__PURE__*/function () {
          function ContentObserver(_mutationObserverFactory) {
            _classCallCheck(this, ContentObserver);

            this._mutationObserverFactory = _mutationObserverFactory;
            /** Keeps track of the existing MutationObservers so they can be reused. */

            this._observedElements = new Map();
          }

          _createClass(ContentObserver, [{
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              var _this = this;

              this._observedElements.forEach(function (_, element) {
                return _this._cleanupObserver(element);
              });
            }
          }, {
            key: "observe",
            value: function observe(elementOrRef) {
              var _this2 = this;

              var element = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceElement)(elementOrRef);
              return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
                var stream = _this2._observeElement(element);

                var subscription = stream.subscribe(observer);
                return function () {
                  subscription.unsubscribe();

                  _this2._unobserveElement(element);
                };
              });
            }
            /**
             * Observes the given element by using the existing MutationObserver if available, or creating a
             * new one if not.
             */

          }, {
            key: "_observeElement",
            value: function _observeElement(element) {
              if (!this._observedElements.has(element)) {
                var stream = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();

                var observer = this._mutationObserverFactory.create(function (mutations) {
                  return stream.next(mutations);
                });

                if (observer) {
                  observer.observe(element, {
                    characterData: true,
                    childList: true,
                    subtree: true
                  });
                }

                this._observedElements.set(element, {
                  observer: observer,
                  stream: stream,
                  count: 1
                });
              } else {
                this._observedElements.get(element).count++;
              }

              return this._observedElements.get(element).stream;
            }
            /**
             * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
             * observing this element.
             */

          }, {
            key: "_unobserveElement",
            value: function _unobserveElement(element) {
              if (this._observedElements.has(element)) {
                this._observedElements.get(element).count--;

                if (!this._observedElements.get(element).count) {
                  this._cleanupObserver(element);
                }
              }
            }
            /** Clean up the underlying MutationObserver for the specified element. */

          }, {
            key: "_cleanupObserver",
            value: function _cleanupObserver(element) {
              if (this._observedElements.has(element)) {
                var _this$_observedElemen = this._observedElements.get(element),
                    observer = _this$_observedElemen.observer,
                    stream = _this$_observedElemen.stream;

                if (observer) {
                  observer.disconnect();
                }

                stream.complete();

                this._observedElements["delete"](element);
              }
            }
          }]);

          return ContentObserver;
        }();

        ContentObserver.ɵfac = function ContentObserver_Factory(t) {
          return new (t || ContentObserver)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MutationObserverFactory));
        };

        ContentObserver.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
          factory: function ContentObserver_Factory() {
            return new ContentObserver((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_MutationObserverFactory));
          },
          token: ContentObserver,
          providedIn: "root"
        });
        return ContentObserver;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Directive that triggers a callback whenever the content of
       * its associated element has changed.
       */


      var _CdkObserveContent = /*#__PURE__*/function () {
        var CdkObserveContent = /*#__PURE__*/function () {
          function CdkObserveContent(_contentObserver, _elementRef, _ngZone) {
            _classCallCheck(this, CdkObserveContent);

            this._contentObserver = _contentObserver;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            /** Event emitted for each change in the element's content. */

            this.event = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
            this._disabled = false;
            this._currentSubscription = null;
          }
          /**
           * Whether observing content is disabled. This option can be used
           * to disconnect the underlying MutationObserver until it is needed.
           */


          _createClass(CdkObserveContent, [{
            key: "disabled",
            get: function get() {
              return this._disabled;
            },
            set: function set(value) {
              this._disabled = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceBooleanProperty)(value);
              this._disabled ? this._unsubscribe() : this._subscribe();
            }
            /** Debounce interval for emitting the changes. */

          }, {
            key: "debounce",
            get: function get() {
              return this._debounce;
            },
            set: function set(value) {
              this._debounce = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(value);

              this._subscribe();
            }
          }, {
            key: "ngAfterContentInit",
            value: function ngAfterContentInit() {
              if (!this._currentSubscription && !this.disabled) {
                this._subscribe();
              }
            }
          }, {
            key: "ngOnDestroy",
            value: function ngOnDestroy() {
              this._unsubscribe();
            }
          }, {
            key: "_subscribe",
            value: function _subscribe() {
              var _this3 = this;

              this._unsubscribe();

              var stream = this._contentObserver.observe(this._elementRef); // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.
              // Consider brining it back inside the zone next time we're making breaking changes.
              // Bringing it back inside can cause things like infinite change detection loops and changed
              // after checked errors if people's code isn't handling it properly.


              this._ngZone.runOutsideAngular(function () {
                _this3._currentSubscription = (_this3.debounce ? stream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.debounceTime)(_this3.debounce)) : stream).subscribe(_this3.event);
              });
            }
          }, {
            key: "_unsubscribe",
            value: function _unsubscribe() {
              var _a;

              (_a = this._currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            }
          }]);

          return CdkObserveContent;
        }();

        CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) {
          return new (t || CdkObserveContent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ContentObserver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        };

        CdkObserveContent.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
          type: CdkObserveContent,
          selectors: [["", "cdkObserveContent", ""]],
          inputs: {
            disabled: ["cdkObserveContentDisabled", "disabled"],
            debounce: "debounce"
          },
          outputs: {
            event: "cdkObserveContent"
          },
          exportAs: ["cdkObserveContent"]
        });
        return CdkObserveContent;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();

      var _ObserversModule = /*#__PURE__*/function () {
        var ObserversModule = function ObserversModule() {
          _classCallCheck(this, ObserversModule);
        };

        ObserversModule.ɵfac = function ObserversModule_Factory(t) {
          return new (t || ObserversModule)();
        };

        ObserversModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
          type: ObserversModule
        });
        ObserversModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
          providers: [_MutationObserverFactory]
        });
        return ObserversModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_ObserversModule, {
          declarations: [_CdkObserveContent],
          exports: [_CdkObserveContent]
        });
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/

    }
  }]);
})();
//# sourceMappingURL=node_modules_angular_cdk_fesm2015_observers_js-_208d1-es5.8aa2c88a3760d6ec2357.js.map