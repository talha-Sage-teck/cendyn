(function () {
  "use strict";

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  (self["webpackChunkshell"] = self["webpackChunkshell"] || []).push([["node_modules_angular_common_fesm2015_http_js-_02b61"], {
    /***/
    18419: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "HTTP_INTERCEPTORS": function HTTP_INTERCEPTORS() {
          return (
            /* binding */
            _HTTP_INTERCEPTORS
          );
        },

        /* harmony export */
        "HttpBackend": function HttpBackend() {
          return (
            /* binding */
            _HttpBackend
          );
        },

        /* harmony export */
        "HttpClient": function HttpClient() {
          return (
            /* binding */
            _HttpClient
          );
        },

        /* harmony export */
        "HttpClientJsonpModule": function HttpClientJsonpModule() {
          return (
            /* binding */
            _HttpClientJsonpModule
          );
        },

        /* harmony export */
        "HttpClientModule": function HttpClientModule() {
          return (
            /* binding */
            _HttpClientModule
          );
        },

        /* harmony export */
        "HttpClientXsrfModule": function HttpClientXsrfModule() {
          return (
            /* binding */
            _HttpClientXsrfModule
          );
        },

        /* harmony export */
        "HttpContext": function HttpContext() {
          return (
            /* binding */
            _HttpContext
          );
        },

        /* harmony export */
        "HttpContextToken": function HttpContextToken() {
          return (
            /* binding */
            _HttpContextToken
          );
        },

        /* harmony export */
        "HttpErrorResponse": function HttpErrorResponse() {
          return (
            /* binding */
            _HttpErrorResponse
          );
        },

        /* harmony export */
        "HttpEventType": function HttpEventType() {
          return (
            /* binding */
            _HttpEventType
          );
        },

        /* harmony export */
        "HttpHandler": function HttpHandler() {
          return (
            /* binding */
            _HttpHandler
          );
        },

        /* harmony export */
        "HttpHeaderResponse": function HttpHeaderResponse() {
          return (
            /* binding */
            _HttpHeaderResponse
          );
        },

        /* harmony export */
        "HttpHeaders": function HttpHeaders() {
          return (
            /* binding */
            _HttpHeaders
          );
        },

        /* harmony export */
        "HttpParams": function HttpParams() {
          return (
            /* binding */
            _HttpParams
          );
        },

        /* harmony export */
        "HttpRequest": function HttpRequest() {
          return (
            /* binding */
            _HttpRequest
          );
        },

        /* harmony export */
        "HttpResponse": function HttpResponse() {
          return (
            /* binding */
            _HttpResponse
          );
        },

        /* harmony export */
        "HttpResponseBase": function HttpResponseBase() {
          return (
            /* binding */
            _HttpResponseBase
          );
        },

        /* harmony export */
        "HttpUrlEncodingCodec": function HttpUrlEncodingCodec() {
          return (
            /* binding */
            _HttpUrlEncodingCodec
          );
        },

        /* harmony export */
        "HttpXhrBackend": function HttpXhrBackend() {
          return (
            /* binding */
            _HttpXhrBackend
          );
        },

        /* harmony export */
        "HttpXsrfTokenExtractor": function HttpXsrfTokenExtractor() {
          return (
            /* binding */
            _HttpXsrfTokenExtractor
          );
        },

        /* harmony export */
        "JsonpClientBackend": function JsonpClientBackend() {
          return (
            /* binding */
            _JsonpClientBackend
          );
        },

        /* harmony export */
        "JsonpInterceptor": function JsonpInterceptor() {
          return (
            /* binding */
            _JsonpInterceptor
          );
        },

        /* harmony export */
        "XhrFactory": function XhrFactory() {
          return (
            /* binding */
            _XhrFactory
          );
        },

        /* harmony export */
        "ɵHttpInterceptingHandler": function ɵHttpInterceptingHandler() {
          return (
            /* binding */
            HttpInterceptingHandler
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_a": function ɵangular_packages_common_http_http_a() {
          return (
            /* binding */
            NoopInterceptor
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_b": function ɵangular_packages_common_http_http_b() {
          return (
            /* binding */
            JsonpCallbackContext
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_c": function ɵangular_packages_common_http_http_c() {
          return (
            /* binding */
            jsonpCallbackContext
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_d": function ɵangular_packages_common_http_http_d() {
          return (
            /* binding */
            XSRF_COOKIE_NAME
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_e": function ɵangular_packages_common_http_http_e() {
          return (
            /* binding */
            XSRF_HEADER_NAME
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_f": function ɵangular_packages_common_http_http_f() {
          return (
            /* binding */
            HttpXsrfCookieExtractor
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_g": function ɵangular_packages_common_http_http_g() {
          return (
            /* binding */
            HttpXsrfInterceptor
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/common */
      1090);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      14468);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs */
      71180);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      92343);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__);
      /**
       * @license Angular v12.1.0
       * (c) 2010-2021 Google LLC. https://angular.io/
       * License: MIT
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
       * `HttpResponse`.
       *
       * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
       * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
       * `HttpBackend`.
       *
       * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
       *
       * @publicApi
       */


      var _HttpHandler = function _HttpHandler() {
        _classCallCheck(this, _HttpHandler);
      };
      /**
       * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
       *
       * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
       *
       * When injected, `HttpBackend` dispatches requests directly to the backend, without going
       * through the interceptor chain.
       *
       * @publicApi
       */


      var _HttpBackend = function _HttpBackend() {
        _classCallCheck(this, _HttpBackend);
      };
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Represents the header configuration options for an HTTP request.
       * Instances are immutable. Modifying methods return a cloned
       * instance with the change. The original object is never changed.
       *
       * @publicApi
       */


      var _HttpHeaders = /*#__PURE__*/function () {
        /**  Constructs a new HTTP header object with the given values.*/
        function _HttpHeaders(headers) {
          var _this = this;

          _classCallCheck(this, _HttpHeaders);

          /**
           * Internal map of lowercased header names to the normalized
           * form of the name (the form seen first).
           */
          this.normalizedNames = new Map();
          /**
           * Queued updates to be materialized the next initialization.
           */

          this.lazyUpdate = null;

          if (!headers) {
            this.headers = new Map();
          } else if (typeof headers === 'string') {
            this.lazyInit = function () {
              _this.headers = new Map();
              headers.split('\n').forEach(function (line) {
                var index = line.indexOf(':');

                if (index > 0) {
                  var name = line.slice(0, index);
                  var key = name.toLowerCase();
                  var value = line.slice(index + 1).trim();

                  _this.maybeSetNormalizedName(name, key);

                  if (_this.headers.has(key)) {
                    _this.headers.get(key).push(value);
                  } else {
                    _this.headers.set(key, [value]);
                  }
                }
              });
            };
          } else {
            this.lazyInit = function () {
              _this.headers = new Map();
              Object.keys(headers).forEach(function (name) {
                var values = headers[name];
                var key = name.toLowerCase();

                if (typeof values === 'string') {
                  values = [values];
                }

                if (values.length > 0) {
                  _this.headers.set(key, values);

                  _this.maybeSetNormalizedName(name, key);
                }
              });
            };
          }
        }
        /**
         * Checks for existence of a given header.
         *
         * @param name The header name to check for existence.
         *
         * @returns True if the header exists, false otherwise.
         */


        _createClass(_HttpHeaders, [{
          key: "has",
          value: function has(name) {
            this.init();
            return this.headers.has(name.toLowerCase());
          }
          /**
           * Retrieves the first value of a given header.
           *
           * @param name The header name.
           *
           * @returns The value string if the header exists, null otherwise
           */

        }, {
          key: "get",
          value: function get(name) {
            this.init();
            var values = this.headers.get(name.toLowerCase());
            return values && values.length > 0 ? values[0] : null;
          }
          /**
           * Retrieves the names of the headers.
           *
           * @returns A list of header names.
           */

        }, {
          key: "keys",
          value: function keys() {
            this.init();
            return Array.from(this.normalizedNames.values());
          }
          /**
           * Retrieves a list of values for a given header.
           *
           * @param name The header name from which to retrieve values.
           *
           * @returns A string of values if the header exists, null otherwise.
           */

        }, {
          key: "getAll",
          value: function getAll(name) {
            this.init();
            return this.headers.get(name.toLowerCase()) || null;
          }
          /**
           * Appends a new value to the existing set of values for a header
           * and returns them in a clone of the original instance.
           *
           * @param name The header name for which to append the values.
           * @param value The value to append.
           *
           * @returns A clone of the HTTP headers object with the value appended to the given header.
           */

        }, {
          key: "append",
          value: function append(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 'a'
            });
          }
          /**
           * Sets or modifies a value for a given header in a clone of the original instance.
           * If the header already exists, its value is replaced with the given value
           * in the returned object.
           *
           * @param name The header name.
           * @param value The value or values to set or overide for the given header.
           *
           * @returns A clone of the HTTP headers object with the newly set header value.
           */

        }, {
          key: "set",
          value: function set(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 's'
            });
          }
          /**
           * Deletes values for a given header in a clone of the original instance.
           *
           * @param name The header name.
           * @param value The value or values to delete for the given header.
           *
           * @returns A clone of the HTTP headers object with the given value deleted.
           */

        }, {
          key: "delete",
          value: function _delete(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 'd'
            });
          }
        }, {
          key: "maybeSetNormalizedName",
          value: function maybeSetNormalizedName(name, lcName) {
            if (!this.normalizedNames.has(lcName)) {
              this.normalizedNames.set(lcName, name);
            }
          }
        }, {
          key: "init",
          value: function init() {
            var _this2 = this;

            if (!!this.lazyInit) {
              if (this.lazyInit instanceof _HttpHeaders) {
                this.copyFrom(this.lazyInit);
              } else {
                this.lazyInit();
              }

              this.lazyInit = null;

              if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) {
                  return _this2.applyUpdate(update);
                });
                this.lazyUpdate = null;
              }
            }
          }
        }, {
          key: "copyFrom",
          value: function copyFrom(other) {
            var _this3 = this;

            other.init();
            Array.from(other.headers.keys()).forEach(function (key) {
              _this3.headers.set(key, other.headers.get(key));

              _this3.normalizedNames.set(key, other.normalizedNames.get(key));
            });
          }
        }, {
          key: "clone",
          value: function clone(update) {
            var clone = new _HttpHeaders();
            clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
            clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
            return clone;
          }
        }, {
          key: "applyUpdate",
          value: function applyUpdate(update) {
            var key = update.name.toLowerCase();

            switch (update.op) {
              case 'a':
              case 's':
                var value = update.value;

                if (typeof value === 'string') {
                  value = [value];
                }

                if (value.length === 0) {
                  return;
                }

                this.maybeSetNormalizedName(update.name, key);
                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, _toConsumableArray(value));
                this.headers.set(key, base);
                break;

              case 'd':
                var toDelete = update.value;

                if (!toDelete) {
                  this.headers["delete"](key);
                  this.normalizedNames["delete"](key);
                } else {
                  var existing = this.headers.get(key);

                  if (!existing) {
                    return;
                  }

                  existing = existing.filter(function (value) {
                    return toDelete.indexOf(value) === -1;
                  });

                  if (existing.length === 0) {
                    this.headers["delete"](key);
                    this.normalizedNames["delete"](key);
                  } else {
                    this.headers.set(key, existing);
                  }
                }

                break;
            }
          }
          /**
           * @internal
           */

        }, {
          key: "forEach",
          value: function forEach(fn) {
            var _this4 = this;

            this.init();
            Array.from(this.normalizedNames.keys()).forEach(function (key) {
              return fn(_this4.normalizedNames.get(key), _this4.headers.get(key));
            });
          }
        }]);

        return _HttpHeaders;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Provides encoding and decoding of URL parameter and query-string values.
       *
       * Serializes and parses URL parameter keys and values to encode and decode them.
       * If you pass URL query parameters without encoding,
       * the query parameters can be misinterpreted at the receiving end.
       *
       *
       * @publicApi
       */


      var _HttpUrlEncodingCodec = /*#__PURE__*/function () {
        function _HttpUrlEncodingCodec() {
          _classCallCheck(this, _HttpUrlEncodingCodec);
        }

        _createClass(_HttpUrlEncodingCodec, [{
          key: "encodeKey",
          value:
          /**
           * Encodes a key name for a URL parameter or query-string.
           * @param key The key name.
           * @returns The encoded key name.
           */
          function encodeKey(key) {
            return standardEncoding(key);
          }
          /**
           * Encodes the value of a URL parameter or query-string.
           * @param value The value.
           * @returns The encoded value.
           */

        }, {
          key: "encodeValue",
          value: function encodeValue(value) {
            return standardEncoding(value);
          }
          /**
           * Decodes an encoded URL parameter or query-string key.
           * @param key The encoded key name.
           * @returns The decoded key name.
           */

        }, {
          key: "decodeKey",
          value: function decodeKey(key) {
            return decodeURIComponent(key);
          }
          /**
           * Decodes an encoded URL parameter or query-string value.
           * @param value The encoded value.
           * @returns The decoded value.
           */

        }, {
          key: "decodeValue",
          value: function decodeValue(value) {
            return decodeURIComponent(value);
          }
        }]);

        return _HttpUrlEncodingCodec;
      }();

      function paramParser(rawParams, codec) {
        var map = new Map();

        if (rawParams.length > 0) {
          // The `window.location.search` can be used while creating an instance of the `HttpParams` class
          // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`
          // may start with the `?` char, so we strip it if it's present.
          var params = rawParams.replace(/^\?/, '').split('&');
          params.forEach(function (param) {
            var eqIdx = param.indexOf('=');

            var _ref = eqIdx == -1 ? [codec.decodeKey(param), ''] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))],
                _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                val = _ref2[1];

            var list = map.get(key) || [];
            list.push(val);
            map.set(key, list);
          });
        }

        return map;
      }

      function standardEncoding(v) {
        return encodeURIComponent(v).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/gi, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%2B/gi, '+').replace(/%3D/gi, '=').replace(/%3F/gi, '?').replace(/%2F/gi, '/');
      }

      function valueToString(value) {
        return "".concat(value);
      }
      /**
       * An HTTP request/response body that represents serialized parameters,
       * per the MIME type `application/x-www-form-urlencoded`.
       *
       * This class is immutable; all mutation operations return a new instance.
       *
       * @publicApi
       */


      var _HttpParams = /*#__PURE__*/function () {
        function _HttpParams() {
          var _this5 = this;

          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpParams);

          this.updates = null;
          this.cloneFrom = null;
          this.encoder = options.encoder || new _HttpUrlEncodingCodec();

          if (!!options.fromString) {
            if (!!options.fromObject) {
              throw new Error("Cannot specify both fromString and fromObject.");
            }

            this.map = paramParser(options.fromString, this.encoder);
          } else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
              var value = options.fromObject[key];

              _this5.map.set(key, Array.isArray(value) ? value : [value]);
            });
          } else {
            this.map = null;
          }
        }
        /**
         * Reports whether the body includes one or more values for a given parameter.
         * @param param The parameter name.
         * @returns True if the parameter has one or more values,
         * false if it has no value or is not present.
         */


        _createClass(_HttpParams, [{
          key: "has",
          value: function has(param) {
            this.init();
            return this.map.has(param);
          }
          /**
           * Retrieves the first value for a parameter.
           * @param param The parameter name.
           * @returns The first value of the given parameter,
           * or `null` if the parameter is not present.
           */

        }, {
          key: "get",
          value: function get(param) {
            this.init();
            var res = this.map.get(param);
            return !!res ? res[0] : null;
          }
          /**
           * Retrieves all values for a  parameter.
           * @param param The parameter name.
           * @returns All values in a string array,
           * or `null` if the parameter not present.
           */

        }, {
          key: "getAll",
          value: function getAll(param) {
            this.init();
            return this.map.get(param) || null;
          }
          /**
           * Retrieves all the parameters for this body.
           * @returns The parameter names in a string array.
           */

        }, {
          key: "keys",
          value: function keys() {
            this.init();
            return Array.from(this.map.keys());
          }
          /**
           * Appends a new value to existing values for a parameter.
           * @param param The parameter name.
           * @param value The new value to add.
           * @return A new body with the appended value.
           */

        }, {
          key: "append",
          value: function append(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 'a'
            });
          }
          /**
           * Constructs a new body with appended values for the given parameter name.
           * @param params parameters and values
           * @return A new body with the new value.
           */

        }, {
          key: "appendAll",
          value: function appendAll(params) {
            var updates = [];
            Object.keys(params).forEach(function (param) {
              var value = params[param];

              if (Array.isArray(value)) {
                value.forEach(function (_value) {
                  updates.push({
                    param: param,
                    value: _value,
                    op: 'a'
                  });
                });
              } else {
                updates.push({
                  param: param,
                  value: value,
                  op: 'a'
                });
              }
            });
            return this.clone(updates);
          }
          /**
           * Replaces the value for a parameter.
           * @param param The parameter name.
           * @param value The new value.
           * @return A new body with the new value.
           */

        }, {
          key: "set",
          value: function set(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 's'
            });
          }
          /**
           * Removes a given value or all values from a parameter.
           * @param param The parameter name.
           * @param value The value to remove, if provided.
           * @return A new body with the given value removed, or with all values
           * removed if no value is specified.
           */

        }, {
          key: "delete",
          value: function _delete(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 'd'
            });
          }
          /**
           * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
           * separated by `&`s.
           */

        }, {
          key: "toString",
          value: function toString() {
            var _this6 = this;

            this.init();
            return this.keys().map(function (key) {
              var eKey = _this6.encoder.encodeKey(key); // `a: ['1']` produces `'a=1'`
              // `b: []` produces `''`
              // `c: ['1', '2']` produces `'c=1&c=2'`


              return _this6.map.get(key).map(function (value) {
                return eKey + '=' + _this6.encoder.encodeValue(value);
              }).join('&');
            }) // filter out empty values because `b: []` produces `''`
            // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't
            .filter(function (param) {
              return param !== '';
            }).join('&');
          }
        }, {
          key: "clone",
          value: function clone(update) {
            var clone = new _HttpParams({
              encoder: this.encoder
            });
            clone.cloneFrom = this.cloneFrom || this;
            clone.updates = (this.updates || []).concat(update);
            return clone;
          }
        }, {
          key: "init",
          value: function init() {
            var _this7 = this;

            if (this.map === null) {
              this.map = new Map();
            }

            if (this.cloneFrom !== null) {
              this.cloneFrom.init();
              this.cloneFrom.keys().forEach(function (key) {
                return _this7.map.set(key, _this7.cloneFrom.map.get(key));
              });
              this.updates.forEach(function (update) {
                switch (update.op) {
                  case 'a':
                  case 's':
                    var base = (update.op === 'a' ? _this7.map.get(update.param) : undefined) || [];
                    base.push(valueToString(update.value));

                    _this7.map.set(update.param, base);

                    break;

                  case 'd':
                    if (update.value !== undefined) {
                      var _base = _this7.map.get(update.param) || [];

                      var idx = _base.indexOf(valueToString(update.value));

                      if (idx !== -1) {
                        _base.splice(idx, 1);
                      }

                      if (_base.length > 0) {
                        _this7.map.set(update.param, _base);
                      } else {
                        _this7.map["delete"](update.param);
                      }
                    } else {
                      _this7.map["delete"](update.param);

                      break;
                    }

                }
              });
              this.cloneFrom = this.updates = null;
            }
          }
        }]);

        return _HttpParams;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A token used to manipulate and access values stored in `HttpContext`.
       *
       * @publicApi
       */


      var _HttpContextToken = function _HttpContextToken(defaultValue) {
        _classCallCheck(this, _HttpContextToken);

        this.defaultValue = defaultValue;
      };
      /**
       * Http context stores arbitrary user defined values and ensures type safety without
       * actually knowing the types. It is backed by a `Map` and guarantees that keys do not clash.
       *
       * This context is mutable and is shared between cloned requests unless explicitly specified.
       *
       * @usageNotes
       *
       * ### Usage Example
       *
       * ```typescript
       * // inside cache.interceptors.ts
       * export const IS_CACHE_ENABLED = new HttpContextToken<boolean>(() => false);
       *
       * export class CacheInterceptor implements HttpInterceptor {
       *
       *   intercept(req: HttpRequest<any>, delegate: HttpHandler): Observable<HttpEvent<any>> {
       *     if (req.context.get(IS_CACHE_ENABLED) === true) {
       *       return ...;
       *     }
       *     return delegate.handle(req);
       *   }
       * }
       *
       * // inside a service
       *
       * this.httpClient.get('/api/weather', {
       *   context: new HttpContext().set(IS_CACHE_ENABLED, true)
       * }).subscribe(...);
       * ```
       *
       * @publicApi
       */


      var _HttpContext = /*#__PURE__*/function () {
        function _HttpContext() {
          _classCallCheck(this, _HttpContext);

          this.map = new Map();
        }
        /**
         * Store a value in the context. If a value is already present it will be overwritten.
         *
         * @param token The reference to an instance of `HttpContextToken`.
         * @param value The value to store.
         *
         * @returns A reference to itself for easy chaining.
         */


        _createClass(_HttpContext, [{
          key: "set",
          value: function set(token, value) {
            this.map.set(token, value);
            return this;
          }
          /**
           * Retrieve the value associated with the given token.
           *
           * @param token The reference to an instance of `HttpContextToken`.
           *
           * @returns The stored value or default if one is defined.
           */

        }, {
          key: "get",
          value: function get(token) {
            if (!this.map.has(token)) {
              this.map.set(token, token.defaultValue());
            }

            return this.map.get(token);
          }
          /**
           * Delete the value associated with the given token.
           *
           * @param token The reference to an instance of `HttpContextToken`.
           *
           * @returns A reference to itself for easy chaining.
           */

        }, {
          key: "delete",
          value: function _delete(token) {
            this.map["delete"](token);
            return this;
          }
          /**
           * @returns a list of tokens currently stored in the context.
           */

        }, {
          key: "keys",
          value: function keys() {
            return this.map.keys();
          }
        }]);

        return _HttpContext;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Determine whether the given HTTP method may include a body.
       */


      function mightHaveBody(method) {
        switch (method) {
          case 'DELETE':
          case 'GET':
          case 'HEAD':
          case 'OPTIONS':
          case 'JSONP':
            return false;

          default:
            return true;
        }
      }
      /**
       * Safely assert whether the given value is an ArrayBuffer.
       *
       * In some execution environments ArrayBuffer is not defined.
       */


      function isArrayBuffer(value) {
        return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
      }
      /**
       * Safely assert whether the given value is a Blob.
       *
       * In some execution environments Blob is not defined.
       */


      function isBlob(value) {
        return typeof Blob !== 'undefined' && value instanceof Blob;
      }
      /**
       * Safely assert whether the given value is a FormData instance.
       *
       * In some execution environments FormData is not defined.
       */


      function isFormData(value) {
        return typeof FormData !== 'undefined' && value instanceof FormData;
      }
      /**
       * Safely assert whether the given value is a URLSearchParams instance.
       *
       * In some execution environments URLSearchParams is not defined.
       */


      function isUrlSearchParams(value) {
        return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;
      }
      /**
       * An outgoing HTTP request with an optional typed body.
       *
       * `HttpRequest` represents an outgoing request, including URL, method,
       * headers, body, and other request configuration options. Instances should be
       * assumed to be immutable. To modify a `HttpRequest`, the `clone`
       * method should be used.
       *
       * @publicApi
       */


      var _HttpRequest = /*#__PURE__*/function () {
        function _HttpRequest(method, url, third, fourth) {
          _classCallCheck(this, _HttpRequest);

          this.url = url;
          /**
           * The request body, or `null` if one isn't set.
           *
           * Bodies are not enforced to be immutable, as they can include a reference to any
           * user-defined data type. However, interceptors should take care to preserve
           * idempotence by treating them as such.
           */

          this.body = null;
          /**
           * Whether this request should be made in a way that exposes progress events.
           *
           * Progress events are expensive (change detection runs on each event) and so
           * they should only be requested if the consumer intends to monitor them.
           */

          this.reportProgress = false;
          /**
           * Whether this request should be sent with outgoing credentials (cookies).
           */

          this.withCredentials = false;
          /**
           * The expected response type of the server.
           *
           * This is used to parse the response appropriately before returning it to
           * the requestee.
           */

          this.responseType = 'json';
          this.method = method.toUpperCase(); // Next, need to figure out which argument holds the HttpRequestInit
          // options, if any.

          var options; // Check whether a body argument is expected. The only valid way to omit
          // the body argument is to use a known no-body method like GET.

          if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = third !== undefined ? third : null;
            options = fourth;
          } else {
            // No body required, options are the third argument. The body stays null.
            options = third;
          } // If options have been passed, interpret them.


          if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials; // Override default response type of 'json' if one is provided.

            if (!!options.responseType) {
              this.responseType = options.responseType;
            } // Override headers if they're provided.


            if (!!options.headers) {
              this.headers = options.headers;
            }

            if (!!options.context) {
              this.context = options.context;
            }

            if (!!options.params) {
              this.params = options.params;
            }
          } // If no headers have been passed in, construct a new HttpHeaders instance.


          if (!this.headers) {
            this.headers = new _HttpHeaders();
          } // If no context have been passed in, construct a new HttpContext instance.


          if (!this.context) {
            this.context = new _HttpContext();
          } // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.


          if (!this.params) {
            this.params = new _HttpParams();
            this.urlWithParams = url;
          } else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();

            if (params.length === 0) {
              // No parameters, the visible URL is just the URL given at creation time.
              this.urlWithParams = url;
            } else {
              // Does the URL already have query parameters? Look for '?'.
              var qIdx = url.indexOf('?'); // There are 3 cases to handle:
              // 1) No existing parameters -> append '?' followed by params.
              // 2) '?' exists and is followed by existing query string ->
              //    append '&' followed by params.
              // 3) '?' exists at the end of the url -> append params directly.
              // This basically amounts to determining the character, if any, with
              // which to join the URL and parameters.

              var sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';
              this.urlWithParams = url + sep + params;
            }
          }
        }
        /**
         * Transform the free-form body into a serialized format suitable for
         * transmission to the server.
         */


        _createClass(_HttpRequest, [{
          key: "serializeBody",
          value: function serializeBody() {
            // If no body is present, no need to serialize it.
            if (this.body === null) {
              return null;
            } // Check whether the body is already in a serialized form. If so,
            // it can just be returned directly.


            if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body) || typeof this.body === 'string') {
              return this.body;
            } // Check whether the body is an instance of HttpUrlEncodedParams.


            if (this.body instanceof _HttpParams) {
              return this.body.toString();
            } // Check whether the body is an object or array, and serialize with JSON if so.


            if (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {
              return JSON.stringify(this.body);
            } // Fall back on toString() for everything else.


            return this.body.toString();
          }
          /**
           * Examine the body and attempt to infer an appropriate MIME type
           * for it.
           *
           * If no such type can be inferred, this method will return `null`.
           */

        }, {
          key: "detectContentTypeHeader",
          value: function detectContentTypeHeader() {
            // An empty body has no content type.
            if (this.body === null) {
              return null;
            } // FormData bodies rely on the browser's content type assignment.


            if (isFormData(this.body)) {
              return null;
            } // Blobs usually have their own content type. If it doesn't, then
            // no type can be inferred.


            if (isBlob(this.body)) {
              return this.body.type || null;
            } // Array buffers have unknown contents and thus no type can be inferred.


            if (isArrayBuffer(this.body)) {
              return null;
            } // Technically, strings could be a form of JSON data, but it's safe enough
            // to assume they're plain strings.


            if (typeof this.body === 'string') {
              return 'text/plain';
            } // `HttpUrlEncodedParams` has its own content-type.


            if (this.body instanceof _HttpParams) {
              return 'application/x-www-form-urlencoded;charset=UTF-8';
            } // Arrays, objects, boolean and numbers will be encoded as JSON.


            if (typeof this.body === 'object' || typeof this.body === 'number' || typeof this.body === 'boolean') {
              return 'application/json';
            } // No type could be inferred.


            return null;
          }
        }, {
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var _a; // For method, url, and responseType, take the current value unless
            // it is overridden in the update hash.


            var method = update.method || this.method;
            var url = update.url || this.url;
            var responseType = update.responseType || this.responseType; // The body is somewhat special - a `null` value in update.body means
            // whatever current body is present is being overridden with an empty
            // body, whereas an `undefined` value in update.body implies no
            // override.

            var body = update.body !== undefined ? update.body : this.body; // Carefully handle the boolean options to differentiate between
            // `false` and `undefined` in the update args.

            var withCredentials = update.withCredentials !== undefined ? update.withCredentials : this.withCredentials;
            var reportProgress = update.reportProgress !== undefined ? update.reportProgress : this.reportProgress; // Headers and params may be appended to if `setHeaders` or
            // `setParams` are used.

            var headers = update.headers || this.headers;
            var params = update.params || this.params; // Pass on context if needed

            var context = (_a = update.context) !== null && _a !== void 0 ? _a : this.context; // Check whether the caller has asked to add headers.

            if (update.setHeaders !== undefined) {
              // Set every requested header.
              headers = Object.keys(update.setHeaders).reduce(function (headers, name) {
                return headers.set(name, update.setHeaders[name]);
              }, headers);
            } // Check whether the caller has asked to set params.


            if (update.setParams) {
              // Set every requested param.
              params = Object.keys(update.setParams).reduce(function (params, param) {
                return params.set(param, update.setParams[param]);
              }, params);
            } // Finally, construct the new HttpRequest using the pieces from above.


            return new _HttpRequest(method, url, body, {
              params: params,
              headers: headers,
              context: context,
              reportProgress: reportProgress,
              responseType: responseType,
              withCredentials: withCredentials
            });
          }
        }]);

        return _HttpRequest;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Type enumeration for the different kinds of `HttpEvent`.
       *
       * @publicApi
       */


      var _HttpEventType = /*#__PURE__*/function () {
        _HttpEventType = _HttpEventType || {};
        /**
         * The request was sent out over the wire.
         */

        _HttpEventType[_HttpEventType["Sent"] = 0] = "Sent";
        /**
         * An upload progress event was received.
         */

        _HttpEventType[_HttpEventType["UploadProgress"] = 1] = "UploadProgress";
        /**
         * The response status code and headers were received.
         */

        _HttpEventType[_HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
        /**
         * A download progress event was received.
         */

        _HttpEventType[_HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
        /**
         * The full response including the body was received.
         */

        _HttpEventType[_HttpEventType["Response"] = 4] = "Response";
        /**
         * A custom event from an interceptor or a backend.
         */

        _HttpEventType[_HttpEventType["User"] = 5] = "User";
        return _HttpEventType;
      }();
      /**
       * Base class for both `HttpResponse` and `HttpHeaderResponse`.
       *
       * @publicApi
       */


      var _HttpResponseBase =
      /**
       * Super-constructor for all responses.
       *
       * The single parameter accepted is an initialization hash. Any properties
       * of the response passed there will override the default values.
       */
      function _HttpResponseBase(init) {
        var defaultStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
        var defaultStatusText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'OK';

        _classCallCheck(this, _HttpResponseBase);

        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new _HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null; // Cache the ok value to avoid defining a getter.

        this.ok = this.status >= 200 && this.status < 300;
      };
      /**
       * A partial HTTP response which only includes the status and header data,
       * but no response body.
       *
       * `HttpHeaderResponse` is a `HttpEvent` available on the response
       * event stream, only when progress events are requested.
       *
       * @publicApi
       */


      var _HttpHeaderResponse = /*#__PURE__*/function (_HttpResponseBase2) {
        _inherits(_HttpHeaderResponse, _HttpResponseBase2);

        var _super = _createSuper(_HttpHeaderResponse);

        /**
         * Create a new `HttpHeaderResponse` with the given parameters.
         */
        function _HttpHeaderResponse() {
          var _this8;

          var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpHeaderResponse);

          _this8 = _super.call(this, init);
          _this8.type = _HttpEventType.ResponseHeader;
          return _this8;
        }
        /**
         * Copy this `HttpHeaderResponse`, overriding its contents with the
         * given parameter hash.
         */


        _createClass(_HttpHeaderResponse, [{
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            // Perform a straightforward initialization of the new HttpHeaderResponse,
            // overriding the current parameters with new ones if given.
            return new _HttpHeaderResponse({
              headers: update.headers || this.headers,
              status: update.status !== undefined ? update.status : this.status,
              statusText: update.statusText || this.statusText,
              url: update.url || this.url || undefined
            });
          }
        }]);

        return _HttpHeaderResponse;
      }(_HttpResponseBase);
      /**
       * A full HTTP response, including a typed response body (which may be `null`
       * if one was not returned).
       *
       * `HttpResponse` is a `HttpEvent` available on the response event
       * stream.
       *
       * @publicApi
       */


      var _HttpResponse = /*#__PURE__*/function (_HttpResponseBase3) {
        _inherits(_HttpResponse, _HttpResponseBase3);

        var _super2 = _createSuper(_HttpResponse);

        /**
         * Construct a new `HttpResponse`.
         */
        function _HttpResponse() {
          var _this9;

          var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpResponse);

          _this9 = _super2.call(this, init);
          _this9.type = _HttpEventType.Response;
          _this9.body = init.body !== undefined ? init.body : null;
          return _this9;
        }

        _createClass(_HttpResponse, [{
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new _HttpResponse({
              body: update.body !== undefined ? update.body : this.body,
              headers: update.headers || this.headers,
              status: update.status !== undefined ? update.status : this.status,
              statusText: update.statusText || this.statusText,
              url: update.url || this.url || undefined
            });
          }
        }]);

        return _HttpResponse;
      }(_HttpResponseBase);
      /**
       * A response that represents an error or failure, either from a
       * non-successful HTTP status, an error while executing the request,
       * or some other failure which occurred during the parsing of the response.
       *
       * Any error returned on the `Observable` response stream will be
       * wrapped in an `HttpErrorResponse` to provide additional context about
       * the state of the HTTP layer when the error occurred. The error property
       * will contain either a wrapped Error object or the error response returned
       * from the server.
       *
       * @publicApi
       */


      var _HttpErrorResponse = /*#__PURE__*/function (_HttpResponseBase4) {
        _inherits(_HttpErrorResponse, _HttpResponseBase4);

        var _super3 = _createSuper(_HttpErrorResponse);

        function _HttpErrorResponse(init) {
          var _this10;

          _classCallCheck(this, _HttpErrorResponse);

          // Initialize with a default status of 0 / Unknown Error.
          _this10 = _super3.call(this, init, 0, 'Unknown Error');
          _this10.name = 'HttpErrorResponse';
          /**
           * Errors are never okay, even when the status code is in the 2xx success range.
           */

          _this10.ok = false; // If the response was successful, then this was a parse error. Otherwise, it was
          // a protocol-level failure of some sort. Either the request failed in transit
          // or the server returned an unsuccessful status code.

          if (_this10.status >= 200 && _this10.status < 300) {
            _this10.message = "Http failure during parsing for ".concat(init.url || '(unknown url)');
          } else {
            _this10.message = "Http failure response for ".concat(init.url || '(unknown url)', ": ").concat(init.status, " ").concat(init.statusText);
          }

          _this10.error = init.error || null;
          return _this10;
        }

        return _HttpErrorResponse;
      }(_HttpResponseBase);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
       * the given `body`. This function clones the object and adds the body.
       *
       * Note that the `responseType` *options* value is a String that identifies the
       * single data type of the response.
       * A single overload version of the method handles each response type.
       * The value of `responseType` cannot be a union, as the combined signature could imply.
       *
       */


      function addBody(options, body) {
        return {
          body: body,
          headers: options.headers,
          context: options.context,
          observe: options.observe,
          params: options.params,
          reportProgress: options.reportProgress,
          responseType: options.responseType,
          withCredentials: options.withCredentials
        };
      }
      /**
       * Performs HTTP requests.
       * This service is available as an injectable class, with methods to perform HTTP requests.
       * Each request method has multiple signatures, and the return type varies based on
       * the signature that is called (mainly the values of `observe` and `responseType`).
       *
       * Note that the `responseType` *options* value is a String that identifies the
       * single data type of the response.
       * A single overload version of the method handles each response type.
       * The value of `responseType` cannot be a union, as the combined signature could imply.
      
       *
       * @usageNotes
       * Sample HTTP requests for the [Tour of Heroes](/tutorial/toh-pt0) application.
       *
       * ### HTTP Request Example
       *
       * ```
       *  // GET heroes whose name contains search term
       * searchHeroes(term: string): observable<Hero[]>{
       *
       *  const params = new HttpParams({fromString: 'name=term'});
       *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});
       * }
       * ```
       *
       * Alternatively, the parameter string can be used without invoking HttpParams
       * by directly joining to the URL.
       * ```
       * this.httpClient.request('GET', this.heroesUrl + '?' + 'name=term', {responseType:'json'});
       * ```
       *
       *
       * ### JSONP Example
       * ```
       * requestJsonp(url, callback = 'callback') {
       *  return this.httpClient.jsonp(this.heroesURL, callback);
       * }
       * ```
       *
       * ### PATCH Example
       * ```
       * // PATCH one of the heroes' name
       * patchHero (id: number, heroName: string): Observable<{}> {
       * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42
       *  return this.httpClient.patch(url, {name: heroName}, httpOptions)
       *    .pipe(catchError(this.handleError('patchHero')));
       * }
       * ```
       *
       * @see [HTTP Guide](guide/http)
       * @see [HTTP Request](api/common/http/HttpRequest)
       *
       * @publicApi
       */


      var _HttpClient = /*#__PURE__*/function () {
        var HttpClient = /*#__PURE__*/function () {
          function HttpClient(handler) {
            _classCallCheck(this, HttpClient);

            this.handler = handler;
          }
          /**
           * Constructs an observable for a generic HTTP request that, when subscribed,
           * fires the request through the chain of registered interceptors and on to the
           * server.
           *
           * You can pass an `HttpRequest` directly as the only parameter. In this case,
           * the call returns an observable of the raw `HttpEvent` stream.
           *
           * Alternatively you can pass an HTTP method as the first parameter,
           * a URL string as the second, and an options hash containing the request body as the third.
           * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
           * type of returned observable.
           *   * The `responseType` value determines how a successful response body is parsed.
           *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
           * object as a type parameter to the call.
           *
           * The `observe` value determines the return type, according to what you are interested in
           * observing.
           *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
           * progress events by default.
           *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
           * where the `T` parameter depends on the `responseType` and any optionally provided type
           * parameter.
           *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
           *
           */


          _createClass(HttpClient, [{
            key: "request",
            value: function request(first, url) {
              var _this11 = this;

              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var req; // First, check whether the primary argument is an instance of `HttpRequest`.

              if (first instanceof _HttpRequest) {
                // It is. The other arguments must be undefined (per the signatures) and can be
                // ignored.
                req = first;
              } else {
                // It's a string, so it represents a URL. Construct a request based on it,
                // and incorporate the remaining arguments (assuming `GET` unless a method is
                // provided.
                // Figure out the headers.
                var headers = undefined;

                if (options.headers instanceof _HttpHeaders) {
                  headers = options.headers;
                } else {
                  headers = new _HttpHeaders(options.headers);
                } // Sort out parameters.


                var params = undefined;

                if (!!options.params) {
                  if (options.params instanceof _HttpParams) {
                    params = options.params;
                  } else {
                    params = new _HttpParams({
                      fromObject: options.params
                    });
                  }
                } // Construct the request.


                req = new _HttpRequest(first, url, options.body !== undefined ? options.body : null, {
                  headers: headers,
                  context: options.context,
                  params: params,
                  reportProgress: options.reportProgress,
                  // By default, JSON is assumed to be returned for all calls.
                  responseType: options.responseType || 'json',
                  withCredentials: options.withCredentials
                });
              } // Start with an Observable.of() the initial request, and run the handler (which
              // includes all interceptors) inside a concatMap(). This way, the handler runs
              // inside an Observable chain, which causes interceptors to be re-run on every
              // subscription (this also makes retries re-run the handler, including interceptors).


              var events$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(req).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.concatMap)(function (req) {
                return _this11.handler.handle(req);
              })); // If coming via the API signature which accepts a previously constructed HttpRequest,
              // the only option is to get the event stream. Otherwise, return the event stream if
              // that is what was requested.

              if (first instanceof _HttpRequest || options.observe === 'events') {
                return events$;
              } // The requested stream contains either the full response or the body. In either
              // case, the first step is to filter the event stream to extract a stream of
              // responses(s).


              var res$ = events$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(function (event) {
                return event instanceof _HttpResponse;
              })); // Decide which stream to return.

              switch (options.observe || 'body') {
                case 'body':
                  // The requested stream is the body. Map the response stream to the response
                  // body. This could be done more simply, but a misbehaving interceptor might
                  // transform the response body into a different format and ignore the requested
                  // responseType. Guard against this by validating that the response is of the
                  // requested type.
                  switch (req.responseType) {
                    case 'arraybuffer':
                      return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                        // Validate that the body is an ArrayBuffer.
                        if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                          throw new Error('Response is not an ArrayBuffer.');
                        }

                        return res.body;
                      }));

                    case 'blob':
                      return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                        // Validate that the body is a Blob.
                        if (res.body !== null && !(res.body instanceof Blob)) {
                          throw new Error('Response is not a Blob.');
                        }

                        return res.body;
                      }));

                    case 'text':
                      return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                        // Validate that the body is a string.
                        if (res.body !== null && typeof res.body !== 'string') {
                          throw new Error('Response is not a string.');
                        }

                        return res.body;
                      }));

                    case 'json':
                    default:
                      // No validation needed for JSON responses, as they can be of any type.
                      return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                        return res.body;
                      }));
                  }

                case 'response':
                  // The response stream was requested directly, so return it.
                  return res$;

                default:
                  // Guard against new future observe types being added.
                  throw new Error("Unreachable: unhandled observe type ".concat(options.observe, "}"));
              }
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `DELETE` request to execute on the server. See the individual overloads for
             * details on the return type.
             *
             * @param url     The endpoint URL.
             * @param options The HTTP options to send with the request.
             *
             */

          }, {
            key: "delete",
            value: function _delete(url) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              return this.request('DELETE', url, options);
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `GET` request to execute on the server. See the individual overloads for
             * details on the return type.
             */

          }, {
            key: "get",
            value: function get(url) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              return this.request('GET', url, options);
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `HEAD` request to execute on the server. The `HEAD` method returns
             * meta information about the resource without transferring the
             * resource itself. See the individual overloads for
             * details on the return type.
             */

          }, {
            key: "head",
            value: function head(url) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              return this.request('HEAD', url, options);
            }
            /**
             * Constructs an `Observable` that, when subscribed, causes a request with the special method
             * `JSONP` to be dispatched via the interceptor pipeline.
             * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
             * API endpoints that don't support newer,
             * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
             * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
             * requests even if the API endpoint is not located on the same domain (origin) as the client-side
             * application making the request.
             * The endpoint API must support JSONP callback for JSONP requests to work.
             * The resource API returns the JSON response wrapped in a callback function.
             * You can pass the callback function name as one of the query parameters.
             * Note that JSONP requests can only be used with `GET` requests.
             *
             * @param url The resource URL.
             * @param callbackParam The callback function name.
             *
             */

          }, {
            key: "jsonp",
            value: function jsonp(url, callbackParam) {
              return this.request('JSONP', url, {
                params: new _HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
                observe: 'body',
                responseType: 'json'
              });
            }
            /**
             * Constructs an `Observable` that, when subscribed, causes the configured
             * `OPTIONS` request to execute on the server. This method allows the client
             * to determine the supported HTTP methods and other capabilites of an endpoint,
             * without implying a resource action. See the individual overloads for
             * details on the return type.
             */

          }, {
            key: "options",
            value: function options(url) {
              var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              return this.request('OPTIONS', url, _options);
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `PATCH` request to execute on the server. See the individual overloads for
             * details on the return type.
             */

          }, {
            key: "patch",
            value: function patch(url, body) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return this.request('PATCH', url, addBody(options, body));
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `POST` request to execute on the server. The server responds with the location of
             * the replaced resource. See the individual overloads for
             * details on the return type.
             */

          }, {
            key: "post",
            value: function post(url, body) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return this.request('POST', url, addBody(options, body));
            }
            /**
             * Constructs an observable that, when subscribed, causes the configured
             * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
             * with a new set of values.
             * See the individual overloads for details on the return type.
             */

          }, {
            key: "put",
            value: function put(url, body) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return this.request('PUT', url, addBody(options, body));
            }
          }]);

          return HttpClient;
        }();

        HttpClient.ɵfac = function HttpClient_Factory(t) {
          return new (t || HttpClient)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_HttpHandler));
        };

        HttpClient.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: HttpClient,
          factory: HttpClient.ɵfac
        });
        return HttpClient;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
       *
       *
       */


      var HttpInterceptorHandler = /*#__PURE__*/function () {
        function HttpInterceptorHandler(next, interceptor) {
          _classCallCheck(this, HttpInterceptorHandler);

          this.next = next;
          this.interceptor = interceptor;
        }

        _createClass(HttpInterceptorHandler, [{
          key: "handle",
          value: function handle(req) {
            return this.interceptor.intercept(req, this.next);
          }
        }]);

        return HttpInterceptorHandler;
      }();
      /**
       * A multi-provider token that represents the array of registered
       * `HttpInterceptor` objects.
       *
       * @publicApi
       */


      var _HTTP_INTERCEPTORS = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HTTP_INTERCEPTORS');

      var NoopInterceptor = /*#__PURE__*/function () {
        var NoopInterceptor = /*#__PURE__*/function () {
          function NoopInterceptor() {
            _classCallCheck(this, NoopInterceptor);
          }

          _createClass(NoopInterceptor, [{
            key: "intercept",
            value: function intercept(req, next) {
              return next.handle(req);
            }
          }]);

          return NoopInterceptor;
        }();

        NoopInterceptor.ɵfac = function NoopInterceptor_Factory(t) {
          return new (t || NoopInterceptor)();
        };

        NoopInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: NoopInterceptor,
          factory: NoopInterceptor.ɵfac
        });
        return NoopInterceptor;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // Every request made through JSONP needs a callback name that's unique across the
      // whole page. Each request is assigned an id and the callback name is constructed
      // from that. The next id to be assigned is tracked in a global variable here that
      // is shared among all applications on the page.


      var nextRequestId = 0; // Error text given when a JSONP script is injected, but doesn't invoke the callback
      // passed in its URL.

      var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.'; // Error text given when a request is passed to the JsonpClientBackend that doesn't
      // have a request method JSONP.

      var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
      var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
      /**
       * DI token/abstract type representing a map of JSONP callbacks.
       *
       * In the browser, this should always be the `window` object.
       *
       *
       */

      var JsonpCallbackContext = function JsonpCallbackContext() {
        _classCallCheck(this, JsonpCallbackContext);
      };
      /**
       * Processes an `HttpRequest` with the JSONP method,
       * by performing JSONP style requests.
       * @see `HttpHandler`
       * @see `HttpXhrBackend`
       *
       * @publicApi
       */


      var _JsonpClientBackend = /*#__PURE__*/function () {
        var JsonpClientBackend = /*#__PURE__*/function () {
          function JsonpClientBackend(callbackMap, document) {
            _classCallCheck(this, JsonpClientBackend);

            this.callbackMap = callbackMap;
            this.document = document;
            /**
             * A resolved promise that can be used to schedule microtasks in the event handlers.
             */

            this.resolvedPromise = Promise.resolve();
          }
          /**
           * Get the name of the next callback method, by incrementing the global `nextRequestId`.
           */


          _createClass(JsonpClientBackend, [{
            key: "nextCallback",
            value: function nextCallback() {
              return "ng_jsonp_callback_".concat(nextRequestId++);
            }
            /**
             * Processes a JSONP request and returns an event stream of the results.
             * @param req The request object.
             * @returns An observable of the response events.
             *
             */

          }, {
            key: "handle",
            value: function handle(req) {
              var _this12 = this;

              // Firstly, check both the method and response type. If either doesn't match
              // then the request was improperly routed here and cannot be handled.
              if (req.method !== 'JSONP') {
                throw new Error(JSONP_ERR_WRONG_METHOD);
              } else if (req.responseType !== 'json') {
                throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
              } // Everything else happens inside the Observable boundary.


              return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(function (observer) {
                // The first step to make a request is to generate the callback name, and replace the
                // callback placeholder in the URL with the name. Care has to be taken here to ensure
                // a trailing &, if matched, gets inserted back into the URL in the correct place.
                var callback = _this12.nextCallback();

                var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=".concat(callback, "$1")); // Construct the <script> tag and point it at the URL.

                var node = _this12.document.createElement('script');

                node.src = url; // A JSONP request requires waiting for multiple callbacks. These variables
                // are closed over and track state across those callbacks.
                // The response object, if one has been received, or null otherwise.

                var body = null; // Whether the response callback has been called.

                var finished = false; // Whether the request has been cancelled (and thus any other callbacks)
                // should be ignored.

                var cancelled = false; // Set the response callback in this.callbackMap (which will be the window
                // object in the browser. The script being loaded via the <script> tag will
                // eventually call this callback.

                _this12.callbackMap[callback] = function (data) {
                  // Data has been received from the JSONP script. Firstly, delete this callback.
                  delete _this12.callbackMap[callback]; // Next, make sure the request wasn't cancelled in the meantime.

                  if (cancelled) {
                    return;
                  } // Set state to indicate data was received.


                  body = data;
                  finished = true;
                }; // cleanup() is a utility closure that removes the <script> from the page and
                // the response callback from the window. This logic is used in both the
                // success, error, and cancellation paths, so it's extracted out for convenience.


                var cleanup = function cleanup() {
                  // Remove the <script> tag if it's still on the page.
                  if (node.parentNode) {
                    node.parentNode.removeChild(node);
                  } // Remove the response callback from the callbackMap (window object in the
                  // browser).


                  delete _this12.callbackMap[callback];
                }; // onLoad() is the success callback which runs after the response callback
                // if the JSONP script loads successfully. The event itself is unimportant.
                // If something went wrong, onLoad() may run without the response callback
                // having been invoked.


                var onLoad = function onLoad(event) {
                  // Do nothing if the request has been cancelled.
                  if (cancelled) {
                    return;
                  } // We wrap it in an extra Promise, to ensure the microtask
                  // is scheduled after the loaded endpoint has executed any potential microtask itself,
                  // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496


                  _this12.resolvedPromise.then(function () {
                    // Cleanup the page.
                    cleanup(); // Check whether the response callback has run.

                    if (!finished) {
                      // It hasn't, something went wrong with the request. Return an error via
                      // the Observable error path. All JSONP errors have status 0.
                      observer.error(new _HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK)
                      }));
                      return;
                    } // Success. body either contains the response body or null if none was
                    // returned.


                    observer.next(new _HttpResponse({
                      body: body,
                      status: 200
                      /* Ok */
                      ,
                      statusText: 'OK',
                      url: url
                    })); // Complete the stream, the response is over.

                    observer.complete();
                  });
                }; // onError() is the error callback, which runs if the script returned generates
                // a Javascript error. It emits the error via the Observable error channel as
                // a HttpErrorResponse.


                var onError = function onError(error) {
                  // If the request was already cancelled, no need to emit anything.
                  if (cancelled) {
                    return;
                  }

                  cleanup(); // Wrap the error in a HttpErrorResponse.

                  observer.error(new _HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error',
                    url: url
                  }));
                }; // Subscribe to both the success (load) and error events on the <script> tag,
                // and add it to the page.


                node.addEventListener('load', onLoad);
                node.addEventListener('error', onError);

                _this12.document.body.appendChild(node); // The request has now been successfully sent.


                observer.next({
                  type: _HttpEventType.Sent
                }); // Cancellation handler.

                return function () {
                  // Track the cancellation so event listeners won't do anything even if already scheduled.
                  cancelled = true; // Remove the event listeners so they won't run if the events later fire.

                  node.removeEventListener('load', onLoad);
                  node.removeEventListener('error', onError); // And finally, clean up the page.

                  cleanup();
                };
              });
            }
          }]);

          return JsonpClientBackend;
        }();

        JsonpClientBackend.ɵfac = function JsonpClientBackend_Factory(t) {
          return new (t || JsonpClientBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](JsonpCallbackContext), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
        };

        JsonpClientBackend.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: JsonpClientBackend,
          factory: JsonpClientBackend.ɵfac
        });
        return JsonpClientBackend;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Identifies requests with the method JSONP and
       * shifts them to the `JsonpClientBackend`.
       *
       * @see `HttpInterceptor`
       *
       * @publicApi
       */


      var _JsonpInterceptor = /*#__PURE__*/function () {
        var JsonpInterceptor = /*#__PURE__*/function () {
          function JsonpInterceptor(jsonp) {
            _classCallCheck(this, JsonpInterceptor);

            this.jsonp = jsonp;
          }
          /**
           * Identifies and handles a given JSONP request.
           * @param req The outgoing request object to handle.
           * @param next The next interceptor in the chain, or the backend
           * if no interceptors remain in the chain.
           * @returns An observable of the event stream.
           */


          _createClass(JsonpInterceptor, [{
            key: "intercept",
            value: function intercept(req, next) {
              if (req.method === 'JSONP') {
                return this.jsonp.handle(req);
              } // Fall through for normal HTTP requests.


              return next.handle(req);
            }
          }]);

          return JsonpInterceptor;
        }();

        JsonpInterceptor.ɵfac = function JsonpInterceptor_Factory(t) {
          return new (t || JsonpInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_JsonpClientBackend));
        };

        JsonpInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: JsonpInterceptor,
          factory: JsonpInterceptor.ɵfac
        });
        return JsonpInterceptor;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var XSSI_PREFIX = /^\)\]\}',?\n/;
      /**
       * Determine an appropriate URL for the response, by checking either
       * XMLHttpRequest.responseURL or the X-Request-URL header.
       */

      function getResponseUrl(xhr) {
        if ('responseURL' in xhr && xhr.responseURL) {
          return xhr.responseURL;
        }

        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL');
        }

        return null;
      }
      /**
       * Uses `XMLHttpRequest` to send requests to a backend server.
       * @see `HttpHandler`
       * @see `JsonpClientBackend`
       *
       * @publicApi
       */


      var _HttpXhrBackend = /*#__PURE__*/function () {
        var HttpXhrBackend = /*#__PURE__*/function () {
          function HttpXhrBackend(xhrFactory) {
            _classCallCheck(this, HttpXhrBackend);

            this.xhrFactory = xhrFactory;
          }
          /**
           * Processes a request and returns a stream of response events.
           * @param req The request object.
           * @returns An observable of the response events.
           */


          _createClass(HttpXhrBackend, [{
            key: "handle",
            value: function handle(req) {
              var _this13 = this;

              // Quick check to give a better error message when a user attempts to use
              // HttpClient.jsonp() without installing the HttpClientJsonpModule
              if (req.method === 'JSONP') {
                throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");
              } // Everything happens on Observable subscription.


              return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(function (observer) {
                // Start by setting up the XHR object with request method, URL, and withCredentials flag.
                var xhr = _this13.xhrFactory.build();

                xhr.open(req.method, req.urlWithParams);

                if (!!req.withCredentials) {
                  xhr.withCredentials = true;
                } // Add all the requested headers.


                req.headers.forEach(function (name, values) {
                  return xhr.setRequestHeader(name, values.join(','));
                }); // Add an Accept header if one isn't present already.

                if (!req.headers.has('Accept')) {
                  xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
                } // Auto-detect the Content-Type header if one isn't present already.


                if (!req.headers.has('Content-Type')) {
                  var detectedType = req.detectContentTypeHeader(); // Sometimes Content-Type detection fails.

                  if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                  }
                } // Set the responseType if one was requested.


                if (req.responseType) {
                  var responseType = req.responseType.toLowerCase(); // JSON responses need to be processed as text. This is because if the server
                  // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                  // xhr.response will be null, and xhr.responseText cannot be accessed to
                  // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                  // is parsed by first requesting text and then applying JSON.parse.

                  xhr.responseType = responseType !== 'json' ? responseType : 'text';
                } // Serialize the request body if one is present. If not, this will be set to null.


                var reqBody = req.serializeBody(); // If progress events are enabled, response headers will be delivered
                // in two events - the HttpHeaderResponse event and the full HttpResponse
                // event. However, since response headers don't change in between these
                // two events, it doesn't make sense to parse them twice. So headerResponse
                // caches the data extracted from the response whenever it's first parsed,
                // to ensure parsing isn't duplicated.

                var headerResponse = null; // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
                // state, and memoizes it into headerResponse.

                var partialFromXhr = function partialFromXhr() {
                  if (headerResponse !== null) {
                    return headerResponse;
                  } // Read status and normalize an IE9 bug (https://bugs.jquery.com/ticket/1450).


                  var status = xhr.status === 1223 ? 204
                  /* NoContent */
                  : xhr.status;
                  var statusText = xhr.statusText || 'OK'; // Parse headers from XMLHttpRequest - this step is lazy.

                  var headers = new _HttpHeaders(xhr.getAllResponseHeaders()); // Read the response URL from the XMLHttpResponse instance and fall back on the
                  // request URL.

                  var url = getResponseUrl(xhr) || req.url; // Construct the HttpHeaderResponse and memoize it.

                  headerResponse = new _HttpHeaderResponse({
                    headers: headers,
                    status: status,
                    statusText: statusText,
                    url: url
                  });
                  return headerResponse;
                }; // Next, a few closures are defined for the various events which XMLHttpRequest can
                // emit. This allows them to be unregistered as event listeners later.
                // First up is the load event, which represents a response being fully available.


                var onLoad = function onLoad() {
                  // Read response state from the memoized partial data.
                  var _partialFromXhr = partialFromXhr(),
                      headers = _partialFromXhr.headers,
                      status = _partialFromXhr.status,
                      statusText = _partialFromXhr.statusText,
                      url = _partialFromXhr.url; // The body will be read out if present.


                  var body = null;

                  if (status !== 204
                  /* NoContent */
                  ) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;
                  } // Normalize another potential bug (this one comes from CORS).


                  if (status === 0) {
                    status = !!body ? 200
                    /* Ok */
                    : 0;
                  } // ok determines whether the response will be transmitted on the event or
                  // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                  // but a successful status code can still result in an error if the user
                  // asked for JSON data and the body cannot be parsed as such.


                  var ok = status >= 200 && status < 300; // Check whether the body needs to be parsed as JSON (in many cases the browser
                  // will have done that already).

                  if (req.responseType === 'json' && typeof body === 'string') {
                    // Save the original body, before attempting XSSI prefix stripping.
                    var originalBody = body;
                    body = body.replace(XSSI_PREFIX, '');

                    try {
                      // Attempt the parse. If it fails, a parse error should be delivered to the user.
                      body = body !== '' ? JSON.parse(body) : null;
                    } catch (error) {
                      // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                      // JSON response. Restore the original body (including any XSSI prefix) to deliver
                      // a better error response.
                      body = originalBody; // If this was an error request to begin with, leave it as a string, it probably
                      // just isn't JSON. Otherwise, deliver the parsing error to the user.

                      if (ok) {
                        // Even though the response status was 2xx, this is still an error.
                        ok = false; // The parse error contains the text of the body that failed to parse.

                        body = {
                          error: error,
                          text: body
                        };
                      }
                    }
                  }

                  if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new _HttpResponse({
                      body: body,
                      headers: headers,
                      status: status,
                      statusText: statusText,
                      url: url || undefined
                    })); // The full body has been received and delivered, no further events
                    // are possible. This request is complete.

                    observer.complete();
                  } else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new _HttpErrorResponse({
                      // The error in this case is the response body (error from the server).
                      error: body,
                      headers: headers,
                      status: status,
                      statusText: statusText,
                      url: url || undefined
                    }));
                  }
                }; // The onError callback is called when something goes wrong at the network level.
                // Connection timeout, DNS error, offline, etc. These are actual errors, and are
                // transmitted on the error channel.


                var onError = function onError(error) {
                  var _partialFromXhr2 = partialFromXhr(),
                      url = _partialFromXhr2.url;

                  var res = new _HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                    url: url || undefined
                  });
                  observer.error(res);
                }; // The sentHeaders flag tracks whether the HttpResponseHeaders event
                // has been sent on the stream. This is necessary to track if progress
                // is enabled since the event will be sent on only the first download
                // progerss event.


                var sentHeaders = false; // The download progress event handler, which is only registered if
                // progress events are enabled.

                var onDownProgress = function onDownProgress(event) {
                  // Send the HttpResponseHeaders event if it hasn't been sent already.
                  if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                  } // Start building the download progress event to deliver on the response
                  // event stream.


                  var progressEvent = {
                    type: _HttpEventType.DownloadProgress,
                    loaded: event.loaded
                  }; // Set the total number of bytes in the event if it's available.

                  if (event.lengthComputable) {
                    progressEvent.total = event.total;
                  } // If the request was for text content and a partial response is
                  // available on XMLHttpRequest, include it in the progress event
                  // to allow for streaming reads.


                  if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                  } // Finally, fire the event.


                  observer.next(progressEvent);
                }; // The upload progress event handler, which is only registered if
                // progress events are enabled.


                var onUpProgress = function onUpProgress(event) {
                  // Upload progress events are simpler. Begin building the progress
                  // event.
                  var progress = {
                    type: _HttpEventType.UploadProgress,
                    loaded: event.loaded
                  }; // If the total number of bytes being uploaded is available, include
                  // it.

                  if (event.lengthComputable) {
                    progress.total = event.total;
                  } // Send the event.


                  observer.next(progress);
                }; // By default, register for load and error events.


                xhr.addEventListener('load', onLoad);
                xhr.addEventListener('error', onError);
                xhr.addEventListener('timeout', onError);
                xhr.addEventListener('abort', onError); // Progress events are only enabled if requested.

                if (req.reportProgress) {
                  // Download progress is always enabled if requested.
                  xhr.addEventListener('progress', onDownProgress); // Upload progress depends on whether there is a body to upload.

                  if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                  }
                } // Fire the request, and notify the event stream that it was fired.


                xhr.send(reqBody);
                observer.next({
                  type: _HttpEventType.Sent
                }); // This is the return from the Observable function, which is the
                // request cancellation handler.

                return function () {
                  // On a cancellation, remove all registered event listeners.
                  xhr.removeEventListener('error', onError);
                  xhr.removeEventListener('abort', onError);
                  xhr.removeEventListener('load', onLoad);
                  xhr.removeEventListener('timeout', onError);

                  if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);

                    if (reqBody !== null && xhr.upload) {
                      xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                  } // Finally, abort the in-flight request.


                  if (xhr.readyState !== xhr.DONE) {
                    xhr.abort();
                  }
                };
              });
            }
          }]);

          return HttpXhrBackend;
        }();

        HttpXhrBackend.ɵfac = function HttpXhrBackend_Factory(t) {
          return new (t || HttpXhrBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.XhrFactory));
        };

        HttpXhrBackend.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: HttpXhrBackend,
          factory: HttpXhrBackend.ɵfac
        });
        return HttpXhrBackend;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var XSRF_COOKIE_NAME = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('XSRF_COOKIE_NAME');
      var XSRF_HEADER_NAME = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('XSRF_HEADER_NAME');
      /**
       * Retrieves the current XSRF token to use with the next outgoing request.
       *
       * @publicApi
       */

      var _HttpXsrfTokenExtractor = function _HttpXsrfTokenExtractor() {
        _classCallCheck(this, _HttpXsrfTokenExtractor);
      };
      /**
       * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
       */


      var HttpXsrfCookieExtractor = /*#__PURE__*/function () {
        var HttpXsrfCookieExtractor = /*#__PURE__*/function () {
          function HttpXsrfCookieExtractor(doc, platform, cookieName) {
            _classCallCheck(this, HttpXsrfCookieExtractor);

            this.doc = doc;
            this.platform = platform;
            this.cookieName = cookieName;
            this.lastCookieString = '';
            this.lastToken = null;
            /**
             * @internal for testing
             */

            this.parseCount = 0;
          }

          _createClass(HttpXsrfCookieExtractor, [{
            key: "getToken",
            value: function getToken() {
              if (this.platform === 'server') {
                return null;
              }

              var cookieString = this.doc.cookie || '';

              if (cookieString !== this.lastCookieString) {
                this.parseCount++;
                this.lastToken = (0, _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵparseCookieValue"])(cookieString, this.cookieName);
                this.lastCookieString = cookieString;
              }

              return this.lastToken;
            }
          }]);

          return HttpXsrfCookieExtractor;
        }();

        HttpXsrfCookieExtractor.ɵfac = function HttpXsrfCookieExtractor_Factory(t) {
          return new (t || HttpXsrfCookieExtractor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](XSRF_COOKIE_NAME));
        };

        HttpXsrfCookieExtractor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: HttpXsrfCookieExtractor,
          factory: HttpXsrfCookieExtractor.ɵfac
        });
        return HttpXsrfCookieExtractor;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
       */


      var HttpXsrfInterceptor = /*#__PURE__*/function () {
        var HttpXsrfInterceptor = /*#__PURE__*/function () {
          function HttpXsrfInterceptor(tokenService, headerName) {
            _classCallCheck(this, HttpXsrfInterceptor);

            this.tokenService = tokenService;
            this.headerName = headerName;
          }

          _createClass(HttpXsrfInterceptor, [{
            key: "intercept",
            value: function intercept(req, next) {
              var lcUrl = req.url.toLowerCase(); // Skip both non-mutating requests and absolute URLs.
              // Non-mutating requests don't require a token, and absolute URLs require special handling
              // anyway as the cookie set
              // on our origin is not the same as the token expected by another origin.

              if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') || lcUrl.startsWith('https://')) {
                return next.handle(req);
              }

              var token = this.tokenService.getToken(); // Be careful not to overwrite an existing header of the same name.

              if (token !== null && !req.headers.has(this.headerName)) {
                req = req.clone({
                  headers: req.headers.set(this.headerName, token)
                });
              }

              return next.handle(req);
            }
          }]);

          return HttpXsrfInterceptor;
        }();

        HttpXsrfInterceptor.ɵfac = function HttpXsrfInterceptor_Factory(t) {
          return new (t || HttpXsrfInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_HttpXsrfTokenExtractor), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](XSRF_HEADER_NAME));
        };

        HttpXsrfInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: HttpXsrfInterceptor,
          factory: HttpXsrfInterceptor.ɵfac
        });
        return HttpXsrfInterceptor;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * An injectable `HttpHandler` that applies multiple interceptors
       * to a request before passing it to the given `HttpBackend`.
       *
       * The interceptors are loaded lazily from the injector, to allow
       * interceptors to themselves inject classes depending indirectly
       * on `HttpInterceptingHandler` itself.
       * @see `HttpInterceptor`
       */


      var HttpInterceptingHandler = /*#__PURE__*/function () {
        var HttpInterceptingHandler = /*#__PURE__*/function () {
          function HttpInterceptingHandler(backend, injector) {
            _classCallCheck(this, HttpInterceptingHandler);

            this.backend = backend;
            this.injector = injector;
            this.chain = null;
          }

          _createClass(HttpInterceptingHandler, [{
            key: "handle",
            value: function handle(req) {
              if (this.chain === null) {
                var interceptors = this.injector.get(_HTTP_INTERCEPTORS, []);
                this.chain = interceptors.reduceRight(function (next, interceptor) {
                  return new HttpInterceptorHandler(next, interceptor);
                }, this.backend);
              }

              return this.chain.handle(req);
            }
          }]);

          return HttpInterceptingHandler;
        }();

        HttpInterceptingHandler.ɵfac = function HttpInterceptingHandler_Factory(t) {
          return new (t || HttpInterceptingHandler)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_HttpBackend), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector));
        };

        HttpInterceptingHandler.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
          token: HttpInterceptingHandler,
          factory: HttpInterceptingHandler.ɵfac
        });
        return HttpInterceptingHandler;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Constructs an `HttpHandler` that applies interceptors
       * to a request before passing it to the given `HttpBackend`.
       *
       * Use as a factory function within `HttpClientModule`.
       *
       *
       */


      function interceptingHandler(backend) {
        var interceptors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!interceptors) {
          return backend;
        }

        return interceptors.reduceRight(function (next, interceptor) {
          return new HttpInterceptorHandler(next, interceptor);
        }, backend);
      }
      /**
       * Factory function that determines where to store JSONP callbacks.
       *
       * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
       * in test environments. In that case, callbacks are stored on an anonymous object instead.
       *
       *
       */


      function jsonpCallbackContext() {
        if (typeof window === 'object') {
          return window;
        }

        return {};
      }
      /**
       * Configures XSRF protection support for outgoing requests.
       *
       * For a server that supports a cookie-based XSRF protection system,
       * use directly to configure XSRF protection with the correct
       * cookie and header names.
       *
       * If no names are supplied, the default cookie name is `XSRF-TOKEN`
       * and the default header name is `X-XSRF-TOKEN`.
       *
       * @publicApi
       */


      var _HttpClientXsrfModule = /*#__PURE__*/function () {
        var HttpClientXsrfModule = /*#__PURE__*/function () {
          function HttpClientXsrfModule() {
            _classCallCheck(this, HttpClientXsrfModule);
          }

          _createClass(HttpClientXsrfModule, null, [{
            key: "disable",
            value:
            /**
             * Disable the default XSRF protection.
             */
            function disable() {
              return {
                ngModule: HttpClientXsrfModule,
                providers: [{
                  provide: HttpXsrfInterceptor,
                  useClass: NoopInterceptor
                }]
              };
            }
            /**
             * Configure XSRF protection.
             * @param options An object that can specify either or both
             * cookie name or header name.
             * - Cookie name default is `XSRF-TOKEN`.
             * - Header name default is `X-XSRF-TOKEN`.
             *
             */

          }, {
            key: "withOptions",
            value: function withOptions() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return {
                ngModule: HttpClientXsrfModule,
                providers: [options.cookieName ? {
                  provide: XSRF_COOKIE_NAME,
                  useValue: options.cookieName
                } : [], options.headerName ? {
                  provide: XSRF_HEADER_NAME,
                  useValue: options.headerName
                } : []]
              };
            }
          }]);

          return HttpClientXsrfModule;
        }();

        HttpClientXsrfModule.ɵfac = function HttpClientXsrfModule_Factory(t) {
          return new (t || HttpClientXsrfModule)();
        };

        HttpClientXsrfModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
          type: HttpClientXsrfModule
        });
        HttpClientXsrfModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
          providers: [HttpXsrfInterceptor, {
            provide: _HTTP_INTERCEPTORS,
            useExisting: HttpXsrfInterceptor,
            multi: true
          }, {
            provide: _HttpXsrfTokenExtractor,
            useClass: HttpXsrfCookieExtractor
          }, {
            provide: XSRF_COOKIE_NAME,
            useValue: 'XSRF-TOKEN'
          }, {
            provide: XSRF_HEADER_NAME,
            useValue: 'X-XSRF-TOKEN'
          }]
        });
        return HttpClientXsrfModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
       * with supporting services for XSRF. Automatically imported by `HttpClientModule`.
       *
       * You can add interceptors to the chain behind `HttpClient` by binding them to the
       * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
       *
       * @publicApi
       */


      var _HttpClientModule = /*#__PURE__*/function () {
        var HttpClientModule = function HttpClientModule() {
          _classCallCheck(this, HttpClientModule);
        };

        HttpClientModule.ɵfac = function HttpClientModule_Factory(t) {
          return new (t || HttpClientModule)();
        };

        HttpClientModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
          type: HttpClientModule
        });
        HttpClientModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
          providers: [_HttpClient, {
            provide: _HttpHandler,
            useClass: HttpInterceptingHandler
          }, _HttpXhrBackend, {
            provide: _HttpBackend,
            useExisting: _HttpXhrBackend
          }],
          imports: [[_HttpClientXsrfModule.withOptions({
            cookieName: 'XSRF-TOKEN',
            headerName: 'X-XSRF-TOKEN'
          })]]
        });
        return HttpClientModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /*#__PURE__*/


      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](_HttpClientModule, {
          imports: [_HttpClientXsrfModule]
        });
      })();
      /**
       * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
       * with supporting services for JSONP.
       * Without this module, Jsonp requests reach the backend
       * with method JSONP, where they are rejected.
       *
       * You can add interceptors to the chain behind `HttpClient` by binding them to the
       * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
       *
       * @publicApi
       */


      var _HttpClientJsonpModule = /*#__PURE__*/function () {
        var HttpClientJsonpModule = function HttpClientJsonpModule() {
          _classCallCheck(this, HttpClientJsonpModule);
        };

        HttpClientJsonpModule.ɵfac = function HttpClientJsonpModule_Factory(t) {
          return new (t || HttpClientJsonpModule)();
        };

        HttpClientJsonpModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
          type: HttpClientJsonpModule
        });
        HttpClientJsonpModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
          providers: [_JsonpClientBackend, {
            provide: JsonpCallbackContext,
            useFactory: jsonpCallbackContext
          }, {
            provide: _HTTP_INTERCEPTORS,
            useClass: _JsonpInterceptor,
            multi: true
          }]
        });
        return HttpClientJsonpModule;
      }();
      /*#__PURE__*/


      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A wrapper around the `XMLHttpRequest` constructor.
       *
       * @publicApi
       * @see `XhrFactory`
       * @deprecated
       * `XhrFactory` has moved, please import `XhrFactory` from `@angular/common` instead.
       */


      var _XhrFactory = _angular_common__WEBPACK_IMPORTED_MODULE_0__.XhrFactory;
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_angular_common_fesm2015_http_js-_02b61-es5.50b8fc060bb072d2ef35.js.map