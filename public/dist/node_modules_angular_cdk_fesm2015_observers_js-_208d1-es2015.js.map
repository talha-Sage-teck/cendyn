{"version":3,"mappings":"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","names":["MutationObserverFactory","create","callback","MutationObserver","ɵfac","t","ɵprov","ɵɵdefineInjectable","factory","token","providedIn","ContentObserver","constructor","_mutationObserverFactory","this","_observedElements","Map","ngOnDestroy","forEach","_","element","_cleanupObserver","observe","elementOrRef","coerceElement","Observable","observer","subscription","stream","_observeElement","subscribe","unsubscribe","_unobserveElement","has","get","count","Subject","mutations","next","characterData","childList","subtree","set","disconnect","complete","delete","ɵngcc0","ɵɵinject","CdkObserveContent","_contentObserver","_elementRef","_ngZone","event","EventEmitter","_disabled","_currentSubscription","value","coerceBooleanProperty","_unsubscribe","_subscribe","_debounce","coerceNumberProperty","ngAfterContentInit","disabled","runOutsideAngular","debounce","pipe","debounceTime","_a","ɵdir","type","selectors","inputs","outputs","exportAs","ObserversModule","ɵmod","ɵinj","providers"],"sources":["webpack:///node_modules/@angular/cdk/fesm2015/observers.js"],"sourcesContent":["import { coerceElement, coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { ɵɵdefineInjectable, Injectable, ɵɵinject, EventEmitter, Directive, ElementRef, NgZone, Output, Input, NgModule } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime } from 'rxjs/operators';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\r\n * @docs-private\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nclass MutationObserverFactory {\r\n    create(callback) {\r\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\r\n    }\r\n}\r\nMutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) { return new (t || MutationObserverFactory)(); };\r\nMutationObserverFactory.ɵprov = ɵɵdefineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MutationObserverFactory, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], null, null); })();\r\n/** An injectable service that allows watching elements for changes to their content. */\r\nclass ContentObserver {\r\n    constructor(_mutationObserverFactory) {\r\n        this._mutationObserverFactory = _mutationObserverFactory;\r\n        /** Keeps track of the existing MutationObservers so they can be reused. */\r\n        this._observedElements = new Map();\r\n    }\r\n    ngOnDestroy() {\r\n        this._observedElements.forEach((_, element) => this._cleanupObserver(element));\r\n    }\r\n    observe(elementOrRef) {\r\n        const element = coerceElement(elementOrRef);\r\n        return new Observable((observer) => {\r\n            const stream = this._observeElement(element);\r\n            const subscription = stream.subscribe(observer);\r\n            return () => {\r\n                subscription.unsubscribe();\r\n                this._unobserveElement(element);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Observes the given element by using the existing MutationObserver if available, or creating a\r\n     * new one if not.\r\n     */\r\n    _observeElement(element) {\r\n        if (!this._observedElements.has(element)) {\r\n            const stream = new Subject();\r\n            const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\r\n            if (observer) {\r\n                observer.observe(element, {\r\n                    characterData: true,\r\n                    childList: true,\r\n                    subtree: true\r\n                });\r\n            }\r\n            this._observedElements.set(element, { observer, stream, count: 1 });\r\n        }\r\n        else {\r\n            this._observedElements.get(element).count++;\r\n        }\r\n        return this._observedElements.get(element).stream;\r\n    }\r\n    /**\r\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\r\n     * observing this element.\r\n     */\r\n    _unobserveElement(element) {\r\n        if (this._observedElements.has(element)) {\r\n            this._observedElements.get(element).count--;\r\n            if (!this._observedElements.get(element).count) {\r\n                this._cleanupObserver(element);\r\n            }\r\n        }\r\n    }\r\n    /** Clean up the underlying MutationObserver for the specified element. */\r\n    _cleanupObserver(element) {\r\n        if (this._observedElements.has(element)) {\r\n            const { observer, stream } = this._observedElements.get(element);\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n            stream.complete();\r\n            this._observedElements.delete(element);\r\n        }\r\n    }\r\n}\r\nContentObserver.ɵfac = function ContentObserver_Factory(t) { return new (t || ContentObserver)(ɵngcc0.ɵɵinject(MutationObserverFactory)); };\r\nContentObserver.ɵprov = ɵɵdefineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(ɵɵinject(MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\r\nContentObserver.ctorParameters = () => [\r\n    { type: MutationObserverFactory }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContentObserver, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: MutationObserverFactory }]; }, null); })();\r\n/**\r\n * Directive that triggers a callback whenever the content of\r\n * its associated element has changed.\r\n */\r\nclass CdkObserveContent {\r\n    constructor(_contentObserver, _elementRef, _ngZone) {\r\n        this._contentObserver = _contentObserver;\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        /** Event emitted for each change in the element's content. */\r\n        this.event = new EventEmitter();\r\n        this._disabled = false;\r\n        this._currentSubscription = null;\r\n    }\r\n    /**\r\n     * Whether observing content is disabled. This option can be used\r\n     * to disconnect the underlying MutationObserver until it is needed.\r\n     */\r\n    get disabled() { return this._disabled; }\r\n    set disabled(value) {\r\n        this._disabled = coerceBooleanProperty(value);\r\n        this._disabled ? this._unsubscribe() : this._subscribe();\r\n    }\r\n    /** Debounce interval for emitting the changes. */\r\n    get debounce() { return this._debounce; }\r\n    set debounce(value) {\r\n        this._debounce = coerceNumberProperty(value);\r\n        this._subscribe();\r\n    }\r\n    ngAfterContentInit() {\r\n        if (!this._currentSubscription && !this.disabled) {\r\n            this._subscribe();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._unsubscribe();\r\n    }\r\n    _subscribe() {\r\n        this._unsubscribe();\r\n        const stream = this._contentObserver.observe(this._elementRef);\r\n        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\r\n        // Consider brining it back inside the zone next time we're making breaking changes.\r\n        // Bringing it back inside can cause things like infinite change detection loops and changed\r\n        // after checked errors if people's code isn't handling it properly.\r\n        this._ngZone.runOutsideAngular(() => {\r\n            this._currentSubscription =\r\n                (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\r\n        });\r\n    }\r\n    _unsubscribe() {\r\n        var _a;\r\n        (_a = this._currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\r\n    }\r\n}\r\nCdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) { return new (t || CdkObserveContent)(ɵngcc0.ɵɵdirectiveInject(ContentObserver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\r\nCdkObserveContent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkObserveContent, selectors: [[\"\", \"cdkObserveContent\", \"\"]], inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"] });\r\nCdkObserveContent.ctorParameters = () => [\r\n    { type: ContentObserver },\r\n    { type: ElementRef },\r\n    { type: NgZone }\r\n];\r\nCdkObserveContent.propDecorators = {\r\n    event: [{ type: Output, args: ['cdkObserveContent',] }],\r\n    disabled: [{ type: Input, args: ['cdkObserveContentDisabled',] }],\r\n    debounce: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkObserveContent, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkObserveContent]',\r\n                exportAs: 'cdkObserveContent'\r\n            }]\r\n    }], function () { return [{ type: ContentObserver }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { event: [{\r\n            type: Output,\r\n            args: ['cdkObserveContent']\r\n        }], disabled: [{\r\n            type: Input,\r\n            args: ['cdkObserveContentDisabled']\r\n        }], debounce: [{\r\n            type: Input\r\n        }] }); })();\r\nclass ObserversModule {\r\n}\r\nObserversModule.ɵfac = function ObserversModule_Factory(t) { return new (t || ObserversModule)(); };\r\nObserversModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ObserversModule });\r\nObserversModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MutationObserverFactory] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ObserversModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: [CdkObserveContent],\r\n                declarations: [CdkObserveContent],\r\n                providers: [MutationObserverFactory]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ObserversModule, { declarations: [CdkObserveContent], exports: [CdkObserveContent] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { CdkObserveContent, ContentObserver, MutationObserverFactory, ObserversModule };\r\n\r\n"]}