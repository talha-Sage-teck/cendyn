{"version":3,"mappings":"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","names":["DIR_DOCUMENT","InjectionToken","providedIn","factory","inject","DOCUMENT","Directionality","constructor","_document","this","value","change","EventEmitter","htmlDir","documentElement","dir","body","ngOnDestroy","complete","ɵfac","t","ɵngcc0","ɵprov","ɵɵdefineInjectable","ɵɵinject","token","BidiModule","ɵmod","type","ɵinj","fallbackValue","isNaN","parseFloat","Number","Array","isArray","elementOrRef","ElementRef","nativeElement","connect","DataSource","_data","super","isObservable","of","disconnect","applyChanges","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","forEachOperation","record","adjustedPreviousIndex","currentIndex","view","operation","previousIndex","insertContext","createEmbeddedView","templateRef","context","index","remove","get","move","detach","viewCacheSize","_viewCache","_insertView","_detachAndCacheView","_moveView","destroy","viewArgsFactory","cachedView","_insertViewFromCache","$implicit","viewArgs","detachedView","_maybeCacheView","length","push","indexOf","pop","insert","_VIEW_REPEATER_STRATEGY","hasV8BreakIterator","Intl","v8BreakIterator","_a","supportsPassiveEvents","rtlScrollAxisType","scrollBehaviorSupported","shadowDomIsSupported","Platform","_platformId","isBrowser","isPlatformBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","window","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","PLATFORM_ID","PlatformModule","options","addEventListener","Object","defineProperty","capture","Element","style","scrollToFunction","prototype","scrollTo","toString","scrollContainer","createElement","containerStyle","width","overflow","visibility","pointerEvents","position","content","contentStyle","height","appendChild","scrollLeft","parentNode","removeChild","element","head","createShadowRoot","attachShadow","rootNode","getRootNode","ShadowRoot","_c0","_c1","VIRTUAL_SCROLL_STRATEGY","itemSize","minBufferPx","maxBufferPx","_scrolledIndexChange","Subject","scrolledIndexChange","pipe","distinctUntilChanged","_viewport","_itemSize","_minBufferPx","_maxBufferPx","attach","viewport","_updateTotalContentSize","_updateRenderedRange","updateItemAndBufferSize","onContentScrolled","onDataLengthChanged","onContentRendered","onRenderedOffsetChanged","scrollToIndex","behavior","scrollToOffset","setTotalContentSize","getDataLength","renderedRange","getRenderedRange","newRange","start","end","viewportSize","getViewportSize","dataLength","scrollOffset","measureScrollOffset","firstVisibleIndex","maxVisibleItems","Math","ceil","newVisibleIndex","max","min","floor","startBuffer","expandStart","endBuffer","expandEnd","setRenderedRange","setRenderedContentOffset","next","fixedSizeDir","_scrollStrategy","CdkFixedSizeVirtualScroll","FixedSizeVirtualScrollStrategy","coerceNumberProperty","ngOnChanges","ɵdir","selectors","inputs","features","provide","useFactory","_fixedSizeVirtualScrollStrategyFactory","deps","forwardRef","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","scrollContainers","Map","register","scrollable","has","set","elementScrolled","subscribe","deregister","scrollableReference","unsubscribe","delete","scrolled","auditTimeInMs","Observable","observer","_addGlobalListener","subscription","auditTime","_removeGlobalListener","forEach","_","container","ancestorScrolled","elementOrElementRef","ancestors","getAncestorScrollContainers","filter","target","scrollingContainers","_subscription","_scrollableContainsElement","_getWindow","defaultView","coerceElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","fromEvent","ɵngcc1","NgZone","CdkScrollable","elementRef","scrollDispatcher","ngZone","_destroyed","_elementScrolled","takeUntil","ngOnInit","el","isRtl","left","right","bottom","top","scrollHeight","clientHeight","getRtlScrollAxisType","scrollWidth","clientWidth","_applyScrollToOptions","supportsScrollBehavior","scrollTop","from","LEFT","RIGHT","ɵngcc2","ViewportRuler","_change","_changeListener","event","_updateViewportSize","removeEventListener","_viewportSize","output","getViewportRect","scrollPosition","getViewportScrollPosition","documentRect","getBoundingClientRect","scrollY","scrollX","throttleTime","innerWidth","innerHeight","SCROLL_SCHEDULER","requestAnimationFrame","animationFrameScheduler","asapScheduler","CdkVirtualScrollViewport","_changeDetectorRef","viewportRuler","_detachedSubject","_renderedRangeSubject","_orientation","Promise","resolve","then","run","renderedRangeStream","_totalContentSize","_totalContentWidth","_totalContentHeight","_renderedRange","_dataLength","_renderedContentOffset","_renderedContentOffsetNeedsRewrite","_isChangeDetectionPending","_runAfterChangeDetection","_viewportChanges","Subscription","checkViewportSize","orientation","_calculateSpacerSize","_measureViewportSize","startWith","_markChangeDetectionNeeded","forOf","_forOf","dataStream","data","newLength","_doChangeDetection","size","range","r1","r2","getOffsetToRenderedContentStart","offset","to","isHorizontal","axis","transform","_renderedContentTransform","measureRenderedContentSize","contentEl","_contentWrapper","offsetWidth","offsetHeight","measureRangeSize","viewportEl","runAfter","markForCheck","runAfterChangeDetection","fn","ɵcmp","viewQuery","rf","ctx","_t","first","hostAttrs","hostVars","hostBindings","outputs","useExisting","ngContentSelectors","decls","vars","consts","template","styles","encapsulation","changeDetection","CdkScrollableModule","ScrollingModule","imports","ctx_r0","justify","headerText","data_r2","ctx_r1","dataAccessor","name","base","args","_sticky","_hasStickyChanged","v","prevValue","coerceBooleanProperty","hasStickyChanged","resetStickyChanged","CDK_TABLE","TEXT_COLUMN_OPTIONS","CdkCellDef","CdkHeaderCellDef","CdkFooterCellDef","_CdkColumnDefBase","mixinHasStickyInput","CdkColumnDefBase","CdkColumnDef","_table","_stickyEnd","_name","_setNameInput","_updateColumnCssClassName","_columnCssClassName","cssClassFriendlyName","replace","contentQueries","dirIndex","cell","headerCell","footerCell","sticky","stickyEnd","columnDef","classList","className","add","CdkHeaderCell","BaseCdkCell","CdkFooterCell","CdkCell","tasks","endTasks","_COALESCED_STYLE_SCHEDULER","_CoalescedStyleScheduler","_currentSchedule","schedule","task","_createScheduleIfNeeded","scheduleEnd","_Schedule","_getScheduleObservable","isStable","undefined","onStable","take","CDK_ROW_TEMPLATE","BaseRowDef","_differs","_columnsDiffer","columns","currentValue","find","create","diff","getColumnsDiff","extractCellTemplate","column","CdkHeaderRowDef","CdkFooterRowDef","_CdkHeaderRowDefBase","CdkHeaderRowDefBase","_CdkFooterRowDefBase","CdkFooterRowDefBase","CdkRowDef","when","CdkCellOutlet","_viewContainer","mostRecentCellOutlet","CdkHeaderRow","directives","CdkFooterRow","CdkRow","CdkNoDataRow","STICKY_DIRECTIONS","_isNativeHtmlTable","_stickCellCss","direction","_coalescedStyleScheduler","_isBrowser","_needsPositionStickyOnElement","_positionListener","_cachedCellWidths","_borderCellCss","clearStickyPositioning","rows","stickyDirections","elementsToClear","row","nodeType","ELEMENT_NODE","i","children","_scheduleStyleChanges","_removeStickyStyle","updateStickyColumns","stickyStartStates","stickyEndStates","recalculateCellWidths","some","state","stickyColumnsUpdated","sizes","stickyEndColumnsUpdated","firstRow","numCells","cellWidths","_getCellWidths","startPositions","_getStickyStartColumnPositions","endPositions","_getStickyEndColumnPositions","lastStickyStart","lastIndexOf","firstStickyEnd","_addStickyStyle","slice","map","reverse","stickRows","rowsToStick","stickyStates","states","stickyOffsets","stickyCellHeights","elementsToStick","rowIndex","stickyOffset","borderedRowIndex","_b","isBorderedRowIndex","stickyHeaderRowsUpdated","elements","stickyFooterRowsUpdated","updateStickyFooterContainer","tableElement","tfoot","querySelector","zIndex","_getCalculatedZIndex","dirValue","isBorderElement","cssText","zIndexIncrements","firstRowCells","widths","positions","nextPosition","STICKY_POSITIONING_LISTENER","DataRowOutlet","viewContainer","HeaderRowOutlet","FooterRowOutlet","NoDataRowOutlet","CDK_TABLE_TEMPLATE","CdkTable","_elementRef","role","_dir","_viewRepeater","_stickyPositioningListener","_viewportRuler","_onDestroy","_columnDefsByName","_customColumnDefs","Set","_customRowDefs","_customHeaderRowDefs","_customFooterRowDefs","_headerRowDefChanged","_footerRowDefChanged","_stickyColumnStylesNeedReset","_forceRecalculateCellWidths","_cachedRenderRowsMap","stickyCssClass","needsPositionStickyOnElement","_isShowingNoDataRow","_multiTemplateDataRows","_fixedLayout","viewChange","BehaviorSubject","MAX_VALUE","setAttribute","nodeName","trackBy","_trackByFn","_dataSource","dataSource","_switchDataSource","_rowOutlet","_forceRenderDataRows","updateStickyColumnStyles","_setupStickyStyler","_applyNativeTableSections","_dataDiffer","_i","dataRow","dataIndex","ngAfterContentChecked","_cacheRowDefs","_cacheColumnDefs","rowDefsChanged","columnsChanged","_renderUpdatedColumns","_forceRenderHeaderRows","_forceRenderFooterRows","_rowDefs","_renderChangeSubscription","_observeRenderChanges","_checkStickyStates","clear","_noDataRowOutlet","_headerRowOutlet","_footerRowOutlet","isDataSource","renderRows","_renderRows","_getAllRenderRows","_updateNoDataRow","_adjustedPreviousIndex","_getEmbeddedViewArgs","item","_renderCellTemplateForItem","rowDef","prevIndex","renderRow","_renderRow","_updateRowIndexContext","forEachIdentityChange","addColumnDef","removeColumnDef","addRowDef","removeRowDef","addHeaderRowDef","headerRowDef","removeHeaderRowDef","addFooterRowDef","footerRowDef","removeFooterRowDef","setNoDataRow","noDataRow","_customNoDataRow","updateStickyHeaderRowStyles","headerRows","_getRenderedRows","thead","display","_headerRowDefs","def","_stickyStyler","updateStickyFooterRowStyles","footerRows","_footerRowDefs","dataRows","headerRow","_addStickyColumnStyles","footerRow","values","prevCachedRenderRows","renderRowsForData","_getRenderRowsForData","WeakMap","j","cache","rowDefs","_getRowDefs","cachedRenderRows","shift","mergeArrayAndSet","_getOwnDefs","_contentColumnDefs","_contentHeaderRowDefs","_contentFooterRowDefs","_contentRowDefs","defaultRowDefs","_defaultRowDef","columnsDiffReducer","acc","dataColumnsChanged","reduce","headerColumnsChanged","footerColumnsChanged","columnDefs","columnName","rowOutlet","renderedRows","viewRef","rootNodes","multiTemplateDataRows","outlet","cellTemplate","_getCellTemplates","renderIndex","count","last","even","odd","columnId","documentFragment","createDocumentFragment","sections","tag","outlets","section","stickyCheckReducer","d","StickyStyler","items","_noDataRow","shouldShow","ɵngcc3","fixedLayout","exportAs","useClass","_DisposeViewRepeaterStrategy","useValue","array","concat","CdkTextColumn","_options","_syncColumnDefName","_createDefaultHeaderText","defaultDataAccessor","defaultHeaderTextTransform","toUpperCase","CdkTextColumn_th_1_Template","CdkTextColumn_td_2_Template","CdkTableModule"],"sources":["webpack:///node_modules/@angular/cdk/fesm2015/bidi.js","webpack:///node_modules/@angular/cdk/fesm2015/coercion.js","webpack:///node_modules/@angular/cdk/fesm2015/collections.js","webpack:///node_modules/@angular/cdk/fesm2015/platform.js","webpack:///node_modules/@angular/cdk/fesm2015/scrolling.js","webpack:///node_modules/@angular/cdk/fesm2015/table.js"],"sourcesContent":["import { InjectionToken, inject, EventEmitter, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, Inject, Directive, Output, Input, NgModule } from '@angular/core';\r\nimport { DOCUMENT } from '@angular/common';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token used to inject the document into Directionality.\r\n * This is used so that the value can be faked in tests.\r\n *\r\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\r\n * tests in Safari to fail.\r\n *\r\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\r\n * themselves use things like `querySelector` in test code.\r\n *\r\n * This token is defined in a separate file from Directionality as a workaround for\r\n * https://github.com/angular/angular/issues/22559\r\n *\r\n * @docs-private\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\r\n    providedIn: 'root',\r\n    factory: DIR_DOCUMENT_FACTORY,\r\n});\r\n/** @docs-private */\r\nfunction DIR_DOCUMENT_FACTORY() {\r\n    return inject(DOCUMENT);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\r\n * Exposes the current direction and a stream of direction changes.\r\n */\r\nclass Directionality {\r\n    constructor(_document) {\r\n        /** The current 'ltr' or 'rtl' value. */\r\n        this.value = 'ltr';\r\n        /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\r\n        this.change = new EventEmitter();\r\n        if (_document) {\r\n            // TODO: handle 'auto' value -\r\n            // We still need to account for dir=\"auto\".\r\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\r\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\r\n            const bodyDir = _document.body ? _document.body.dir : null;\r\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\r\n            const value = bodyDir || htmlDir;\r\n            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.change.complete();\r\n    }\r\n}\r\nDirectionality.ɵfac = function Directionality_Factory(t) { return new (t || Directionality)(ɵngcc0.ɵɵinject(DIR_DOCUMENT, 8)); };\r\nDirectionality.ɵprov = ɵɵdefineInjectable({ factory: function Directionality_Factory() { return new Directionality(ɵɵinject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\r\nDirectionality.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Directionality, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DIR_DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Directive to listen for changes of direction of part of the DOM.\r\n *\r\n * Provides itself as Directionality such that descendant directives only need to ever inject\r\n * Directionality to get the closest direction.\r\n */\r\nclass Dir {\r\n    constructor() {\r\n        /** Normalized direction that accounts for invalid/unsupported values. */\r\n        this._dir = 'ltr';\r\n        /** Whether the `value` has been set to its initial value. */\r\n        this._isInitialized = false;\r\n        /** Event emitted when the direction changes. */\r\n        this.change = new EventEmitter();\r\n    }\r\n    /** @docs-private */\r\n    get dir() { return this._dir; }\r\n    set dir(value) {\r\n        const old = this._dir;\r\n        const normalizedValue = value ? value.toLowerCase() : value;\r\n        this._rawDir = value;\r\n        this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\r\n        if (old !== this._dir && this._isInitialized) {\r\n            this.change.emit(this._dir);\r\n        }\r\n    }\r\n    /** Current layout direction of the element. */\r\n    get value() { return this.dir; }\r\n    /** Initialize once default value has been set. */\r\n    ngAfterContentInit() {\r\n        this._isInitialized = true;\r\n    }\r\n    ngOnDestroy() {\r\n        this.change.complete();\r\n    }\r\n}\r\nDir.ɵfac = function Dir_Factory(t) { return new (t || Dir)(); };\r\nDir.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"dir\", ctx._rawDir);\r\n    } }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: Directionality, useExisting: Dir }])] });\r\nDir.propDecorators = {\r\n    change: [{ type: Output, args: ['dirChange',] }],\r\n    dir: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Dir, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[dir]',\r\n                providers: [{ provide: Directionality, useExisting: Dir }],\r\n                host: { '[attr.dir]': '_rawDir' },\r\n                exportAs: 'dir'\r\n            }]\r\n    }], function () { return []; }, { change: [{\r\n            type: Output,\r\n            args: ['dirChange']\r\n        }], dir: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass BidiModule {\r\n}\r\nBidiModule.ɵfac = function BidiModule_Factory(t) { return new (t || BidiModule)(); };\r\nBidiModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BidiModule });\r\nBidiModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BidiModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: [Dir],\r\n                declarations: [Dir]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BidiModule, { declarations: [Dir], exports: [Dir] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { BidiModule, DIR_DOCUMENT, Dir, Directionality, DIR_DOCUMENT_FACTORY as ɵangular_material_src_cdk_bidi_bidi_a };\r\n\r\n","import { ElementRef } from '@angular/core';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nfunction _isNumberValue(value) {\r\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction coerceArray(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Coerces a value to a CSS pixel value. */\r\nfunction coerceCssPixelValue(value) {\r\n    if (value == null) {\r\n        return '';\r\n    }\r\n    return typeof value === 'string' ? value : `${value}px`;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Coerces an ElementRef or an Element into an element.\r\n * Useful for APIs that can accept either a ref or the native element itself.\r\n */\r\nfunction coerceElement(elementOrRef) {\r\n    return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Coerces a value to an array of trimmed non-empty strings.\r\n * Any input that is not an array, `null` or `undefined` will be turned into a string\r\n * via `toString()` and subsequently split with the given separator.\r\n * `null` and `undefined` will result in an empty array.\r\n * This results in the following outcomes:\r\n * - `null` -&gt; `[]`\r\n * - `[null]` -&gt; `[\"null\"]`\r\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\r\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\r\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\r\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\r\n *\r\n * Useful for defining CSS classes or table columns.\r\n * @param value the value to coerce into an array of strings\r\n * @param separator split-separator if value isn't an array\r\n */\r\nfunction coerceStringArray(value, separator = /\\s+/) {\r\n    const result = [];\r\n    if (value != null) {\r\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\r\n        for (const sourceValue of sourceValues) {\r\n            const trimmedString = `${sourceValue}`.trim();\r\n            if (trimmedString) {\r\n                result.push(trimmedString);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nexport { _isNumberValue, coerceArray, coerceBooleanProperty, coerceCssPixelValue, coerceElement, coerceNumberProperty, coerceStringArray };\r\n\n","import { isObservable, of, Subject } from 'rxjs';\r\nimport { ɵɵdefineInjectable, Injectable, InjectionToken } from '@angular/core';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nclass DataSource {\r\n}\r\n/** Checks whether an object is a data source. */\r\nfunction isDataSource(value) {\r\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\r\n    // be checked as an `instanceof DataSource` since people could create their own sources\r\n    // that match the interface, but don't extend DataSource.\r\n    return value && typeof value.connect === 'function';\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** DataSource wrapper for a native array. */\r\nclass ArrayDataSource extends DataSource {\r\n    constructor(_data) {\r\n        super();\r\n        this._data = _data;\r\n    }\r\n    connect() {\r\n        return isObservable(this._data) ? this._data : of(this._data);\r\n    }\r\n    disconnect() { }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A repeater that destroys views when they are removed from a\r\n * {@link ViewContainerRef}. When new items are inserted into the container,\r\n * the repeater will always construct a new embedded view for each item.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\r\nclass _DisposeViewRepeaterStrategy {\r\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\r\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\r\n            let view;\r\n            let operation;\r\n            if (record.previousIndex == null) {\r\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\r\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\r\n                operation = 1 /* INSERTED */;\r\n            }\r\n            else if (currentIndex == null) {\r\n                viewContainerRef.remove(adjustedPreviousIndex);\r\n                operation = 3 /* REMOVED */;\r\n            }\r\n            else {\r\n                view = viewContainerRef.get(adjustedPreviousIndex);\r\n                viewContainerRef.move(view, currentIndex);\r\n                operation = 2 /* MOVED */;\r\n            }\r\n            if (itemViewChanged) {\r\n                itemViewChanged({\r\n                    context: view === null || view === void 0 ? void 0 : view.context,\r\n                    operation,\r\n                    record,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    detach() {\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A repeater that caches views when they are removed from a\r\n * {@link ViewContainerRef}. When new items are inserted into the container,\r\n * the repeater will reuse one of the cached views instead of creating a new\r\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\r\n * inserts.\r\n *\r\n * @template T The type for the embedded view's $implicit property.\r\n * @template R The type for the item in each IterableDiffer change record.\r\n * @template C The type for the context passed to each embedded view.\r\n */\r\nclass _RecycleViewRepeaterStrategy {\r\n    constructor() {\r\n        /**\r\n         * The size of the cache used to store unused views.\r\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\r\n         */\r\n        this.viewCacheSize = 20;\r\n        /**\r\n         * View cache that stores embedded view instances that have been previously stamped out,\r\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\r\n         * creating brand new ones.\r\n         *\r\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\r\n         */\r\n        this._viewCache = [];\r\n    }\r\n    /** Apply changes to the DOM. */\r\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\r\n        // Rearrange the views to put them in the right location.\r\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\r\n            let view;\r\n            let operation;\r\n            if (record.previousIndex == null) { // Item added.\r\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\r\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\r\n            }\r\n            else if (currentIndex == null) { // Item removed.\r\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\r\n                operation = 3 /* REMOVED */;\r\n            }\r\n            else { // Item moved.\r\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\r\n                operation = 2 /* MOVED */;\r\n            }\r\n            if (itemViewChanged) {\r\n                itemViewChanged({\r\n                    context: view === null || view === void 0 ? void 0 : view.context,\r\n                    operation,\r\n                    record,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    detach() {\r\n        for (const view of this._viewCache) {\r\n            view.destroy();\r\n        }\r\n        this._viewCache = [];\r\n    }\r\n    /**\r\n     * Inserts a view for a new item, either from the cache or by creating a new\r\n     * one. Returns `undefined` if the item was inserted into a cached view.\r\n     */\r\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\r\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\r\n        if (cachedView) {\r\n            cachedView.context.$implicit = value;\r\n            return undefined;\r\n        }\r\n        const viewArgs = viewArgsFactory();\r\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\r\n    }\r\n    /** Detaches the view at the given index and inserts into the view cache. */\r\n    _detachAndCacheView(index, viewContainerRef) {\r\n        const detachedView = viewContainerRef.detach(index);\r\n        this._maybeCacheView(detachedView, viewContainerRef);\r\n    }\r\n    /** Moves view at the previous index to the current index. */\r\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\r\n        const view = viewContainerRef.get(adjustedPreviousIndex);\r\n        viewContainerRef.move(view, currentIndex);\r\n        view.context.$implicit = value;\r\n        return view;\r\n    }\r\n    /**\r\n     * Cache the given detached view. If the cache is full, the view will be\r\n     * destroyed.\r\n     */\r\n    _maybeCacheView(view, viewContainerRef) {\r\n        if (this._viewCache.length < this.viewCacheSize) {\r\n            this._viewCache.push(view);\r\n        }\r\n        else {\r\n            const index = viewContainerRef.indexOf(view);\r\n            // The host component could remove views from the container outside of\r\n            // the view repeater. It's unlikely this will occur, but just in case,\r\n            // destroy the view on its own, otherwise destroy it through the\r\n            // container to ensure that all the references are removed.\r\n            if (index === -1) {\r\n                view.destroy();\r\n            }\r\n            else {\r\n                viewContainerRef.remove(index);\r\n            }\r\n        }\r\n    }\r\n    /** Inserts a recycled view from the cache at the given index. */\r\n    _insertViewFromCache(index, viewContainerRef) {\r\n        const cachedView = this._viewCache.pop();\r\n        if (cachedView) {\r\n            viewContainerRef.insert(cachedView, index);\r\n        }\r\n        return cachedView || null;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Class to be used to power selecting one or more options from a list.\r\n */\r\nclass SelectionModel {\r\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\r\n        this._multiple = _multiple;\r\n        this._emitChanges = _emitChanges;\r\n        /** Currently-selected values. */\r\n        this._selection = new Set();\r\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\r\n        this._deselectedToEmit = [];\r\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\r\n        this._selectedToEmit = [];\r\n        /** Event emitted when the value has changed. */\r\n        this.changed = new Subject();\r\n        if (initiallySelectedValues && initiallySelectedValues.length) {\r\n            if (_multiple) {\r\n                initiallySelectedValues.forEach(value => this._markSelected(value));\r\n            }\r\n            else {\r\n                this._markSelected(initiallySelectedValues[0]);\r\n            }\r\n            // Clear the array in order to avoid firing the change event for preselected values.\r\n            this._selectedToEmit.length = 0;\r\n        }\r\n    }\r\n    /** Selected values. */\r\n    get selected() {\r\n        if (!this._selected) {\r\n            this._selected = Array.from(this._selection.values());\r\n        }\r\n        return this._selected;\r\n    }\r\n    /**\r\n     * Selects a value or an array of values.\r\n     */\r\n    select(...values) {\r\n        this._verifyValueAssignment(values);\r\n        values.forEach(value => this._markSelected(value));\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Deselects a value or an array of values.\r\n     */\r\n    deselect(...values) {\r\n        this._verifyValueAssignment(values);\r\n        values.forEach(value => this._unmarkSelected(value));\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Toggles a value between selected and deselected.\r\n     */\r\n    toggle(value) {\r\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\r\n    }\r\n    /**\r\n     * Clears all of the selected values.\r\n     */\r\n    clear() {\r\n        this._unmarkAll();\r\n        this._emitChangeEvent();\r\n    }\r\n    /**\r\n     * Determines whether a value is selected.\r\n     */\r\n    isSelected(value) {\r\n        return this._selection.has(value);\r\n    }\r\n    /**\r\n     * Determines whether the model does not have a value.\r\n     */\r\n    isEmpty() {\r\n        return this._selection.size === 0;\r\n    }\r\n    /**\r\n     * Determines whether the model has a value.\r\n     */\r\n    hasValue() {\r\n        return !this.isEmpty();\r\n    }\r\n    /**\r\n     * Sorts the selected values based on a predicate function.\r\n     */\r\n    sort(predicate) {\r\n        if (this._multiple && this.selected) {\r\n            this._selected.sort(predicate);\r\n        }\r\n    }\r\n    /**\r\n     * Gets whether multiple values can be selected.\r\n     */\r\n    isMultipleSelection() {\r\n        return this._multiple;\r\n    }\r\n    /** Emits a change event and clears the records of selected and deselected values. */\r\n    _emitChangeEvent() {\r\n        // Clear the selected values so they can be re-cached.\r\n        this._selected = null;\r\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\r\n            this.changed.next({\r\n                source: this,\r\n                added: this._selectedToEmit,\r\n                removed: this._deselectedToEmit\r\n            });\r\n            this._deselectedToEmit = [];\r\n            this._selectedToEmit = [];\r\n        }\r\n    }\r\n    /** Selects a value. */\r\n    _markSelected(value) {\r\n        if (!this.isSelected(value)) {\r\n            if (!this._multiple) {\r\n                this._unmarkAll();\r\n            }\r\n            this._selection.add(value);\r\n            if (this._emitChanges) {\r\n                this._selectedToEmit.push(value);\r\n            }\r\n        }\r\n    }\r\n    /** Deselects a value. */\r\n    _unmarkSelected(value) {\r\n        if (this.isSelected(value)) {\r\n            this._selection.delete(value);\r\n            if (this._emitChanges) {\r\n                this._deselectedToEmit.push(value);\r\n            }\r\n        }\r\n    }\r\n    /** Clears out the selected values. */\r\n    _unmarkAll() {\r\n        if (!this.isEmpty()) {\r\n            this._selection.forEach(value => this._unmarkSelected(value));\r\n        }\r\n    }\r\n    /**\r\n     * Verifies the value assignment and throws an error if the specified value array is\r\n     * including multiple values while the selection model is not supporting multiple values.\r\n     */\r\n    _verifyValueAssignment(values) {\r\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getMultipleValuesInSingleSelectionError();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns an error that reports that multiple values are passed into a selection model\r\n * with a single value.\r\n * @docs-private\r\n */\r\nfunction getMultipleValuesInSingleSelectionError() {\r\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Class to coordinate unique selection based on name.\r\n * Intended to be consumed as an Angular service.\r\n * This service is needed because native radio change events are only fired on the item currently\r\n * being selected, and we still need to uncheck the previous selection.\r\n *\r\n * This service does not *store* any IDs and names because they may change at any time, so it is\r\n * less error-prone if they are simply passed through when the events occur.\r\n */\r\nclass UniqueSelectionDispatcher {\r\n    constructor() {\r\n        this._listeners = [];\r\n    }\r\n    /**\r\n     * Notify other items that selection for the given name has been set.\r\n     * @param id ID of the item.\r\n     * @param name Name of the item.\r\n     */\r\n    notify(id, name) {\r\n        for (let listener of this._listeners) {\r\n            listener(id, name);\r\n        }\r\n    }\r\n    /**\r\n     * Listen for future changes to item selection.\r\n     * @return Function used to deregister listener\r\n     */\r\n    listen(listener) {\r\n        this._listeners.push(listener);\r\n        return () => {\r\n            this._listeners = this._listeners.filter((registered) => {\r\n                return listener !== registered;\r\n            });\r\n        };\r\n    }\r\n    ngOnDestroy() {\r\n        this._listeners = [];\r\n    }\r\n}\r\nUniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\r\nUniqueSelectionDispatcher.ɵprov = ɵɵdefineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UniqueSelectionDispatcher, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return []; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\r\n * @docs-private\r\n */\r\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, getMultipleValuesInSingleSelectionError, isDataSource };\r\n\r\n","import { ɵɵdefineInjectable, ɵɵinject, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\r\nimport { isPlatformBrowser } from '@angular/common';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// Whether the current platform supports the V8 Break Iterator. The V8 check\r\n// is necessary to detect all Blink based browsers.\r\nimport * as ɵngcc0 from '@angular/core';\r\nlet hasV8BreakIterator;\r\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\r\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\r\n// the consumer is providing a polyfilled `Map`. See:\r\n// https://github.com/Microsoft/ChakraCore/issues/3189\r\n// https://github.com/angular/components/issues/15687\r\ntry {\r\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\r\n}\r\ncatch (_a) {\r\n    hasV8BreakIterator = false;\r\n}\r\n/**\r\n * Service to detect the current platform by comparing the userAgent strings and\r\n * checking browser-specific global properties.\r\n */\r\nclass Platform {\r\n    constructor(_platformId) {\r\n        this._platformId = _platformId;\r\n        // We want to use the Angular platform check because if the Document is shimmed\r\n        // without the navigator, the following checks will fail. This is preferred because\r\n        // sometimes the Document may be shimmed without the user's knowledge or intention\r\n        /** Whether the Angular application is being rendered in the browser. */\r\n        this.isBrowser = this._platformId ?\r\n            isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\r\n        /** Whether the current browser is Microsoft Edge. */\r\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\r\n        /** Whether the current rendering engine is Microsoft Trident. */\r\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\r\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\r\n        /** Whether the current rendering engine is Blink. */\r\n        this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\r\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\r\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\r\n        // ensure that Webkit runs standalone and is not used as another engine's base.\r\n        /** Whether the current rendering engine is WebKit. */\r\n        this.WEBKIT = this.isBrowser &&\r\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\r\n        /** Whether the current platform is Apple iOS. */\r\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\r\n            !('MSStream' in window);\r\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\r\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\r\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\r\n        // instead of having an unstable check for Gecko.\r\n        /** Whether the current browser is Firefox. */\r\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\r\n        /** Whether the current platform is Android. */\r\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\r\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\r\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\r\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\r\n        // Safari browser should also use Webkit as its layout engine.\r\n        /** Whether the current browser is Safari. */\r\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\r\n    }\r\n}\r\nPlatform.ɵfac = function Platform_Factory(t) { return new (t || Platform)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };\r\nPlatform.ɵprov = ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(ɵɵinject(PLATFORM_ID)); }, token: Platform, providedIn: \"root\" });\r\nPlatform.ctorParameters = () => [\r\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Platform, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: Object, decorators: [{\r\n                type: Inject,\r\n                args: [PLATFORM_ID]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass PlatformModule {\r\n}\r\nPlatformModule.ɵfac = function PlatformModule_Factory(t) { return new (t || PlatformModule)(); };\r\nPlatformModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PlatformModule });\r\nPlatformModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlatformModule, [{\r\n        type: NgModule,\r\n        args: [{}]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result Set of input types support by the current browser. */\r\nlet supportedInputTypes;\r\n/** Types of `<input>` that *might* be supported. */\r\nconst candidateInputTypes = [\r\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\r\n    // first changing it to something else:\r\n    // The specified value \"\" does not conform to the required format.\r\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\r\n    'color',\r\n    'button',\r\n    'checkbox',\r\n    'date',\r\n    'datetime-local',\r\n    'email',\r\n    'file',\r\n    'hidden',\r\n    'image',\r\n    'month',\r\n    'number',\r\n    'password',\r\n    'radio',\r\n    'range',\r\n    'reset',\r\n    'search',\r\n    'submit',\r\n    'tel',\r\n    'text',\r\n    'time',\r\n    'url',\r\n    'week',\r\n];\r\n/** @returns The input types supported by this browser. */\r\nfunction getSupportedInputTypes() {\r\n    // Result is cached.\r\n    if (supportedInputTypes) {\r\n        return supportedInputTypes;\r\n    }\r\n    // We can't check if an input type is not supported until we're on the browser, so say that\r\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\r\n    // just a helper function and can't inject it.\r\n    if (typeof document !== 'object' || !document) {\r\n        supportedInputTypes = new Set(candidateInputTypes);\r\n        return supportedInputTypes;\r\n    }\r\n    let featureTestInput = document.createElement('input');\r\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\r\n        featureTestInput.setAttribute('type', value);\r\n        return featureTestInput.type === value;\r\n    }));\r\n    return supportedInputTypes;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result of whether the user's browser supports passive event listeners. */\r\nlet supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\r\nfunction supportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                get: () => supportsPassiveEvents = true\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\r\nfunction normalizePassiveListenerOptions(options) {\r\n    return supportsPassiveEventListeners() ? options : !!options.capture;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\r\nlet rtlScrollAxisType;\r\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\r\nlet scrollBehaviorSupported;\r\n/** Check whether the browser supports scroll behaviors. */\r\nfunction supportsScrollBehavior() {\r\n    if (scrollBehaviorSupported == null) {\r\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\r\n        // some projects stub out the global `document` during SSR which can throw us off.\r\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\r\n            scrollBehaviorSupported = false;\r\n            return scrollBehaviorSupported;\r\n        }\r\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\r\n        if ('scrollBehavior' in document.documentElement.style) {\r\n            scrollBehaviorSupported = true;\r\n        }\r\n        else {\r\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\r\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\r\n            const scrollToFunction = Element.prototype.scrollTo;\r\n            if (scrollToFunction) {\r\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\r\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\r\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\r\n                // polyfilled functions as supporting scroll behavior.\r\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\r\n            }\r\n            else {\r\n                scrollBehaviorSupported = false;\r\n            }\r\n        }\r\n    }\r\n    return scrollBehaviorSupported;\r\n}\r\n/**\r\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\r\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\r\n */\r\nfunction getRtlScrollAxisType() {\r\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\r\n    if (typeof document !== 'object' || !document) {\r\n        return 0 /* NORMAL */;\r\n    }\r\n    if (rtlScrollAxisType == null) {\r\n        // Create a 1px wide scrolling container and a 2px wide content element.\r\n        const scrollContainer = document.createElement('div');\r\n        const containerStyle = scrollContainer.style;\r\n        scrollContainer.dir = 'rtl';\r\n        containerStyle.width = '1px';\r\n        containerStyle.overflow = 'auto';\r\n        containerStyle.visibility = 'hidden';\r\n        containerStyle.pointerEvents = 'none';\r\n        containerStyle.position = 'absolute';\r\n        const content = document.createElement('div');\r\n        const contentStyle = content.style;\r\n        contentStyle.width = '2px';\r\n        contentStyle.height = '1px';\r\n        scrollContainer.appendChild(content);\r\n        document.body.appendChild(scrollContainer);\r\n        rtlScrollAxisType = 0 /* NORMAL */;\r\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\r\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\r\n        // dealing with one of the other two types of browsers.\r\n        if (scrollContainer.scrollLeft === 0) {\r\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\r\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\r\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\r\n            // return 0 when we read it again.\r\n            scrollContainer.scrollLeft = 1;\r\n            rtlScrollAxisType =\r\n                scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\r\n        }\r\n        scrollContainer.parentNode.removeChild(scrollContainer);\r\n    }\r\n    return rtlScrollAxisType;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nlet shadowDomIsSupported;\r\n/** Checks whether the user's browser support Shadow DOM. */\r\nfunction _supportsShadowDom() {\r\n    if (shadowDomIsSupported == null) {\r\n        const head = typeof document !== 'undefined' ? document.head : null;\r\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\r\n    }\r\n    return shadowDomIsSupported;\r\n}\r\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\r\nfunction _getShadowRoot(element) {\r\n    if (_supportsShadowDom()) {\r\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\r\n        // Note that this should be caught by `_supportsShadowDom`, but some\r\n        // teams have been able to hit this code path on unsupported browsers.\r\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\r\n            return rootNode;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { Platform, PlatformModule, _getShadowRoot, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };\r\n\r\n","import { coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\r\nimport { InjectionToken, Directive, forwardRef, Input, ɵɵdefineInjectable, ɵɵinject, NgZone, Injectable, Optional, Inject, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Output, ViewChild, ViewContainerRef, TemplateRef, IterableDiffers, SkipSelf, NgModule } from '@angular/core';\r\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\r\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\r\nimport { Platform, getRtlScrollAxisType, supportsScrollBehavior, PlatformModule } from '@angular/cdk/platform';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\r\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** The injection token used to specify the virtual scrolling strategy. */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/platform';\r\nimport * as ɵngcc2 from '@angular/cdk/bidi';\r\nimport * as ɵngcc3 from '@angular/cdk/collections';\r\n\r\nconst _c0 = [\"contentWrapper\"];\r\nconst _c1 = [\"*\"];\r\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Virtual scrolling strategy for lists with items of known fixed size. */\r\nclass FixedSizeVirtualScrollStrategy {\r\n    /**\r\n     * @param itemSize The size of the items in the virtually scrolling list.\r\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     */\r\n    constructor(itemSize, minBufferPx, maxBufferPx) {\r\n        this._scrolledIndexChange = new Subject();\r\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\r\n        /** The attached viewport. */\r\n        this._viewport = null;\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n    }\r\n    /**\r\n     * Attaches this scroll strategy to a viewport.\r\n     * @param viewport The viewport to attach this strategy to.\r\n     */\r\n    attach(viewport) {\r\n        this._viewport = viewport;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** Detaches this scroll strategy from the currently attached viewport. */\r\n    detach() {\r\n        this._scrolledIndexChange.complete();\r\n        this._viewport = null;\r\n    }\r\n    /**\r\n     * Update the item size and buffer size.\r\n     * @param itemSize The size of the items in the virtually scrolling list.\r\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\r\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\r\n     */\r\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\r\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\r\n        }\r\n        this._itemSize = itemSize;\r\n        this._minBufferPx = minBufferPx;\r\n        this._maxBufferPx = maxBufferPx;\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onContentScrolled() {\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onDataLengthChanged() {\r\n        this._updateTotalContentSize();\r\n        this._updateRenderedRange();\r\n    }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onContentRendered() { }\r\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\r\n    onRenderedOffsetChanged() { }\r\n    /**\r\n     * Scroll to the offset for the given index.\r\n     * @param index The index of the element to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling.\r\n     */\r\n    scrollToIndex(index, behavior) {\r\n        if (this._viewport) {\r\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\r\n        }\r\n    }\r\n    /** Update the viewport's total content size. */\r\n    _updateTotalContentSize() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\r\n    }\r\n    /** Update the viewport's rendered range. */\r\n    _updateRenderedRange() {\r\n        if (!this._viewport) {\r\n            return;\r\n        }\r\n        const renderedRange = this._viewport.getRenderedRange();\r\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\r\n        const viewportSize = this._viewport.getViewportSize();\r\n        const dataLength = this._viewport.getDataLength();\r\n        let scrollOffset = this._viewport.measureScrollOffset();\r\n        // Prevent NaN as result when dividing by zero.\r\n        let firstVisibleIndex = (this._itemSize > 0) ? scrollOffset / this._itemSize : 0;\r\n        // If user scrolls to the bottom of the list and data changes to a smaller list\r\n        if (newRange.end > dataLength) {\r\n            // We have to recalculate the first visible index based on new data length and viewport size.\r\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\r\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\r\n            // If first visible index changed we must update scroll offset to handle start/end buffers\r\n            // Current range must also be adjusted to cover the new position (bottom of new list).\r\n            if (firstVisibleIndex != newVisibleIndex) {\r\n                firstVisibleIndex = newVisibleIndex;\r\n                scrollOffset = newVisibleIndex * this._itemSize;\r\n                newRange.start = Math.floor(firstVisibleIndex);\r\n            }\r\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\r\n        }\r\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\r\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\r\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\r\n            newRange.start = Math.max(0, newRange.start - expandStart);\r\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\r\n        }\r\n        else {\r\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\r\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\r\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\r\n                if (expandEnd > 0) {\r\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\r\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\r\n                }\r\n            }\r\n        }\r\n        this._viewport.setRenderedRange(newRange);\r\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\r\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\r\n    }\r\n}\r\n/**\r\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\r\n * `FixedSizeVirtualScrollStrategy` from the given directive.\r\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\r\n *     `FixedSizeVirtualScrollStrategy` from.\r\n */\r\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\r\n    return fixedSizeDir._scrollStrategy;\r\n}\r\n/** A virtual scroll strategy that supports fixed-size items. */\r\nclass CdkFixedSizeVirtualScroll {\r\n    constructor() {\r\n        this._itemSize = 20;\r\n        this._minBufferPx = 100;\r\n        this._maxBufferPx = 200;\r\n        /** The scroll strategy used by this directive. */\r\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n    /** The size of the items in the list (in pixels). */\r\n    get itemSize() { return this._itemSize; }\r\n    set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\r\n    /**\r\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\r\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\r\n     */\r\n    get minBufferPx() { return this._minBufferPx; }\r\n    set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\r\n    /**\r\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\r\n     */\r\n    get maxBufferPx() { return this._maxBufferPx; }\r\n    set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\r\n    ngOnChanges() {\r\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\r\n    }\r\n}\r\nCdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\r\nCdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: VIRTUAL_SCROLL_STRATEGY,\r\n                useFactory: _fixedSizeVirtualScrollStrategyFactory,\r\n                deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\r\n            }]), ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkFixedSizeVirtualScroll.propDecorators = {\r\n    itemSize: [{ type: Input }],\r\n    minBufferPx: [{ type: Input }],\r\n    maxBufferPx: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFixedSizeVirtualScroll, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-virtual-scroll-viewport[itemSize]',\r\n                providers: [{\r\n                        provide: VIRTUAL_SCROLL_STRATEGY,\r\n                        useFactory: _fixedSizeVirtualScrollStrategyFactory,\r\n                        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\r\n                    }]\r\n            }]\r\n    }], function () { return []; }, { itemSize: [{\r\n            type: Input\r\n        }], minBufferPx: [{\r\n            type: Input\r\n        }], maxBufferPx: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Time in ms to throttle the scrolling events by default. */\r\nconst DEFAULT_SCROLL_TIME = 20;\r\n/**\r\n * Service contained all registered Scrollable references and emits an event when any one of the\r\n * Scrollable references emit a scrolled event.\r\n */\r\nclass ScrollDispatcher {\r\n    constructor(_ngZone, _platform, document) {\r\n        this._ngZone = _ngZone;\r\n        this._platform = _platform;\r\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\r\n        this._scrolled = new Subject();\r\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\r\n        this._globalSubscription = null;\r\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\r\n        this._scrolledCount = 0;\r\n        /**\r\n         * Map of all the scrollable references that are registered with the service and their\r\n         * scroll event subscriptions.\r\n         */\r\n        this.scrollContainers = new Map();\r\n        this._document = document;\r\n    }\r\n    /**\r\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\r\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\r\n     * @param scrollable Scrollable instance to be registered.\r\n     */\r\n    register(scrollable) {\r\n        if (!this.scrollContainers.has(scrollable)) {\r\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled()\r\n                .subscribe(() => this._scrolled.next(scrollable)));\r\n        }\r\n    }\r\n    /**\r\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\n     * @param scrollable Scrollable instance to be deregistered.\r\n     */\r\n    deregister(scrollable) {\r\n        const scrollableReference = this.scrollContainers.get(scrollable);\r\n        if (scrollableReference) {\r\n            scrollableReference.unsubscribe();\r\n            this.scrollContainers.delete(scrollable);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an observable that emits an event whenever any of the registered Scrollable\r\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\r\n     * to override the default \"throttle\" time.\r\n     *\r\n     * **Note:** in order to avoid hitting change detection for every scroll event,\r\n     * all of the events emitted from this stream will be run outside the Angular zone.\r\n     * If you need to update any data bindings as a result of a scroll event, you have\r\n     * to run the callback using `NgZone.run`.\r\n     */\r\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\r\n        if (!this._platform.isBrowser) {\r\n            return of();\r\n        }\r\n        return new Observable((observer) => {\r\n            if (!this._globalSubscription) {\r\n                this._addGlobalListener();\r\n            }\r\n            // In the case of a 0ms delay, use an observable without auditTime\r\n            // since it does add a perceptible delay in processing overhead.\r\n            const subscription = auditTimeInMs > 0 ?\r\n                this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\r\n                this._scrolled.subscribe(observer);\r\n            this._scrolledCount++;\r\n            return () => {\r\n                subscription.unsubscribe();\r\n                this._scrolledCount--;\r\n                if (!this._scrolledCount) {\r\n                    this._removeGlobalListener();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this._removeGlobalListener();\r\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\r\n        this._scrolled.complete();\r\n    }\r\n    /**\r\n     * Returns an observable that emits whenever any of the\r\n     * scrollable ancestors of an element are scrolled.\r\n     * @param elementOrElementRef Element whose ancestors to listen for.\r\n     * @param auditTimeInMs Time to throttle the scroll events.\r\n     */\r\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\r\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\r\n        return this.scrolled(auditTimeInMs).pipe(filter(target => {\r\n            return !target || ancestors.indexOf(target) > -1;\r\n        }));\r\n    }\r\n    /** Returns all registered Scrollables that contain the provided element. */\r\n    getAncestorScrollContainers(elementOrElementRef) {\r\n        const scrollingContainers = [];\r\n        this.scrollContainers.forEach((_subscription, scrollable) => {\r\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\r\n                scrollingContainers.push(scrollable);\r\n            }\r\n        });\r\n        return scrollingContainers;\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    /** Returns true if the element is contained within the provided Scrollable. */\r\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\r\n        let element = coerceElement(elementOrElementRef);\r\n        let scrollableElement = scrollable.getElementRef().nativeElement;\r\n        // Traverse through the element parents until we reach null, checking if any of the elements\r\n        // are the scrollable's element.\r\n        do {\r\n            if (element == scrollableElement) {\r\n                return true;\r\n            }\r\n        } while (element = element.parentElement);\r\n        return false;\r\n    }\r\n    /** Sets up the global scroll listeners. */\r\n    _addGlobalListener() {\r\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\r\n            const window = this._getWindow();\r\n            return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\r\n        });\r\n    }\r\n    /** Cleans up the global scroll listener. */\r\n    _removeGlobalListener() {\r\n        if (this._globalSubscription) {\r\n            this._globalSubscription.unsubscribe();\r\n            this._globalSubscription = null;\r\n        }\r\n    }\r\n}\r\nScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(DOCUMENT, 8)); };\r\nScrollDispatcher.ɵprov = ɵɵdefineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\r\nScrollDispatcher.ctorParameters = () => [\r\n    { type: NgZone },\r\n    { type: Platform },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollDispatcher, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Sends an event when the directive's element is scrolled. Registers itself with the\r\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\r\n * can be listened to through the service.\r\n */\r\nclass CdkScrollable {\r\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\r\n        this.elementRef = elementRef;\r\n        this.scrollDispatcher = scrollDispatcher;\r\n        this.ngZone = ngZone;\r\n        this.dir = dir;\r\n        this._destroyed = new Subject();\r\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\r\n            .subscribe(observer)));\r\n    }\r\n    ngOnInit() {\r\n        this.scrollDispatcher.register(this);\r\n    }\r\n    ngOnDestroy() {\r\n        this.scrollDispatcher.deregister(this);\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /** Returns observable that emits when a scroll event is fired on the host element. */\r\n    elementScrolled() {\r\n        return this._elementScrolled;\r\n    }\r\n    /** Gets the ElementRef for the viewport. */\r\n    getElementRef() {\r\n        return this.elementRef;\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param options specified the offsets to scroll to.\r\n     */\r\n    scrollTo(options) {\r\n        const el = this.elementRef.nativeElement;\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        // Rewrite start & end offsets as right or left offsets.\r\n        if (options.left == null) {\r\n            options.left = isRtl ? options.end : options.start;\r\n        }\r\n        if (options.right == null) {\r\n            options.right = isRtl ? options.start : options.end;\r\n        }\r\n        // Rewrite the bottom offset as a top offset.\r\n        if (options.bottom != null) {\r\n            options.top =\r\n                el.scrollHeight - el.clientHeight - options.bottom;\r\n        }\r\n        // Rewrite the right offset as a left offset.\r\n        if (isRtl && getRtlScrollAxisType() != 0 /* NORMAL */) {\r\n            if (options.left != null) {\r\n                options.right =\r\n                    el.scrollWidth - el.clientWidth - options.left;\r\n            }\r\n            if (getRtlScrollAxisType() == 2 /* INVERTED */) {\r\n                options.left = options.right;\r\n            }\r\n            else if (getRtlScrollAxisType() == 1 /* NEGATED */) {\r\n                options.left = options.right ? -options.right : options.right;\r\n            }\r\n        }\r\n        else {\r\n            if (options.right != null) {\r\n                options.left =\r\n                    el.scrollWidth - el.clientWidth - options.right;\r\n            }\r\n        }\r\n        this._applyScrollToOptions(options);\r\n    }\r\n    _applyScrollToOptions(options) {\r\n        const el = this.elementRef.nativeElement;\r\n        if (supportsScrollBehavior()) {\r\n            el.scrollTo(options);\r\n        }\r\n        else {\r\n            if (options.top != null) {\r\n                el.scrollTop = options.top;\r\n            }\r\n            if (options.left != null) {\r\n                el.scrollLeft = options.left;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\r\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\r\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param from The edge to measure from.\r\n     */\r\n    measureScrollOffset(from) {\r\n        const LEFT = 'left';\r\n        const RIGHT = 'right';\r\n        const el = this.elementRef.nativeElement;\r\n        if (from == 'top') {\r\n            return el.scrollTop;\r\n        }\r\n        if (from == 'bottom') {\r\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\r\n        }\r\n        // Rewrite start & end as left or right offsets.\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        if (from == 'start') {\r\n            from = isRtl ? RIGHT : LEFT;\r\n        }\r\n        else if (from == 'end') {\r\n            from = isRtl ? LEFT : RIGHT;\r\n        }\r\n        if (isRtl && getRtlScrollAxisType() == 2 /* INVERTED */) {\r\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollLeft;\r\n            }\r\n        }\r\n        else if (isRtl && getRtlScrollAxisType() == 1 /* NEGATED */) {\r\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\r\n            // 0 when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\r\n            }\r\n            else {\r\n                return -el.scrollLeft;\r\n            }\r\n        }\r\n        else {\r\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\r\n            // (scrollWidth - clientWidth) when scrolled all the way right.\r\n            if (from == LEFT) {\r\n                return el.scrollLeft;\r\n            }\r\n            else {\r\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n            }\r\n        }\r\n    }\r\n}\r\nCdkScrollable.ɵfac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8)); };\r\nCdkScrollable.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\r\nCdkScrollable.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ScrollDispatcher },\r\n    { type: NgZone },\r\n    { type: Directionality, decorators: [{ type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkScrollable, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdk-scrollable], [cdkScrollable]'\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScrollDispatcher }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Time in ms to throttle the resize events by default. */\r\nconst DEFAULT_RESIZE_TIME = 20;\r\n/**\r\n * Simple utility for getting the bounds of the browser viewport.\r\n * @docs-private\r\n */\r\nclass ViewportRuler {\r\n    constructor(_platform, ngZone, document) {\r\n        this._platform = _platform;\r\n        /** Stream of viewport change events. */\r\n        this._change = new Subject();\r\n        /** Event listener that will be used to handle the viewport change events. */\r\n        this._changeListener = (event) => {\r\n            this._change.next(event);\r\n        };\r\n        this._document = document;\r\n        ngZone.runOutsideAngular(() => {\r\n            if (_platform.isBrowser) {\r\n                const window = this._getWindow();\r\n                // Note that bind the events ourselves, rather than going through something like RxJS's\r\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\r\n                window.addEventListener('resize', this._changeListener);\r\n                window.addEventListener('orientationchange', this._changeListener);\r\n            }\r\n            // We don't need to keep track of the subscription,\r\n            // because we complete the `change` stream on destroy.\r\n            this.change().subscribe(() => this._updateViewportSize());\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._platform.isBrowser) {\r\n            const window = this._getWindow();\r\n            window.removeEventListener('resize', this._changeListener);\r\n            window.removeEventListener('orientationchange', this._changeListener);\r\n        }\r\n        this._change.complete();\r\n    }\r\n    /** Returns the viewport's width and height. */\r\n    getViewportSize() {\r\n        if (!this._viewportSize) {\r\n            this._updateViewportSize();\r\n        }\r\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\r\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\r\n        if (!this._platform.isBrowser) {\r\n            this._viewportSize = null;\r\n        }\r\n        return output;\r\n    }\r\n    /** Gets a ClientRect for the viewport's bounds. */\r\n    getViewportRect() {\r\n        // Use the document element's bounding rect rather than the window scroll properties\r\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n        // We use the documentElement instead of the body because, by default (without a css reset)\r\n        // browsers typically give the document body an 8px margin, which is not included in\r\n        // getBoundingClientRect().\r\n        const scrollPosition = this.getViewportScrollPosition();\r\n        const { width, height } = this.getViewportSize();\r\n        return {\r\n            top: scrollPosition.top,\r\n            left: scrollPosition.left,\r\n            bottom: scrollPosition.top + height,\r\n            right: scrollPosition.left + width,\r\n            height,\r\n            width,\r\n        };\r\n    }\r\n    /** Gets the (top, left) scroll position of the viewport. */\r\n    getViewportScrollPosition() {\r\n        // While we can get a reference to the fake document\r\n        // during SSR, it doesn't have getBoundingClientRect.\r\n        if (!this._platform.isBrowser) {\r\n            return { top: 0, left: 0 };\r\n        }\r\n        // The top-left-corner of the viewport is determined by the scroll position of the document\r\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n        // `document.documentElement` works consistently, where the `top` and `left` values will\r\n        // equal negative the scroll position.\r\n        const document = this._document;\r\n        const window = this._getWindow();\r\n        const documentElement = document.documentElement;\r\n        const documentRect = documentElement.getBoundingClientRect();\r\n        const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\r\n            documentElement.scrollTop || 0;\r\n        const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\r\n            documentElement.scrollLeft || 0;\r\n        return { top, left };\r\n    }\r\n    /**\r\n     * Returns a stream that emits whenever the size of the viewport changes.\r\n     * @param throttleTime Time in milliseconds to throttle the stream.\r\n     */\r\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\r\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    /** Updates the cached viewport size. */\r\n    _updateViewportSize() {\r\n        const window = this._getWindow();\r\n        this._viewportSize = this._platform.isBrowser ?\r\n            { width: window.innerWidth, height: window.innerHeight } :\r\n            { width: 0, height: 0 };\r\n    }\r\n}\r\nViewportRuler.ɵfac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT, 8)); };\r\nViewportRuler.ɵprov = ɵɵdefineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8)); }, token: ViewportRuler, providedIn: \"root\" });\r\nViewportRuler.ctorParameters = () => [\r\n    { type: Platform },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ViewportRuler, [{\r\n        type: Injectable,\r\n        args: [{ providedIn: 'root' }]\r\n    }], function () { return [{ type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Checks if the given ranges are equal. */\r\nfunction rangesEqual(r1, r2) {\r\n    return r1.start == r2.start && r1.end == r2.end;\r\n}\r\n/**\r\n * Scheduler to be used for scroll events. Needs to fall back to\r\n * something that doesn't rely on requestAnimationFrame on environments\r\n * that don't support it (e.g. server-side rendering).\r\n */\r\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\r\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\r\nclass CdkVirtualScrollViewport extends CdkScrollable {\r\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {\r\n        super(elementRef, scrollDispatcher, ngZone, dir);\r\n        this.elementRef = elementRef;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._scrollStrategy = _scrollStrategy;\r\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\r\n        this._detachedSubject = new Subject();\r\n        /** Emits when the rendered range changes. */\r\n        this._renderedRangeSubject = new Subject();\r\n        this._orientation = 'vertical';\r\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\r\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\r\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\r\n        // performance.\r\n        /** Emits when the index of the first element visible in the viewport changes. */\r\n        this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\r\n        /** A stream that emits whenever the rendered range changes. */\r\n        this.renderedRangeStream = this._renderedRangeSubject;\r\n        /**\r\n         * The total size of all content (in pixels), including content that is not currently rendered.\r\n         */\r\n        this._totalContentSize = 0;\r\n        /** A string representing the `style.width` property value to be used for the spacer element. */\r\n        this._totalContentWidth = '';\r\n        /** A string representing the `style.height` property value to be used for the spacer element. */\r\n        this._totalContentHeight = '';\r\n        /** The currently rendered range of indices. */\r\n        this._renderedRange = { start: 0, end: 0 };\r\n        /** The length of the data bound to this viewport (in number of items). */\r\n        this._dataLength = 0;\r\n        /** The size of the viewport (in pixels). */\r\n        this._viewportSize = 0;\r\n        /** The last rendered content offset that was set. */\r\n        this._renderedContentOffset = 0;\r\n        /**\r\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\r\n         * be rewritten as an offset to the start of the content).\r\n         */\r\n        this._renderedContentOffsetNeedsRewrite = false;\r\n        /** Whether there is a pending change detection cycle. */\r\n        this._isChangeDetectionPending = false;\r\n        /** A list of functions to run after the next change detection cycle. */\r\n        this._runAfterChangeDetection = [];\r\n        /** Subscription to changes in the viewport size. */\r\n        this._viewportChanges = Subscription.EMPTY;\r\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\r\n        }\r\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\r\n            this.checkViewportSize();\r\n        });\r\n    }\r\n    /** The direction the viewport scrolls. */\r\n    get orientation() {\r\n        return this._orientation;\r\n    }\r\n    set orientation(orientation) {\r\n        if (this._orientation !== orientation) {\r\n            this._orientation = orientation;\r\n            this._calculateSpacerSize();\r\n        }\r\n    }\r\n    ngOnInit() {\r\n        super.ngOnInit();\r\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\r\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\r\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\r\n        // ourselves instead.\r\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n            this._measureViewportSize();\r\n            this._scrollStrategy.attach(this);\r\n            this.elementScrolled()\r\n                .pipe(\r\n            // Start off with a fake scroll event so we properly detect our initial position.\r\n            startWith(null), \r\n            // Collect multiple events into one until the next animation frame. This way if\r\n            // there are multiple scroll events in the same frame we only need to recheck\r\n            // our layout once.\r\n            auditTime(0, SCROLL_SCHEDULER))\r\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\r\n            this._markChangeDetectionNeeded();\r\n        }));\r\n    }\r\n    ngOnDestroy() {\r\n        this.detach();\r\n        this._scrollStrategy.detach();\r\n        // Complete all subjects\r\n        this._renderedRangeSubject.complete();\r\n        this._detachedSubject.complete();\r\n        this._viewportChanges.unsubscribe();\r\n        super.ngOnDestroy();\r\n    }\r\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\r\n    attach(forOf) {\r\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error('CdkVirtualScrollViewport is already attached.');\r\n        }\r\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\r\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\r\n        // change detection loop ourselves.\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this._forOf = forOf;\r\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\r\n                const newLength = data.length;\r\n                if (newLength !== this._dataLength) {\r\n                    this._dataLength = newLength;\r\n                    this._scrollStrategy.onDataLengthChanged();\r\n                }\r\n                this._doChangeDetection();\r\n            });\r\n        });\r\n    }\r\n    /** Detaches the current `CdkVirtualForOf`. */\r\n    detach() {\r\n        this._forOf = null;\r\n        this._detachedSubject.next();\r\n    }\r\n    /** Gets the length of the data bound to this viewport (in number of items). */\r\n    getDataLength() {\r\n        return this._dataLength;\r\n    }\r\n    /** Gets the size of the viewport (in pixels). */\r\n    getViewportSize() {\r\n        return this._viewportSize;\r\n    }\r\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\r\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\r\n    // setting it to something else, but its error prone and should probably be split into\r\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\r\n    /** Get the current rendered range of items. */\r\n    getRenderedRange() {\r\n        return this._renderedRange;\r\n    }\r\n    /**\r\n     * Sets the total size of all content (in pixels), including content that is not currently\r\n     * rendered.\r\n     */\r\n    setTotalContentSize(size) {\r\n        if (this._totalContentSize !== size) {\r\n            this._totalContentSize = size;\r\n            this._calculateSpacerSize();\r\n            this._markChangeDetectionNeeded();\r\n        }\r\n    }\r\n    /** Sets the currently rendered range of indices. */\r\n    setRenderedRange(range) {\r\n        if (!rangesEqual(this._renderedRange, range)) {\r\n            this._renderedRangeSubject.next(this._renderedRange = range);\r\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\r\n        }\r\n    }\r\n    /**\r\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\r\n     */\r\n    getOffsetToRenderedContentStart() {\r\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\r\n    }\r\n    /**\r\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\r\n     * (in pixels).\r\n     */\r\n    setRenderedContentOffset(offset, to = 'to-start') {\r\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\r\n        // in the negative direction.\r\n        const isRtl = this.dir && this.dir.value == 'rtl';\r\n        const isHorizontal = this.orientation == 'horizontal';\r\n        const axis = isHorizontal ? 'X' : 'Y';\r\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\r\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\r\n        this._renderedContentOffset = offset;\r\n        if (to === 'to-end') {\r\n            transform += ` translate${axis}(-100%)`;\r\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\r\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\r\n            // expand upward).\r\n            this._renderedContentOffsetNeedsRewrite = true;\r\n        }\r\n        if (this._renderedContentTransform != transform) {\r\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\r\n            // into the string.\r\n            this._renderedContentTransform = transform;\r\n            this._markChangeDetectionNeeded(() => {\r\n                if (this._renderedContentOffsetNeedsRewrite) {\r\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\r\n                    this._renderedContentOffsetNeedsRewrite = false;\r\n                    this.setRenderedContentOffset(this._renderedContentOffset);\r\n                }\r\n                else {\r\n                    this._scrollStrategy.onRenderedOffsetChanged();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\r\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\r\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\r\n     * @param offset The offset to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToOffset(offset, behavior = 'auto') {\r\n        const options = { behavior };\r\n        if (this.orientation === 'horizontal') {\r\n            options.start = offset;\r\n        }\r\n        else {\r\n            options.top = offset;\r\n        }\r\n        this.scrollTo(options);\r\n    }\r\n    /**\r\n     * Scrolls to the offset for the given index.\r\n     * @param index The index of the element to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToIndex(index, behavior = 'auto') {\r\n        this._scrollStrategy.scrollToIndex(index, behavior);\r\n    }\r\n    /**\r\n     * Gets the current scroll offset from the start of the viewport (in pixels).\r\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\r\n     *     in horizontal mode.\r\n     */\r\n    measureScrollOffset(from) {\r\n        return from ?\r\n            super.measureScrollOffset(from) :\r\n            super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\r\n    }\r\n    /** Measure the combined size of all of the rendered items. */\r\n    measureRenderedContentSize() {\r\n        const contentEl = this._contentWrapper.nativeElement;\r\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\r\n    }\r\n    /**\r\n     * Measure the total combined size of the given range. Throws if the range includes items that are\r\n     * not rendered.\r\n     */\r\n    measureRangeSize(range) {\r\n        if (!this._forOf) {\r\n            return 0;\r\n        }\r\n        return this._forOf.measureRangeSize(range, this.orientation);\r\n    }\r\n    /** Update the viewport dimensions and re-render. */\r\n    checkViewportSize() {\r\n        // TODO: Cleanup later when add logic for handling content resize\r\n        this._measureViewportSize();\r\n        this._scrollStrategy.onDataLengthChanged();\r\n    }\r\n    /** Measure the viewport size. */\r\n    _measureViewportSize() {\r\n        const viewportEl = this.elementRef.nativeElement;\r\n        this._viewportSize = this.orientation === 'horizontal' ?\r\n            viewportEl.clientWidth : viewportEl.clientHeight;\r\n    }\r\n    /** Queue up change detection to run. */\r\n    _markChangeDetectionNeeded(runAfter) {\r\n        if (runAfter) {\r\n            this._runAfterChangeDetection.push(runAfter);\r\n        }\r\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\r\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\r\n        if (!this._isChangeDetectionPending) {\r\n            this._isChangeDetectionPending = true;\r\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\r\n                this._doChangeDetection();\r\n            }));\r\n        }\r\n    }\r\n    /** Run change detection. */\r\n    _doChangeDetection() {\r\n        this._isChangeDetectionPending = false;\r\n        // Apply the content transform. The transform can't be set via an Angular binding because\r\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\r\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\r\n        // the `Number` function first to coerce it to a numeric value.\r\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\r\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\r\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\r\n        // instead does not properly check the projected content.\r\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\r\n        const runAfterChangeDetection = this._runAfterChangeDetection;\r\n        this._runAfterChangeDetection = [];\r\n        for (const fn of runAfterChangeDetection) {\r\n            fn();\r\n        }\r\n    }\r\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\r\n    _calculateSpacerSize() {\r\n        this._totalContentHeight =\r\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\r\n        this._totalContentWidth =\r\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\r\n    }\r\n}\r\nCdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ViewportRuler)); };\r\nCdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);\r\n    } }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\r\n    } }, inputs: { orientation: \"orientation\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: CdkScrollable,\r\n                useExisting: CdkVirtualScrollViewport\r\n            }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\r\n        ɵngcc0.ɵɵprojection(2);\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelement(3, \"div\", 2);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵadvance(3);\r\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\r\n    } }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\r\nCdkVirtualScrollViewport.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ChangeDetectorRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [VIRTUAL_SCROLL_STRATEGY,] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: ScrollDispatcher },\r\n    { type: ViewportRuler }\r\n];\r\nCdkVirtualScrollViewport.propDecorators = {\r\n    orientation: [{ type: Input }],\r\n    scrolledIndexChange: [{ type: Output }],\r\n    _contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { static: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkVirtualScrollViewport, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-virtual-scroll-viewport',\r\n                template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\r\n                host: {\r\n                    'class': 'cdk-virtual-scroll-viewport',\r\n                    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\r\n                    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"'\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                providers: [{\r\n                        provide: CdkScrollable,\r\n                        useExisting: CdkVirtualScrollViewport\r\n                    }],\r\n                styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [VIRTUAL_SCROLL_STRATEGY]\r\n            }] }, { type: ɵngcc2.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ScrollDispatcher }, { type: ViewportRuler }]; }, { scrolledIndexChange: [{\r\n            type: Output\r\n        }], orientation: [{\r\n            type: Input\r\n        }], _contentWrapper: [{\r\n            type: ViewChild,\r\n            args: ['contentWrapper', { static: true }]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Helper to extract the offset of a DOM Node in a certain direction. */\r\nfunction getOffset(orientation, direction, node) {\r\n    const el = node;\r\n    if (!el.getBoundingClientRect) {\r\n        return 0;\r\n    }\r\n    const rect = el.getBoundingClientRect();\r\n    if (orientation === 'horizontal') {\r\n        return direction === 'start' ? rect.left : rect.right;\r\n    }\r\n    return direction === 'start' ? rect.top : rect.bottom;\r\n}\r\n/**\r\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\r\n * container.\r\n */\r\nclass CdkVirtualForOf {\r\n    constructor(\r\n    /** The view container to add items to. */\r\n    _viewContainerRef, \r\n    /** The template to use when stamping out new items. */\r\n    _template, \r\n    /** The set of available differs. */\r\n    _differs, \r\n    /** The strategy used to render items in the virtual scroll viewport. */\r\n    _viewRepeater, \r\n    /** The virtual scrolling viewport that these items are being rendered in. */\r\n    _viewport, ngZone) {\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._template = _template;\r\n        this._differs = _differs;\r\n        this._viewRepeater = _viewRepeater;\r\n        this._viewport = _viewport;\r\n        /** Emits when the rendered view of the data changes. */\r\n        this.viewChange = new Subject();\r\n        /** Subject that emits when a new DataSource instance is given. */\r\n        this._dataSourceChanges = new Subject();\r\n        /** Emits whenever the data in the current DataSource changes. */\r\n        this.dataStream = this._dataSourceChanges\r\n            .pipe(\r\n        // Start off with null `DataSource`.\r\n        startWith(null), \r\n        // Bundle up the previous and current data sources so we can work with both.\r\n        pairwise(), \r\n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\r\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\r\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\r\n        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), \r\n        // Replay the last emitted data when someone subscribes.\r\n        shareReplay(1));\r\n        /** The differ used to calculate changes to the data. */\r\n        this._differ = null;\r\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\r\n        this._needsUpdate = false;\r\n        this._destroyed = new Subject();\r\n        this.dataStream.subscribe(data => {\r\n            this._data = data;\r\n            this._onRenderedDataChange();\r\n        });\r\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\r\n            this._renderedRange = range;\r\n            ngZone.run(() => this.viewChange.next(this._renderedRange));\r\n            this._onRenderedDataChange();\r\n        });\r\n        this._viewport.attach(this);\r\n    }\r\n    /** The DataSource to display. */\r\n    get cdkVirtualForOf() {\r\n        return this._cdkVirtualForOf;\r\n    }\r\n    set cdkVirtualForOf(value) {\r\n        this._cdkVirtualForOf = value;\r\n        if (isDataSource(value)) {\r\n            this._dataSourceChanges.next(value);\r\n        }\r\n        else {\r\n            // If value is an an NgIterable, convert it to an array.\r\n            this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\r\n        }\r\n    }\r\n    /**\r\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\r\n     * the item and produces a value to be used as the item's identity when tracking changes.\r\n     */\r\n    get cdkVirtualForTrackBy() {\r\n        return this._cdkVirtualForTrackBy;\r\n    }\r\n    set cdkVirtualForTrackBy(fn) {\r\n        this._needsUpdate = true;\r\n        this._cdkVirtualForTrackBy = fn ?\r\n            (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\r\n            undefined;\r\n    }\r\n    /** The template used to stamp out new elements. */\r\n    set cdkVirtualForTemplate(value) {\r\n        if (value) {\r\n            this._needsUpdate = true;\r\n            this._template = value;\r\n        }\r\n    }\r\n    /**\r\n     * The size of the cache used to store templates that are not being used for re-use later.\r\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\r\n     */\r\n    get cdkVirtualForTemplateCacheSize() {\r\n        return this._viewRepeater.viewCacheSize;\r\n    }\r\n    set cdkVirtualForTemplateCacheSize(size) {\r\n        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\r\n    }\r\n    /**\r\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\r\n     * in the specified range. Throws an error if the range includes items that are not currently\r\n     * rendered.\r\n     */\r\n    measureRangeSize(range, orientation) {\r\n        if (range.start >= range.end) {\r\n            return 0;\r\n        }\r\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\r\n        }\r\n        // The index into the list of rendered views for the first item in the range.\r\n        const renderedStartIndex = range.start - this._renderedRange.start;\r\n        // The length of the range we're measuring.\r\n        const rangeLen = range.end - range.start;\r\n        // Loop over all the views, find the first and land node and compute the size by subtracting\r\n        // the top of the first node from the bottom of the last one.\r\n        let firstNode;\r\n        let lastNode;\r\n        // Find the first node by starting from the beginning and going forwards.\r\n        for (let i = 0; i < rangeLen; i++) {\r\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\r\n            if (view && view.rootNodes.length) {\r\n                firstNode = lastNode = view.rootNodes[0];\r\n                break;\r\n            }\r\n        }\r\n        // Find the last node by starting from the end and going backwards.\r\n        for (let i = rangeLen - 1; i > -1; i--) {\r\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\r\n            if (view && view.rootNodes.length) {\r\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        return firstNode && lastNode ?\r\n            getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\r\n    }\r\n    ngDoCheck() {\r\n        if (this._differ && this._needsUpdate) {\r\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\r\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\r\n            // changing (need to do this diff).\r\n            const changes = this._differ.diff(this._renderedItems);\r\n            if (!changes) {\r\n                this._updateContext();\r\n            }\r\n            else {\r\n                this._applyChanges(changes);\r\n            }\r\n            this._needsUpdate = false;\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this._viewport.detach();\r\n        this._dataSourceChanges.next(undefined);\r\n        this._dataSourceChanges.complete();\r\n        this.viewChange.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n        this._viewRepeater.detach();\r\n    }\r\n    /** React to scroll state changes in the viewport. */\r\n    _onRenderedDataChange() {\r\n        if (!this._renderedRange) {\r\n            return;\r\n        }\r\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\r\n        if (!this._differ) {\r\n            // Use a wrapper function for the `trackBy` so any new values are\r\n            // picked up automatically without having to recreate the differ.\r\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\r\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\r\n            });\r\n        }\r\n        this._needsUpdate = true;\r\n    }\r\n    /** Swap out one `DataSource` for another. */\r\n    _changeDataSource(oldDs, newDs) {\r\n        if (oldDs) {\r\n            oldDs.disconnect(this);\r\n        }\r\n        this._needsUpdate = true;\r\n        return newDs ? newDs.connect(this) : of();\r\n    }\r\n    /** Update the `CdkVirtualForOfContext` for all views. */\r\n    _updateContext() {\r\n        const count = this._data.length;\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            const view = this._viewContainerRef.get(i);\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n            view.detectChanges();\r\n        }\r\n    }\r\n    /** Apply changes to the DOM. */\r\n    _applyChanges(changes) {\r\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);\r\n        // Update $implicit for any items that had an identity change.\r\n        changes.forEachIdentityChange((record) => {\r\n            const view = this._viewContainerRef.get(record.currentIndex);\r\n            view.context.$implicit = record.item;\r\n        });\r\n        // Update the context variables on all items.\r\n        const count = this._data.length;\r\n        let i = this._viewContainerRef.length;\r\n        while (i--) {\r\n            const view = this._viewContainerRef.get(i);\r\n            view.context.index = this._renderedRange.start + i;\r\n            view.context.count = count;\r\n            this._updateComputedContextProperties(view.context);\r\n        }\r\n    }\r\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\r\n    _updateComputedContextProperties(context) {\r\n        context.first = context.index === 0;\r\n        context.last = context.index === context.count - 1;\r\n        context.even = context.index % 2 === 0;\r\n        context.odd = !context.even;\r\n    }\r\n    _getEmbeddedViewArgs(record, index) {\r\n        // Note that it's important that we insert the item directly at the proper index,\r\n        // rather than inserting it and the moving it in place, because if there's a directive\r\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\r\n        // comment node which can throw off the move when it's being repeated for all items.\r\n        return {\r\n            templateRef: this._template,\r\n            context: {\r\n                $implicit: record.item,\r\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\r\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\r\n                cdkVirtualForOf: this._cdkVirtualForOf,\r\n                index: -1,\r\n                count: -1,\r\n                first: false,\r\n                last: false,\r\n                odd: false,\r\n                even: false\r\n            },\r\n            index,\r\n        };\r\n    }\r\n}\r\nCdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵngcc0.ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\r\nCdkVirtualForOf.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\r\n        ])] });\r\nCdkVirtualForOf.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: _RecycleViewRepeaterStrategy, decorators: [{ type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },\r\n    { type: CdkVirtualScrollViewport, decorators: [{ type: SkipSelf }] },\r\n    { type: NgZone }\r\n];\r\nCdkVirtualForOf.propDecorators = {\r\n    cdkVirtualForOf: [{ type: Input }],\r\n    cdkVirtualForTrackBy: [{ type: Input }],\r\n    cdkVirtualForTemplate: [{ type: Input }],\r\n    cdkVirtualForTemplateCacheSize: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkVirtualForOf, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkVirtualFor][cdkVirtualForOf]',\r\n                providers: [\r\n                    { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\r\n                ]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc3._RecycleViewRepeaterStrategy, decorators: [{\r\n                type: Inject,\r\n                args: [_VIEW_REPEATER_STRATEGY]\r\n            }] }, { type: CdkVirtualScrollViewport, decorators: [{\r\n                type: SkipSelf\r\n            }] }, { type: ɵngcc0.NgZone }]; }, { cdkVirtualForOf: [{\r\n            type: Input\r\n        }], cdkVirtualForTrackBy: [{\r\n            type: Input\r\n        }], cdkVirtualForTemplate: [{\r\n            type: Input\r\n        }], cdkVirtualForTemplateCacheSize: [{\r\n            type: Input\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass CdkScrollableModule {\r\n}\r\nCdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); };\r\nCdkScrollableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CdkScrollableModule });\r\nCdkScrollableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkScrollableModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: [CdkScrollable],\r\n                declarations: [CdkScrollable]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkScrollableModule, { declarations: [CdkScrollable], exports: [CdkScrollable] }); })();\r\n/**\r\n * @docs-primary-export\r\n */\r\nclass ScrollingModule {\r\n}\r\nScrollingModule.ɵfac = function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); };\r\nScrollingModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ScrollingModule });\r\nScrollingModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[\r\n            BidiModule,\r\n            PlatformModule,\r\n            CdkScrollableModule\r\n        ], BidiModule, CdkScrollableModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrollingModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    BidiModule,\r\n                    PlatformModule,\r\n                    CdkScrollableModule\r\n                ],\r\n                exports: [\r\n                    BidiModule,\r\n                    CdkScrollableModule,\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ],\r\n                declarations: [\r\n                    CdkFixedSizeVirtualScroll,\r\n                    CdkVirtualForOf,\r\n                    CdkVirtualScrollViewport,\r\n                ]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollingModule, { declarations: function () { return [CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; }, imports: function () { return [BidiModule,\r\n        PlatformModule, CdkScrollableModule]; }, exports: function () { return [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\r\n\r\n","import { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { isDataSource, _VIEW_REPEATER_STRATEGY, _DisposeViewRepeaterStrategy } from '@angular/cdk/collections';\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/bidi';\r\nimport * as ɵngcc2 from '@angular/cdk/platform';\r\nimport * as ɵngcc3 from '@angular/cdk/scrolling';\r\n\r\nconst _c0 = [[[\"caption\"]], [[\"colgroup\"], [\"col\"]]];\r\nconst _c1 = [\"caption\", \"colgroup, col\"];\r\nfunction CdkTextColumn_th_1_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"th\", 3);\r\n    ɵngcc0.ɵɵtext(1);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵstyleProp(\"text-align\", ctx_r0.justify);\r\n    ɵngcc0.ɵɵadvance(1);\r\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r0.headerText, \" \");\r\n} }\r\nfunction CdkTextColumn_td_2_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"td\", 4);\r\n    ɵngcc0.ɵɵtext(1);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const data_r2 = ctx.$implicit;\r\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵstyleProp(\"text-align\", ctx_r1.justify);\r\n    ɵngcc0.ɵɵadvance(1);\r\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.dataAccessor(data_r2, ctx_r1.name), \" \");\r\n} }\r\nexport { DataSource } from '@angular/cdk/collections';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ViewportRuler, ScrollingModule } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { InjectionToken, Directive, TemplateRef, Inject, Optional, Input, ContentChild, ElementRef, Injectable, NgZone, IterableDiffers, ViewContainerRef, Component, ChangeDetectionStrategy, ViewEncapsulation, EmbeddedViewRef, ChangeDetectorRef, Attribute, SkipSelf, ViewChild, ContentChildren, NgModule } from '@angular/core';\r\nimport { Subject, from, BehaviorSubject, isObservable, of } from 'rxjs';\r\nimport { takeUntil, take } from 'rxjs/operators';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Mixin to provide a directive with a function that checks if the sticky input has been\r\n * changed since the last time the function was called. Essentially adds a dirty-check to the\r\n * sticky value.\r\n * @docs-private\r\n */\r\nfunction mixinHasStickyInput(base) {\r\n    return class extends base {\r\n        constructor(...args) {\r\n            super(...args);\r\n            this._sticky = false;\r\n            /** Whether the sticky input has changed since it was last checked. */\r\n            this._hasStickyChanged = false;\r\n        }\r\n        /** Whether sticky positioning should be applied. */\r\n        get sticky() { return this._sticky; }\r\n        set sticky(v) {\r\n            const prevValue = this._sticky;\r\n            this._sticky = coerceBooleanProperty(v);\r\n            this._hasStickyChanged = prevValue !== this._sticky;\r\n        }\r\n        /** Whether the sticky value has changed since this was last called. */\r\n        hasStickyChanged() {\r\n            const hasStickyChanged = this._hasStickyChanged;\r\n            this._hasStickyChanged = false;\r\n            return hasStickyChanged;\r\n        }\r\n        /** Resets the dirty check for cases where the sticky state has been used without checking. */\r\n        resetStickyChanged() {\r\n            this._hasStickyChanged = false;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Used to provide a table to some of the sub-components without causing a circular dependency.\r\n * @docs-private\r\n */\r\nconst CDK_TABLE = new InjectionToken('CDK_TABLE');\r\n/** Injection token that can be used to specify the text column options. */\r\nconst TEXT_COLUMN_OPTIONS = new InjectionToken('text-column-options');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Cell definition for a CDK table.\r\n * Captures the template of a column's data row cell as well as cell-specific properties.\r\n */\r\nclass CdkCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkCellDef.ɵfac = function CdkCellDef_Factory(t) { return new (t || CdkCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCellDef, selectors: [[\"\", \"cdkCellDef\", \"\"]] });\r\nCdkCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n/**\r\n * Header cell definition for a CDK table.\r\n * Captures the template of a column's header cell and as well as cell-specific properties.\r\n */\r\nclass CdkHeaderCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) { return new (t || CdkHeaderCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkHeaderCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCellDef, selectors: [[\"\", \"cdkHeaderCellDef\", \"\"]] });\r\nCdkHeaderCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkHeaderCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n/**\r\n * Footer cell definition for a CDK table.\r\n * Captures the template of a column's footer cell and as well as cell-specific properties.\r\n */\r\nclass CdkFooterCellDef {\r\n    constructor(/** @docs-private */ template) {\r\n        this.template = template;\r\n    }\r\n}\r\nCdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) { return new (t || CdkFooterCellDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkFooterCellDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCellDef, selectors: [[\"\", \"cdkFooterCellDef\", \"\"]] });\r\nCdkFooterCellDef.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterCellDef, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkFooterCellDef]' }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkColumnDef.\r\n/** @docs-private */\r\nclass CdkColumnDefBase {\r\n}\r\nconst _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);\r\n/**\r\n * Column definition for the CDK table.\r\n * Defines a set of cells available for a table column.\r\n */\r\nclass CdkColumnDef extends _CdkColumnDefBase {\r\n    constructor(_table) {\r\n        super();\r\n        this._table = _table;\r\n        this._stickyEnd = false;\r\n    }\r\n    /** Unique name for this column. */\r\n    get name() { return this._name; }\r\n    set name(name) { this._setNameInput(name); }\r\n    /**\r\n     * Whether this column should be sticky positioned on the end of the row. Should make sure\r\n     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value\r\n     * has been changed.\r\n     */\r\n    get stickyEnd() {\r\n        return this._stickyEnd;\r\n    }\r\n    set stickyEnd(v) {\r\n        const prevValue = this._stickyEnd;\r\n        this._stickyEnd = coerceBooleanProperty(v);\r\n        this._hasStickyChanged = prevValue !== this._stickyEnd;\r\n    }\r\n    /**\r\n     * Overridable method that sets the css classes that will be added to every cell in this\r\n     * column.\r\n     * In the future, columnCssClassName will change from type string[] to string and this\r\n     * will set a single string value.\r\n     * @docs-private\r\n     */\r\n    _updateColumnCssClassName() {\r\n        this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];\r\n    }\r\n    /**\r\n     * This has been extracted to a util because of TS 4 and VE.\r\n     * View Engine doesn't support property rename inheritance.\r\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\r\n     * @docs-private\r\n     */\r\n    _setNameInput(value) {\r\n        // If the directive is set without a name (updated programmatically), then this setter will\r\n        // trigger with an empty string and should not overwrite the programmatically set value.\r\n        if (value) {\r\n            this._name = value;\r\n            this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/ig, '-');\r\n            this._updateColumnCssClassName();\r\n        }\r\n    }\r\n}\r\nCdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) { return new (t || CdkColumnDef)(ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkColumnDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkColumnDef, selectors: [[\"\", \"cdkColumnDef\", \"\"]], contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkCellDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerCell = _t.first);\r\n    } }, inputs: { sticky: \"sticky\", name: [\"cdkColumnDef\", \"name\"], stickyEnd: \"stickyEnd\" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]), ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkColumnDef.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\nCdkColumnDef.propDecorators = {\r\n    name: [{ type: Input, args: ['cdkColumnDef',] }],\r\n    stickyEnd: [{ type: Input, args: ['stickyEnd',] }],\r\n    cell: [{ type: ContentChild, args: [CdkCellDef,] }],\r\n    headerCell: [{ type: ContentChild, args: [CdkHeaderCellDef,] }],\r\n    footerCell: [{ type: ContentChild, args: [CdkFooterCellDef,] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkColumnDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkColumnDef]',\r\n                inputs: ['sticky'],\r\n                providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]\r\n            }]\r\n    }], function () { return [{ type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, { name: [{\r\n            type: Input,\r\n            args: ['cdkColumnDef']\r\n        }], stickyEnd: [{\r\n            type: Input,\r\n            args: ['stickyEnd']\r\n        }], cell: [{\r\n            type: ContentChild,\r\n            args: [CdkCellDef]\r\n        }], headerCell: [{\r\n            type: ContentChild,\r\n            args: [CdkHeaderCellDef]\r\n        }], footerCell: [{\r\n            type: ContentChild,\r\n            args: [CdkFooterCellDef]\r\n        }] }); })();\r\n/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */\r\nclass BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        // If IE 11 is dropped before we switch to setting a single class name, change to multi param\r\n        // with destructuring.\r\n        const classList = elementRef.nativeElement.classList;\r\n        for (const className of columnDef._columnCssClassName) {\r\n            classList.add(className);\r\n        }\r\n    }\r\n}\r\n/** Header cell template container that adds the right classes and role. */\r\nclass CdkHeaderCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) { return new (t || CdkHeaderCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkHeaderCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderCell, selectors: [[\"cdk-header-cell\"], [\"th\", \"cdk-header-cell\", \"\"]], hostAttrs: [\"role\", \"columnheader\", 1, \"cdk-header-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkHeaderCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-header-cell, th[cdk-header-cell]',\r\n                host: {\r\n                    'class': 'cdk-header-cell',\r\n                    'role': 'columnheader'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/** Footer cell template container that adds the right classes and role. */\r\nclass CdkFooterCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) { return new (t || CdkFooterCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkFooterCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterCell, selectors: [[\"cdk-footer-cell\"], [\"td\", \"cdk-footer-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-footer-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkFooterCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-footer-cell, td[cdk-footer-cell]',\r\n                host: {\r\n                    'class': 'cdk-footer-cell',\r\n                    'role': 'gridcell'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/** Cell template container that adds the right classes and role. */\r\nclass CdkCell extends BaseCdkCell {\r\n    constructor(columnDef, elementRef) {\r\n        super(columnDef, elementRef);\r\n    }\r\n}\r\nCdkCell.ɵfac = function CdkCell_Factory(t) { return new (t || CdkCell)(ɵngcc0.ɵɵdirectiveInject(CdkColumnDef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nCdkCell.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCell, selectors: [[\"cdk-cell\"], [\"td\", \"cdk-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-cell\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkCell.ctorParameters = () => [\r\n    { type: CdkColumnDef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCell, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'cdk-cell, td[cdk-cell]',\r\n                host: {\r\n                    'class': 'cdk-cell',\r\n                    'role': 'gridcell'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: CdkColumnDef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * @docs-private\r\n */\r\nclass _Schedule {\r\n    constructor() {\r\n        this.tasks = [];\r\n        this.endTasks = [];\r\n    }\r\n}\r\n/** Injection token used to provide a coalesced style scheduler. */\r\nconst _COALESCED_STYLE_SCHEDULER = new InjectionToken('_COALESCED_STYLE_SCHEDULER');\r\n/**\r\n * Allows grouping up CSSDom mutations after the current execution context.\r\n * This can significantly improve performance when separate consecutive functions are\r\n * reading from the CSSDom and then mutating it.\r\n *\r\n * @docs-private\r\n */\r\nclass _CoalescedStyleScheduler {\r\n    constructor(_ngZone) {\r\n        this._ngZone = _ngZone;\r\n        this._currentSchedule = null;\r\n        this._destroyed = new Subject();\r\n    }\r\n    /**\r\n     * Schedules the specified task to run at the end of the current VM turn.\r\n     */\r\n    schedule(task) {\r\n        this._createScheduleIfNeeded();\r\n        this._currentSchedule.tasks.push(task);\r\n    }\r\n    /**\r\n     * Schedules the specified task to run after other scheduled tasks at the end of the current\r\n     * VM turn.\r\n     */\r\n    scheduleEnd(task) {\r\n        this._createScheduleIfNeeded();\r\n        this._currentSchedule.endTasks.push(task);\r\n    }\r\n    /** Prevent any further tasks from running. */\r\n    ngOnDestroy() {\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    _createScheduleIfNeeded() {\r\n        if (this._currentSchedule) {\r\n            return;\r\n        }\r\n        this._currentSchedule = new _Schedule();\r\n        this._getScheduleObservable().pipe(takeUntil(this._destroyed)).subscribe(() => {\r\n            while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {\r\n                const schedule = this._currentSchedule;\r\n                // Capture new tasks scheduled by the current set of tasks.\r\n                this._currentSchedule = new _Schedule();\r\n                for (const task of schedule.tasks) {\r\n                    task();\r\n                }\r\n                for (const task of schedule.endTasks) {\r\n                    task();\r\n                }\r\n            }\r\n            this._currentSchedule = null;\r\n        });\r\n    }\r\n    _getScheduleObservable() {\r\n        // Use onStable when in the context of an ongoing change detection cycle so that we\r\n        // do not accidentally trigger additional cycles.\r\n        return this._ngZone.isStable ?\r\n            from(Promise.resolve(undefined)) :\r\n            this._ngZone.onStable.pipe(take(1));\r\n    }\r\n}\r\n_CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) { return new (t || _CoalescedStyleScheduler)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };\r\n_CoalescedStyleScheduler.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: _CoalescedStyleScheduler, factory: _CoalescedStyleScheduler.ɵfac });\r\n_CoalescedStyleScheduler.ctorParameters = () => [\r\n    { type: NgZone }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_CoalescedStyleScheduler, [{\r\n        type: Injectable\r\n    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The row template that can be used by the mat-table. Should not be used outside of the\r\n * material library.\r\n */\r\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\r\n/**\r\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\r\n * for changes and notifying the table.\r\n */\r\nclass BaseRowDef {\r\n    constructor(\r\n    /** @docs-private */ template, _differs) {\r\n        this.template = template;\r\n        this._differs = _differs;\r\n    }\r\n    ngOnChanges(changes) {\r\n        // Create a new columns differ if one does not yet exist. Initialize it based on initial value\r\n        // of the columns property or an empty array if none is provided.\r\n        if (!this._columnsDiffer) {\r\n            const columns = (changes['columns'] && changes['columns'].currentValue) || [];\r\n            this._columnsDiffer = this._differs.find(columns).create();\r\n            this._columnsDiffer.diff(columns);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the difference between the current columns and the columns from the last diff, or null\r\n     * if there is no difference.\r\n     */\r\n    getColumnsDiff() {\r\n        return this._columnsDiffer.diff(this.columns);\r\n    }\r\n    /** Gets this row def's relevant cell template from the provided column def. */\r\n    extractCellTemplate(column) {\r\n        if (this instanceof CdkHeaderRowDef) {\r\n            return column.headerCell.template;\r\n        }\r\n        if (this instanceof CdkFooterRowDef) {\r\n            return column.footerCell.template;\r\n        }\r\n        else {\r\n            return column.cell.template;\r\n        }\r\n    }\r\n}\r\nBaseRowDef.ɵfac = function BaseRowDef_Factory(t) { return new (t || BaseRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };\r\nBaseRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseRowDef, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\r\nBaseRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseRowDef, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkHeaderRowDef.\r\n/** @docs-private */\r\nclass CdkHeaderRowDefBase extends BaseRowDef {\r\n}\r\nconst _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);\r\n/**\r\n * Header row definition for the CDK table.\r\n * Captures the header row's template and other header properties such as the columns to display.\r\n */\r\nclass CdkHeaderRowDef extends _CdkHeaderRowDefBase {\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\r\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\r\n    ngOnChanges(changes) {\r\n        super.ngOnChanges(changes);\r\n    }\r\n}\r\nCdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) { return new (t || CdkHeaderRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkHeaderRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkHeaderRowDef, selectors: [[\"\", \"cdkHeaderRowDef\", \"\"]], inputs: { columns: [\"cdkHeaderRowDef\", \"columns\"], sticky: [\"cdkHeaderRowDefSticky\", \"sticky\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkHeaderRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkHeaderRowDef]',\r\n                inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n// Boilerplate for applying mixins to CdkFooterRowDef.\r\n/** @docs-private */\r\nclass CdkFooterRowDefBase extends BaseRowDef {\r\n}\r\nconst _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);\r\n/**\r\n * Footer row definition for the CDK table.\r\n * Captures the footer row's template and other footer properties such as the columns to display.\r\n */\r\nclass CdkFooterRowDef extends _CdkFooterRowDefBase {\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\r\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\r\n    ngOnChanges(changes) {\r\n        super.ngOnChanges(changes);\r\n    }\r\n}\r\nCdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) { return new (t || CdkFooterRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkFooterRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkFooterRowDef, selectors: [[\"\", \"cdkFooterRowDef\", \"\"]], inputs: { columns: [\"cdkFooterRowDef\", \"columns\"], sticky: [\"cdkFooterRowDefSticky\", \"sticky\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\r\nCdkFooterRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkFooterRowDef]',\r\n                inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n/**\r\n * Data row definition for the CDK table.\r\n * Captures the header row's template and other row properties such as the columns to display and\r\n * a when predicate that describes when this row should be used.\r\n */\r\nclass CdkRowDef extends BaseRowDef {\r\n    // TODO(andrewseguin): Add an input for providing a switch function to determine\r\n    //   if this template should be used.\r\n    constructor(template, _differs, _table) {\r\n        super(template, _differs);\r\n        this._table = _table;\r\n    }\r\n}\r\nCdkRowDef.ɵfac = function CdkRowDef_Factory(t) { return new (t || CdkRowDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CDK_TABLE, 8)); };\r\nCdkRowDef.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkRowDef, selectors: [[\"\", \"cdkRowDef\", \"\"]], inputs: { columns: [\"cdkRowDefColumns\", \"columns\"], when: [\"cdkRowDefWhen\", \"when\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\nCdkRowDef.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: IterableDiffers },\r\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_TABLE,] }, { type: Optional }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkRowDef, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[cdkRowDef]',\r\n                inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen']\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [CDK_TABLE]\r\n            }, {\r\n                type: Optional\r\n            }] }]; }, null); })();\r\n/**\r\n * Outlet for rendering cells inside of a row or header row.\r\n * @docs-private\r\n */\r\nclass CdkCellOutlet {\r\n    constructor(_viewContainer) {\r\n        this._viewContainer = _viewContainer;\r\n        CdkCellOutlet.mostRecentCellOutlet = this;\r\n    }\r\n    ngOnDestroy() {\r\n        // If this was the last outlet being rendered in the view, remove the reference\r\n        // from the static property after it has been destroyed to avoid leaking memory.\r\n        if (CdkCellOutlet.mostRecentCellOutlet === this) {\r\n            CdkCellOutlet.mostRecentCellOutlet = null;\r\n        }\r\n    }\r\n}\r\nCdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) { return new (t || CdkCellOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };\r\nCdkCellOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkCellOutlet, selectors: [[\"\", \"cdkCellOutlet\", \"\"]] });\r\n/**\r\n * Static property containing the latest constructed instance of this class.\r\n * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\r\n * createEmbeddedView. After one of these components are created, this property will provide\r\n * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\r\n * construct the cells with the provided context.\r\n */\r\nCdkCellOutlet.mostRecentCellOutlet = null;\r\nCdkCellOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkCellOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[cdkCellOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();\r\n/** Header template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkHeaderRow {\r\n}\r\nCdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) { return new (t || CdkHeaderRow)(); };\r\nCdkHeaderRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkHeaderRow, selectors: [[\"cdk-header-row\"], [\"tr\", \"cdk-header-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-header-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkHeaderRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkHeaderRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-header-row, tr[cdk-header-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-header-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkFooterRow {\r\n}\r\nCdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) { return new (t || CdkFooterRow)(); };\r\nCdkFooterRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkFooterRow, selectors: [[\"cdk-footer-row\"], [\"tr\", \"cdk-footer-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-footer-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkFooterRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFooterRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-footer-row, tr[cdk-footer-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-footer-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\r\nclass CdkRow {\r\n}\r\nCdkRow.ɵfac = function CdkRow_Factory(t) { return new (t || CdkRow)(); };\r\nCdkRow.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkRow, selectors: [[\"cdk-row\"], [\"tr\", \"cdk-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkRow_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainer(0, 0);\r\n    } }, directives: [CdkCellOutlet], encapsulation: 2 });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkRow, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-row, tr[cdk-row]',\r\n                template: CDK_ROW_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-row',\r\n                    'role': 'row'\r\n                },\r\n                // See note on CdkTable for explanation on why this uses the default change detection strategy.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, null); })();\r\n/** Row that can be used to display a message when no data is shown in the table. */\r\nclass CdkNoDataRow {\r\n    constructor(templateRef) {\r\n        this.templateRef = templateRef;\r\n    }\r\n}\r\nCdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) { return new (t || CdkNoDataRow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };\r\nCdkNoDataRow.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CdkNoDataRow, selectors: [[\"ng-template\", \"cdkNoDataRow\", \"\"]] });\r\nCdkNoDataRow.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkNoDataRow, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'ng-template[cdkNoDataRow]'\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * List of all possible directions that can be used for sticky positioning.\r\n * @docs-private\r\n */\r\nconst STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];\r\n/**\r\n * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.\r\n * @docs-private\r\n */\r\nclass StickyStyler {\r\n    /**\r\n     * @param _isNativeHtmlTable Whether the sticky logic should be based on a table\r\n     *     that uses the native `<table>` element.\r\n     * @param _stickCellCss The CSS class that will be applied to every row/cell that has\r\n     *     sticky positioning applied.\r\n     * @param direction The directionality context of the table (ltr/rtl); affects column positioning\r\n     *     by reversing left/right positions.\r\n     * @param _isBrowser Whether the table is currently being rendered on the server or the client.\r\n     * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells\r\n     *     using inline styles. If false, it is assumed that position: sticky is included in\r\n     *     the component stylesheet for _stickCellCss.\r\n     * @param _positionListener A listener that is notified of changes to sticky rows/columns\r\n     *     and their dimensions.\r\n     */\r\n    constructor(_isNativeHtmlTable, _stickCellCss, direction, \r\n    /**\r\n     * @deprecated `_coalescedStyleScheduler` parameter to become required.\r\n     * @breaking-change 11.0.0\r\n     */\r\n    _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener) {\r\n        this._isNativeHtmlTable = _isNativeHtmlTable;\r\n        this._stickCellCss = _stickCellCss;\r\n        this.direction = direction;\r\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\r\n        this._isBrowser = _isBrowser;\r\n        this._needsPositionStickyOnElement = _needsPositionStickyOnElement;\r\n        this._positionListener = _positionListener;\r\n        this._cachedCellWidths = [];\r\n        this._borderCellCss = {\r\n            'top': `${_stickCellCss}-border-elem-top`,\r\n            'bottom': `${_stickCellCss}-border-elem-bottom`,\r\n            'left': `${_stickCellCss}-border-elem-left`,\r\n            'right': `${_stickCellCss}-border-elem-right`,\r\n        };\r\n    }\r\n    /**\r\n     * Clears the sticky positioning styles from the row and its cells by resetting the `position`\r\n     * style, setting the zIndex to 0, and unsetting each provided sticky direction.\r\n     * @param rows The list of rows that should be cleared from sticking in the provided directions\r\n     * @param stickyDirections The directions that should no longer be set as sticky on the rows.\r\n     */\r\n    clearStickyPositioning(rows, stickyDirections) {\r\n        const elementsToClear = [];\r\n        for (const row of rows) {\r\n            // If the row isn't an element (e.g. if it's an `ng-container`),\r\n            // it won't have inline styles or `children` so we skip it.\r\n            if (row.nodeType !== row.ELEMENT_NODE) {\r\n                continue;\r\n            }\r\n            elementsToClear.push(row);\r\n            for (let i = 0; i < row.children.length; i++) {\r\n                elementsToClear.push(row.children[i]);\r\n            }\r\n        }\r\n        // Coalesce with sticky row/column updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            for (const element of elementsToClear) {\r\n                this._removeStickyStyle(element, stickyDirections);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Applies sticky left and right positions to the cells of each row according to the sticky\r\n     * states of the rendered column definitions.\r\n     * @param rows The rows that should have its set of cells stuck according to the sticky states.\r\n     * @param stickyStartStates A list of boolean states where each state represents whether the cell\r\n     *     in this index position should be stuck to the start of the row.\r\n     * @param stickyEndStates A list of boolean states where each state represents whether the cell\r\n     *     in this index position should be stuck to the end of the row.\r\n     * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each\r\n     *     column cell. If `false` cached widths will be used instead.\r\n     */\r\n    updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {\r\n        if (!rows.length || !this._isBrowser || !(stickyStartStates.some(state => state) ||\r\n            stickyEndStates.some(state => state))) {\r\n            if (this._positionListener) {\r\n                this._positionListener.stickyColumnsUpdated({ sizes: [] });\r\n                this._positionListener.stickyEndColumnsUpdated({ sizes: [] });\r\n            }\r\n            return;\r\n        }\r\n        const firstRow = rows[0];\r\n        const numCells = firstRow.children.length;\r\n        const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);\r\n        const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);\r\n        const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);\r\n        const lastStickyStart = stickyStartStates.lastIndexOf(true);\r\n        const firstStickyEnd = stickyEndStates.indexOf(true);\r\n        // Coalesce with sticky row updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            const isRtl = this.direction === 'rtl';\r\n            const start = isRtl ? 'right' : 'left';\r\n            const end = isRtl ? 'left' : 'right';\r\n            for (const row of rows) {\r\n                for (let i = 0; i < numCells; i++) {\r\n                    const cell = row.children[i];\r\n                    if (stickyStartStates[i]) {\r\n                        this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);\r\n                    }\r\n                    if (stickyEndStates[i]) {\r\n                        this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);\r\n                    }\r\n                }\r\n            }\r\n            if (this._positionListener) {\r\n                this._positionListener.stickyColumnsUpdated({\r\n                    sizes: lastStickyStart === -1 ?\r\n                        [] :\r\n                        cellWidths\r\n                            .slice(0, lastStickyStart + 1)\r\n                            .map((width, index) => stickyStartStates[index] ? width : null)\r\n                });\r\n                this._positionListener.stickyEndColumnsUpdated({\r\n                    sizes: firstStickyEnd === -1 ?\r\n                        [] :\r\n                        cellWidths\r\n                            .slice(firstStickyEnd)\r\n                            .map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null)\r\n                            .reverse()\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Applies sticky positioning to the row's cells if using the native table layout, and to the\r\n     * row itself otherwise.\r\n     * @param rowsToStick The list of rows that should be stuck according to their corresponding\r\n     *     sticky state and to the provided top or bottom position.\r\n     * @param stickyStates A list of boolean states where each state represents whether the row\r\n     *     should be stuck in the particular top or bottom position.\r\n     * @param position The position direction in which the row should be stuck if that row should be\r\n     *     sticky.\r\n     *\r\n     */\r\n    stickRows(rowsToStick, stickyStates, position) {\r\n        // Since we can't measure the rows on the server, we can't stick the rows properly.\r\n        if (!this._isBrowser) {\r\n            return;\r\n        }\r\n        // If positioning the rows to the bottom, reverse their order when evaluating the sticky\r\n        // position such that the last row stuck will be \"bottom: 0px\" and so on. Note that the\r\n        // sticky states need to be reversed as well.\r\n        const rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;\r\n        const states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates;\r\n        // Measure row heights all at once before adding sticky styles to reduce layout thrashing.\r\n        const stickyOffsets = [];\r\n        const stickyCellHeights = [];\r\n        const elementsToStick = [];\r\n        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {\r\n            stickyOffsets[rowIndex] = stickyOffset;\r\n            if (!states[rowIndex]) {\r\n                continue;\r\n            }\r\n            const row = rows[rowIndex];\r\n            elementsToStick[rowIndex] = this._isNativeHtmlTable ?\r\n                Array.from(row.children) : [row];\r\n            const height = row.getBoundingClientRect().height;\r\n            stickyOffset += height;\r\n            stickyCellHeights[rowIndex] = height;\r\n        }\r\n        const borderedRowIndex = states.lastIndexOf(true);\r\n        // Coalesce with other sticky row updates (top/bottom), sticky columns updates\r\n        // (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            var _a, _b;\r\n            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n                if (!states[rowIndex]) {\r\n                    continue;\r\n                }\r\n                const offset = stickyOffsets[rowIndex];\r\n                const isBorderedRowIndex = rowIndex === borderedRowIndex;\r\n                for (const element of elementsToStick[rowIndex]) {\r\n                    this._addStickyStyle(element, position, offset, isBorderedRowIndex);\r\n                }\r\n            }\r\n            if (position === 'top') {\r\n                (_a = this._positionListener) === null || _a === void 0 ? void 0 : _a.stickyHeaderRowsUpdated({ sizes: stickyCellHeights, elements: elementsToStick });\r\n            }\r\n            else {\r\n                (_b = this._positionListener) === null || _b === void 0 ? void 0 : _b.stickyFooterRowsUpdated({ sizes: stickyCellHeights, elements: elementsToStick });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick\r\n     * footer rows is to apply sticky styling to the tfoot container. This should only be done if\r\n     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from\r\n     * the tfoot element.\r\n     */\r\n    updateStickyFooterContainer(tableElement, stickyStates) {\r\n        if (!this._isNativeHtmlTable) {\r\n            return;\r\n        }\r\n        const tfoot = tableElement.querySelector('tfoot');\r\n        // Coalesce with other sticky updates (and potentially other changes like column resize).\r\n        this._scheduleStyleChanges(() => {\r\n            if (stickyStates.some(state => !state)) {\r\n                this._removeStickyStyle(tfoot, ['bottom']);\r\n            }\r\n            else {\r\n                this._addStickyStyle(tfoot, 'bottom', 0, false);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating\r\n     * the zIndex, removing each of the provided sticky directions, and removing the\r\n     * sticky position if there are no more directions.\r\n     */\r\n    _removeStickyStyle(element, stickyDirections) {\r\n        for (const dir of stickyDirections) {\r\n            element.style[dir] = '';\r\n            element.classList.remove(this._borderCellCss[dir]);\r\n        }\r\n        // If the element no longer has any more sticky directions, remove sticky positioning and\r\n        // the sticky CSS class.\r\n        // Short-circuit checking element.style[dir] for stickyDirections as they\r\n        // were already removed above.\r\n        const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);\r\n        if (hasDirection) {\r\n            element.style.zIndex = this._getCalculatedZIndex(element);\r\n        }\r\n        else {\r\n            // When not hasDirection, _getCalculatedZIndex will always return ''.\r\n            element.style.zIndex = '';\r\n            if (this._needsPositionStickyOnElement) {\r\n                element.style.position = '';\r\n            }\r\n            element.classList.remove(this._stickCellCss);\r\n        }\r\n    }\r\n    /**\r\n     * Adds the sticky styling to the element by adding the sticky style class, changing position\r\n     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky\r\n     * direction and value.\r\n     */\r\n    _addStickyStyle(element, dir, dirValue, isBorderElement) {\r\n        element.classList.add(this._stickCellCss);\r\n        if (isBorderElement) {\r\n            element.classList.add(this._borderCellCss[dir]);\r\n        }\r\n        element.style[dir] = `${dirValue}px`;\r\n        element.style.zIndex = this._getCalculatedZIndex(element);\r\n        if (this._needsPositionStickyOnElement) {\r\n            element.style.cssText += 'position: -webkit-sticky; position: sticky; ';\r\n        }\r\n    }\r\n    /**\r\n     * Calculate what the z-index should be for the element, depending on what directions (top,\r\n     * bottom, left, right) have been set. It should be true that elements with a top direction\r\n     * should have the highest index since these are elements like a table header. If any of those\r\n     * elements are also sticky in another direction, then they should appear above other elements\r\n     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements\r\n     * (e.g. footer rows) should then be next in the ordering such that they are below the header\r\n     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)\r\n     * should minimally increment so that they are above non-sticky elements but below top and bottom\r\n     * elements.\r\n     */\r\n    _getCalculatedZIndex(element) {\r\n        const zIndexIncrements = {\r\n            top: 100,\r\n            bottom: 10,\r\n            left: 1,\r\n            right: 1,\r\n        };\r\n        let zIndex = 0;\r\n        // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\r\n        // loses the array generic type in the `for of`. But we *also* have to use `Array` because\r\n        // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\r\n        for (const dir of STICKY_DIRECTIONS) {\r\n            if (element.style[dir]) {\r\n                zIndex += zIndexIncrements[dir];\r\n            }\r\n        }\r\n        return zIndex ? `${zIndex}` : '';\r\n    }\r\n    /** Gets the widths for each cell in the provided row. */\r\n    _getCellWidths(row, recalculateCellWidths = true) {\r\n        if (!recalculateCellWidths && this._cachedCellWidths.length) {\r\n            return this._cachedCellWidths;\r\n        }\r\n        const cellWidths = [];\r\n        const firstRowCells = row.children;\r\n        for (let i = 0; i < firstRowCells.length; i++) {\r\n            let cell = firstRowCells[i];\r\n            cellWidths.push(cell.getBoundingClientRect().width);\r\n        }\r\n        this._cachedCellWidths = cellWidths;\r\n        return cellWidths;\r\n    }\r\n    /**\r\n     * Determines the left and right positions of each sticky column cell, which will be the\r\n     * accumulation of all sticky column cell widths to the left and right, respectively.\r\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\r\n     */\r\n    _getStickyStartColumnPositions(widths, stickyStates) {\r\n        const positions = [];\r\n        let nextPosition = 0;\r\n        for (let i = 0; i < widths.length; i++) {\r\n            if (stickyStates[i]) {\r\n                positions[i] = nextPosition;\r\n                nextPosition += widths[i];\r\n            }\r\n        }\r\n        return positions;\r\n    }\r\n    /**\r\n     * Determines the left and right positions of each sticky column cell, which will be the\r\n     * accumulation of all sticky column cell widths to the left and right, respectively.\r\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\r\n     */\r\n    _getStickyEndColumnPositions(widths, stickyStates) {\r\n        const positions = [];\r\n        let nextPosition = 0;\r\n        for (let i = widths.length; i > 0; i--) {\r\n            if (stickyStates[i]) {\r\n                positions[i] = nextPosition;\r\n                nextPosition += widths[i];\r\n            }\r\n        }\r\n        return positions;\r\n    }\r\n    /**\r\n     * Schedules styles to be applied when the style scheduler deems appropriate.\r\n     * @breaking-change 11.0.0 This method can be removed in favor of calling\r\n     * `CoalescedStyleScheduler.schedule` directly once the scheduler is a required parameter.\r\n     */\r\n    _scheduleStyleChanges(changes) {\r\n        if (this._coalescedStyleScheduler) {\r\n            this._coalescedStyleScheduler.schedule(changes);\r\n        }\r\n        else {\r\n            changes();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Returns an error to be thrown when attempting to find an unexisting column.\r\n * @param id Id whose lookup failed.\r\n * @docs-private\r\n */\r\nfunction getTableUnknownColumnError(id) {\r\n    return Error(`Could not find column with id \"${id}\".`);\r\n}\r\n/**\r\n * Returns an error to be thrown when two column definitions have the same name.\r\n * @docs-private\r\n */\r\nfunction getTableDuplicateColumnNameError(name) {\r\n    return Error(`Duplicate column definition name provided: \"${name}\".`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there are multiple rows that are missing a when function.\r\n * @docs-private\r\n */\r\nfunction getTableMultipleDefaultRowDefsError() {\r\n    return Error(`There can only be one default row without a when predicate function.`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there are no matching row defs for a particular set of data.\r\n * @docs-private\r\n */\r\nfunction getTableMissingMatchingRowDefError(data) {\r\n    return Error(`Could not find a matching row definition for the` +\r\n        `provided row data: ${JSON.stringify(data)}`);\r\n}\r\n/**\r\n * Returns an error to be thrown when there is no row definitions present in the content.\r\n * @docs-private\r\n */\r\nfunction getTableMissingRowDefsError() {\r\n    return Error('Missing definitions for header, footer, and row; ' +\r\n        'cannot determine which columns should be rendered.');\r\n}\r\n/**\r\n * Returns an error to be thrown when the data source does not match the compatible types.\r\n * @docs-private\r\n */\r\nfunction getTableUnknownDataSourceError() {\r\n    return Error(`Provided data source did not match an array, Observable, or DataSource`);\r\n}\r\n/**\r\n * Returns an error to be thrown when the text column cannot find a parent table to inject.\r\n * @docs-private\r\n */\r\nfunction getTableTextColumnMissingParentTableError() {\r\n    return Error(`Text column could not find a parent table for registration.`);\r\n}\r\n/**\r\n * Returns an error to be thrown when a table text column doesn't have a name.\r\n * @docs-private\r\n */\r\nfunction getTableTextColumnMissingNameError() {\r\n    return Error(`Table text column must have a name.`);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** The injection token used to specify the StickyPositioningListener. */\r\nconst STICKY_POSITIONING_LISTENER = new InjectionToken('CDK_SPL');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\r\n * @docs-private\r\n */\r\nclass DataRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nDataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) { return new (t || DataRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nDataRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DataRowOutlet, selectors: [[\"\", \"rowOutlet\", \"\"]] });\r\nDataRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[rowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\r\n * @docs-private\r\n */\r\nclass HeaderRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nHeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) { return new (t || HeaderRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nHeaderRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: HeaderRowOutlet, selectors: [[\"\", \"headerRowOutlet\", \"\"]] });\r\nHeaderRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[headerRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the footer.\r\n * @docs-private\r\n */\r\nclass FooterRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nFooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) { return new (t || FooterRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nFooterRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FooterRowOutlet, selectors: [[\"\", \"footerRowOutlet\", \"\"]] });\r\nFooterRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[footerRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Provides a handle for the table to grab the view\r\n * container's ng-container to insert the no data row.\r\n * @docs-private\r\n */\r\nclass NoDataRowOutlet {\r\n    constructor(viewContainer, elementRef) {\r\n        this.viewContainer = viewContainer;\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\nNoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) { return new (t || NoDataRowOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\nNoDataRowOutlet.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NoDataRowOutlet, selectors: [[\"\", \"noDataRowOutlet\", \"\"]] });\r\nNoDataRowOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef },\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NoDataRowOutlet, [{\r\n        type: Directive,\r\n        args: [{ selector: '[noDataRowOutlet]' }]\r\n    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * The table template that can be used by the mat-table. Should not be used outside of the\r\n * material library.\r\n * @docs-private\r\n */\r\nconst CDK_TABLE_TEMPLATE = \r\n// Note that according to MDN, the `caption` element has to be projected as the **first**\r\n// element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption\r\n`\r\n  <ng-content select=\"caption\"></ng-content>\r\n  <ng-content select=\"colgroup, col\"></ng-content>\r\n  <ng-container headerRowOutlet></ng-container>\r\n  <ng-container rowOutlet></ng-container>\r\n  <ng-container noDataRowOutlet></ng-container>\r\n  <ng-container footerRowOutlet></ng-container>\r\n`;\r\n/**\r\n * Class used to conveniently type the embedded view ref for rows with a context.\r\n * @docs-private\r\n */\r\nclass RowViewRef extends EmbeddedViewRef {\r\n}\r\n/**\r\n * A data table that can render a header row, data rows, and a footer row.\r\n * Uses the dataSource input to determine the data to be rendered. The data can be provided either\r\n * as a data array, an Observable stream that emits the data array to render, or a DataSource with a\r\n * connect function that will return an Observable stream that emits the data array to render.\r\n */\r\nclass CdkTable {\r\n    constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, \r\n    /**\r\n     * @deprecated `_coalescedStyleScheduler`, `_viewRepeater` and `_viewportRuler`\r\n     *    parameters to become required.\r\n     * @breaking-change 11.0.0\r\n     */\r\n    _viewRepeater, _coalescedStyleScheduler, _stickyPositioningListener, \r\n    // Optional for backwards compatibility. The viewport ruler is provided in root. Therefore,\r\n    // this property will never be null.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _viewportRuler) {\r\n        this._differs = _differs;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._elementRef = _elementRef;\r\n        this._dir = _dir;\r\n        this._platform = _platform;\r\n        this._viewRepeater = _viewRepeater;\r\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\r\n        this._stickyPositioningListener = _stickyPositioningListener;\r\n        this._viewportRuler = _viewportRuler;\r\n        /** Subject that emits when the component has been destroyed. */\r\n        this._onDestroy = new Subject();\r\n        /**\r\n         * Map of all the user's defined columns (header, data, and footer cell template) identified by\r\n         * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\r\n         * any custom column definitions added to `_customColumnDefs`.\r\n         */\r\n        this._columnDefsByName = new Map();\r\n        /**\r\n         * Column definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * column definitions as *its* content child.\r\n         */\r\n        this._customColumnDefs = new Set();\r\n        /**\r\n         * Data row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * built-in data rows as *its* content child.\r\n         */\r\n        this._customRowDefs = new Set();\r\n        /**\r\n         * Header row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n         * built-in header rows as *its* content child.\r\n         */\r\n        this._customHeaderRowDefs = new Set();\r\n        /**\r\n         * Footer row definitions that were defined outside of the direct content children of the table.\r\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\r\n         * built-in footer row as *its* content child.\r\n         */\r\n        this._customFooterRowDefs = new Set();\r\n        /**\r\n         * Whether the header row definition has been changed. Triggers an update to the header row after\r\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n         */\r\n        this._headerRowDefChanged = true;\r\n        /**\r\n         * Whether the footer row definition has been changed. Triggers an update to the footer row after\r\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n         */\r\n        this._footerRowDefChanged = true;\r\n        /**\r\n         * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\r\n         * change.\r\n         */\r\n        this._stickyColumnStylesNeedReset = true;\r\n        /**\r\n         * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\r\n         * `false`, cached values will be used instead. This is only applicable to tables with\r\n         * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\r\n         */\r\n        this._forceRecalculateCellWidths = true;\r\n        /**\r\n         * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\r\n         * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\r\n         * the cached `RenderRow` objects when possible, the row identity is preserved when the data\r\n         * and row template matches, which allows the `IterableDiffer` to check rows by reference\r\n         * and understand which rows are added/moved/removed.\r\n         *\r\n         * Implemented as a map of maps where the first key is the `data: T` object and the second is the\r\n         * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\r\n         * contains an array of created pairs. The array is necessary to handle cases where the data\r\n         * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\r\n         * stored.\r\n         */\r\n        this._cachedRenderRowsMap = new Map();\r\n        /**\r\n         * CSS class added to any row or cell that has sticky positioning applied. May be overriden by\r\n         * table subclasses.\r\n         */\r\n        this.stickyCssClass = 'cdk-table-sticky';\r\n        /**\r\n         * Whether to manually add positon: sticky to all sticky cell elements. Not needed if\r\n         * the position is set in a selector associated with the value of stickyCssClass. May be\r\n         * overridden by table subclasses\r\n         */\r\n        this.needsPositionStickyOnElement = true;\r\n        /** Whether the no data row is currently showing anything. */\r\n        this._isShowingNoDataRow = false;\r\n        this._multiTemplateDataRows = false;\r\n        this._fixedLayout = false;\r\n        // TODO(andrewseguin): Remove max value as the end index\r\n        //   and instead calculate the view on init and scroll.\r\n        /**\r\n         * Stream containing the latest information on what rows are being displayed on screen.\r\n         * Can be used by the data source to as a heuristic of what data should be provided.\r\n         *\r\n         * @docs-private\r\n         */\r\n        this.viewChange = new BehaviorSubject({ start: 0, end: Number.MAX_VALUE });\r\n        if (!role) {\r\n            this._elementRef.nativeElement.setAttribute('role', 'grid');\r\n        }\r\n        this._document = _document;\r\n        this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';\r\n    }\r\n    /**\r\n     * Tracking function that will be used to check the differences in data changes. Used similarly\r\n     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\r\n     * relative to the function to know if a row should be added/removed/moved.\r\n     * Accepts a function that takes two parameters, `index` and `item`.\r\n     */\r\n    get trackBy() {\r\n        return this._trackByFn;\r\n    }\r\n    set trackBy(fn) {\r\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\r\n            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\r\n        }\r\n        this._trackByFn = fn;\r\n    }\r\n    /**\r\n     * The table's source of data, which can be provided in three ways (in order of complexity):\r\n     *   - Simple data array (each object represents one table row)\r\n     *   - Stream that emits a data array each time the array changes\r\n     *   - `DataSource` object that implements the connect/disconnect interface.\r\n     *\r\n     * If a data array is provided, the table must be notified when the array's objects are\r\n     * added, removed, or moved. This can be done by calling the `renderRows()` function which will\r\n     * render the diff since the last table render. If the data array reference is changed, the table\r\n     * will automatically trigger an update to the rows.\r\n     *\r\n     * When providing an Observable stream, the table will trigger an update automatically when the\r\n     * stream emits a new array of data.\r\n     *\r\n     * Finally, when providing a `DataSource` object, the table will use the Observable stream\r\n     * provided by the connect function and trigger updates when that stream emits new data array\r\n     * values. During the table's ngOnDestroy or when the data source is removed from the table, the\r\n     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\r\n     * subscriptions registered during the connect process).\r\n     */\r\n    get dataSource() {\r\n        return this._dataSource;\r\n    }\r\n    set dataSource(dataSource) {\r\n        if (this._dataSource !== dataSource) {\r\n            this._switchDataSource(dataSource);\r\n        }\r\n    }\r\n    /**\r\n     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\r\n     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\r\n     * dataobject will render the first row that evaluates its when predicate to true, in the order\r\n     * defined in the table, or otherwise the default row which does not have a when predicate.\r\n     */\r\n    get multiTemplateDataRows() {\r\n        return this._multiTemplateDataRows;\r\n    }\r\n    set multiTemplateDataRows(v) {\r\n        this._multiTemplateDataRows = coerceBooleanProperty(v);\r\n        // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),\r\n        // this setter will be invoked before the row outlet has been defined hence the null check.\r\n        if (this._rowOutlet && this._rowOutlet.viewContainer.length) {\r\n            this._forceRenderDataRows();\r\n            this.updateStickyColumnStyles();\r\n        }\r\n    }\r\n    /**\r\n     * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\r\n     * and optimize rendering sticky styles for native tables. No-op for flex tables.\r\n     */\r\n    get fixedLayout() {\r\n        return this._fixedLayout;\r\n    }\r\n    set fixedLayout(v) {\r\n        this._fixedLayout = coerceBooleanProperty(v);\r\n        // Toggling `fixedLayout` may change column widths. Sticky column styles should be recalculated.\r\n        this._forceRecalculateCellWidths = true;\r\n        this._stickyColumnStylesNeedReset = true;\r\n    }\r\n    ngOnInit() {\r\n        this._setupStickyStyler();\r\n        if (this._isNativeHtmlTable) {\r\n            this._applyNativeTableSections();\r\n        }\r\n        // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If\r\n        // the user has provided a custom trackBy, return the result of that function as evaluated\r\n        // with the values of the `RenderRow`'s data and index.\r\n        this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {\r\n            return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;\r\n        });\r\n        // Table cell dimensions may change after resizing the window. Signal the sticky styler to\r\n        // refresh its cache of cell widths the next time sticky styles are updated.\r\n        // @breaking-change 11.0.0 Remove null check for _viewportRuler once it's a required parameter.\r\n        if (this._viewportRuler) {\r\n            this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {\r\n                this._forceRecalculateCellWidths = true;\r\n            });\r\n        }\r\n    }\r\n    ngAfterContentChecked() {\r\n        // Cache the row and column definitions gathered by ContentChildren and programmatic injection.\r\n        this._cacheRowDefs();\r\n        this._cacheColumnDefs();\r\n        // Make sure that the user has at least added header, footer, or data row def.\r\n        if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMissingRowDefsError();\r\n        }\r\n        // Render updates if the list of columns have been changed for the header, row, or footer defs.\r\n        const columnsChanged = this._renderUpdatedColumns();\r\n        const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;\r\n        // Ensure sticky column styles are reset if set to `true` elsewhere.\r\n        this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;\r\n        this._forceRecalculateCellWidths = rowDefsChanged;\r\n        // If the header row definition has been changed, trigger a render to the header row.\r\n        if (this._headerRowDefChanged) {\r\n            this._forceRenderHeaderRows();\r\n            this._headerRowDefChanged = false;\r\n        }\r\n        // If the footer row definition has been changed, trigger a render to the footer row.\r\n        if (this._footerRowDefChanged) {\r\n            this._forceRenderFooterRows();\r\n            this._footerRowDefChanged = false;\r\n        }\r\n        // If there is a data source and row definitions, connect to the data source unless a\r\n        // connection has already been made.\r\n        if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\r\n            this._observeRenderChanges();\r\n        }\r\n        else if (this._stickyColumnStylesNeedReset) {\r\n            // In the above case, _observeRenderChanges will result in updateStickyColumnStyles being\r\n            // called when it row data arrives. Otherwise, we need to call it proactively.\r\n            this.updateStickyColumnStyles();\r\n        }\r\n        this._checkStickyStates();\r\n    }\r\n    ngOnDestroy() {\r\n        this._rowOutlet.viewContainer.clear();\r\n        this._noDataRowOutlet.viewContainer.clear();\r\n        this._headerRowOutlet.viewContainer.clear();\r\n        this._footerRowOutlet.viewContainer.clear();\r\n        this._cachedRenderRowsMap.clear();\r\n        this._onDestroy.next();\r\n        this._onDestroy.complete();\r\n        if (isDataSource(this.dataSource)) {\r\n            this.dataSource.disconnect(this);\r\n        }\r\n    }\r\n    /**\r\n     * Renders rows based on the table's latest set of data, which was either provided directly as an\r\n     * input or retrieved through an Observable stream (directly or from a DataSource).\r\n     * Checks for differences in the data since the last diff to perform only the necessary\r\n     * changes (add/remove/move rows).\r\n     *\r\n     * If the table's data source is a DataSource or Observable, this will be invoked automatically\r\n     * each time the provided Observable stream emits a new data array. Otherwise if your data is\r\n     * an array, this function will need to be called to render any changes.\r\n     */\r\n    renderRows() {\r\n        this._renderRows = this._getAllRenderRows();\r\n        const changes = this._dataDiffer.diff(this._renderRows);\r\n        if (!changes) {\r\n            this._updateNoDataRow();\r\n            return;\r\n        }\r\n        const viewContainer = this._rowOutlet.viewContainer;\r\n        // @breaking-change 11.0.0 Remove null check for `_viewRepeater` and the\r\n        // `else` clause once `_viewRepeater` is turned into a required parameter.\r\n        if (this._viewRepeater) {\r\n            this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {\r\n                if (change.operation === 1 /* INSERTED */ && change.context) {\r\n                    this._renderCellTemplateForItem(change.record.item.rowDef, change.context);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            changes.forEachOperation((record, prevIndex, currentIndex) => {\r\n                if (record.previousIndex == null) {\r\n                    const renderRow = record.item;\r\n                    const rowDef = renderRow.rowDef;\r\n                    const context = { $implicit: renderRow.data };\r\n                    this._renderRow(this._rowOutlet, rowDef, currentIndex, context);\r\n                }\r\n                else if (currentIndex == null) {\r\n                    viewContainer.remove(prevIndex);\r\n                }\r\n                else {\r\n                    const view = viewContainer.get(prevIndex);\r\n                    viewContainer.move(view, currentIndex);\r\n                }\r\n            });\r\n        }\r\n        // Update the meta context of a row's context data (index, count, first, last, ...)\r\n        this._updateRowIndexContext();\r\n        // Update rows that did not get added/removed/moved but may have had their identity changed,\r\n        // e.g. if trackBy matched data on some property but the actual data reference changed.\r\n        changes.forEachIdentityChange((record) => {\r\n            const rowView = viewContainer.get(record.currentIndex);\r\n            rowView.context.$implicit = record.item.data;\r\n        });\r\n        this._updateNoDataRow();\r\n        this.updateStickyColumnStyles();\r\n    }\r\n    /** Adds a column definition that was not included as part of the content children. */\r\n    addColumnDef(columnDef) {\r\n        this._customColumnDefs.add(columnDef);\r\n    }\r\n    /** Removes a column definition that was not included as part of the content children. */\r\n    removeColumnDef(columnDef) {\r\n        this._customColumnDefs.delete(columnDef);\r\n    }\r\n    /** Adds a row definition that was not included as part of the content children. */\r\n    addRowDef(rowDef) {\r\n        this._customRowDefs.add(rowDef);\r\n    }\r\n    /** Removes a row definition that was not included as part of the content children. */\r\n    removeRowDef(rowDef) {\r\n        this._customRowDefs.delete(rowDef);\r\n    }\r\n    /** Adds a header row definition that was not included as part of the content children. */\r\n    addHeaderRowDef(headerRowDef) {\r\n        this._customHeaderRowDefs.add(headerRowDef);\r\n        this._headerRowDefChanged = true;\r\n    }\r\n    /** Removes a header row definition that was not included as part of the content children. */\r\n    removeHeaderRowDef(headerRowDef) {\r\n        this._customHeaderRowDefs.delete(headerRowDef);\r\n        this._headerRowDefChanged = true;\r\n    }\r\n    /** Adds a footer row definition that was not included as part of the content children. */\r\n    addFooterRowDef(footerRowDef) {\r\n        this._customFooterRowDefs.add(footerRowDef);\r\n        this._footerRowDefChanged = true;\r\n    }\r\n    /** Removes a footer row definition that was not included as part of the content children. */\r\n    removeFooterRowDef(footerRowDef) {\r\n        this._customFooterRowDefs.delete(footerRowDef);\r\n        this._footerRowDefChanged = true;\r\n    }\r\n    /** Sets a no data row definition that was not included as a part of the content children. */\r\n    setNoDataRow(noDataRow) {\r\n        this._customNoDataRow = noDataRow;\r\n    }\r\n    /**\r\n     * Updates the header sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\r\n     * automatically called when the header row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyHeaderRowStyles() {\r\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\r\n        const tableElement = this._elementRef.nativeElement;\r\n        // Hide the thead element if there are no header rows. This is necessary to satisfy\r\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\r\n        // required child `row`.\r\n        const thead = tableElement.querySelector('thead');\r\n        if (thead) {\r\n            thead.style.display = headerRows.length ? '' : 'none';\r\n        }\r\n        const stickyStates = this._headerRowDefs.map(def => def.sticky);\r\n        this._stickyStyler.clearStickyPositioning(headerRows, ['top']);\r\n        this._stickyStyler.stickRows(headerRows, stickyStates, 'top');\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        this._headerRowDefs.forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Updates the footer sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\r\n     * automatically called when the footer row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyFooterRowStyles() {\r\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\r\n        const tableElement = this._elementRef.nativeElement;\r\n        // Hide the tfoot element if there are no footer rows. This is necessary to satisfy\r\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\r\n        // required child `row`.\r\n        const tfoot = tableElement.querySelector('tfoot');\r\n        if (tfoot) {\r\n            tfoot.style.display = footerRows.length ? '' : 'none';\r\n        }\r\n        const stickyStates = this._footerRowDefs.map(def => def.sticky);\r\n        this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);\r\n        this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');\r\n        this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        this._footerRowDefs.forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Updates the column sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the left and right. Then sticky styles are added for the left and right according\r\n     * to the column definitions for each cell in each row. This is automatically called when\r\n     * the data source provides a new set of data or when a column definition changes its sticky\r\n     * input. May be called manually for cases where the cell content changes outside of these events.\r\n     */\r\n    updateStickyColumnStyles() {\r\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\r\n        const dataRows = this._getRenderedRows(this._rowOutlet);\r\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\r\n        // For tables not using a fixed layout, the column widths may change when new rows are rendered.\r\n        // In a table using a fixed layout, row content won't affect column width, so sticky styles\r\n        // don't need to be cleared unless either the sticky column config changes or one of the row\r\n        // defs change.\r\n        if ((this._isNativeHtmlTable && !this._fixedLayout)\r\n            || this._stickyColumnStylesNeedReset) {\r\n            // Clear the left and right positioning from all columns in the table across all rows since\r\n            // sticky columns span across all table sections (header, data, footer)\r\n            this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ['left', 'right']);\r\n            this._stickyColumnStylesNeedReset = false;\r\n        }\r\n        // Update the sticky styles for each header row depending on the def's sticky state\r\n        headerRows.forEach((headerRow, i) => {\r\n            this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);\r\n        });\r\n        // Update the sticky styles for each data row depending on its def's sticky state\r\n        this._rowDefs.forEach(rowDef => {\r\n            // Collect all the rows rendered with this row definition.\r\n            const rows = [];\r\n            for (let i = 0; i < dataRows.length; i++) {\r\n                if (this._renderRows[i].rowDef === rowDef) {\r\n                    rows.push(dataRows[i]);\r\n                }\r\n            }\r\n            this._addStickyColumnStyles(rows, rowDef);\r\n        });\r\n        // Update the sticky styles for each footer row depending on the def's sticky state\r\n        footerRows.forEach((footerRow, i) => {\r\n            this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);\r\n        });\r\n        // Reset the dirty state of the sticky input change since it has been used.\r\n        Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());\r\n    }\r\n    /**\r\n     * Get the list of RenderRow objects to render according to the current list of data and defined\r\n     * row definitions. If the previous list already contained a particular pair, it should be reused\r\n     * so that the differ equates their references.\r\n     */\r\n    _getAllRenderRows() {\r\n        const renderRows = [];\r\n        // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the\r\n        // new cache while unused ones can be picked up by garbage collection.\r\n        const prevCachedRenderRows = this._cachedRenderRowsMap;\r\n        this._cachedRenderRowsMap = new Map();\r\n        // For each data object, get the list of rows that should be rendered, represented by the\r\n        // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.\r\n        for (let i = 0; i < this._data.length; i++) {\r\n            let data = this._data[i];\r\n            const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));\r\n            if (!this._cachedRenderRowsMap.has(data)) {\r\n                this._cachedRenderRowsMap.set(data, new WeakMap());\r\n            }\r\n            for (let j = 0; j < renderRowsForData.length; j++) {\r\n                let renderRow = renderRowsForData[j];\r\n                const cache = this._cachedRenderRowsMap.get(renderRow.data);\r\n                if (cache.has(renderRow.rowDef)) {\r\n                    cache.get(renderRow.rowDef).push(renderRow);\r\n                }\r\n                else {\r\n                    cache.set(renderRow.rowDef, [renderRow]);\r\n                }\r\n                renderRows.push(renderRow);\r\n            }\r\n        }\r\n        return renderRows;\r\n    }\r\n    /**\r\n     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\r\n     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\r\n     * `(T, CdkRowDef)` pair.\r\n     */\r\n    _getRenderRowsForData(data, dataIndex, cache) {\r\n        const rowDefs = this._getRowDefs(data, dataIndex);\r\n        return rowDefs.map(rowDef => {\r\n            const cachedRenderRows = (cache && cache.has(rowDef)) ? cache.get(rowDef) : [];\r\n            if (cachedRenderRows.length) {\r\n                const dataRow = cachedRenderRows.shift();\r\n                dataRow.dataIndex = dataIndex;\r\n                return dataRow;\r\n            }\r\n            else {\r\n                return { data, rowDef, dataIndex };\r\n            }\r\n        });\r\n    }\r\n    /** Update the map containing the content's column definitions. */\r\n    _cacheColumnDefs() {\r\n        this._columnDefsByName.clear();\r\n        const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);\r\n        columnDefs.forEach(columnDef => {\r\n            if (this._columnDefsByName.has(columnDef.name) &&\r\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableDuplicateColumnNameError(columnDef.name);\r\n            }\r\n            this._columnDefsByName.set(columnDef.name, columnDef);\r\n        });\r\n    }\r\n    /** Update the list of all available row definitions that can be used. */\r\n    _cacheRowDefs() {\r\n        this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);\r\n        this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);\r\n        this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);\r\n        // After all row definitions are determined, find the row definition to be considered default.\r\n        const defaultRowDefs = this._rowDefs.filter(def => !def.when);\r\n        if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMultipleDefaultRowDefsError();\r\n        }\r\n        this._defaultRowDef = defaultRowDefs[0];\r\n    }\r\n    /**\r\n     * Check if the header, data, or footer rows have changed what columns they want to display or\r\n     * whether the sticky states have changed for the header or footer. If there is a diff, then\r\n     * re-render that section.\r\n     */\r\n    _renderUpdatedColumns() {\r\n        const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();\r\n        // Force re-render data rows if the list of column definitions have changed.\r\n        const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);\r\n        if (dataColumnsChanged) {\r\n            this._forceRenderDataRows();\r\n        }\r\n        // Force re-render header/footer rows if the list of column definitions have changed.\r\n        const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);\r\n        if (headerColumnsChanged) {\r\n            this._forceRenderHeaderRows();\r\n        }\r\n        const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);\r\n        if (footerColumnsChanged) {\r\n            this._forceRenderFooterRows();\r\n        }\r\n        return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;\r\n    }\r\n    /**\r\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\r\n     * render change subscription if one exists. If the data source is null, interpret this by\r\n     * clearing the row outlet. Otherwise start listening for new data.\r\n     */\r\n    _switchDataSource(dataSource) {\r\n        this._data = [];\r\n        if (isDataSource(this.dataSource)) {\r\n            this.dataSource.disconnect(this);\r\n        }\r\n        // Stop listening for data from the previous data source.\r\n        if (this._renderChangeSubscription) {\r\n            this._renderChangeSubscription.unsubscribe();\r\n            this._renderChangeSubscription = null;\r\n        }\r\n        if (!dataSource) {\r\n            if (this._dataDiffer) {\r\n                this._dataDiffer.diff([]);\r\n            }\r\n            this._rowOutlet.viewContainer.clear();\r\n        }\r\n        this._dataSource = dataSource;\r\n    }\r\n    /** Set up a subscription for the data provided by the data source. */\r\n    _observeRenderChanges() {\r\n        // If no data source has been set, there is nothing to observe for changes.\r\n        if (!this.dataSource) {\r\n            return;\r\n        }\r\n        let dataStream;\r\n        if (isDataSource(this.dataSource)) {\r\n            dataStream = this.dataSource.connect(this);\r\n        }\r\n        else if (isObservable(this.dataSource)) {\r\n            dataStream = this.dataSource;\r\n        }\r\n        else if (Array.isArray(this.dataSource)) {\r\n            dataStream = of(this.dataSource);\r\n        }\r\n        if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableUnknownDataSourceError();\r\n        }\r\n        this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy))\r\n            .subscribe(data => {\r\n            this._data = data || [];\r\n            this.renderRows();\r\n        });\r\n    }\r\n    /**\r\n     * Clears any existing content in the header row outlet and creates a new embedded view\r\n     * in the outlet using the header row definition.\r\n     */\r\n    _forceRenderHeaderRows() {\r\n        // Clear the header row outlet if any content exists.\r\n        if (this._headerRowOutlet.viewContainer.length > 0) {\r\n            this._headerRowOutlet.viewContainer.clear();\r\n        }\r\n        this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));\r\n        this.updateStickyHeaderRowStyles();\r\n    }\r\n    /**\r\n     * Clears any existing content in the footer row outlet and creates a new embedded view\r\n     * in the outlet using the footer row definition.\r\n     */\r\n    _forceRenderFooterRows() {\r\n        // Clear the footer row outlet if any content exists.\r\n        if (this._footerRowOutlet.viewContainer.length > 0) {\r\n            this._footerRowOutlet.viewContainer.clear();\r\n        }\r\n        this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));\r\n        this.updateStickyFooterRowStyles();\r\n    }\r\n    /** Adds the sticky column styles for the rows according to the columns' stick states. */\r\n    _addStickyColumnStyles(rows, rowDef) {\r\n        const columnDefs = Array.from(rowDef.columns || []).map(columnName => {\r\n            const columnDef = this._columnDefsByName.get(columnName);\r\n            if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableUnknownColumnError(columnName);\r\n            }\r\n            return columnDef;\r\n        });\r\n        const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);\r\n        const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);\r\n        this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);\r\n    }\r\n    /** Gets the list of rows that have been rendered in the row outlet. */\r\n    _getRenderedRows(rowOutlet) {\r\n        const renderedRows = [];\r\n        for (let i = 0; i < rowOutlet.viewContainer.length; i++) {\r\n            const viewRef = rowOutlet.viewContainer.get(i);\r\n            renderedRows.push(viewRef.rootNodes[0]);\r\n        }\r\n        return renderedRows;\r\n    }\r\n    /**\r\n     * Get the matching row definitions that should be used for this row data. If there is only\r\n     * one row definition, it is returned. Otherwise, find the row definitions that has a when\r\n     * predicate that returns true with the data. If none return true, return the default row\r\n     * definition.\r\n     */\r\n    _getRowDefs(data, dataIndex) {\r\n        if (this._rowDefs.length == 1) {\r\n            return [this._rowDefs[0]];\r\n        }\r\n        let rowDefs = [];\r\n        if (this.multiTemplateDataRows) {\r\n            rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));\r\n        }\r\n        else {\r\n            let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;\r\n            if (rowDef) {\r\n                rowDefs.push(rowDef);\r\n            }\r\n        }\r\n        if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableMissingMatchingRowDefError(data);\r\n        }\r\n        return rowDefs;\r\n    }\r\n    _getEmbeddedViewArgs(renderRow, index) {\r\n        const rowDef = renderRow.rowDef;\r\n        const context = { $implicit: renderRow.data };\r\n        return {\r\n            templateRef: rowDef.template,\r\n            context,\r\n            index,\r\n        };\r\n    }\r\n    /**\r\n     * Creates a new row template in the outlet and fills it with the set of cell templates.\r\n     * Optionally takes a context to provide to the row and cells, as well as an optional index\r\n     * of where to place the new row template in the outlet.\r\n     */\r\n    _renderRow(outlet, rowDef, index, context = {}) {\r\n        // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView\r\n        const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);\r\n        this._renderCellTemplateForItem(rowDef, context);\r\n        return view;\r\n    }\r\n    _renderCellTemplateForItem(rowDef, context) {\r\n        for (let cellTemplate of this._getCellTemplates(rowDef)) {\r\n            if (CdkCellOutlet.mostRecentCellOutlet) {\r\n                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);\r\n            }\r\n        }\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /**\r\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\r\n     * e.g. first/last/even/odd.\r\n     */\r\n    _updateRowIndexContext() {\r\n        const viewContainer = this._rowOutlet.viewContainer;\r\n        for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\r\n            const viewRef = viewContainer.get(renderIndex);\r\n            const context = viewRef.context;\r\n            context.count = count;\r\n            context.first = renderIndex === 0;\r\n            context.last = renderIndex === count - 1;\r\n            context.even = renderIndex % 2 === 0;\r\n            context.odd = !context.even;\r\n            if (this.multiTemplateDataRows) {\r\n                context.dataIndex = this._renderRows[renderIndex].dataIndex;\r\n                context.renderIndex = renderIndex;\r\n            }\r\n            else {\r\n                context.index = this._renderRows[renderIndex].dataIndex;\r\n            }\r\n        }\r\n    }\r\n    /** Gets the column definitions for the provided row def. */\r\n    _getCellTemplates(rowDef) {\r\n        if (!rowDef || !rowDef.columns) {\r\n            return [];\r\n        }\r\n        return Array.from(rowDef.columns, columnId => {\r\n            const column = this._columnDefsByName.get(columnId);\r\n            if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throw getTableUnknownColumnError(columnId);\r\n            }\r\n            return rowDef.extractCellTemplate(column);\r\n        });\r\n    }\r\n    /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\r\n    _applyNativeTableSections() {\r\n        const documentFragment = this._document.createDocumentFragment();\r\n        const sections = [\r\n            { tag: 'thead', outlets: [this._headerRowOutlet] },\r\n            { tag: 'tbody', outlets: [this._rowOutlet, this._noDataRowOutlet] },\r\n            { tag: 'tfoot', outlets: [this._footerRowOutlet] },\r\n        ];\r\n        for (const section of sections) {\r\n            const element = this._document.createElement(section.tag);\r\n            element.setAttribute('role', 'rowgroup');\r\n            for (const outlet of section.outlets) {\r\n                element.appendChild(outlet.elementRef.nativeElement);\r\n            }\r\n            documentFragment.appendChild(element);\r\n        }\r\n        // Use a DocumentFragment so we don't hit the DOM on each iteration.\r\n        this._elementRef.nativeElement.appendChild(documentFragment);\r\n    }\r\n    /**\r\n     * Forces a re-render of the data rows. Should be called in cases where there has been an input\r\n     * change that affects the evaluation of which rows should be rendered, e.g. toggling\r\n     * `multiTemplateDataRows` or adding/removing row definitions.\r\n     */\r\n    _forceRenderDataRows() {\r\n        this._dataDiffer.diff([]);\r\n        this._rowOutlet.viewContainer.clear();\r\n        this.renderRows();\r\n    }\r\n    /**\r\n     * Checks if there has been a change in sticky states since last check and applies the correct\r\n     * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\r\n     * during a change detection and after the inputs are settled (after content check).\r\n     */\r\n    _checkStickyStates() {\r\n        const stickyCheckReducer = (acc, d) => {\r\n            return acc || d.hasStickyChanged();\r\n        };\r\n        // Note that the check needs to occur for every definition since it notifies the definition\r\n        // that it can reset its dirty state. Using another operator like `some` may short-circuit\r\n        // remaining definitions and leave them in an unchecked state.\r\n        if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {\r\n            this.updateStickyHeaderRowStyles();\r\n        }\r\n        if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {\r\n            this.updateStickyFooterRowStyles();\r\n        }\r\n        if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {\r\n            this._stickyColumnStylesNeedReset = true;\r\n            this.updateStickyColumnStyles();\r\n        }\r\n    }\r\n    /**\r\n     * Creates the sticky styler that will be used for sticky rows and columns. Listens\r\n     * for directionality changes and provides the latest direction to the styler. Re-applies column\r\n     * stickiness when directionality changes.\r\n     */\r\n    _setupStickyStyler() {\r\n        const direction = this._dir ? this._dir.value : 'ltr';\r\n        this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);\r\n        (this._dir ? this._dir.change : of())\r\n            .pipe(takeUntil(this._onDestroy))\r\n            .subscribe(value => {\r\n            this._stickyStyler.direction = value;\r\n            this.updateStickyColumnStyles();\r\n        });\r\n    }\r\n    /** Filters definitions that belong to this table from a QueryList. */\r\n    _getOwnDefs(items) {\r\n        return items.filter(item => !item._table || item._table === this);\r\n    }\r\n    /** Creates or removes the no data row, depending on whether any data is being shown. */\r\n    _updateNoDataRow() {\r\n        const noDataRow = this._customNoDataRow || this._noDataRow;\r\n        if (noDataRow) {\r\n            const shouldShow = this._rowOutlet.viewContainer.length === 0;\r\n            if (shouldShow !== this._isShowingNoDataRow) {\r\n                const container = this._noDataRowOutlet.viewContainer;\r\n                shouldShow ? container.createEmbeddedView(noDataRow.templateRef) : container.clear();\r\n                this._isShowingNoDataRow = shouldShow;\r\n            }\r\n        }\r\n    }\r\n}\r\nCdkTable.ɵfac = function CdkTable_Factory(t) { return new (t || CdkTable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER, 8), ɵngcc0.ɵɵdirectiveInject(STICKY_POSITIONING_LISTENER, 12), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ViewportRuler, 8)); };\r\nCdkTable.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkTable, selectors: [[\"cdk-table\"], [\"table\", \"cdk-table\", \"\"]], contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkRowDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._noDataRow = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentRowDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);\r\n    } }, viewQuery: function CdkTable_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(DataRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(HeaderRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(FooterRowOutlet, 7);\r\n        ɵngcc0.ɵɵviewQuery(NoDataRowOutlet, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._headerRowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._footerRowOutlet = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._noDataRowOutlet = _t.first);\r\n    } }, hostAttrs: [1, \"cdk-table\"], hostVars: 2, hostBindings: function CdkTable_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"cdk-table-fixed-layout\", ctx.fixedLayout);\r\n    } }, inputs: { trackBy: \"trackBy\", dataSource: \"dataSource\", multiTemplateDataRows: \"multiTemplateDataRows\", fixedLayout: \"fixedLayout\" }, exportAs: [\"cdkTable\"], features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: CDK_TABLE, useExisting: CdkTable },\r\n            { provide: _VIEW_REPEATER_STRATEGY, useClass: _DisposeViewRepeaterStrategy },\r\n            { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\r\n            // Prevent nested tables from seeing this table's StickyPositioningListener.\r\n            { provide: STICKY_POSITIONING_LISTENER, useValue: null },\r\n        ])], ngContentSelectors: _c1, decls: 6, vars: 0, consts: [[\"headerRowOutlet\", \"\"], [\"rowOutlet\", \"\"], [\"noDataRowOutlet\", \"\"], [\"footerRowOutlet\", \"\"]], template: function CdkTable_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef(_c0);\r\n        ɵngcc0.ɵɵprojection(0);\r\n        ɵngcc0.ɵɵprojection(1, 1);\r\n        ɵngcc0.ɵɵelementContainer(2, 0);\r\n        ɵngcc0.ɵɵelementContainer(3, 1);\r\n        ɵngcc0.ɵɵelementContainer(4, 2);\r\n        ɵngcc0.ɵɵelementContainer(5, 3);\r\n    } }, directives: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet], styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"], encapsulation: 2 });\r\nCdkTable.ctorParameters = () => [\r\n    { type: IterableDiffers },\r\n    { type: ChangeDetectorRef },\r\n    { type: ElementRef },\r\n    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: Platform },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },\r\n    { type: _CoalescedStyleScheduler, decorators: [{ type: Optional }, { type: Inject, args: [_COALESCED_STYLE_SCHEDULER,] }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [STICKY_POSITIONING_LISTENER,] }] },\r\n    { type: ViewportRuler, decorators: [{ type: Optional }] }\r\n];\r\nCdkTable.propDecorators = {\r\n    trackBy: [{ type: Input }],\r\n    dataSource: [{ type: Input }],\r\n    multiTemplateDataRows: [{ type: Input }],\r\n    fixedLayout: [{ type: Input }],\r\n    _rowOutlet: [{ type: ViewChild, args: [DataRowOutlet, { static: true },] }],\r\n    _headerRowOutlet: [{ type: ViewChild, args: [HeaderRowOutlet, { static: true },] }],\r\n    _footerRowOutlet: [{ type: ViewChild, args: [FooterRowOutlet, { static: true },] }],\r\n    _noDataRowOutlet: [{ type: ViewChild, args: [NoDataRowOutlet, { static: true },] }],\r\n    _contentColumnDefs: [{ type: ContentChildren, args: [CdkColumnDef, { descendants: true },] }],\r\n    _contentRowDefs: [{ type: ContentChildren, args: [CdkRowDef, { descendants: true },] }],\r\n    _contentHeaderRowDefs: [{ type: ContentChildren, args: [CdkHeaderRowDef, {\r\n                    descendants: true\r\n                },] }],\r\n    _contentFooterRowDefs: [{ type: ContentChildren, args: [CdkFooterRowDef, {\r\n                    descendants: true\r\n                },] }],\r\n    _noDataRow: [{ type: ContentChild, args: [CdkNoDataRow,] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTable, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-table, table[cdk-table]',\r\n                exportAs: 'cdkTable',\r\n                template: CDK_TABLE_TEMPLATE,\r\n                host: {\r\n                    'class': 'cdk-table',\r\n                    '[class.cdk-table-fixed-layout]': 'fixedLayout'\r\n                },\r\n                encapsulation: ViewEncapsulation.None,\r\n                // The \"OnPush\" status for the `MatTable` component is effectively a noop, so we are removing it.\r\n                // The view for `MatTable` consists entirely of templates declared in other views. As they are\r\n                // declared elsewhere, they are checked when their declaration points are checked.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                providers: [\r\n                    { provide: CDK_TABLE, useExisting: CdkTable },\r\n                    { provide: _VIEW_REPEATER_STRATEGY, useClass: _DisposeViewRepeaterStrategy },\r\n                    { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\r\n                    // Prevent nested tables from seeing this table's StickyPositioningListener.\r\n                    { provide: STICKY_POSITIONING_LISTENER, useValue: null },\r\n                ],\r\n                styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{\r\n                type: Attribute,\r\n                args: ['role']\r\n            }] }, { type: ɵngcc1.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: ɵngcc2.Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [_VIEW_REPEATER_STRATEGY]\r\n            }] }, { type: _CoalescedStyleScheduler, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [_COALESCED_STYLE_SCHEDULER]\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: SkipSelf\r\n            }, {\r\n                type: Inject,\r\n                args: [STICKY_POSITIONING_LISTENER]\r\n            }] }, { type: ɵngcc3.ViewportRuler, decorators: [{\r\n                type: Optional\r\n            }] }]; }, { trackBy: [{\r\n            type: Input\r\n        }], dataSource: [{\r\n            type: Input\r\n        }], multiTemplateDataRows: [{\r\n            type: Input\r\n        }], fixedLayout: [{\r\n            type: Input\r\n        }], _rowOutlet: [{\r\n            type: ViewChild,\r\n            args: [DataRowOutlet, { static: true }]\r\n        }], _headerRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [HeaderRowOutlet, { static: true }]\r\n        }], _footerRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [FooterRowOutlet, { static: true }]\r\n        }], _noDataRowOutlet: [{\r\n            type: ViewChild,\r\n            args: [NoDataRowOutlet, { static: true }]\r\n        }], _contentColumnDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkColumnDef, { descendants: true }]\r\n        }], _contentRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkRowDef, { descendants: true }]\r\n        }], _contentHeaderRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkHeaderRowDef, {\r\n                    descendants: true\r\n                }]\r\n        }], _contentFooterRowDefs: [{\r\n            type: ContentChildren,\r\n            args: [CdkFooterRowDef, {\r\n                    descendants: true\r\n                }]\r\n        }], _noDataRow: [{\r\n            type: ContentChild,\r\n            args: [CdkNoDataRow]\r\n        }] }); })();\r\n/** Utility function that gets a merged list of the entries in an array and values of a Set. */\r\nfunction mergeArrayAndSet(array, set) {\r\n    return array.concat(Array.from(set));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Column that simply shows text content for the header and row cells. Assumes that the table\r\n * is using the native table implementation (`<table>`).\r\n *\r\n * By default, the name of this column will be the header text and data property accessor.\r\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\r\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\r\n * input.\r\n */\r\nclass CdkTextColumn {\r\n    constructor(\r\n    // `CdkTextColumn` is always requiring a table, but we just assert it manually\r\n    // for better error reporting.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _table, _options) {\r\n        this._table = _table;\r\n        this._options = _options;\r\n        /** Alignment of the cell values. */\r\n        this.justify = 'start';\r\n        this._options = _options || {};\r\n    }\r\n    /** Column name that should be used to reference this column. */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    set name(name) {\r\n        this._name = name;\r\n        // With Ivy, inputs can be initialized before static query results are\r\n        // available. In that case, we defer the synchronization until \"ngOnInit\" fires.\r\n        this._syncColumnDefName();\r\n    }\r\n    ngOnInit() {\r\n        this._syncColumnDefName();\r\n        if (this.headerText === undefined) {\r\n            this.headerText = this._createDefaultHeaderText();\r\n        }\r\n        if (!this.dataAccessor) {\r\n            this.dataAccessor =\r\n                this._options.defaultDataAccessor || ((data, name) => data[name]);\r\n        }\r\n        if (this._table) {\r\n            // Provide the cell and headerCell directly to the table with the static `ViewChild` query,\r\n            // since the columnDef will not pick up its content by the time the table finishes checking\r\n            // its content and initializing the rows.\r\n            this.columnDef.cell = this.cell;\r\n            this.columnDef.headerCell = this.headerCell;\r\n            this._table.addColumnDef(this.columnDef);\r\n        }\r\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n            throw getTableTextColumnMissingParentTableError();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._table) {\r\n            this._table.removeColumnDef(this.columnDef);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a default header text. Use the options' header text transformation function if one\r\n     * has been provided. Otherwise simply capitalize the column name.\r\n     */\r\n    _createDefaultHeaderText() {\r\n        const name = this.name;\r\n        if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getTableTextColumnMissingNameError();\r\n        }\r\n        if (this._options && this._options.defaultHeaderTextTransform) {\r\n            return this._options.defaultHeaderTextTransform(name);\r\n        }\r\n        return name[0].toUpperCase() + name.slice(1);\r\n    }\r\n    /** Synchronizes the column definition name with the text column name. */\r\n    _syncColumnDefName() {\r\n        if (this.columnDef) {\r\n            this.columnDef.name = this.name;\r\n        }\r\n    }\r\n}\r\nCdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) { return new (t || CdkTextColumn)(ɵngcc0.ɵɵdirectiveInject(CdkTable, 8), ɵngcc0.ɵɵdirectiveInject(TEXT_COLUMN_OPTIONS, 8)); };\r\nCdkTextColumn.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkTextColumn, selectors: [[\"cdk-text-column\"]], viewQuery: function CdkTextColumn_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(CdkColumnDef, 7);\r\n        ɵngcc0.ɵɵviewQuery(CdkCellDef, 7);\r\n        ɵngcc0.ɵɵviewQuery(CdkHeaderCellDef, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnDef = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);\r\n    } }, inputs: { justify: \"justify\", name: \"name\", headerText: \"headerText\", dataAccessor: \"dataAccessor\" }, decls: 3, vars: 0, consts: [[\"cdkColumnDef\", \"\"], [\"cdk-header-cell\", \"\", 3, \"text-align\", 4, \"cdkHeaderCellDef\"], [\"cdk-cell\", \"\", 3, \"text-align\", 4, \"cdkCellDef\"], [\"cdk-header-cell\", \"\"], [\"cdk-cell\", \"\"]], template: function CdkTextColumn_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementContainerStart(0, 0);\r\n        ɵngcc0.ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, \"th\", 1);\r\n        ɵngcc0.ɵɵtemplate(2, CdkTextColumn_td_2_Template, 2, 3, \"td\", 2);\r\n        ɵngcc0.ɵɵelementContainerEnd();\r\n    } }, directives: [CdkColumnDef, CdkHeaderCellDef, CdkCellDef, CdkHeaderCell, CdkCell], encapsulation: 2 });\r\nCdkTextColumn.ctorParameters = () => [\r\n    { type: CdkTable, decorators: [{ type: Optional }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TEXT_COLUMN_OPTIONS,] }] }\r\n];\r\nCdkTextColumn.propDecorators = {\r\n    name: [{ type: Input }],\r\n    headerText: [{ type: Input }],\r\n    dataAccessor: [{ type: Input }],\r\n    justify: [{ type: Input }],\r\n    columnDef: [{ type: ViewChild, args: [CdkColumnDef, { static: true },] }],\r\n    cell: [{ type: ViewChild, args: [CdkCellDef, { static: true },] }],\r\n    headerCell: [{ type: ViewChild, args: [CdkHeaderCellDef, { static: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTextColumn, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'cdk-text-column',\r\n                template: `\r\n    <ng-container cdkColumnDef>\r\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\r\n        {{headerText}}\r\n      </th>\r\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\r\n        {{dataAccessor(data, name)}}\r\n      </td>\r\n    </ng-container>\r\n  `,\r\n                encapsulation: ViewEncapsulation.None,\r\n                // Change detection is intentionally not set to OnPush. This component's template will be provided\r\n                // to the table to be inserted into its view. This is problematic when change detection runs since\r\n                // the bindings in this template will be evaluated _after_ the table's view is evaluated, which\r\n                // mean's the template in the table's view will not have the updated value (and in fact will cause\r\n                // an ExpressionChangedAfterItHasBeenCheckedError).\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default\r\n            }]\r\n    }], function () { return [{ type: CdkTable, decorators: [{\r\n                type: Optional\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [TEXT_COLUMN_OPTIONS]\r\n            }] }]; }, { justify: [{\r\n            type: Input\r\n        }], name: [{\r\n            type: Input\r\n        }], headerText: [{\r\n            type: Input\r\n        }], dataAccessor: [{\r\n            type: Input\r\n        }], columnDef: [{\r\n            type: ViewChild,\r\n            args: [CdkColumnDef, { static: true }]\r\n        }], cell: [{\r\n            type: ViewChild,\r\n            args: [CdkCellDef, { static: true }]\r\n        }], headerCell: [{\r\n            type: ViewChild,\r\n            args: [CdkHeaderCellDef, { static: true }]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst EXPORTED_DECLARATIONS = [\r\n    CdkTable,\r\n    CdkRowDef,\r\n    CdkCellDef,\r\n    CdkCellOutlet,\r\n    CdkHeaderCellDef,\r\n    CdkFooterCellDef,\r\n    CdkColumnDef,\r\n    CdkCell,\r\n    CdkRow,\r\n    CdkHeaderCell,\r\n    CdkFooterCell,\r\n    CdkHeaderRow,\r\n    CdkHeaderRowDef,\r\n    CdkFooterRow,\r\n    CdkFooterRowDef,\r\n    DataRowOutlet,\r\n    HeaderRowOutlet,\r\n    FooterRowOutlet,\r\n    CdkTextColumn,\r\n    CdkNoDataRow,\r\n    NoDataRowOutlet,\r\n];\r\nclass CdkTableModule {\r\n}\r\nCdkTableModule.ɵfac = function CdkTableModule_Factory(t) { return new (t || CdkTableModule)(); };\r\nCdkTableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CdkTableModule });\r\nCdkTableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[ScrollingModule]] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkTableModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                exports: EXPORTED_DECLARATIONS,\r\n                declarations: EXPORTED_DECLARATIONS,\r\n                imports: [ScrollingModule]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkTableModule, { declarations: function () { return [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, NoDataRowOutlet]; }, imports: function () { return [ScrollingModule]; }, exports: function () { return [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, NoDataRowOutlet]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { BaseCdkCell, BaseRowDef, CDK_ROW_TEMPLATE, CDK_TABLE, CDK_TABLE_TEMPLATE, CdkCell, CdkCellDef, CdkCellOutlet, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkFooterRow, CdkFooterRowDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkNoDataRow, CdkRow, CdkRowDef, CdkTable, CdkTableModule, CdkTextColumn, DataRowOutlet, FooterRowOutlet, HeaderRowOutlet, NoDataRowOutlet, STICKY_DIRECTIONS, STICKY_POSITIONING_LISTENER, StickyStyler, TEXT_COLUMN_OPTIONS, _COALESCED_STYLE_SCHEDULER, _CoalescedStyleScheduler, _Schedule, mixinHasStickyInput };\r\n\r\n"]}